//------------------------------------------------------------------------------
//        This code was generated by myriad.
//        Changes to this file will be lost when the code is regenerated.
//------------------------------------------------------------------------------
namespace Pulumi.FSharp.Azure

open Pulumi.FSharp

module Advisor =
    open Pulumi.Azure.Advisor

module AnalysisServices =
    open Pulumi.Azure.AnalysisServices
    open Pulumi.Azure.AnalysisServices.Inputs

    type ServerIpv4FirewallRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ServerIpv4FirewallRuleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ServerIpv4FirewallRuleArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ServerIpv4FirewallRuleArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("rangeEnd")>]
        member _.RangeEnd((n, args), rangeEnd) =
            let apply (args: ServerIpv4FirewallRuleArgs) =
                args.RangeEnd <- input rangeEnd
                args

            ()
            n, List.Cons(apply, args)

        member _.RangeEnd((n, args), rangeEnd) =
            let apply (args: ServerIpv4FirewallRuleArgs) =
                args.RangeEnd <- io rangeEnd
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("rangeStart")>]
        member _.RangeStart((n, args), rangeStart) =
            let apply (args: ServerIpv4FirewallRuleArgs) =
                args.RangeStart <- input rangeStart
                args

            ()
            n, List.Cons(apply, args)

        member _.RangeStart((n, args), rangeStart) =
            let apply (args: ServerIpv4FirewallRuleArgs) =
                args.RangeStart <- io rangeStart
                args

            ()
            n, List.Cons(apply, args)

    let serverIpv4FirewallRule = ServerIpv4FirewallRuleBuilder()

    type ServerBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Server(name, (List.fold func (ServerArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("adminUsers")>]
        member _.AdminUsers((name, args), adminUsers) =
            let apply (args: ServerArgs) =
                args.AdminUsers <- inputList adminUsers
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("backupBlobContainerUri")>]
        member _.BackupBlobContainerUri((name, args), backupBlobContainerUri) =
            let apply (args: ServerArgs) =
                args.BackupBlobContainerUri <- input backupBlobContainerUri
                args

            ()
            name, List.Cons(apply, args)

        member _.BackupBlobContainerUri((name, args), backupBlobContainerUri) =
            let apply (args: ServerArgs) =
                args.BackupBlobContainerUri <- io backupBlobContainerUri
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enablePowerBiService")>]
        member _.EnablePowerBiService((name, args), enablePowerBiService) =
            let apply (args: ServerArgs) =
                args.EnablePowerBiService <- input enablePowerBiService
                args

            ()
            name, List.Cons(apply, args)

        member _.EnablePowerBiService((name, args), enablePowerBiService) =
            let apply (args: ServerArgs) =
                args.EnablePowerBiService <- io enablePowerBiService
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("ipv4FirewallRules")>]
        member _.Ipv4FirewallRules((name, args), ipv4FirewallRules) =
            let apply (args: ServerArgs) =
                args.Ipv4FirewallRules <- inputList ipv4FirewallRules
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ServerArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ServerArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ServerArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ServerArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("querypoolConnectionMode")>]
        member _.QuerypoolConnectionMode((name, args), querypoolConnectionMode) =
            let apply (args: ServerArgs) =
                args.QuerypoolConnectionMode <- input querypoolConnectionMode
                args

            ()
            name, List.Cons(apply, args)

        member _.QuerypoolConnectionMode((name, args), querypoolConnectionMode) =
            let apply (args: ServerArgs) =
                args.QuerypoolConnectionMode <- io querypoolConnectionMode
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ServerArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ServerArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sku")>]
        member _.Sku((name, args), sku) =
            let apply (args: ServerArgs) =
                args.Sku <- input sku
                args

            ()
            name, List.Cons(apply, args)

        member _.Sku((name, args), sku) =
            let apply (args: ServerArgs) =
                args.Sku <- io sku
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ServerArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let server = ServerBuilder()

module ApiManagement =
    open Pulumi.Azure.ApiManagement
    open Pulumi.Azure.ApiManagement.Inputs

    type ApiImportBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApiImportArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("contentFormat")>]
        member _.ContentFormat((n, args), contentFormat) =
            let apply (args: ApiImportArgs) =
                args.ContentFormat <- input contentFormat
                args

            ()
            n, List.Cons(apply, args)

        member _.ContentFormat((n, args), contentFormat) =
            let apply (args: ApiImportArgs) =
                args.ContentFormat <- io contentFormat
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("contentValue")>]
        member _.ContentValue((n, args), contentValue) =
            let apply (args: ApiImportArgs) =
                args.ContentValue <- input contentValue
                args

            ()
            n, List.Cons(apply, args)

        member _.ContentValue((n, args), contentValue) =
            let apply (args: ApiImportArgs) =
                args.ContentValue <- io contentValue
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ApiImportArgs) =
                   args.WsdlSelector <- input arg
                   args

               ()
               func) ]

    let apiImport = ApiImportBuilder()

    type ApiImportWsdlSelectorBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApiImportWsdlSelectorArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("endpointName")>]
        member _.EndpointName((n, args), endpointName) =
            let apply (args: ApiImportWsdlSelectorArgs) =
                args.EndpointName <- input endpointName
                args

            ()
            n, List.Cons(apply, args)

        member _.EndpointName((n, args), endpointName) =
            let apply (args: ApiImportWsdlSelectorArgs) =
                args.EndpointName <- io endpointName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("serviceName")>]
        member _.ServiceName((n, args), serviceName) =
            let apply (args: ApiImportWsdlSelectorArgs) =
                args.ServiceName <- input serviceName
                args

            ()
            n, List.Cons(apply, args)

        member _.ServiceName((n, args), serviceName) =
            let apply (args: ApiImportWsdlSelectorArgs) =
                args.ServiceName <- io serviceName
                args

            ()
            n, List.Cons(apply, args)

    let apiImportWsdlSelector = ApiImportWsdlSelectorBuilder()

    type ApiOperationRequestBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApiOperationRequestArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("description")>]
        member _.Description((n, args), description) =
            let apply (args: ApiOperationRequestArgs) =
                args.Description <- input description
                args

            ()
            n, List.Cons(apply, args)

        member _.Description((n, args), description) =
            let apply (args: ApiOperationRequestArgs) =
                args.Description <- io description
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("headers")>]
        member _.Headers((n, args), headers) =
            let apply (args: ApiOperationRequestArgs) =
                args.Headers <- inputList headers
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("queryParameters")>]
        member _.QueryParameters((n, args), queryParameters) =
            let apply (args: ApiOperationRequestArgs) =
                args.QueryParameters <- inputList queryParameters
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("representations")>]
        member _.Representations((n, args), representations) =
            let apply (args: ApiOperationRequestArgs) =
                args.Representations <- inputList representations
                args

            ()
            n, List.Cons(apply, args)

    let apiOperationRequest = ApiOperationRequestBuilder()

    type ApiOperationRequestHeaderBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApiOperationRequestHeaderArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("defaultValue")>]
        member _.DefaultValue((n, args), defaultValue) =
            let apply (args: ApiOperationRequestHeaderArgs) =
                args.DefaultValue <- input defaultValue
                args

            ()
            n, List.Cons(apply, args)

        member _.DefaultValue((n, args), defaultValue) =
            let apply (args: ApiOperationRequestHeaderArgs) =
                args.DefaultValue <- io defaultValue
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((n, args), description) =
            let apply (args: ApiOperationRequestHeaderArgs) =
                args.Description <- input description
                args

            ()
            n, List.Cons(apply, args)

        member _.Description((n, args), description) =
            let apply (args: ApiOperationRequestHeaderArgs) =
                args.Description <- io description
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ApiOperationRequestHeaderArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ApiOperationRequestHeaderArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("required")>]
        member _.Required((n, args), required) =
            let apply (args: ApiOperationRequestHeaderArgs) =
                args.Required <- input required
                args

            ()
            n, List.Cons(apply, args)

        member _.Required((n, args), required) =
            let apply (args: ApiOperationRequestHeaderArgs) =
                args.Required <- io required
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: ApiOperationRequestHeaderArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: ApiOperationRequestHeaderArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: ApiOperationRequestHeaderArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let apiOperationRequestHeader = ApiOperationRequestHeaderBuilder()

    type ApiOperationRequestQueryParameterBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApiOperationRequestQueryParameterArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("defaultValue")>]
        member _.DefaultValue((n, args), defaultValue) =
            let apply (args: ApiOperationRequestQueryParameterArgs) =
                args.DefaultValue <- input defaultValue
                args

            ()
            n, List.Cons(apply, args)

        member _.DefaultValue((n, args), defaultValue) =
            let apply (args: ApiOperationRequestQueryParameterArgs) =
                args.DefaultValue <- io defaultValue
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((n, args), description) =
            let apply (args: ApiOperationRequestQueryParameterArgs) =
                args.Description <- input description
                args

            ()
            n, List.Cons(apply, args)

        member _.Description((n, args), description) =
            let apply (args: ApiOperationRequestQueryParameterArgs) =
                args.Description <- io description
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ApiOperationRequestQueryParameterArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ApiOperationRequestQueryParameterArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("required")>]
        member _.Required((n, args), required) =
            let apply (args: ApiOperationRequestQueryParameterArgs) =
                args.Required <- input required
                args

            ()
            n, List.Cons(apply, args)

        member _.Required((n, args), required) =
            let apply (args: ApiOperationRequestQueryParameterArgs) =
                args.Required <- io required
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: ApiOperationRequestQueryParameterArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: ApiOperationRequestQueryParameterArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: ApiOperationRequestQueryParameterArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let apiOperationRequestQueryParameter =
        ApiOperationRequestQueryParameterBuilder()

    type ApiOperationRequestRepresentationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApiOperationRequestRepresentationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("contentType")>]
        member _.ContentType((n, args), contentType) =
            let apply (args: ApiOperationRequestRepresentationArgs) =
                args.ContentType <- input contentType
                args

            ()
            n, List.Cons(apply, args)

        member _.ContentType((n, args), contentType) =
            let apply (args: ApiOperationRequestRepresentationArgs) =
                args.ContentType <- io contentType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("formParameters")>]
        member _.FormParameters((n, args), formParameters) =
            let apply (args: ApiOperationRequestRepresentationArgs) =
                args.FormParameters <- inputList formParameters
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sample")>]
        member _.Sample((n, args), sample) =
            let apply (args: ApiOperationRequestRepresentationArgs) =
                args.Sample <- input sample
                args

            ()
            n, List.Cons(apply, args)

        member _.Sample((n, args), sample) =
            let apply (args: ApiOperationRequestRepresentationArgs) =
                args.Sample <- io sample
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("schemaId")>]
        member _.SchemaId((n, args), schemaId) =
            let apply (args: ApiOperationRequestRepresentationArgs) =
                args.SchemaId <- input schemaId
                args

            ()
            n, List.Cons(apply, args)

        member _.SchemaId((n, args), schemaId) =
            let apply (args: ApiOperationRequestRepresentationArgs) =
                args.SchemaId <- io schemaId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("typeName")>]
        member _.TypeName((n, args), typeName) =
            let apply (args: ApiOperationRequestRepresentationArgs) =
                args.TypeName <- input typeName
                args

            ()
            n, List.Cons(apply, args)

        member _.TypeName((n, args), typeName) =
            let apply (args: ApiOperationRequestRepresentationArgs) =
                args.TypeName <- io typeName
                args

            ()
            n, List.Cons(apply, args)

    let apiOperationRequestRepresentation =
        ApiOperationRequestRepresentationBuilder()

    type ApiOperationRequestRepresentationFormParameterBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApiOperationRequestRepresentationFormParameterArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("defaultValue")>]
        member _.DefaultValue((n, args), defaultValue) =
            let apply (args: ApiOperationRequestRepresentationFormParameterArgs) =
                args.DefaultValue <- input defaultValue
                args

            ()
            n, List.Cons(apply, args)

        member _.DefaultValue((n, args), defaultValue) =
            let apply (args: ApiOperationRequestRepresentationFormParameterArgs) =
                args.DefaultValue <- io defaultValue
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((n, args), description) =
            let apply (args: ApiOperationRequestRepresentationFormParameterArgs) =
                args.Description <- input description
                args

            ()
            n, List.Cons(apply, args)

        member _.Description((n, args), description) =
            let apply (args: ApiOperationRequestRepresentationFormParameterArgs) =
                args.Description <- io description
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ApiOperationRequestRepresentationFormParameterArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ApiOperationRequestRepresentationFormParameterArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("required")>]
        member _.Required((n, args), required) =
            let apply (args: ApiOperationRequestRepresentationFormParameterArgs) =
                args.Required <- input required
                args

            ()
            n, List.Cons(apply, args)

        member _.Required((n, args), required) =
            let apply (args: ApiOperationRequestRepresentationFormParameterArgs) =
                args.Required <- io required
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: ApiOperationRequestRepresentationFormParameterArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: ApiOperationRequestRepresentationFormParameterArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: ApiOperationRequestRepresentationFormParameterArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let apiOperationRequestRepresentationFormParameter =
        ApiOperationRequestRepresentationFormParameterBuilder()

    type ApiOperationResponseBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApiOperationResponseArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("description")>]
        member _.Description((n, args), description) =
            let apply (args: ApiOperationResponseArgs) =
                args.Description <- input description
                args

            ()
            n, List.Cons(apply, args)

        member _.Description((n, args), description) =
            let apply (args: ApiOperationResponseArgs) =
                args.Description <- io description
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("headers")>]
        member _.Headers((n, args), headers) =
            let apply (args: ApiOperationResponseArgs) =
                args.Headers <- inputList headers
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("representations")>]
        member _.Representations((n, args), representations) =
            let apply (args: ApiOperationResponseArgs) =
                args.Representations <- inputList representations
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("statusCode")>]
        member _.StatusCode((n, args), statusCode) =
            let apply (args: ApiOperationResponseArgs) =
                args.StatusCode <- input statusCode
                args

            ()
            n, List.Cons(apply, args)

        member _.StatusCode((n, args), statusCode) =
            let apply (args: ApiOperationResponseArgs) =
                args.StatusCode <- io statusCode
                args

            ()
            n, List.Cons(apply, args)

    let apiOperationResponse = ApiOperationResponseBuilder()

    type ApiOperationResponseHeaderBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApiOperationResponseHeaderArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("defaultValue")>]
        member _.DefaultValue((n, args), defaultValue) =
            let apply (args: ApiOperationResponseHeaderArgs) =
                args.DefaultValue <- input defaultValue
                args

            ()
            n, List.Cons(apply, args)

        member _.DefaultValue((n, args), defaultValue) =
            let apply (args: ApiOperationResponseHeaderArgs) =
                args.DefaultValue <- io defaultValue
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((n, args), description) =
            let apply (args: ApiOperationResponseHeaderArgs) =
                args.Description <- input description
                args

            ()
            n, List.Cons(apply, args)

        member _.Description((n, args), description) =
            let apply (args: ApiOperationResponseHeaderArgs) =
                args.Description <- io description
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ApiOperationResponseHeaderArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ApiOperationResponseHeaderArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("required")>]
        member _.Required((n, args), required) =
            let apply (args: ApiOperationResponseHeaderArgs) =
                args.Required <- input required
                args

            ()
            n, List.Cons(apply, args)

        member _.Required((n, args), required) =
            let apply (args: ApiOperationResponseHeaderArgs) =
                args.Required <- io required
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: ApiOperationResponseHeaderArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: ApiOperationResponseHeaderArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: ApiOperationResponseHeaderArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let apiOperationResponseHeader = ApiOperationResponseHeaderBuilder()

    type ApiOperationResponseRepresentationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApiOperationResponseRepresentationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("contentType")>]
        member _.ContentType((n, args), contentType) =
            let apply (args: ApiOperationResponseRepresentationArgs) =
                args.ContentType <- input contentType
                args

            ()
            n, List.Cons(apply, args)

        member _.ContentType((n, args), contentType) =
            let apply (args: ApiOperationResponseRepresentationArgs) =
                args.ContentType <- io contentType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("formParameters")>]
        member _.FormParameters((n, args), formParameters) =
            let apply (args: ApiOperationResponseRepresentationArgs) =
                args.FormParameters <- inputList formParameters
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sample")>]
        member _.Sample((n, args), sample) =
            let apply (args: ApiOperationResponseRepresentationArgs) =
                args.Sample <- input sample
                args

            ()
            n, List.Cons(apply, args)

        member _.Sample((n, args), sample) =
            let apply (args: ApiOperationResponseRepresentationArgs) =
                args.Sample <- io sample
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("schemaId")>]
        member _.SchemaId((n, args), schemaId) =
            let apply (args: ApiOperationResponseRepresentationArgs) =
                args.SchemaId <- input schemaId
                args

            ()
            n, List.Cons(apply, args)

        member _.SchemaId((n, args), schemaId) =
            let apply (args: ApiOperationResponseRepresentationArgs) =
                args.SchemaId <- io schemaId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("typeName")>]
        member _.TypeName((n, args), typeName) =
            let apply (args: ApiOperationResponseRepresentationArgs) =
                args.TypeName <- input typeName
                args

            ()
            n, List.Cons(apply, args)

        member _.TypeName((n, args), typeName) =
            let apply (args: ApiOperationResponseRepresentationArgs) =
                args.TypeName <- io typeName
                args

            ()
            n, List.Cons(apply, args)

    let apiOperationResponseRepresentation =
        ApiOperationResponseRepresentationBuilder()

    type ApiOperationResponseRepresentationFormParameterBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApiOperationResponseRepresentationFormParameterArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("defaultValue")>]
        member _.DefaultValue((n, args), defaultValue) =
            let apply (args: ApiOperationResponseRepresentationFormParameterArgs) =
                args.DefaultValue <- input defaultValue
                args

            ()
            n, List.Cons(apply, args)

        member _.DefaultValue((n, args), defaultValue) =
            let apply (args: ApiOperationResponseRepresentationFormParameterArgs) =
                args.DefaultValue <- io defaultValue
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((n, args), description) =
            let apply (args: ApiOperationResponseRepresentationFormParameterArgs) =
                args.Description <- input description
                args

            ()
            n, List.Cons(apply, args)

        member _.Description((n, args), description) =
            let apply (args: ApiOperationResponseRepresentationFormParameterArgs) =
                args.Description <- io description
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ApiOperationResponseRepresentationFormParameterArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ApiOperationResponseRepresentationFormParameterArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("required")>]
        member _.Required((n, args), required) =
            let apply (args: ApiOperationResponseRepresentationFormParameterArgs) =
                args.Required <- input required
                args

            ()
            n, List.Cons(apply, args)

        member _.Required((n, args), required) =
            let apply (args: ApiOperationResponseRepresentationFormParameterArgs) =
                args.Required <- io required
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: ApiOperationResponseRepresentationFormParameterArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: ApiOperationResponseRepresentationFormParameterArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: ApiOperationResponseRepresentationFormParameterArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let apiOperationResponseRepresentationFormParameter =
        ApiOperationResponseRepresentationFormParameterBuilder()

    type ApiOperationTemplateParameterBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApiOperationTemplateParameterArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("defaultValue")>]
        member _.DefaultValue((n, args), defaultValue) =
            let apply (args: ApiOperationTemplateParameterArgs) =
                args.DefaultValue <- input defaultValue
                args

            ()
            n, List.Cons(apply, args)

        member _.DefaultValue((n, args), defaultValue) =
            let apply (args: ApiOperationTemplateParameterArgs) =
                args.DefaultValue <- io defaultValue
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((n, args), description) =
            let apply (args: ApiOperationTemplateParameterArgs) =
                args.Description <- input description
                args

            ()
            n, List.Cons(apply, args)

        member _.Description((n, args), description) =
            let apply (args: ApiOperationTemplateParameterArgs) =
                args.Description <- io description
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ApiOperationTemplateParameterArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ApiOperationTemplateParameterArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("required")>]
        member _.Required((n, args), required) =
            let apply (args: ApiOperationTemplateParameterArgs) =
                args.Required <- input required
                args

            ()
            n, List.Cons(apply, args)

        member _.Required((n, args), required) =
            let apply (args: ApiOperationTemplateParameterArgs) =
                args.Required <- io required
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: ApiOperationTemplateParameterArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: ApiOperationTemplateParameterArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: ApiOperationTemplateParameterArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let apiOperationTemplateParameter = ApiOperationTemplateParameterBuilder()

    type ApiSubscriptionKeyParameterNamesBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApiSubscriptionKeyParameterNamesArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("header")>]
        member _.Header((n, args), header) =
            let apply (args: ApiSubscriptionKeyParameterNamesArgs) =
                args.Header <- input header
                args

            ()
            n, List.Cons(apply, args)

        member _.Header((n, args), header) =
            let apply (args: ApiSubscriptionKeyParameterNamesArgs) =
                args.Header <- io header
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("query")>]
        member _.Query((n, args), query) =
            let apply (args: ApiSubscriptionKeyParameterNamesArgs) =
                args.Query <- input query
                args

            ()
            n, List.Cons(apply, args)

        member _.Query((n, args), query) =
            let apply (args: ApiSubscriptionKeyParameterNamesArgs) =
                args.Query <- io query
                args

            ()
            n, List.Cons(apply, args)

    let apiSubscriptionKeyParameterNames =
        ApiSubscriptionKeyParameterNamesBuilder()

    type AuthorizationServerTokenBodyParameterBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AuthorizationServerTokenBodyParameterArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: AuthorizationServerTokenBodyParameterArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: AuthorizationServerTokenBodyParameterArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((n, args), value) =
            let apply (args: AuthorizationServerTokenBodyParameterArgs) =
                args.Value <- input value
                args

            ()
            n, List.Cons(apply, args)

        member _.Value((n, args), value) =
            let apply (args: AuthorizationServerTokenBodyParameterArgs) =
                args.Value <- io value
                args

            ()
            n, List.Cons(apply, args)

    let authorizationServerTokenBodyParameter =
        AuthorizationServerTokenBodyParameterBuilder()

    type BackendCredentialsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (BackendCredentialsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: BackendCredentialsArgs) =
                   args.Authorization <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("certificates")>]
        member _.Certificates((n, args), certificates) =
            let apply (args: BackendCredentialsArgs) =
                args.Certificates <- inputList certificates
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("header")>]
        member _.Header((n, args), header) =
            let apply (args: BackendCredentialsArgs) =
                args.Header <- inputMap header
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("query")>]
        member _.Query((n, args), query) =
            let apply (args: BackendCredentialsArgs) =
                args.Query <- inputMap query
                args

            ()
            n, List.Cons(apply, args)

    let backendCredentials = BackendCredentialsBuilder()

    type BackendCredentialsAuthorizationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (BackendCredentialsAuthorizationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("parameter")>]
        member _.Parameter((n, args), parameter) =
            let apply (args: BackendCredentialsAuthorizationArgs) =
                args.Parameter <- input parameter
                args

            ()
            n, List.Cons(apply, args)

        member _.Parameter((n, args), parameter) =
            let apply (args: BackendCredentialsAuthorizationArgs) =
                args.Parameter <- io parameter
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("scheme")>]
        member _.Scheme((n, args), scheme) =
            let apply (args: BackendCredentialsAuthorizationArgs) =
                args.Scheme <- input scheme
                args

            ()
            n, List.Cons(apply, args)

        member _.Scheme((n, args), scheme) =
            let apply (args: BackendCredentialsAuthorizationArgs) =
                args.Scheme <- io scheme
                args

            ()
            n, List.Cons(apply, args)

    let backendCredentialsAuthorization = BackendCredentialsAuthorizationBuilder()

    type BackendProxyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (BackendProxyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: BackendProxyArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: BackendProxyArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("url")>]
        member _.Url((n, args), url) =
            let apply (args: BackendProxyArgs) =
                args.Url <- input url
                args

            ()
            n, List.Cons(apply, args)

        member _.Url((n, args), url) =
            let apply (args: BackendProxyArgs) =
                args.Url <- io url
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: BackendProxyArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: BackendProxyArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

    let backendProxy = BackendProxyBuilder()

    type BackendServiceFabricClusterBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (BackendServiceFabricClusterArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("clientCertificateThumbprint")>]
        member _.ClientCertificateThumbprint((n, args), clientCertificateThumbprint) =
            let apply (args: BackendServiceFabricClusterArgs) =
                args.ClientCertificateThumbprint <- input clientCertificateThumbprint
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientCertificateThumbprint((n, args), clientCertificateThumbprint) =
            let apply (args: BackendServiceFabricClusterArgs) =
                args.ClientCertificateThumbprint <- io clientCertificateThumbprint
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("managementEndpoints")>]
        member _.ManagementEndpoints((n, args), managementEndpoints) =
            let apply (args: BackendServiceFabricClusterArgs) =
                args.ManagementEndpoints <- inputList managementEndpoints
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("maxPartitionResolutionRetries")>]
        member _.MaxPartitionResolutionRetries((n, args), maxPartitionResolutionRetries) =
            let apply (args: BackendServiceFabricClusterArgs) =
                args.MaxPartitionResolutionRetries <- input maxPartitionResolutionRetries
                args

            ()
            n, List.Cons(apply, args)

        member _.MaxPartitionResolutionRetries((n, args), maxPartitionResolutionRetries) =
            let apply (args: BackendServiceFabricClusterArgs) =
                args.MaxPartitionResolutionRetries <- io maxPartitionResolutionRetries
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("serverCertificateThumbprints")>]
        member _.ServerCertificateThumbprints((n, args), serverCertificateThumbprints) =
            let apply (args: BackendServiceFabricClusterArgs) =
                args.ServerCertificateThumbprints <- inputList serverCertificateThumbprints
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("serverX509Names")>]
        member _.ServerX509Names((n, args), serverX509Names) =
            let apply (args: BackendServiceFabricClusterArgs) =
                args.ServerX509Names <- inputList serverX509Names
                args

            ()
            n, List.Cons(apply, args)

    let backendServiceFabricCluster = BackendServiceFabricClusterBuilder()

    type BackendServiceFabricClusterServerX509NameBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (BackendServiceFabricClusterServerX509NameArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("issuerCertificateThumbprint")>]
        member _.IssuerCertificateThumbprint((n, args), issuerCertificateThumbprint) =
            let apply (args: BackendServiceFabricClusterServerX509NameArgs) =
                args.IssuerCertificateThumbprint <- input issuerCertificateThumbprint
                args

            ()
            n, List.Cons(apply, args)

        member _.IssuerCertificateThumbprint((n, args), issuerCertificateThumbprint) =
            let apply (args: BackendServiceFabricClusterServerX509NameArgs) =
                args.IssuerCertificateThumbprint <- io issuerCertificateThumbprint
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: BackendServiceFabricClusterServerX509NameArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: BackendServiceFabricClusterServerX509NameArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

    let backendServiceFabricClusterServerX509Name =
        BackendServiceFabricClusterServerX509NameBuilder()

    type BackendTlsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (BackendTlsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("validateCertificateChain")>]
        member _.ValidateCertificateChain((n, args), validateCertificateChain) =
            let apply (args: BackendTlsArgs) =
                args.ValidateCertificateChain <- input validateCertificateChain
                args

            ()
            n, List.Cons(apply, args)

        member _.ValidateCertificateChain((n, args), validateCertificateChain) =
            let apply (args: BackendTlsArgs) =
                args.ValidateCertificateChain <- io validateCertificateChain
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("validateCertificateName")>]
        member _.ValidateCertificateName((n, args), validateCertificateName) =
            let apply (args: BackendTlsArgs) =
                args.ValidateCertificateName <- input validateCertificateName
                args

            ()
            n, List.Cons(apply, args)

        member _.ValidateCertificateName((n, args), validateCertificateName) =
            let apply (args: BackendTlsArgs) =
                args.ValidateCertificateName <- io validateCertificateName
                args

            ()
            n, List.Cons(apply, args)

    let backendTls = BackendTlsBuilder()

    type LoggerApplicationInsightsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LoggerApplicationInsightsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("instrumentationKey")>]
        member _.InstrumentationKey((n, args), instrumentationKey) =
            let apply (args: LoggerApplicationInsightsArgs) =
                args.InstrumentationKey <- input instrumentationKey
                args

            ()
            n, List.Cons(apply, args)

        member _.InstrumentationKey((n, args), instrumentationKey) =
            let apply (args: LoggerApplicationInsightsArgs) =
                args.InstrumentationKey <- io instrumentationKey
                args

            ()
            n, List.Cons(apply, args)

    let loggerApplicationInsights = LoggerApplicationInsightsBuilder()

    type LoggerEventhubBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LoggerEventhubArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("connectionString")>]
        member _.ConnectionString((n, args), connectionString) =
            let apply (args: LoggerEventhubArgs) =
                args.ConnectionString <- input connectionString
                args

            ()
            n, List.Cons(apply, args)

        member _.ConnectionString((n, args), connectionString) =
            let apply (args: LoggerEventhubArgs) =
                args.ConnectionString <- io connectionString
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: LoggerEventhubArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: LoggerEventhubArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

    let loggerEventhub = LoggerEventhubBuilder()

    type ServiceAdditionalLocationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ServiceAdditionalLocationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("gatewayRegionalUrl")>]
        member _.GatewayRegionalUrl((n, args), gatewayRegionalUrl) =
            let apply (args: ServiceAdditionalLocationArgs) =
                args.GatewayRegionalUrl <- input gatewayRegionalUrl
                args

            ()
            n, List.Cons(apply, args)

        member _.GatewayRegionalUrl((n, args), gatewayRegionalUrl) =
            let apply (args: ServiceAdditionalLocationArgs) =
                args.GatewayRegionalUrl <- io gatewayRegionalUrl
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((n, args), location) =
            let apply (args: ServiceAdditionalLocationArgs) =
                args.Location <- input location
                args

            ()
            n, List.Cons(apply, args)

        member _.Location((n, args), location) =
            let apply (args: ServiceAdditionalLocationArgs) =
                args.Location <- io location
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publicIpAddresses")>]
        member _.PublicIpAddresses((n, args), publicIpAddresses) =
            let apply (args: ServiceAdditionalLocationArgs) =
                args.PublicIpAddresses <- inputList publicIpAddresses
                args

            ()
            n, List.Cons(apply, args)

    let serviceAdditionalLocation = ServiceAdditionalLocationBuilder()

    type ServiceCertificateBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ServiceCertificateArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("certificatePassword")>]
        member _.CertificatePassword((n, args), certificatePassword) =
            let apply (args: ServiceCertificateArgs) =
                args.CertificatePassword <- input certificatePassword
                args

            ()
            n, List.Cons(apply, args)

        member _.CertificatePassword((n, args), certificatePassword) =
            let apply (args: ServiceCertificateArgs) =
                args.CertificatePassword <- io certificatePassword
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("encodedCertificate")>]
        member _.EncodedCertificate((n, args), encodedCertificate) =
            let apply (args: ServiceCertificateArgs) =
                args.EncodedCertificate <- input encodedCertificate
                args

            ()
            n, List.Cons(apply, args)

        member _.EncodedCertificate((n, args), encodedCertificate) =
            let apply (args: ServiceCertificateArgs) =
                args.EncodedCertificate <- io encodedCertificate
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storeName")>]
        member _.StoreName((n, args), storeName) =
            let apply (args: ServiceCertificateArgs) =
                args.StoreName <- input storeName
                args

            ()
            n, List.Cons(apply, args)

        member _.StoreName((n, args), storeName) =
            let apply (args: ServiceCertificateArgs) =
                args.StoreName <- io storeName
                args

            ()
            n, List.Cons(apply, args)

    let serviceCertificate = ServiceCertificateBuilder()

    type ServiceHostnameConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ServiceHostnameConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("developerPortals")>]
        member _.DeveloperPortals((n, args), developerPortals) =
            let apply (args: ServiceHostnameConfigurationArgs) =
                args.DeveloperPortals <- inputList developerPortals
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("managements")>]
        member _.Managements((n, args), managements) =
            let apply (args: ServiceHostnameConfigurationArgs) =
                args.Managements <- inputList managements
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("portals")>]
        member _.Portals((n, args), portals) =
            let apply (args: ServiceHostnameConfigurationArgs) =
                args.Portals <- inputList portals
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("proxies")>]
        member _.Proxies((n, args), proxies) =
            let apply (args: ServiceHostnameConfigurationArgs) =
                args.Proxies <- inputList proxies
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("scms")>]
        member _.Scms((n, args), scms) =
            let apply (args: ServiceHostnameConfigurationArgs) =
                args.Scms <- inputList scms
                args

            ()
            n, List.Cons(apply, args)

    let serviceHostnameConfiguration = ServiceHostnameConfigurationBuilder()

    type ServiceHostnameConfigurationDeveloperPortalBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ServiceHostnameConfigurationDeveloperPortalArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("certificate")>]
        member _.Certificate((n, args), certificate) =
            let apply (args: ServiceHostnameConfigurationDeveloperPortalArgs) =
                args.Certificate <- input certificate
                args

            ()
            n, List.Cons(apply, args)

        member _.Certificate((n, args), certificate) =
            let apply (args: ServiceHostnameConfigurationDeveloperPortalArgs) =
                args.Certificate <- io certificate
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("certificatePassword")>]
        member _.CertificatePassword((n, args), certificatePassword) =
            let apply (args: ServiceHostnameConfigurationDeveloperPortalArgs) =
                args.CertificatePassword <- input certificatePassword
                args

            ()
            n, List.Cons(apply, args)

        member _.CertificatePassword((n, args), certificatePassword) =
            let apply (args: ServiceHostnameConfigurationDeveloperPortalArgs) =
                args.CertificatePassword <- io certificatePassword
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("hostName")>]
        member _.HostName((n, args), hostName) =
            let apply (args: ServiceHostnameConfigurationDeveloperPortalArgs) =
                args.HostName <- input hostName
                args

            ()
            n, List.Cons(apply, args)

        member _.HostName((n, args), hostName) =
            let apply (args: ServiceHostnameConfigurationDeveloperPortalArgs) =
                args.HostName <- io hostName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("keyVaultId")>]
        member _.KeyVaultId((n, args), keyVaultId) =
            let apply (args: ServiceHostnameConfigurationDeveloperPortalArgs) =
                args.KeyVaultId <- input keyVaultId
                args

            ()
            n, List.Cons(apply, args)

        member _.KeyVaultId((n, args), keyVaultId) =
            let apply (args: ServiceHostnameConfigurationDeveloperPortalArgs) =
                args.KeyVaultId <- io keyVaultId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("negotiateClientCertificate")>]
        member _.NegotiateClientCertificate((n, args), negotiateClientCertificate) =
            let apply (args: ServiceHostnameConfigurationDeveloperPortalArgs) =
                args.NegotiateClientCertificate <- input negotiateClientCertificate
                args

            ()
            n, List.Cons(apply, args)

        member _.NegotiateClientCertificate((n, args), negotiateClientCertificate) =
            let apply (args: ServiceHostnameConfigurationDeveloperPortalArgs) =
                args.NegotiateClientCertificate <- io negotiateClientCertificate
                args

            ()
            n, List.Cons(apply, args)

    let serviceHostnameConfigurationDeveloperPortal =
        ServiceHostnameConfigurationDeveloperPortalBuilder()

    type ServiceHostnameConfigurationManagementBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ServiceHostnameConfigurationManagementArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("certificate")>]
        member _.Certificate((n, args), certificate) =
            let apply (args: ServiceHostnameConfigurationManagementArgs) =
                args.Certificate <- input certificate
                args

            ()
            n, List.Cons(apply, args)

        member _.Certificate((n, args), certificate) =
            let apply (args: ServiceHostnameConfigurationManagementArgs) =
                args.Certificate <- io certificate
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("certificatePassword")>]
        member _.CertificatePassword((n, args), certificatePassword) =
            let apply (args: ServiceHostnameConfigurationManagementArgs) =
                args.CertificatePassword <- input certificatePassword
                args

            ()
            n, List.Cons(apply, args)

        member _.CertificatePassword((n, args), certificatePassword) =
            let apply (args: ServiceHostnameConfigurationManagementArgs) =
                args.CertificatePassword <- io certificatePassword
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("hostName")>]
        member _.HostName((n, args), hostName) =
            let apply (args: ServiceHostnameConfigurationManagementArgs) =
                args.HostName <- input hostName
                args

            ()
            n, List.Cons(apply, args)

        member _.HostName((n, args), hostName) =
            let apply (args: ServiceHostnameConfigurationManagementArgs) =
                args.HostName <- io hostName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("keyVaultId")>]
        member _.KeyVaultId((n, args), keyVaultId) =
            let apply (args: ServiceHostnameConfigurationManagementArgs) =
                args.KeyVaultId <- input keyVaultId
                args

            ()
            n, List.Cons(apply, args)

        member _.KeyVaultId((n, args), keyVaultId) =
            let apply (args: ServiceHostnameConfigurationManagementArgs) =
                args.KeyVaultId <- io keyVaultId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("negotiateClientCertificate")>]
        member _.NegotiateClientCertificate((n, args), negotiateClientCertificate) =
            let apply (args: ServiceHostnameConfigurationManagementArgs) =
                args.NegotiateClientCertificate <- input negotiateClientCertificate
                args

            ()
            n, List.Cons(apply, args)

        member _.NegotiateClientCertificate((n, args), negotiateClientCertificate) =
            let apply (args: ServiceHostnameConfigurationManagementArgs) =
                args.NegotiateClientCertificate <- io negotiateClientCertificate
                args

            ()
            n, List.Cons(apply, args)

    let serviceHostnameConfigurationManagement =
        ServiceHostnameConfigurationManagementBuilder()

    type ServiceHostnameConfigurationPortalBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ServiceHostnameConfigurationPortalArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("certificate")>]
        member _.Certificate((n, args), certificate) =
            let apply (args: ServiceHostnameConfigurationPortalArgs) =
                args.Certificate <- input certificate
                args

            ()
            n, List.Cons(apply, args)

        member _.Certificate((n, args), certificate) =
            let apply (args: ServiceHostnameConfigurationPortalArgs) =
                args.Certificate <- io certificate
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("certificatePassword")>]
        member _.CertificatePassword((n, args), certificatePassword) =
            let apply (args: ServiceHostnameConfigurationPortalArgs) =
                args.CertificatePassword <- input certificatePassword
                args

            ()
            n, List.Cons(apply, args)

        member _.CertificatePassword((n, args), certificatePassword) =
            let apply (args: ServiceHostnameConfigurationPortalArgs) =
                args.CertificatePassword <- io certificatePassword
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("hostName")>]
        member _.HostName((n, args), hostName) =
            let apply (args: ServiceHostnameConfigurationPortalArgs) =
                args.HostName <- input hostName
                args

            ()
            n, List.Cons(apply, args)

        member _.HostName((n, args), hostName) =
            let apply (args: ServiceHostnameConfigurationPortalArgs) =
                args.HostName <- io hostName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("keyVaultId")>]
        member _.KeyVaultId((n, args), keyVaultId) =
            let apply (args: ServiceHostnameConfigurationPortalArgs) =
                args.KeyVaultId <- input keyVaultId
                args

            ()
            n, List.Cons(apply, args)

        member _.KeyVaultId((n, args), keyVaultId) =
            let apply (args: ServiceHostnameConfigurationPortalArgs) =
                args.KeyVaultId <- io keyVaultId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("negotiateClientCertificate")>]
        member _.NegotiateClientCertificate((n, args), negotiateClientCertificate) =
            let apply (args: ServiceHostnameConfigurationPortalArgs) =
                args.NegotiateClientCertificate <- input negotiateClientCertificate
                args

            ()
            n, List.Cons(apply, args)

        member _.NegotiateClientCertificate((n, args), negotiateClientCertificate) =
            let apply (args: ServiceHostnameConfigurationPortalArgs) =
                args.NegotiateClientCertificate <- io negotiateClientCertificate
                args

            ()
            n, List.Cons(apply, args)

    let serviceHostnameConfigurationPortal =
        ServiceHostnameConfigurationPortalBuilder()

    type ServiceHostnameConfigurationProxyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ServiceHostnameConfigurationProxyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("certificate")>]
        member _.Certificate((n, args), certificate) =
            let apply (args: ServiceHostnameConfigurationProxyArgs) =
                args.Certificate <- input certificate
                args

            ()
            n, List.Cons(apply, args)

        member _.Certificate((n, args), certificate) =
            let apply (args: ServiceHostnameConfigurationProxyArgs) =
                args.Certificate <- io certificate
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("certificatePassword")>]
        member _.CertificatePassword((n, args), certificatePassword) =
            let apply (args: ServiceHostnameConfigurationProxyArgs) =
                args.CertificatePassword <- input certificatePassword
                args

            ()
            n, List.Cons(apply, args)

        member _.CertificatePassword((n, args), certificatePassword) =
            let apply (args: ServiceHostnameConfigurationProxyArgs) =
                args.CertificatePassword <- io certificatePassword
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("defaultSslBinding")>]
        member _.DefaultSslBinding((n, args), defaultSslBinding) =
            let apply (args: ServiceHostnameConfigurationProxyArgs) =
                args.DefaultSslBinding <- input defaultSslBinding
                args

            ()
            n, List.Cons(apply, args)

        member _.DefaultSslBinding((n, args), defaultSslBinding) =
            let apply (args: ServiceHostnameConfigurationProxyArgs) =
                args.DefaultSslBinding <- io defaultSslBinding
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("hostName")>]
        member _.HostName((n, args), hostName) =
            let apply (args: ServiceHostnameConfigurationProxyArgs) =
                args.HostName <- input hostName
                args

            ()
            n, List.Cons(apply, args)

        member _.HostName((n, args), hostName) =
            let apply (args: ServiceHostnameConfigurationProxyArgs) =
                args.HostName <- io hostName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("keyVaultId")>]
        member _.KeyVaultId((n, args), keyVaultId) =
            let apply (args: ServiceHostnameConfigurationProxyArgs) =
                args.KeyVaultId <- input keyVaultId
                args

            ()
            n, List.Cons(apply, args)

        member _.KeyVaultId((n, args), keyVaultId) =
            let apply (args: ServiceHostnameConfigurationProxyArgs) =
                args.KeyVaultId <- io keyVaultId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("negotiateClientCertificate")>]
        member _.NegotiateClientCertificate((n, args), negotiateClientCertificate) =
            let apply (args: ServiceHostnameConfigurationProxyArgs) =
                args.NegotiateClientCertificate <- input negotiateClientCertificate
                args

            ()
            n, List.Cons(apply, args)

        member _.NegotiateClientCertificate((n, args), negotiateClientCertificate) =
            let apply (args: ServiceHostnameConfigurationProxyArgs) =
                args.NegotiateClientCertificate <- io negotiateClientCertificate
                args

            ()
            n, List.Cons(apply, args)

    let serviceHostnameConfigurationProxy =
        ServiceHostnameConfigurationProxyBuilder()

    type ServiceHostnameConfigurationScmBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ServiceHostnameConfigurationScmArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("certificate")>]
        member _.Certificate((n, args), certificate) =
            let apply (args: ServiceHostnameConfigurationScmArgs) =
                args.Certificate <- input certificate
                args

            ()
            n, List.Cons(apply, args)

        member _.Certificate((n, args), certificate) =
            let apply (args: ServiceHostnameConfigurationScmArgs) =
                args.Certificate <- io certificate
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("certificatePassword")>]
        member _.CertificatePassword((n, args), certificatePassword) =
            let apply (args: ServiceHostnameConfigurationScmArgs) =
                args.CertificatePassword <- input certificatePassword
                args

            ()
            n, List.Cons(apply, args)

        member _.CertificatePassword((n, args), certificatePassword) =
            let apply (args: ServiceHostnameConfigurationScmArgs) =
                args.CertificatePassword <- io certificatePassword
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("hostName")>]
        member _.HostName((n, args), hostName) =
            let apply (args: ServiceHostnameConfigurationScmArgs) =
                args.HostName <- input hostName
                args

            ()
            n, List.Cons(apply, args)

        member _.HostName((n, args), hostName) =
            let apply (args: ServiceHostnameConfigurationScmArgs) =
                args.HostName <- io hostName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("keyVaultId")>]
        member _.KeyVaultId((n, args), keyVaultId) =
            let apply (args: ServiceHostnameConfigurationScmArgs) =
                args.KeyVaultId <- input keyVaultId
                args

            ()
            n, List.Cons(apply, args)

        member _.KeyVaultId((n, args), keyVaultId) =
            let apply (args: ServiceHostnameConfigurationScmArgs) =
                args.KeyVaultId <- io keyVaultId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("negotiateClientCertificate")>]
        member _.NegotiateClientCertificate((n, args), negotiateClientCertificate) =
            let apply (args: ServiceHostnameConfigurationScmArgs) =
                args.NegotiateClientCertificate <- input negotiateClientCertificate
                args

            ()
            n, List.Cons(apply, args)

        member _.NegotiateClientCertificate((n, args), negotiateClientCertificate) =
            let apply (args: ServiceHostnameConfigurationScmArgs) =
                args.NegotiateClientCertificate <- io negotiateClientCertificate
                args

            ()
            n, List.Cons(apply, args)

    let serviceHostnameConfigurationScm = ServiceHostnameConfigurationScmBuilder()

    type ServiceIdentityBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ServiceIdentityArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("identityIds")>]
        member _.IdentityIds((n, args), identityIds) =
            let apply (args: ServiceIdentityArgs) =
                args.IdentityIds <- inputList identityIds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("principalId")>]
        member _.PrincipalId((n, args), principalId) =
            let apply (args: ServiceIdentityArgs) =
                args.PrincipalId <- input principalId
                args

            ()
            n, List.Cons(apply, args)

        member _.PrincipalId((n, args), principalId) =
            let apply (args: ServiceIdentityArgs) =
                args.PrincipalId <- io principalId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tenantId")>]
        member _.TenantId((n, args), tenantId) =
            let apply (args: ServiceIdentityArgs) =
                args.TenantId <- input tenantId
                args

            ()
            n, List.Cons(apply, args)

        member _.TenantId((n, args), tenantId) =
            let apply (args: ServiceIdentityArgs) =
                args.TenantId <- io tenantId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: ServiceIdentityArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: ServiceIdentityArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let serviceIdentity = ServiceIdentityBuilder()

    type ServicePolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ServicePolicyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("xmlContent")>]
        member _.XmlContent((n, args), xmlContent) =
            let apply (args: ServicePolicyArgs) =
                args.XmlContent <- input xmlContent
                args

            ()
            n, List.Cons(apply, args)

        member _.XmlContent((n, args), xmlContent) =
            let apply (args: ServicePolicyArgs) =
                args.XmlContent <- io xmlContent
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("xmlLink")>]
        member _.XmlLink((n, args), xmlLink) =
            let apply (args: ServicePolicyArgs) =
                args.XmlLink <- input xmlLink
                args

            ()
            n, List.Cons(apply, args)

        member _.XmlLink((n, args), xmlLink) =
            let apply (args: ServicePolicyArgs) =
                args.XmlLink <- io xmlLink
                args

            ()
            n, List.Cons(apply, args)

    let servicePolicy = ServicePolicyBuilder()

    type ServiceProtocolsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ServiceProtocolsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("enableHttp2")>]
        member _.EnableHttp2((n, args), enableHttp2) =
            let apply (args: ServiceProtocolsArgs) =
                args.EnableHttp2 <- input enableHttp2
                args

            ()
            n, List.Cons(apply, args)

        member _.EnableHttp2((n, args), enableHttp2) =
            let apply (args: ServiceProtocolsArgs) =
                args.EnableHttp2 <- io enableHttp2
                args

            ()
            n, List.Cons(apply, args)

    let serviceProtocols = ServiceProtocolsBuilder()

    type ServiceSecurityBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ServiceSecurityArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("enableBackendSsl30")>]
        member _.EnableBackendSsl30((n, args), enableBackendSsl30) =
            let apply (args: ServiceSecurityArgs) =
                args.EnableBackendSsl30 <- input enableBackendSsl30
                args

            ()
            n, List.Cons(apply, args)

        member _.EnableBackendSsl30((n, args), enableBackendSsl30) =
            let apply (args: ServiceSecurityArgs) =
                args.EnableBackendSsl30 <- io enableBackendSsl30
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enableBackendTls10")>]
        member _.EnableBackendTls10((n, args), enableBackendTls10) =
            let apply (args: ServiceSecurityArgs) =
                args.EnableBackendTls10 <- input enableBackendTls10
                args

            ()
            n, List.Cons(apply, args)

        member _.EnableBackendTls10((n, args), enableBackendTls10) =
            let apply (args: ServiceSecurityArgs) =
                args.EnableBackendTls10 <- io enableBackendTls10
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enableBackendTls11")>]
        member _.EnableBackendTls11((n, args), enableBackendTls11) =
            let apply (args: ServiceSecurityArgs) =
                args.EnableBackendTls11 <- input enableBackendTls11
                args

            ()
            n, List.Cons(apply, args)

        member _.EnableBackendTls11((n, args), enableBackendTls11) =
            let apply (args: ServiceSecurityArgs) =
                args.EnableBackendTls11 <- io enableBackendTls11
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enableFrontendSsl30")>]
        member _.EnableFrontendSsl30((n, args), enableFrontendSsl30) =
            let apply (args: ServiceSecurityArgs) =
                args.EnableFrontendSsl30 <- input enableFrontendSsl30
                args

            ()
            n, List.Cons(apply, args)

        member _.EnableFrontendSsl30((n, args), enableFrontendSsl30) =
            let apply (args: ServiceSecurityArgs) =
                args.EnableFrontendSsl30 <- io enableFrontendSsl30
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enableFrontendTls10")>]
        member _.EnableFrontendTls10((n, args), enableFrontendTls10) =
            let apply (args: ServiceSecurityArgs) =
                args.EnableFrontendTls10 <- input enableFrontendTls10
                args

            ()
            n, List.Cons(apply, args)

        member _.EnableFrontendTls10((n, args), enableFrontendTls10) =
            let apply (args: ServiceSecurityArgs) =
                args.EnableFrontendTls10 <- io enableFrontendTls10
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enableFrontendTls11")>]
        member _.EnableFrontendTls11((n, args), enableFrontendTls11) =
            let apply (args: ServiceSecurityArgs) =
                args.EnableFrontendTls11 <- input enableFrontendTls11
                args

            ()
            n, List.Cons(apply, args)

        member _.EnableFrontendTls11((n, args), enableFrontendTls11) =
            let apply (args: ServiceSecurityArgs) =
                args.EnableFrontendTls11 <- io enableFrontendTls11
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enableTripleDesCiphers")>]
        member _.EnableTripleDesCiphers((n, args), enableTripleDesCiphers) =
            let apply (args: ServiceSecurityArgs) =
                args.EnableTripleDesCiphers <- input enableTripleDesCiphers
                args

            ()
            n, List.Cons(apply, args)

        member _.EnableTripleDesCiphers((n, args), enableTripleDesCiphers) =
            let apply (args: ServiceSecurityArgs) =
                args.EnableTripleDesCiphers <- io enableTripleDesCiphers
                args

            ()
            n, List.Cons(apply, args)

    let serviceSecurity = ServiceSecurityBuilder()

    type ServiceSignInBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ServiceSignInArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: ServiceSignInArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: ServiceSignInArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

    let serviceSignIn = ServiceSignInBuilder()

    type ServiceSignUpBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ServiceSignUpArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: ServiceSignUpArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: ServiceSignUpArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ServiceSignUpArgs) =
                   args.TermsOfService <- input arg
                   args

               ()
               func) ]

    let serviceSignUp = ServiceSignUpBuilder()

    type ServiceSignUpTermsOfServiceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ServiceSignUpTermsOfServiceArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("consentRequired")>]
        member _.ConsentRequired((n, args), consentRequired) =
            let apply (args: ServiceSignUpTermsOfServiceArgs) =
                args.ConsentRequired <- input consentRequired
                args

            ()
            n, List.Cons(apply, args)

        member _.ConsentRequired((n, args), consentRequired) =
            let apply (args: ServiceSignUpTermsOfServiceArgs) =
                args.ConsentRequired <- io consentRequired
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: ServiceSignUpTermsOfServiceArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: ServiceSignUpTermsOfServiceArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("text")>]
        member _.Text((n, args), text) =
            let apply (args: ServiceSignUpTermsOfServiceArgs) =
                args.Text <- input text
                args

            ()
            n, List.Cons(apply, args)

        member _.Text((n, args), text) =
            let apply (args: ServiceSignUpTermsOfServiceArgs) =
                args.Text <- io text
                args

            ()
            n, List.Cons(apply, args)

    let serviceSignUpTermsOfService = ServiceSignUpTermsOfServiceBuilder()

    type ServiceVirtualNetworkConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ServiceVirtualNetworkConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: ServiceVirtualNetworkConfigurationArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: ServiceVirtualNetworkConfigurationArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

    let serviceVirtualNetworkConfiguration =
        ServiceVirtualNetworkConfigurationBuilder()

    type ApiBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Api(name, (List.fold func (ApiArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("apiManagementName")>]
        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: ApiArgs) =
                args.ApiManagementName <- input apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: ApiArgs) =
                args.ApiManagementName <- io apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: ApiArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: ApiArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("displayName")>]
        member _.DisplayName((name, args), displayName) =
            let apply (args: ApiArgs) =
                args.DisplayName <- input displayName
                args

            ()
            name, List.Cons(apply, args)

        member _.DisplayName((name, args), displayName) =
            let apply (args: ApiArgs) =
                args.DisplayName <- io displayName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ApiArgs) =
                   args.Import <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ApiArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ApiArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("path")>]
        member _.Path((name, args), path) =
            let apply (args: ApiArgs) =
                args.Path <- input path
                args

            ()
            name, List.Cons(apply, args)

        member _.Path((name, args), path) =
            let apply (args: ApiArgs) =
                args.Path <- io path
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("protocols")>]
        member _.Protocols((name, args), protocols) =
            let apply (args: ApiArgs) =
                args.Protocols <- inputList protocols
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ApiArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ApiArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("revision")>]
        member _.Revision((name, args), revision) =
            let apply (args: ApiArgs) =
                args.Revision <- input revision
                args

            ()
            name, List.Cons(apply, args)

        member _.Revision((name, args), revision) =
            let apply (args: ApiArgs) =
                args.Revision <- io revision
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serviceUrl")>]
        member _.ServiceUrl((name, args), serviceUrl) =
            let apply (args: ApiArgs) =
                args.ServiceUrl <- input serviceUrl
                args

            ()
            name, List.Cons(apply, args)

        member _.ServiceUrl((name, args), serviceUrl) =
            let apply (args: ApiArgs) =
                args.ServiceUrl <- io serviceUrl
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("soapPassThrough")>]
        member _.SoapPassThrough((name, args), soapPassThrough) =
            let apply (args: ApiArgs) =
                args.SoapPassThrough <- input soapPassThrough
                args

            ()
            name, List.Cons(apply, args)

        member _.SoapPassThrough((name, args), soapPassThrough) =
            let apply (args: ApiArgs) =
                args.SoapPassThrough <- io soapPassThrough
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ApiArgs) =
                   args.SubscriptionKeyParameterNames <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("subscriptionRequired")>]
        member _.SubscriptionRequired((name, args), subscriptionRequired) =
            let apply (args: ApiArgs) =
                args.SubscriptionRequired <- input subscriptionRequired
                args

            ()
            name, List.Cons(apply, args)

        member _.SubscriptionRequired((name, args), subscriptionRequired) =
            let apply (args: ApiArgs) =
                args.SubscriptionRequired <- io subscriptionRequired
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("version")>]
        member _.Version((name, args), version) =
            let apply (args: ApiArgs) =
                args.Version <- input version
                args

            ()
            name, List.Cons(apply, args)

        member _.Version((name, args), version) =
            let apply (args: ApiArgs) =
                args.Version <- io version
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("versionSetId")>]
        member _.VersionSetId((name, args), versionSetId) =
            let apply (args: ApiArgs) =
                args.VersionSetId <- input versionSetId
                args

            ()
            name, List.Cons(apply, args)

        member _.VersionSetId((name, args), versionSetId) =
            let apply (args: ApiArgs) =
                args.VersionSetId <- io versionSetId
                args

            ()
            name, List.Cons(apply, args)

    let api = ApiBuilder()

    type ApiOperationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ApiOperation(name, (List.fold func (ApiOperationArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("apiManagementName")>]
        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: ApiOperationArgs) =
                args.ApiManagementName <- input apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: ApiOperationArgs) =
                args.ApiManagementName <- io apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("apiName")>]
        member _.ApiName((name, args), apiName) =
            let apply (args: ApiOperationArgs) =
                args.ApiName <- input apiName
                args

            ()
            name, List.Cons(apply, args)

        member _.ApiName((name, args), apiName) =
            let apply (args: ApiOperationArgs) =
                args.ApiName <- io apiName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: ApiOperationArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: ApiOperationArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("displayName")>]
        member _.DisplayName((name, args), displayName) =
            let apply (args: ApiOperationArgs) =
                args.DisplayName <- input displayName
                args

            ()
            name, List.Cons(apply, args)

        member _.DisplayName((name, args), displayName) =
            let apply (args: ApiOperationArgs) =
                args.DisplayName <- io displayName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("method")>]
        member _.Method((name, args), method) =
            let apply (args: ApiOperationArgs) =
                args.Method <- input method
                args

            ()
            name, List.Cons(apply, args)

        member _.Method((name, args), method) =
            let apply (args: ApiOperationArgs) =
                args.Method <- io method
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("operationId")>]
        member _.OperationId((name, args), operationId) =
            let apply (args: ApiOperationArgs) =
                args.OperationId <- input operationId
                args

            ()
            name, List.Cons(apply, args)

        member _.OperationId((name, args), operationId) =
            let apply (args: ApiOperationArgs) =
                args.OperationId <- io operationId
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ApiOperationArgs) =
                   args.Request <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ApiOperationArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ApiOperationArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("responses")>]
        member _.Responses((name, args), responses) =
            let apply (args: ApiOperationArgs) =
                args.Responses <- inputList responses
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("templateParameters")>]
        member _.TemplateParameters((name, args), templateParameters) =
            let apply (args: ApiOperationArgs) =
                args.TemplateParameters <- inputList templateParameters
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("urlTemplate")>]
        member _.UrlTemplate((name, args), urlTemplate) =
            let apply (args: ApiOperationArgs) =
                args.UrlTemplate <- input urlTemplate
                args

            ()
            name, List.Cons(apply, args)

        member _.UrlTemplate((name, args), urlTemplate) =
            let apply (args: ApiOperationArgs) =
                args.UrlTemplate <- io urlTemplate
                args

            ()
            name, List.Cons(apply, args)

    let apiOperation = ApiOperationBuilder()

    type ApiOperationPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ApiOperationPolicy(name, (List.fold func (ApiOperationPolicyArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("apiManagementName")>]
        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: ApiOperationPolicyArgs) =
                args.ApiManagementName <- input apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: ApiOperationPolicyArgs) =
                args.ApiManagementName <- io apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("apiName")>]
        member _.ApiName((name, args), apiName) =
            let apply (args: ApiOperationPolicyArgs) =
                args.ApiName <- input apiName
                args

            ()
            name, List.Cons(apply, args)

        member _.ApiName((name, args), apiName) =
            let apply (args: ApiOperationPolicyArgs) =
                args.ApiName <- io apiName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("operationId")>]
        member _.OperationId((name, args), operationId) =
            let apply (args: ApiOperationPolicyArgs) =
                args.OperationId <- input operationId
                args

            ()
            name, List.Cons(apply, args)

        member _.OperationId((name, args), operationId) =
            let apply (args: ApiOperationPolicyArgs) =
                args.OperationId <- io operationId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ApiOperationPolicyArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ApiOperationPolicyArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("xmlContent")>]
        member _.XmlContent((name, args), xmlContent) =
            let apply (args: ApiOperationPolicyArgs) =
                args.XmlContent <- input xmlContent
                args

            ()
            name, List.Cons(apply, args)

        member _.XmlContent((name, args), xmlContent) =
            let apply (args: ApiOperationPolicyArgs) =
                args.XmlContent <- io xmlContent
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("xmlLink")>]
        member _.XmlLink((name, args), xmlLink) =
            let apply (args: ApiOperationPolicyArgs) =
                args.XmlLink <- input xmlLink
                args

            ()
            name, List.Cons(apply, args)

        member _.XmlLink((name, args), xmlLink) =
            let apply (args: ApiOperationPolicyArgs) =
                args.XmlLink <- io xmlLink
                args

            ()
            name, List.Cons(apply, args)

    let apiOperationPolicy = ApiOperationPolicyBuilder()

    type ApiPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ApiPolicy(name, (List.fold func (ApiPolicyArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("apiManagementName")>]
        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: ApiPolicyArgs) =
                args.ApiManagementName <- input apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: ApiPolicyArgs) =
                args.ApiManagementName <- io apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("apiName")>]
        member _.ApiName((name, args), apiName) =
            let apply (args: ApiPolicyArgs) =
                args.ApiName <- input apiName
                args

            ()
            name, List.Cons(apply, args)

        member _.ApiName((name, args), apiName) =
            let apply (args: ApiPolicyArgs) =
                args.ApiName <- io apiName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ApiPolicyArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ApiPolicyArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("xmlContent")>]
        member _.XmlContent((name, args), xmlContent) =
            let apply (args: ApiPolicyArgs) =
                args.XmlContent <- input xmlContent
                args

            ()
            name, List.Cons(apply, args)

        member _.XmlContent((name, args), xmlContent) =
            let apply (args: ApiPolicyArgs) =
                args.XmlContent <- io xmlContent
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("xmlLink")>]
        member _.XmlLink((name, args), xmlLink) =
            let apply (args: ApiPolicyArgs) =
                args.XmlLink <- input xmlLink
                args

            ()
            name, List.Cons(apply, args)

        member _.XmlLink((name, args), xmlLink) =
            let apply (args: ApiPolicyArgs) =
                args.XmlLink <- io xmlLink
                args

            ()
            name, List.Cons(apply, args)

    let apiPolicy = ApiPolicyBuilder()

    type ApiSchemaBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ApiSchema(name, (List.fold func (ApiSchemaArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("apiManagementName")>]
        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: ApiSchemaArgs) =
                args.ApiManagementName <- input apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: ApiSchemaArgs) =
                args.ApiManagementName <- io apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("apiName")>]
        member _.ApiName((name, args), apiName) =
            let apply (args: ApiSchemaArgs) =
                args.ApiName <- input apiName
                args

            ()
            name, List.Cons(apply, args)

        member _.ApiName((name, args), apiName) =
            let apply (args: ApiSchemaArgs) =
                args.ApiName <- io apiName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("contentType")>]
        member _.ContentType((name, args), contentType) =
            let apply (args: ApiSchemaArgs) =
                args.ContentType <- input contentType
                args

            ()
            name, List.Cons(apply, args)

        member _.ContentType((name, args), contentType) =
            let apply (args: ApiSchemaArgs) =
                args.ContentType <- io contentType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ApiSchemaArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ApiSchemaArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("schemaId")>]
        member _.SchemaId((name, args), schemaId) =
            let apply (args: ApiSchemaArgs) =
                args.SchemaId <- input schemaId
                args

            ()
            name, List.Cons(apply, args)

        member _.SchemaId((name, args), schemaId) =
            let apply (args: ApiSchemaArgs) =
                args.SchemaId <- io schemaId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((name, args), value) =
            let apply (args: ApiSchemaArgs) =
                args.Value <- input value
                args

            ()
            name, List.Cons(apply, args)

        member _.Value((name, args), value) =
            let apply (args: ApiSchemaArgs) =
                args.Value <- io value
                args

            ()
            name, List.Cons(apply, args)

    let apiSchema = ApiSchemaBuilder()

    type ApiVersionSetBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ApiVersionSet(name, (List.fold func (ApiVersionSetArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("apiManagementName")>]
        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: ApiVersionSetArgs) =
                args.ApiManagementName <- input apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: ApiVersionSetArgs) =
                args.ApiManagementName <- io apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: ApiVersionSetArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: ApiVersionSetArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("displayName")>]
        member _.DisplayName((name, args), displayName) =
            let apply (args: ApiVersionSetArgs) =
                args.DisplayName <- input displayName
                args

            ()
            name, List.Cons(apply, args)

        member _.DisplayName((name, args), displayName) =
            let apply (args: ApiVersionSetArgs) =
                args.DisplayName <- io displayName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ApiVersionSetArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ApiVersionSetArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ApiVersionSetArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ApiVersionSetArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("versionHeaderName")>]
        member _.VersionHeaderName((name, args), versionHeaderName) =
            let apply (args: ApiVersionSetArgs) =
                args.VersionHeaderName <- input versionHeaderName
                args

            ()
            name, List.Cons(apply, args)

        member _.VersionHeaderName((name, args), versionHeaderName) =
            let apply (args: ApiVersionSetArgs) =
                args.VersionHeaderName <- io versionHeaderName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("versionQueryName")>]
        member _.VersionQueryName((name, args), versionQueryName) =
            let apply (args: ApiVersionSetArgs) =
                args.VersionQueryName <- input versionQueryName
                args

            ()
            name, List.Cons(apply, args)

        member _.VersionQueryName((name, args), versionQueryName) =
            let apply (args: ApiVersionSetArgs) =
                args.VersionQueryName <- io versionQueryName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("versioningScheme")>]
        member _.VersioningScheme((name, args), versioningScheme) =
            let apply (args: ApiVersionSetArgs) =
                args.VersioningScheme <- input versioningScheme
                args

            ()
            name, List.Cons(apply, args)

        member _.VersioningScheme((name, args), versioningScheme) =
            let apply (args: ApiVersionSetArgs) =
                args.VersioningScheme <- io versioningScheme
                args

            ()
            name, List.Cons(apply, args)

    let apiVersionSet = ApiVersionSetBuilder()

    type AuthorizationServerBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            AuthorizationServer(name, (List.fold func (AuthorizationServerArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("apiManagementName")>]
        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: AuthorizationServerArgs) =
                args.ApiManagementName <- input apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: AuthorizationServerArgs) =
                args.ApiManagementName <- io apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("authorizationEndpoint")>]
        member _.AuthorizationEndpoint((name, args), authorizationEndpoint) =
            let apply (args: AuthorizationServerArgs) =
                args.AuthorizationEndpoint <- input authorizationEndpoint
                args

            ()
            name, List.Cons(apply, args)

        member _.AuthorizationEndpoint((name, args), authorizationEndpoint) =
            let apply (args: AuthorizationServerArgs) =
                args.AuthorizationEndpoint <- io authorizationEndpoint
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("authorizationMethods")>]
        member _.AuthorizationMethods((name, args), authorizationMethods) =
            let apply (args: AuthorizationServerArgs) =
                args.AuthorizationMethods <- inputList authorizationMethods
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("bearerTokenSendingMethods")>]
        member _.BearerTokenSendingMethods((name, args), bearerTokenSendingMethods) =
            let apply (args: AuthorizationServerArgs) =
                args.BearerTokenSendingMethods <- inputList bearerTokenSendingMethods
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("clientAuthenticationMethods")>]
        member _.ClientAuthenticationMethods((name, args), clientAuthenticationMethods) =
            let apply (args: AuthorizationServerArgs) =
                args.ClientAuthenticationMethods <- inputList clientAuthenticationMethods
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("clientId")>]
        member _.ClientId((name, args), clientId) =
            let apply (args: AuthorizationServerArgs) =
                args.ClientId <- input clientId
                args

            ()
            name, List.Cons(apply, args)

        member _.ClientId((name, args), clientId) =
            let apply (args: AuthorizationServerArgs) =
                args.ClientId <- io clientId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("clientRegistrationEndpoint")>]
        member _.ClientRegistrationEndpoint((name, args), clientRegistrationEndpoint) =
            let apply (args: AuthorizationServerArgs) =
                args.ClientRegistrationEndpoint <- input clientRegistrationEndpoint
                args

            ()
            name, List.Cons(apply, args)

        member _.ClientRegistrationEndpoint((name, args), clientRegistrationEndpoint) =
            let apply (args: AuthorizationServerArgs) =
                args.ClientRegistrationEndpoint <- io clientRegistrationEndpoint
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("clientSecret")>]
        member _.ClientSecret((name, args), clientSecret) =
            let apply (args: AuthorizationServerArgs) =
                args.ClientSecret <- input clientSecret
                args

            ()
            name, List.Cons(apply, args)

        member _.ClientSecret((name, args), clientSecret) =
            let apply (args: AuthorizationServerArgs) =
                args.ClientSecret <- io clientSecret
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("defaultScope")>]
        member _.DefaultScope((name, args), defaultScope) =
            let apply (args: AuthorizationServerArgs) =
                args.DefaultScope <- input defaultScope
                args

            ()
            name, List.Cons(apply, args)

        member _.DefaultScope((name, args), defaultScope) =
            let apply (args: AuthorizationServerArgs) =
                args.DefaultScope <- io defaultScope
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: AuthorizationServerArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: AuthorizationServerArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("displayName")>]
        member _.DisplayName((name, args), displayName) =
            let apply (args: AuthorizationServerArgs) =
                args.DisplayName <- input displayName
                args

            ()
            name, List.Cons(apply, args)

        member _.DisplayName((name, args), displayName) =
            let apply (args: AuthorizationServerArgs) =
                args.DisplayName <- io displayName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("grantTypes")>]
        member _.GrantTypes((name, args), grantTypes) =
            let apply (args: AuthorizationServerArgs) =
                args.GrantTypes <- inputList grantTypes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: AuthorizationServerArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: AuthorizationServerArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AuthorizationServerArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AuthorizationServerArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceOwnerPassword")>]
        member _.ResourceOwnerPassword((name, args), resourceOwnerPassword) =
            let apply (args: AuthorizationServerArgs) =
                args.ResourceOwnerPassword <- input resourceOwnerPassword
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceOwnerPassword((name, args), resourceOwnerPassword) =
            let apply (args: AuthorizationServerArgs) =
                args.ResourceOwnerPassword <- io resourceOwnerPassword
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceOwnerUsername")>]
        member _.ResourceOwnerUsername((name, args), resourceOwnerUsername) =
            let apply (args: AuthorizationServerArgs) =
                args.ResourceOwnerUsername <- input resourceOwnerUsername
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceOwnerUsername((name, args), resourceOwnerUsername) =
            let apply (args: AuthorizationServerArgs) =
                args.ResourceOwnerUsername <- io resourceOwnerUsername
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("supportState")>]
        member _.SupportState((name, args), supportState) =
            let apply (args: AuthorizationServerArgs) =
                args.SupportState <- input supportState
                args

            ()
            name, List.Cons(apply, args)

        member _.SupportState((name, args), supportState) =
            let apply (args: AuthorizationServerArgs) =
                args.SupportState <- io supportState
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tokenBodyParameters")>]
        member _.TokenBodyParameters((name, args), tokenBodyParameters) =
            let apply (args: AuthorizationServerArgs) =
                args.TokenBodyParameters <- inputList tokenBodyParameters
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tokenEndpoint")>]
        member _.TokenEndpoint((name, args), tokenEndpoint) =
            let apply (args: AuthorizationServerArgs) =
                args.TokenEndpoint <- input tokenEndpoint
                args

            ()
            name, List.Cons(apply, args)

        member _.TokenEndpoint((name, args), tokenEndpoint) =
            let apply (args: AuthorizationServerArgs) =
                args.TokenEndpoint <- io tokenEndpoint
                args

            ()
            name, List.Cons(apply, args)

    let authorizationServer = AuthorizationServerBuilder()

    type BackendBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Backend(name, (List.fold func (BackendArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("apiManagementName")>]
        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: BackendArgs) =
                args.ApiManagementName <- input apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: BackendArgs) =
                args.ApiManagementName <- io apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: BackendArgs) =
                   args.Credentials <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: BackendArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: BackendArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: BackendArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: BackendArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("protocol")>]
        member _.Protocol((name, args), protocol) =
            let apply (args: BackendArgs) =
                args.Protocol <- input protocol
                args

            ()
            name, List.Cons(apply, args)

        member _.Protocol((name, args), protocol) =
            let apply (args: BackendArgs) =
                args.Protocol <- io protocol
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: BackendArgs) =
                   args.Proxy <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: BackendArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: BackendArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceId")>]
        member _.ResourceId((name, args), resourceId) =
            let apply (args: BackendArgs) =
                args.ResourceId <- input resourceId
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceId((name, args), resourceId) =
            let apply (args: BackendArgs) =
                args.ResourceId <- io resourceId
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: BackendArgs) =
                   args.ServiceFabricCluster <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("title")>]
        member _.Title((name, args), title) =
            let apply (args: BackendArgs) =
                args.Title <- input title
                args

            ()
            name, List.Cons(apply, args)

        member _.Title((name, args), title) =
            let apply (args: BackendArgs) =
                args.Title <- io title
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: BackendArgs) =
                   args.Tls <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("url")>]
        member _.Url((name, args), url) =
            let apply (args: BackendArgs) =
                args.Url <- input url
                args

            ()
            name, List.Cons(apply, args)

        member _.Url((name, args), url) =
            let apply (args: BackendArgs) =
                args.Url <- io url
                args

            ()
            name, List.Cons(apply, args)

    let backend = BackendBuilder()

    type CertificateBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Certificate(name, (List.fold func (CertificateArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("apiManagementName")>]
        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: CertificateArgs) =
                args.ApiManagementName <- input apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: CertificateArgs) =
                args.ApiManagementName <- io apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("data")>]
        member _.Data((name, args), data) =
            let apply (args: CertificateArgs) =
                args.Data <- input data
                args

            ()
            name, List.Cons(apply, args)

        member _.Data((name, args), data) =
            let apply (args: CertificateArgs) =
                args.Data <- io data
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: CertificateArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: CertificateArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("password")>]
        member _.Password((name, args), password) =
            let apply (args: CertificateArgs) =
                args.Password <- input password
                args

            ()
            name, List.Cons(apply, args)

        member _.Password((name, args), password) =
            let apply (args: CertificateArgs) =
                args.Password <- io password
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: CertificateArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: CertificateArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let certificate = CertificateBuilder()

    type DiagnosticBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Diagnostic(name, (List.fold func (DiagnosticArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("apiManagementLoggerId")>]
        member _.ApiManagementLoggerId((name, args), apiManagementLoggerId) =
            let apply (args: DiagnosticArgs) =
                args.ApiManagementLoggerId <- input apiManagementLoggerId
                args

            ()
            name, List.Cons(apply, args)

        member _.ApiManagementLoggerId((name, args), apiManagementLoggerId) =
            let apply (args: DiagnosticArgs) =
                args.ApiManagementLoggerId <- io apiManagementLoggerId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("apiManagementName")>]
        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: DiagnosticArgs) =
                args.ApiManagementName <- input apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: DiagnosticArgs) =
                args.ApiManagementName <- io apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((name, args), enabled) =
            let apply (args: DiagnosticArgs) =
                args.Enabled <- input enabled
                args

            ()
            name, List.Cons(apply, args)

        member _.Enabled((name, args), enabled) =
            let apply (args: DiagnosticArgs) =
                args.Enabled <- io enabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("identifier")>]
        member _.Identifier((name, args), identifier) =
            let apply (args: DiagnosticArgs) =
                args.Identifier <- input identifier
                args

            ()
            name, List.Cons(apply, args)

        member _.Identifier((name, args), identifier) =
            let apply (args: DiagnosticArgs) =
                args.Identifier <- io identifier
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DiagnosticArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DiagnosticArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let diagnostic = DiagnosticBuilder()

    type GroupBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Group(name, (List.fold func (GroupArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("apiManagementName")>]
        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: GroupArgs) =
                args.ApiManagementName <- input apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: GroupArgs) =
                args.ApiManagementName <- io apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: GroupArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: GroupArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("displayName")>]
        member _.DisplayName((name, args), displayName) =
            let apply (args: GroupArgs) =
                args.DisplayName <- input displayName
                args

            ()
            name, List.Cons(apply, args)

        member _.DisplayName((name, args), displayName) =
            let apply (args: GroupArgs) =
                args.DisplayName <- io displayName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("externalId")>]
        member _.ExternalId((name, args), externalId) =
            let apply (args: GroupArgs) =
                args.ExternalId <- input externalId
                args

            ()
            name, List.Cons(apply, args)

        member _.ExternalId((name, args), externalId) =
            let apply (args: GroupArgs) =
                args.ExternalId <- io externalId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: GroupArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: GroupArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: GroupArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: GroupArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((name, args), ``type``) =
            let apply (args: GroupArgs) =
                args.Type <- input ``type``
                args

            ()
            name, List.Cons(apply, args)

        member _.Type((name, args), ``type``) =
            let apply (args: GroupArgs) =
                args.Type <- io ``type``
                args

            ()
            name, List.Cons(apply, args)

    let group = GroupBuilder()

    type GroupUserBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            GroupUser(name, (List.fold func (GroupUserArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("apiManagementName")>]
        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: GroupUserArgs) =
                args.ApiManagementName <- input apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: GroupUserArgs) =
                args.ApiManagementName <- io apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("groupName")>]
        member _.GroupName((name, args), groupName) =
            let apply (args: GroupUserArgs) =
                args.GroupName <- input groupName
                args

            ()
            name, List.Cons(apply, args)

        member _.GroupName((name, args), groupName) =
            let apply (args: GroupUserArgs) =
                args.GroupName <- io groupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: GroupUserArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: GroupUserArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("userId")>]
        member _.UserId((name, args), userId) =
            let apply (args: GroupUserArgs) =
                args.UserId <- input userId
                args

            ()
            name, List.Cons(apply, args)

        member _.UserId((name, args), userId) =
            let apply (args: GroupUserArgs) =
                args.UserId <- io userId
                args

            ()
            name, List.Cons(apply, args)

    let groupUser = GroupUserBuilder()

    type IdentityProviderAadBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            IdentityProviderAad(name, (List.fold func (IdentityProviderAadArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("allowedTenants")>]
        member _.AllowedTenants((name, args), allowedTenants) =
            let apply (args: IdentityProviderAadArgs) =
                args.AllowedTenants <- inputList allowedTenants
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("apiManagementName")>]
        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: IdentityProviderAadArgs) =
                args.ApiManagementName <- input apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: IdentityProviderAadArgs) =
                args.ApiManagementName <- io apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("clientId")>]
        member _.ClientId((name, args), clientId) =
            let apply (args: IdentityProviderAadArgs) =
                args.ClientId <- input clientId
                args

            ()
            name, List.Cons(apply, args)

        member _.ClientId((name, args), clientId) =
            let apply (args: IdentityProviderAadArgs) =
                args.ClientId <- io clientId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("clientSecret")>]
        member _.ClientSecret((name, args), clientSecret) =
            let apply (args: IdentityProviderAadArgs) =
                args.ClientSecret <- input clientSecret
                args

            ()
            name, List.Cons(apply, args)

        member _.ClientSecret((name, args), clientSecret) =
            let apply (args: IdentityProviderAadArgs) =
                args.ClientSecret <- io clientSecret
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: IdentityProviderAadArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: IdentityProviderAadArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let identityProviderAad = IdentityProviderAadBuilder()

    type IdentityProviderFacebookBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            IdentityProviderFacebook(name, (List.fold func (IdentityProviderFacebookArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("apiManagementName")>]
        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: IdentityProviderFacebookArgs) =
                args.ApiManagementName <- input apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: IdentityProviderFacebookArgs) =
                args.ApiManagementName <- io apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("appId")>]
        member _.AppId((name, args), appId) =
            let apply (args: IdentityProviderFacebookArgs) =
                args.AppId <- input appId
                args

            ()
            name, List.Cons(apply, args)

        member _.AppId((name, args), appId) =
            let apply (args: IdentityProviderFacebookArgs) =
                args.AppId <- io appId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("appSecret")>]
        member _.AppSecret((name, args), appSecret) =
            let apply (args: IdentityProviderFacebookArgs) =
                args.AppSecret <- input appSecret
                args

            ()
            name, List.Cons(apply, args)

        member _.AppSecret((name, args), appSecret) =
            let apply (args: IdentityProviderFacebookArgs) =
                args.AppSecret <- io appSecret
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: IdentityProviderFacebookArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: IdentityProviderFacebookArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let identityProviderFacebook = IdentityProviderFacebookBuilder()

    type IdentityProviderGoogleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            IdentityProviderGoogle(name, (List.fold func (IdentityProviderGoogleArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("apiManagementName")>]
        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: IdentityProviderGoogleArgs) =
                args.ApiManagementName <- input apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: IdentityProviderGoogleArgs) =
                args.ApiManagementName <- io apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("clientId")>]
        member _.ClientId((name, args), clientId) =
            let apply (args: IdentityProviderGoogleArgs) =
                args.ClientId <- input clientId
                args

            ()
            name, List.Cons(apply, args)

        member _.ClientId((name, args), clientId) =
            let apply (args: IdentityProviderGoogleArgs) =
                args.ClientId <- io clientId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("clientSecret")>]
        member _.ClientSecret((name, args), clientSecret) =
            let apply (args: IdentityProviderGoogleArgs) =
                args.ClientSecret <- input clientSecret
                args

            ()
            name, List.Cons(apply, args)

        member _.ClientSecret((name, args), clientSecret) =
            let apply (args: IdentityProviderGoogleArgs) =
                args.ClientSecret <- io clientSecret
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: IdentityProviderGoogleArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: IdentityProviderGoogleArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let identityProviderGoogle = IdentityProviderGoogleBuilder()

    type IdentityProviderMicrosoftBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            IdentityProviderMicrosoft(name, (List.fold func (IdentityProviderMicrosoftArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("apiManagementName")>]
        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: IdentityProviderMicrosoftArgs) =
                args.ApiManagementName <- input apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: IdentityProviderMicrosoftArgs) =
                args.ApiManagementName <- io apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("clientId")>]
        member _.ClientId((name, args), clientId) =
            let apply (args: IdentityProviderMicrosoftArgs) =
                args.ClientId <- input clientId
                args

            ()
            name, List.Cons(apply, args)

        member _.ClientId((name, args), clientId) =
            let apply (args: IdentityProviderMicrosoftArgs) =
                args.ClientId <- io clientId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("clientSecret")>]
        member _.ClientSecret((name, args), clientSecret) =
            let apply (args: IdentityProviderMicrosoftArgs) =
                args.ClientSecret <- input clientSecret
                args

            ()
            name, List.Cons(apply, args)

        member _.ClientSecret((name, args), clientSecret) =
            let apply (args: IdentityProviderMicrosoftArgs) =
                args.ClientSecret <- io clientSecret
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: IdentityProviderMicrosoftArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: IdentityProviderMicrosoftArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let identityProviderMicrosoft = IdentityProviderMicrosoftBuilder()

    type IdentityProviderTwitterBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            IdentityProviderTwitter(name, (List.fold func (IdentityProviderTwitterArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("apiKey")>]
        member _.ApiKey((name, args), apiKey) =
            let apply (args: IdentityProviderTwitterArgs) =
                args.ApiKey <- input apiKey
                args

            ()
            name, List.Cons(apply, args)

        member _.ApiKey((name, args), apiKey) =
            let apply (args: IdentityProviderTwitterArgs) =
                args.ApiKey <- io apiKey
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("apiManagementName")>]
        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: IdentityProviderTwitterArgs) =
                args.ApiManagementName <- input apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: IdentityProviderTwitterArgs) =
                args.ApiManagementName <- io apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("apiSecretKey")>]
        member _.ApiSecretKey((name, args), apiSecretKey) =
            let apply (args: IdentityProviderTwitterArgs) =
                args.ApiSecretKey <- input apiSecretKey
                args

            ()
            name, List.Cons(apply, args)

        member _.ApiSecretKey((name, args), apiSecretKey) =
            let apply (args: IdentityProviderTwitterArgs) =
                args.ApiSecretKey <- io apiSecretKey
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: IdentityProviderTwitterArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: IdentityProviderTwitterArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let identityProviderTwitter = IdentityProviderTwitterBuilder()

    type LoggerBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Logger(name, (List.fold func (LoggerArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("apiManagementName")>]
        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: LoggerArgs) =
                args.ApiManagementName <- input apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: LoggerArgs) =
                args.ApiManagementName <- io apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: LoggerArgs) =
                   args.ApplicationInsights <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("buffered")>]
        member _.Buffered((name, args), buffered) =
            let apply (args: LoggerArgs) =
                args.Buffered <- input buffered
                args

            ()
            name, List.Cons(apply, args)

        member _.Buffered((name, args), buffered) =
            let apply (args: LoggerArgs) =
                args.Buffered <- io buffered
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: LoggerArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: LoggerArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: LoggerArgs) =
                   args.Eventhub <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: LoggerArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: LoggerArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: LoggerArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: LoggerArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let logger = LoggerBuilder()

    type NamedValueBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            NamedValue(name, (List.fold func (NamedValueArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("apiManagementName")>]
        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: NamedValueArgs) =
                args.ApiManagementName <- input apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: NamedValueArgs) =
                args.ApiManagementName <- io apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("displayName")>]
        member _.DisplayName((name, args), displayName) =
            let apply (args: NamedValueArgs) =
                args.DisplayName <- input displayName
                args

            ()
            name, List.Cons(apply, args)

        member _.DisplayName((name, args), displayName) =
            let apply (args: NamedValueArgs) =
                args.DisplayName <- io displayName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: NamedValueArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: NamedValueArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NamedValueArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NamedValueArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("secret")>]
        member _.Secret((name, args), secret) =
            let apply (args: NamedValueArgs) =
                args.Secret <- input secret
                args

            ()
            name, List.Cons(apply, args)

        member _.Secret((name, args), secret) =
            let apply (args: NamedValueArgs) =
                args.Secret <- io secret
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: NamedValueArgs) =
                args.Tags <- inputList tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((name, args), value) =
            let apply (args: NamedValueArgs) =
                args.Value <- input value
                args

            ()
            name, List.Cons(apply, args)

        member _.Value((name, args), value) =
            let apply (args: NamedValueArgs) =
                args.Value <- io value
                args

            ()
            name, List.Cons(apply, args)

    let namedValue = NamedValueBuilder()

    type OpenIdConnectProviderBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            OpenIdConnectProvider(name, (List.fold func (OpenIdConnectProviderArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("apiManagementName")>]
        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: OpenIdConnectProviderArgs) =
                args.ApiManagementName <- input apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: OpenIdConnectProviderArgs) =
                args.ApiManagementName <- io apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("clientId")>]
        member _.ClientId((name, args), clientId) =
            let apply (args: OpenIdConnectProviderArgs) =
                args.ClientId <- input clientId
                args

            ()
            name, List.Cons(apply, args)

        member _.ClientId((name, args), clientId) =
            let apply (args: OpenIdConnectProviderArgs) =
                args.ClientId <- io clientId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("clientSecret")>]
        member _.ClientSecret((name, args), clientSecret) =
            let apply (args: OpenIdConnectProviderArgs) =
                args.ClientSecret <- input clientSecret
                args

            ()
            name, List.Cons(apply, args)

        member _.ClientSecret((name, args), clientSecret) =
            let apply (args: OpenIdConnectProviderArgs) =
                args.ClientSecret <- io clientSecret
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: OpenIdConnectProviderArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: OpenIdConnectProviderArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("displayName")>]
        member _.DisplayName((name, args), displayName) =
            let apply (args: OpenIdConnectProviderArgs) =
                args.DisplayName <- input displayName
                args

            ()
            name, List.Cons(apply, args)

        member _.DisplayName((name, args), displayName) =
            let apply (args: OpenIdConnectProviderArgs) =
                args.DisplayName <- io displayName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("metadataEndpoint")>]
        member _.MetadataEndpoint((name, args), metadataEndpoint) =
            let apply (args: OpenIdConnectProviderArgs) =
                args.MetadataEndpoint <- input metadataEndpoint
                args

            ()
            name, List.Cons(apply, args)

        member _.MetadataEndpoint((name, args), metadataEndpoint) =
            let apply (args: OpenIdConnectProviderArgs) =
                args.MetadataEndpoint <- io metadataEndpoint
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: OpenIdConnectProviderArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: OpenIdConnectProviderArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: OpenIdConnectProviderArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: OpenIdConnectProviderArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let openIdConnectProvider = OpenIdConnectProviderBuilder()

    type ProductBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Product(name, (List.fold func (ProductArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("apiManagementName")>]
        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: ProductArgs) =
                args.ApiManagementName <- input apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: ProductArgs) =
                args.ApiManagementName <- io apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("approvalRequired")>]
        member _.ApprovalRequired((name, args), approvalRequired) =
            let apply (args: ProductArgs) =
                args.ApprovalRequired <- input approvalRequired
                args

            ()
            name, List.Cons(apply, args)

        member _.ApprovalRequired((name, args), approvalRequired) =
            let apply (args: ProductArgs) =
                args.ApprovalRequired <- io approvalRequired
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: ProductArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: ProductArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("displayName")>]
        member _.DisplayName((name, args), displayName) =
            let apply (args: ProductArgs) =
                args.DisplayName <- input displayName
                args

            ()
            name, List.Cons(apply, args)

        member _.DisplayName((name, args), displayName) =
            let apply (args: ProductArgs) =
                args.DisplayName <- io displayName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("productId")>]
        member _.ProductId((name, args), productId) =
            let apply (args: ProductArgs) =
                args.ProductId <- input productId
                args

            ()
            name, List.Cons(apply, args)

        member _.ProductId((name, args), productId) =
            let apply (args: ProductArgs) =
                args.ProductId <- io productId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("published")>]
        member _.Published((name, args), published) =
            let apply (args: ProductArgs) =
                args.Published <- input published
                args

            ()
            name, List.Cons(apply, args)

        member _.Published((name, args), published) =
            let apply (args: ProductArgs) =
                args.Published <- io published
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ProductArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ProductArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("subscriptionRequired")>]
        member _.SubscriptionRequired((name, args), subscriptionRequired) =
            let apply (args: ProductArgs) =
                args.SubscriptionRequired <- input subscriptionRequired
                args

            ()
            name, List.Cons(apply, args)

        member _.SubscriptionRequired((name, args), subscriptionRequired) =
            let apply (args: ProductArgs) =
                args.SubscriptionRequired <- io subscriptionRequired
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("subscriptionsLimit")>]
        member _.SubscriptionsLimit((name, args), subscriptionsLimit) =
            let apply (args: ProductArgs) =
                args.SubscriptionsLimit <- input subscriptionsLimit
                args

            ()
            name, List.Cons(apply, args)

        member _.SubscriptionsLimit((name, args), subscriptionsLimit) =
            let apply (args: ProductArgs) =
                args.SubscriptionsLimit <- io subscriptionsLimit
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("terms")>]
        member _.Terms((name, args), terms) =
            let apply (args: ProductArgs) =
                args.Terms <- input terms
                args

            ()
            name, List.Cons(apply, args)

        member _.Terms((name, args), terms) =
            let apply (args: ProductArgs) =
                args.Terms <- io terms
                args

            ()
            name, List.Cons(apply, args)

    let product = ProductBuilder()

    type ProductApiBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ProductApi(name, (List.fold func (ProductApiArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("apiManagementName")>]
        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: ProductApiArgs) =
                args.ApiManagementName <- input apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: ProductApiArgs) =
                args.ApiManagementName <- io apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("apiName")>]
        member _.ApiName((name, args), apiName) =
            let apply (args: ProductApiArgs) =
                args.ApiName <- input apiName
                args

            ()
            name, List.Cons(apply, args)

        member _.ApiName((name, args), apiName) =
            let apply (args: ProductApiArgs) =
                args.ApiName <- io apiName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("productId")>]
        member _.ProductId((name, args), productId) =
            let apply (args: ProductApiArgs) =
                args.ProductId <- input productId
                args

            ()
            name, List.Cons(apply, args)

        member _.ProductId((name, args), productId) =
            let apply (args: ProductApiArgs) =
                args.ProductId <- io productId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ProductApiArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ProductApiArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let productApi = ProductApiBuilder()

    type ProductGroupBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ProductGroup(name, (List.fold func (ProductGroupArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("apiManagementName")>]
        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: ProductGroupArgs) =
                args.ApiManagementName <- input apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: ProductGroupArgs) =
                args.ApiManagementName <- io apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("groupName")>]
        member _.GroupName((name, args), groupName) =
            let apply (args: ProductGroupArgs) =
                args.GroupName <- input groupName
                args

            ()
            name, List.Cons(apply, args)

        member _.GroupName((name, args), groupName) =
            let apply (args: ProductGroupArgs) =
                args.GroupName <- io groupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("productId")>]
        member _.ProductId((name, args), productId) =
            let apply (args: ProductGroupArgs) =
                args.ProductId <- input productId
                args

            ()
            name, List.Cons(apply, args)

        member _.ProductId((name, args), productId) =
            let apply (args: ProductGroupArgs) =
                args.ProductId <- io productId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ProductGroupArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ProductGroupArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let productGroup = ProductGroupBuilder()

    type ProductPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ProductPolicy(name, (List.fold func (ProductPolicyArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("apiManagementName")>]
        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: ProductPolicyArgs) =
                args.ApiManagementName <- input apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: ProductPolicyArgs) =
                args.ApiManagementName <- io apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("productId")>]
        member _.ProductId((name, args), productId) =
            let apply (args: ProductPolicyArgs) =
                args.ProductId <- input productId
                args

            ()
            name, List.Cons(apply, args)

        member _.ProductId((name, args), productId) =
            let apply (args: ProductPolicyArgs) =
                args.ProductId <- io productId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ProductPolicyArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ProductPolicyArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("xmlContent")>]
        member _.XmlContent((name, args), xmlContent) =
            let apply (args: ProductPolicyArgs) =
                args.XmlContent <- input xmlContent
                args

            ()
            name, List.Cons(apply, args)

        member _.XmlContent((name, args), xmlContent) =
            let apply (args: ProductPolicyArgs) =
                args.XmlContent <- io xmlContent
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("xmlLink")>]
        member _.XmlLink((name, args), xmlLink) =
            let apply (args: ProductPolicyArgs) =
                args.XmlLink <- input xmlLink
                args

            ()
            name, List.Cons(apply, args)

        member _.XmlLink((name, args), xmlLink) =
            let apply (args: ProductPolicyArgs) =
                args.XmlLink <- io xmlLink
                args

            ()
            name, List.Cons(apply, args)

    let productPolicy = ProductPolicyBuilder()

    type PropertyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Property(name, (List.fold func (PropertyArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("apiManagementName")>]
        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: PropertyArgs) =
                args.ApiManagementName <- input apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: PropertyArgs) =
                args.ApiManagementName <- io apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("displayName")>]
        member _.DisplayName((name, args), displayName) =
            let apply (args: PropertyArgs) =
                args.DisplayName <- input displayName
                args

            ()
            name, List.Cons(apply, args)

        member _.DisplayName((name, args), displayName) =
            let apply (args: PropertyArgs) =
                args.DisplayName <- io displayName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: PropertyArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: PropertyArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: PropertyArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: PropertyArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("secret")>]
        member _.Secret((name, args), secret) =
            let apply (args: PropertyArgs) =
                args.Secret <- input secret
                args

            ()
            name, List.Cons(apply, args)

        member _.Secret((name, args), secret) =
            let apply (args: PropertyArgs) =
                args.Secret <- io secret
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: PropertyArgs) =
                args.Tags <- inputList tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((name, args), value) =
            let apply (args: PropertyArgs) =
                args.Value <- input value
                args

            ()
            name, List.Cons(apply, args)

        member _.Value((name, args), value) =
            let apply (args: PropertyArgs) =
                args.Value <- io value
                args

            ()
            name, List.Cons(apply, args)

    let property = PropertyBuilder()

    type ServiceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Service(name, (List.fold func (ServiceArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("additionalLocations")>]
        member _.AdditionalLocations((name, args), additionalLocations) =
            let apply (args: ServiceArgs) =
                args.AdditionalLocations <- inputList additionalLocations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("certificates")>]
        member _.Certificates((name, args), certificates) =
            let apply (args: ServiceArgs) =
                args.Certificates <- inputList certificates
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ServiceArgs) =
                   args.HostnameConfiguration <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: ServiceArgs) =
                   args.Identity <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ServiceArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ServiceArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ServiceArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ServiceArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("notificationSenderEmail")>]
        member _.NotificationSenderEmail((name, args), notificationSenderEmail) =
            let apply (args: ServiceArgs) =
                args.NotificationSenderEmail <- input notificationSenderEmail
                args

            ()
            name, List.Cons(apply, args)

        member _.NotificationSenderEmail((name, args), notificationSenderEmail) =
            let apply (args: ServiceArgs) =
                args.NotificationSenderEmail <- io notificationSenderEmail
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ServiceArgs) =
                   args.Policy <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: ServiceArgs) =
                   args.Protocols <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("publisherEmail")>]
        member _.PublisherEmail((name, args), publisherEmail) =
            let apply (args: ServiceArgs) =
                args.PublisherEmail <- input publisherEmail
                args

            ()
            name, List.Cons(apply, args)

        member _.PublisherEmail((name, args), publisherEmail) =
            let apply (args: ServiceArgs) =
                args.PublisherEmail <- io publisherEmail
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("publisherName")>]
        member _.PublisherName((name, args), publisherName) =
            let apply (args: ServiceArgs) =
                args.PublisherName <- input publisherName
                args

            ()
            name, List.Cons(apply, args)

        member _.PublisherName((name, args), publisherName) =
            let apply (args: ServiceArgs) =
                args.PublisherName <- io publisherName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ServiceArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ServiceArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ServiceArgs) =
                   args.Security <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: ServiceArgs) =
                   args.SignIn <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: ServiceArgs) =
                   args.SignUp <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("skuName")>]
        member _.SkuName((name, args), skuName) =
            let apply (args: ServiceArgs) =
                args.SkuName <- input skuName
                args

            ()
            name, List.Cons(apply, args)

        member _.SkuName((name, args), skuName) =
            let apply (args: ServiceArgs) =
                args.SkuName <- io skuName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ServiceArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ServiceArgs) =
                   args.VirtualNetworkConfiguration <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("virtualNetworkType")>]
        member _.VirtualNetworkType((name, args), virtualNetworkType) =
            let apply (args: ServiceArgs) =
                args.VirtualNetworkType <- input virtualNetworkType
                args

            ()
            name, List.Cons(apply, args)

        member _.VirtualNetworkType((name, args), virtualNetworkType) =
            let apply (args: ServiceArgs) =
                args.VirtualNetworkType <- io virtualNetworkType
                args

            ()
            name, List.Cons(apply, args)

    let service = ServiceBuilder()

    type SubscriptionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Subscription(name, (List.fold func (SubscriptionArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("apiManagementName")>]
        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: SubscriptionArgs) =
                args.ApiManagementName <- input apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: SubscriptionArgs) =
                args.ApiManagementName <- io apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("displayName")>]
        member _.DisplayName((name, args), displayName) =
            let apply (args: SubscriptionArgs) =
                args.DisplayName <- input displayName
                args

            ()
            name, List.Cons(apply, args)

        member _.DisplayName((name, args), displayName) =
            let apply (args: SubscriptionArgs) =
                args.DisplayName <- io displayName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("primaryKey")>]
        member _.PrimaryKey((name, args), primaryKey) =
            let apply (args: SubscriptionArgs) =
                args.PrimaryKey <- input primaryKey
                args

            ()
            name, List.Cons(apply, args)

        member _.PrimaryKey((name, args), primaryKey) =
            let apply (args: SubscriptionArgs) =
                args.PrimaryKey <- io primaryKey
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("productId")>]
        member _.ProductId((name, args), productId) =
            let apply (args: SubscriptionArgs) =
                args.ProductId <- input productId
                args

            ()
            name, List.Cons(apply, args)

        member _.ProductId((name, args), productId) =
            let apply (args: SubscriptionArgs) =
                args.ProductId <- io productId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SubscriptionArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SubscriptionArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("secondaryKey")>]
        member _.SecondaryKey((name, args), secondaryKey) =
            let apply (args: SubscriptionArgs) =
                args.SecondaryKey <- input secondaryKey
                args

            ()
            name, List.Cons(apply, args)

        member _.SecondaryKey((name, args), secondaryKey) =
            let apply (args: SubscriptionArgs) =
                args.SecondaryKey <- io secondaryKey
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("state")>]
        member _.State((name, args), state) =
            let apply (args: SubscriptionArgs) =
                args.State <- input state
                args

            ()
            name, List.Cons(apply, args)

        member _.State((name, args), state) =
            let apply (args: SubscriptionArgs) =
                args.State <- io state
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("subscriptionId")>]
        member _.SubscriptionId((name, args), subscriptionId) =
            let apply (args: SubscriptionArgs) =
                args.SubscriptionId <- input subscriptionId
                args

            ()
            name, List.Cons(apply, args)

        member _.SubscriptionId((name, args), subscriptionId) =
            let apply (args: SubscriptionArgs) =
                args.SubscriptionId <- io subscriptionId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("userId")>]
        member _.UserId((name, args), userId) =
            let apply (args: SubscriptionArgs) =
                args.UserId <- input userId
                args

            ()
            name, List.Cons(apply, args)

        member _.UserId((name, args), userId) =
            let apply (args: SubscriptionArgs) =
                args.UserId <- io userId
                args

            ()
            name, List.Cons(apply, args)

    let subscription = SubscriptionBuilder()

    type UserBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            User(name, (List.fold func (UserArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("apiManagementName")>]
        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: UserArgs) =
                args.ApiManagementName <- input apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        member _.ApiManagementName((name, args), apiManagementName) =
            let apply (args: UserArgs) =
                args.ApiManagementName <- io apiManagementName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("confirmation")>]
        member _.Confirmation((name, args), confirmation) =
            let apply (args: UserArgs) =
                args.Confirmation <- input confirmation
                args

            ()
            name, List.Cons(apply, args)

        member _.Confirmation((name, args), confirmation) =
            let apply (args: UserArgs) =
                args.Confirmation <- io confirmation
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("email")>]
        member _.Email((name, args), email) =
            let apply (args: UserArgs) =
                args.Email <- input email
                args

            ()
            name, List.Cons(apply, args)

        member _.Email((name, args), email) =
            let apply (args: UserArgs) =
                args.Email <- io email
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("firstName")>]
        member _.FirstName((name, args), firstName) =
            let apply (args: UserArgs) =
                args.FirstName <- input firstName
                args

            ()
            name, List.Cons(apply, args)

        member _.FirstName((name, args), firstName) =
            let apply (args: UserArgs) =
                args.FirstName <- io firstName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("lastName")>]
        member _.LastName((name, args), lastName) =
            let apply (args: UserArgs) =
                args.LastName <- input lastName
                args

            ()
            name, List.Cons(apply, args)

        member _.LastName((name, args), lastName) =
            let apply (args: UserArgs) =
                args.LastName <- io lastName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("note")>]
        member _.Note((name, args), note) =
            let apply (args: UserArgs) =
                args.Note <- input note
                args

            ()
            name, List.Cons(apply, args)

        member _.Note((name, args), note) =
            let apply (args: UserArgs) =
                args.Note <- io note
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("password")>]
        member _.Password((name, args), password) =
            let apply (args: UserArgs) =
                args.Password <- input password
                args

            ()
            name, List.Cons(apply, args)

        member _.Password((name, args), password) =
            let apply (args: UserArgs) =
                args.Password <- io password
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: UserArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: UserArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("state")>]
        member _.State((name, args), state) =
            let apply (args: UserArgs) =
                args.State <- input state
                args

            ()
            name, List.Cons(apply, args)

        member _.State((name, args), state) =
            let apply (args: UserArgs) =
                args.State <- io state
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("userId")>]
        member _.UserId((name, args), userId) =
            let apply (args: UserArgs) =
                args.UserId <- input userId
                args

            ()
            name, List.Cons(apply, args)

        member _.UserId((name, args), userId) =
            let apply (args: UserArgs) =
                args.UserId <- io userId
                args

            ()
            name, List.Cons(apply, args)

    let user = UserBuilder()

module AppConfiguration =
    open Pulumi.Azure.AppConfiguration
    open Pulumi.Azure.AppConfiguration.Inputs

    type ConfigurationStorePrimaryReadKeyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ConfigurationStorePrimaryReadKeyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("connectionString")>]
        member _.ConnectionString((n, args), connectionString) =
            let apply (args: ConfigurationStorePrimaryReadKeyArgs) =
                args.ConnectionString <- input connectionString
                args

            ()
            n, List.Cons(apply, args)

        member _.ConnectionString((n, args), connectionString) =
            let apply (args: ConfigurationStorePrimaryReadKeyArgs) =
                args.ConnectionString <- io connectionString
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: ConfigurationStorePrimaryReadKeyArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: ConfigurationStorePrimaryReadKeyArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("secret")>]
        member _.Secret((n, args), secret) =
            let apply (args: ConfigurationStorePrimaryReadKeyArgs) =
                args.Secret <- input secret
                args

            ()
            n, List.Cons(apply, args)

        member _.Secret((n, args), secret) =
            let apply (args: ConfigurationStorePrimaryReadKeyArgs) =
                args.Secret <- io secret
                args

            ()
            n, List.Cons(apply, args)

    let configurationStorePrimaryReadKey =
        ConfigurationStorePrimaryReadKeyBuilder()

    type ConfigurationStorePrimaryWriteKeyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ConfigurationStorePrimaryWriteKeyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("connectionString")>]
        member _.ConnectionString((n, args), connectionString) =
            let apply (args: ConfigurationStorePrimaryWriteKeyArgs) =
                args.ConnectionString <- input connectionString
                args

            ()
            n, List.Cons(apply, args)

        member _.ConnectionString((n, args), connectionString) =
            let apply (args: ConfigurationStorePrimaryWriteKeyArgs) =
                args.ConnectionString <- io connectionString
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: ConfigurationStorePrimaryWriteKeyArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: ConfigurationStorePrimaryWriteKeyArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("secret")>]
        member _.Secret((n, args), secret) =
            let apply (args: ConfigurationStorePrimaryWriteKeyArgs) =
                args.Secret <- input secret
                args

            ()
            n, List.Cons(apply, args)

        member _.Secret((n, args), secret) =
            let apply (args: ConfigurationStorePrimaryWriteKeyArgs) =
                args.Secret <- io secret
                args

            ()
            n, List.Cons(apply, args)

    let configurationStorePrimaryWriteKey =
        ConfigurationStorePrimaryWriteKeyBuilder()

    type ConfigurationStoreSecondaryReadKeyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ConfigurationStoreSecondaryReadKeyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("connectionString")>]
        member _.ConnectionString((n, args), connectionString) =
            let apply (args: ConfigurationStoreSecondaryReadKeyArgs) =
                args.ConnectionString <- input connectionString
                args

            ()
            n, List.Cons(apply, args)

        member _.ConnectionString((n, args), connectionString) =
            let apply (args: ConfigurationStoreSecondaryReadKeyArgs) =
                args.ConnectionString <- io connectionString
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: ConfigurationStoreSecondaryReadKeyArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: ConfigurationStoreSecondaryReadKeyArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("secret")>]
        member _.Secret((n, args), secret) =
            let apply (args: ConfigurationStoreSecondaryReadKeyArgs) =
                args.Secret <- input secret
                args

            ()
            n, List.Cons(apply, args)

        member _.Secret((n, args), secret) =
            let apply (args: ConfigurationStoreSecondaryReadKeyArgs) =
                args.Secret <- io secret
                args

            ()
            n, List.Cons(apply, args)

    let configurationStoreSecondaryReadKey =
        ConfigurationStoreSecondaryReadKeyBuilder()

    type ConfigurationStoreSecondaryWriteKeyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ConfigurationStoreSecondaryWriteKeyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("connectionString")>]
        member _.ConnectionString((n, args), connectionString) =
            let apply (args: ConfigurationStoreSecondaryWriteKeyArgs) =
                args.ConnectionString <- input connectionString
                args

            ()
            n, List.Cons(apply, args)

        member _.ConnectionString((n, args), connectionString) =
            let apply (args: ConfigurationStoreSecondaryWriteKeyArgs) =
                args.ConnectionString <- io connectionString
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: ConfigurationStoreSecondaryWriteKeyArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: ConfigurationStoreSecondaryWriteKeyArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("secret")>]
        member _.Secret((n, args), secret) =
            let apply (args: ConfigurationStoreSecondaryWriteKeyArgs) =
                args.Secret <- input secret
                args

            ()
            n, List.Cons(apply, args)

        member _.Secret((n, args), secret) =
            let apply (args: ConfigurationStoreSecondaryWriteKeyArgs) =
                args.Secret <- io secret
                args

            ()
            n, List.Cons(apply, args)

    let configurationStoreSecondaryWriteKey =
        ConfigurationStoreSecondaryWriteKeyBuilder()

    type ConfigurationStoreBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ConfigurationStore(name, (List.fold func (ConfigurationStoreArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ConfigurationStoreArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ConfigurationStoreArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ConfigurationStoreArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ConfigurationStoreArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ConfigurationStoreArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ConfigurationStoreArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sku")>]
        member _.Sku((name, args), sku) =
            let apply (args: ConfigurationStoreArgs) =
                args.Sku <- input sku
                args

            ()
            name, List.Cons(apply, args)

        member _.Sku((name, args), sku) =
            let apply (args: ConfigurationStoreArgs) =
                args.Sku <- io sku
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ConfigurationStoreArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let configurationStore = ConfigurationStoreBuilder()

module AppPlatform =
    open Pulumi.Azure.AppPlatform
    open Pulumi.Azure.AppPlatform.Inputs

    type SpringCloudServiceConfigServerGitSettingBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SpringCloudServiceConfigServerGitSettingArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: SpringCloudServiceConfigServerGitSettingArgs) =
                   args.HttpBasicAuth <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("label")>]
        member _.Label((n, args), label) =
            let apply (args: SpringCloudServiceConfigServerGitSettingArgs) =
                args.Label <- input label
                args

            ()
            n, List.Cons(apply, args)

        member _.Label((n, args), label) =
            let apply (args: SpringCloudServiceConfigServerGitSettingArgs) =
                args.Label <- io label
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("repositories")>]
        member _.Repositories((n, args), repositories) =
            let apply (args: SpringCloudServiceConfigServerGitSettingArgs) =
                args.Repositories <- inputList repositories
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("searchPaths")>]
        member _.SearchPaths((n, args), searchPaths) =
            let apply (args: SpringCloudServiceConfigServerGitSettingArgs) =
                args.SearchPaths <- inputList searchPaths
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: SpringCloudServiceConfigServerGitSettingArgs) =
                   args.SshAuth <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("uri")>]
        member _.Uri((n, args), uri) =
            let apply (args: SpringCloudServiceConfigServerGitSettingArgs) =
                args.Uri <- input uri
                args

            ()
            n, List.Cons(apply, args)

        member _.Uri((n, args), uri) =
            let apply (args: SpringCloudServiceConfigServerGitSettingArgs) =
                args.Uri <- io uri
                args

            ()
            n, List.Cons(apply, args)

    let springCloudServiceConfigServerGitSetting =
        SpringCloudServiceConfigServerGitSettingBuilder()

    type SpringCloudServiceConfigServerGitSettingHttpBasicAuthBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SpringCloudServiceConfigServerGitSettingHttpBasicAuthArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: SpringCloudServiceConfigServerGitSettingHttpBasicAuthArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: SpringCloudServiceConfigServerGitSettingHttpBasicAuthArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: SpringCloudServiceConfigServerGitSettingHttpBasicAuthArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: SpringCloudServiceConfigServerGitSettingHttpBasicAuthArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

    let springCloudServiceConfigServerGitSettingHttpBasicAuth =
        SpringCloudServiceConfigServerGitSettingHttpBasicAuthBuilder()

    type SpringCloudServiceConfigServerGitSettingRepositoryBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SpringCloudServiceConfigServerGitSettingRepositoryArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: SpringCloudServiceConfigServerGitSettingRepositoryArgs) =
                   args.HttpBasicAuth <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("label")>]
        member _.Label((n, args), label) =
            let apply (args: SpringCloudServiceConfigServerGitSettingRepositoryArgs) =
                args.Label <- input label
                args

            ()
            n, List.Cons(apply, args)

        member _.Label((n, args), label) =
            let apply (args: SpringCloudServiceConfigServerGitSettingRepositoryArgs) =
                args.Label <- io label
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: SpringCloudServiceConfigServerGitSettingRepositoryArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: SpringCloudServiceConfigServerGitSettingRepositoryArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("patterns")>]
        member _.Patterns((n, args), patterns) =
            let apply (args: SpringCloudServiceConfigServerGitSettingRepositoryArgs) =
                args.Patterns <- inputList patterns
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("searchPaths")>]
        member _.SearchPaths((n, args), searchPaths) =
            let apply (args: SpringCloudServiceConfigServerGitSettingRepositoryArgs) =
                args.SearchPaths <- inputList searchPaths
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: SpringCloudServiceConfigServerGitSettingRepositoryArgs) =
                   args.SshAuth <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("uri")>]
        member _.Uri((n, args), uri) =
            let apply (args: SpringCloudServiceConfigServerGitSettingRepositoryArgs) =
                args.Uri <- input uri
                args

            ()
            n, List.Cons(apply, args)

        member _.Uri((n, args), uri) =
            let apply (args: SpringCloudServiceConfigServerGitSettingRepositoryArgs) =
                args.Uri <- io uri
                args

            ()
            n, List.Cons(apply, args)

    let springCloudServiceConfigServerGitSettingRepository =
        SpringCloudServiceConfigServerGitSettingRepositoryBuilder()

    type SpringCloudServiceConfigServerGitSettingRepositoryHttpBasicAuthBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SpringCloudServiceConfigServerGitSettingRepositoryHttpBasicAuthArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: SpringCloudServiceConfigServerGitSettingRepositoryHttpBasicAuthArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: SpringCloudServiceConfigServerGitSettingRepositoryHttpBasicAuthArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: SpringCloudServiceConfigServerGitSettingRepositoryHttpBasicAuthArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: SpringCloudServiceConfigServerGitSettingRepositoryHttpBasicAuthArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

    let springCloudServiceConfigServerGitSettingRepositoryHttpBasicAuth =
        SpringCloudServiceConfigServerGitSettingRepositoryHttpBasicAuthBuilder()

    type SpringCloudServiceConfigServerGitSettingRepositorySshAuthBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SpringCloudServiceConfigServerGitSettingRepositorySshAuthArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("hostKey")>]
        member _.HostKey((n, args), hostKey) =
            let apply (args: SpringCloudServiceConfigServerGitSettingRepositorySshAuthArgs) =
                args.HostKey <- input hostKey
                args

            ()
            n, List.Cons(apply, args)

        member _.HostKey((n, args), hostKey) =
            let apply (args: SpringCloudServiceConfigServerGitSettingRepositorySshAuthArgs) =
                args.HostKey <- io hostKey
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("hostKeyAlgorithm")>]
        member _.HostKeyAlgorithm((n, args), hostKeyAlgorithm) =
            let apply (args: SpringCloudServiceConfigServerGitSettingRepositorySshAuthArgs) =
                args.HostKeyAlgorithm <- input hostKeyAlgorithm
                args

            ()
            n, List.Cons(apply, args)

        member _.HostKeyAlgorithm((n, args), hostKeyAlgorithm) =
            let apply (args: SpringCloudServiceConfigServerGitSettingRepositorySshAuthArgs) =
                args.HostKeyAlgorithm <- io hostKeyAlgorithm
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("privateKey")>]
        member _.PrivateKey((n, args), privateKey) =
            let apply (args: SpringCloudServiceConfigServerGitSettingRepositorySshAuthArgs) =
                args.PrivateKey <- input privateKey
                args

            ()
            n, List.Cons(apply, args)

        member _.PrivateKey((n, args), privateKey) =
            let apply (args: SpringCloudServiceConfigServerGitSettingRepositorySshAuthArgs) =
                args.PrivateKey <- io privateKey
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("strictHostKeyCheckingEnabled")>]
        member _.StrictHostKeyCheckingEnabled((n, args), strictHostKeyCheckingEnabled) =
            let apply (args: SpringCloudServiceConfigServerGitSettingRepositorySshAuthArgs) =
                args.StrictHostKeyCheckingEnabled <- input strictHostKeyCheckingEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.StrictHostKeyCheckingEnabled((n, args), strictHostKeyCheckingEnabled) =
            let apply (args: SpringCloudServiceConfigServerGitSettingRepositorySshAuthArgs) =
                args.StrictHostKeyCheckingEnabled <- io strictHostKeyCheckingEnabled
                args

            ()
            n, List.Cons(apply, args)

    let springCloudServiceConfigServerGitSettingRepositorySshAuth =
        SpringCloudServiceConfigServerGitSettingRepositorySshAuthBuilder()

    type SpringCloudServiceConfigServerGitSettingSshAuthBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SpringCloudServiceConfigServerGitSettingSshAuthArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("hostKey")>]
        member _.HostKey((n, args), hostKey) =
            let apply (args: SpringCloudServiceConfigServerGitSettingSshAuthArgs) =
                args.HostKey <- input hostKey
                args

            ()
            n, List.Cons(apply, args)

        member _.HostKey((n, args), hostKey) =
            let apply (args: SpringCloudServiceConfigServerGitSettingSshAuthArgs) =
                args.HostKey <- io hostKey
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("hostKeyAlgorithm")>]
        member _.HostKeyAlgorithm((n, args), hostKeyAlgorithm) =
            let apply (args: SpringCloudServiceConfigServerGitSettingSshAuthArgs) =
                args.HostKeyAlgorithm <- input hostKeyAlgorithm
                args

            ()
            n, List.Cons(apply, args)

        member _.HostKeyAlgorithm((n, args), hostKeyAlgorithm) =
            let apply (args: SpringCloudServiceConfigServerGitSettingSshAuthArgs) =
                args.HostKeyAlgorithm <- io hostKeyAlgorithm
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("privateKey")>]
        member _.PrivateKey((n, args), privateKey) =
            let apply (args: SpringCloudServiceConfigServerGitSettingSshAuthArgs) =
                args.PrivateKey <- input privateKey
                args

            ()
            n, List.Cons(apply, args)

        member _.PrivateKey((n, args), privateKey) =
            let apply (args: SpringCloudServiceConfigServerGitSettingSshAuthArgs) =
                args.PrivateKey <- io privateKey
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("strictHostKeyCheckingEnabled")>]
        member _.StrictHostKeyCheckingEnabled((n, args), strictHostKeyCheckingEnabled) =
            let apply (args: SpringCloudServiceConfigServerGitSettingSshAuthArgs) =
                args.StrictHostKeyCheckingEnabled <- input strictHostKeyCheckingEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.StrictHostKeyCheckingEnabled((n, args), strictHostKeyCheckingEnabled) =
            let apply (args: SpringCloudServiceConfigServerGitSettingSshAuthArgs) =
                args.StrictHostKeyCheckingEnabled <- io strictHostKeyCheckingEnabled
                args

            ()
            n, List.Cons(apply, args)

    let springCloudServiceConfigServerGitSettingSshAuth =
        SpringCloudServiceConfigServerGitSettingSshAuthBuilder()

    type SpringCloudAppBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            SpringCloudApp(name, (List.fold func (SpringCloudAppArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: SpringCloudAppArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: SpringCloudAppArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SpringCloudAppArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SpringCloudAppArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serviceName")>]
        member _.ServiceName((name, args), serviceName) =
            let apply (args: SpringCloudAppArgs) =
                args.ServiceName <- input serviceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ServiceName((name, args), serviceName) =
            let apply (args: SpringCloudAppArgs) =
                args.ServiceName <- io serviceName
                args

            ()
            name, List.Cons(apply, args)

    let springCloudApp = SpringCloudAppBuilder()

    type SpringCloudServiceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            SpringCloudService(name, (List.fold func (SpringCloudServiceArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: SpringCloudServiceArgs) =
                   args.ConfigServerGitSetting <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: SpringCloudServiceArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: SpringCloudServiceArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: SpringCloudServiceArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: SpringCloudServiceArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SpringCloudServiceArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SpringCloudServiceArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: SpringCloudServiceArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let springCloudService = SpringCloudServiceBuilder()

module AppService =
    open Pulumi.Azure.AppService
    open Pulumi.Azure.AppService.Inputs

    type AppServiceAuthSettingsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AppServiceAuthSettingsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: AppServiceAuthSettingsArgs) =
                   args.ActiveDirectory <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("additionalLoginParams")>]
        member _.AdditionalLoginParams((n, args), additionalLoginParams) =
            let apply (args: AppServiceAuthSettingsArgs) =
                args.AdditionalLoginParams <- inputMap additionalLoginParams
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("allowedExternalRedirectUrls")>]
        member _.AllowedExternalRedirectUrls((n, args), allowedExternalRedirectUrls) =
            let apply (args: AppServiceAuthSettingsArgs) =
                args.AllowedExternalRedirectUrls <- inputList allowedExternalRedirectUrls
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("defaultProvider")>]
        member _.DefaultProvider((n, args), defaultProvider) =
            let apply (args: AppServiceAuthSettingsArgs) =
                args.DefaultProvider <- input defaultProvider
                args

            ()
            n, List.Cons(apply, args)

        member _.DefaultProvider((n, args), defaultProvider) =
            let apply (args: AppServiceAuthSettingsArgs) =
                args.DefaultProvider <- io defaultProvider
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: AppServiceAuthSettingsArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: AppServiceAuthSettingsArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: AppServiceAuthSettingsArgs) =
                   args.Facebook <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: AppServiceAuthSettingsArgs) =
                   args.Google <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("issuer")>]
        member _.Issuer((n, args), issuer) =
            let apply (args: AppServiceAuthSettingsArgs) =
                args.Issuer <- input issuer
                args

            ()
            n, List.Cons(apply, args)

        member _.Issuer((n, args), issuer) =
            let apply (args: AppServiceAuthSettingsArgs) =
                args.Issuer <- io issuer
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: AppServiceAuthSettingsArgs) =
                   args.Microsoft <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("runtimeVersion")>]
        member _.RuntimeVersion((n, args), runtimeVersion) =
            let apply (args: AppServiceAuthSettingsArgs) =
                args.RuntimeVersion <- input runtimeVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.RuntimeVersion((n, args), runtimeVersion) =
            let apply (args: AppServiceAuthSettingsArgs) =
                args.RuntimeVersion <- io runtimeVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tokenRefreshExtensionHours")>]
        member _.TokenRefreshExtensionHours((n, args), tokenRefreshExtensionHours) =
            let apply (args: AppServiceAuthSettingsArgs) =
                args.TokenRefreshExtensionHours <- input tokenRefreshExtensionHours
                args

            ()
            n, List.Cons(apply, args)

        member _.TokenRefreshExtensionHours((n, args), tokenRefreshExtensionHours) =
            let apply (args: AppServiceAuthSettingsArgs) =
                args.TokenRefreshExtensionHours <- io tokenRefreshExtensionHours
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tokenStoreEnabled")>]
        member _.TokenStoreEnabled((n, args), tokenStoreEnabled) =
            let apply (args: AppServiceAuthSettingsArgs) =
                args.TokenStoreEnabled <- input tokenStoreEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.TokenStoreEnabled((n, args), tokenStoreEnabled) =
            let apply (args: AppServiceAuthSettingsArgs) =
                args.TokenStoreEnabled <- io tokenStoreEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: AppServiceAuthSettingsArgs) =
                   args.Twitter <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("unauthenticatedClientAction")>]
        member _.UnauthenticatedClientAction((n, args), unauthenticatedClientAction) =
            let apply (args: AppServiceAuthSettingsArgs) =
                args.UnauthenticatedClientAction <- input unauthenticatedClientAction
                args

            ()
            n, List.Cons(apply, args)

        member _.UnauthenticatedClientAction((n, args), unauthenticatedClientAction) =
            let apply (args: AppServiceAuthSettingsArgs) =
                args.UnauthenticatedClientAction <- io unauthenticatedClientAction
                args

            ()
            n, List.Cons(apply, args)

    let appServiceAuthSettings = AppServiceAuthSettingsBuilder()

    type AppServiceAuthSettingsActiveDirectoryBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AppServiceAuthSettingsActiveDirectoryArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("allowedAudiences")>]
        member _.AllowedAudiences((n, args), allowedAudiences) =
            let apply (args: AppServiceAuthSettingsActiveDirectoryArgs) =
                args.AllowedAudiences <- inputList allowedAudiences
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("clientId")>]
        member _.ClientId((n, args), clientId) =
            let apply (args: AppServiceAuthSettingsActiveDirectoryArgs) =
                args.ClientId <- input clientId
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientId((n, args), clientId) =
            let apply (args: AppServiceAuthSettingsActiveDirectoryArgs) =
                args.ClientId <- io clientId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("clientSecret")>]
        member _.ClientSecret((n, args), clientSecret) =
            let apply (args: AppServiceAuthSettingsActiveDirectoryArgs) =
                args.ClientSecret <- input clientSecret
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientSecret((n, args), clientSecret) =
            let apply (args: AppServiceAuthSettingsActiveDirectoryArgs) =
                args.ClientSecret <- io clientSecret
                args

            ()
            n, List.Cons(apply, args)

    let appServiceAuthSettingsActiveDirectory =
        AppServiceAuthSettingsActiveDirectoryBuilder()

    type AppServiceAuthSettingsFacebookBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AppServiceAuthSettingsFacebookArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("appId")>]
        member _.AppId((n, args), appId) =
            let apply (args: AppServiceAuthSettingsFacebookArgs) =
                args.AppId <- input appId
                args

            ()
            n, List.Cons(apply, args)

        member _.AppId((n, args), appId) =
            let apply (args: AppServiceAuthSettingsFacebookArgs) =
                args.AppId <- io appId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("appSecret")>]
        member _.AppSecret((n, args), appSecret) =
            let apply (args: AppServiceAuthSettingsFacebookArgs) =
                args.AppSecret <- input appSecret
                args

            ()
            n, List.Cons(apply, args)

        member _.AppSecret((n, args), appSecret) =
            let apply (args: AppServiceAuthSettingsFacebookArgs) =
                args.AppSecret <- io appSecret
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("oauthScopes")>]
        member _.OauthScopes((n, args), oauthScopes) =
            let apply (args: AppServiceAuthSettingsFacebookArgs) =
                args.OauthScopes <- inputList oauthScopes
                args

            ()
            n, List.Cons(apply, args)

    let appServiceAuthSettingsFacebook = AppServiceAuthSettingsFacebookBuilder()

    type AppServiceAuthSettingsGoogleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AppServiceAuthSettingsGoogleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("clientId")>]
        member _.ClientId((n, args), clientId) =
            let apply (args: AppServiceAuthSettingsGoogleArgs) =
                args.ClientId <- input clientId
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientId((n, args), clientId) =
            let apply (args: AppServiceAuthSettingsGoogleArgs) =
                args.ClientId <- io clientId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("clientSecret")>]
        member _.ClientSecret((n, args), clientSecret) =
            let apply (args: AppServiceAuthSettingsGoogleArgs) =
                args.ClientSecret <- input clientSecret
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientSecret((n, args), clientSecret) =
            let apply (args: AppServiceAuthSettingsGoogleArgs) =
                args.ClientSecret <- io clientSecret
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("oauthScopes")>]
        member _.OauthScopes((n, args), oauthScopes) =
            let apply (args: AppServiceAuthSettingsGoogleArgs) =
                args.OauthScopes <- inputList oauthScopes
                args

            ()
            n, List.Cons(apply, args)

    let appServiceAuthSettingsGoogle = AppServiceAuthSettingsGoogleBuilder()

    type AppServiceAuthSettingsMicrosoftBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AppServiceAuthSettingsMicrosoftArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("clientId")>]
        member _.ClientId((n, args), clientId) =
            let apply (args: AppServiceAuthSettingsMicrosoftArgs) =
                args.ClientId <- input clientId
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientId((n, args), clientId) =
            let apply (args: AppServiceAuthSettingsMicrosoftArgs) =
                args.ClientId <- io clientId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("clientSecret")>]
        member _.ClientSecret((n, args), clientSecret) =
            let apply (args: AppServiceAuthSettingsMicrosoftArgs) =
                args.ClientSecret <- input clientSecret
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientSecret((n, args), clientSecret) =
            let apply (args: AppServiceAuthSettingsMicrosoftArgs) =
                args.ClientSecret <- io clientSecret
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("oauthScopes")>]
        member _.OauthScopes((n, args), oauthScopes) =
            let apply (args: AppServiceAuthSettingsMicrosoftArgs) =
                args.OauthScopes <- inputList oauthScopes
                args

            ()
            n, List.Cons(apply, args)

    let appServiceAuthSettingsMicrosoft = AppServiceAuthSettingsMicrosoftBuilder()

    type AppServiceAuthSettingsTwitterBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AppServiceAuthSettingsTwitterArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("consumerKey")>]
        member _.ConsumerKey((n, args), consumerKey) =
            let apply (args: AppServiceAuthSettingsTwitterArgs) =
                args.ConsumerKey <- input consumerKey
                args

            ()
            n, List.Cons(apply, args)

        member _.ConsumerKey((n, args), consumerKey) =
            let apply (args: AppServiceAuthSettingsTwitterArgs) =
                args.ConsumerKey <- io consumerKey
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("consumerSecret")>]
        member _.ConsumerSecret((n, args), consumerSecret) =
            let apply (args: AppServiceAuthSettingsTwitterArgs) =
                args.ConsumerSecret <- input consumerSecret
                args

            ()
            n, List.Cons(apply, args)

        member _.ConsumerSecret((n, args), consumerSecret) =
            let apply (args: AppServiceAuthSettingsTwitterArgs) =
                args.ConsumerSecret <- io consumerSecret
                args

            ()
            n, List.Cons(apply, args)

    let appServiceAuthSettingsTwitter = AppServiceAuthSettingsTwitterBuilder()

    type AppServiceBackupBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AppServiceBackupArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: AppServiceBackupArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: AppServiceBackupArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: AppServiceBackupArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: AppServiceBackupArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: AppServiceBackupArgs) =
                   args.Schedule <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("storageAccountUrl")>]
        member _.StorageAccountUrl((n, args), storageAccountUrl) =
            let apply (args: AppServiceBackupArgs) =
                args.StorageAccountUrl <- input storageAccountUrl
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountUrl((n, args), storageAccountUrl) =
            let apply (args: AppServiceBackupArgs) =
                args.StorageAccountUrl <- io storageAccountUrl
                args

            ()
            n, List.Cons(apply, args)

    let appServiceBackup = AppServiceBackupBuilder()

    type AppServiceBackupScheduleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AppServiceBackupScheduleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("frequencyInterval")>]
        member _.FrequencyInterval((n, args), frequencyInterval) =
            let apply (args: AppServiceBackupScheduleArgs) =
                args.FrequencyInterval <- input frequencyInterval
                args

            ()
            n, List.Cons(apply, args)

        member _.FrequencyInterval((n, args), frequencyInterval) =
            let apply (args: AppServiceBackupScheduleArgs) =
                args.FrequencyInterval <- io frequencyInterval
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("frequencyUnit")>]
        member _.FrequencyUnit((n, args), frequencyUnit) =
            let apply (args: AppServiceBackupScheduleArgs) =
                args.FrequencyUnit <- input frequencyUnit
                args

            ()
            n, List.Cons(apply, args)

        member _.FrequencyUnit((n, args), frequencyUnit) =
            let apply (args: AppServiceBackupScheduleArgs) =
                args.FrequencyUnit <- io frequencyUnit
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("keepAtLeastOneBackup")>]
        member _.KeepAtLeastOneBackup((n, args), keepAtLeastOneBackup) =
            let apply (args: AppServiceBackupScheduleArgs) =
                args.KeepAtLeastOneBackup <- input keepAtLeastOneBackup
                args

            ()
            n, List.Cons(apply, args)

        member _.KeepAtLeastOneBackup((n, args), keepAtLeastOneBackup) =
            let apply (args: AppServiceBackupScheduleArgs) =
                args.KeepAtLeastOneBackup <- io keepAtLeastOneBackup
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("retentionPeriodInDays")>]
        member _.RetentionPeriodInDays((n, args), retentionPeriodInDays) =
            let apply (args: AppServiceBackupScheduleArgs) =
                args.RetentionPeriodInDays <- input retentionPeriodInDays
                args

            ()
            n, List.Cons(apply, args)

        member _.RetentionPeriodInDays((n, args), retentionPeriodInDays) =
            let apply (args: AppServiceBackupScheduleArgs) =
                args.RetentionPeriodInDays <- io retentionPeriodInDays
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("startTime")>]
        member _.StartTime((n, args), startTime) =
            let apply (args: AppServiceBackupScheduleArgs) =
                args.StartTime <- input startTime
                args

            ()
            n, List.Cons(apply, args)

        member _.StartTime((n, args), startTime) =
            let apply (args: AppServiceBackupScheduleArgs) =
                args.StartTime <- io startTime
                args

            ()
            n, List.Cons(apply, args)

    let appServiceBackupSchedule = AppServiceBackupScheduleBuilder()

    type AppServiceConnectionStringBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AppServiceConnectionStringArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: AppServiceConnectionStringArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: AppServiceConnectionStringArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: AppServiceConnectionStringArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: AppServiceConnectionStringArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((n, args), value) =
            let apply (args: AppServiceConnectionStringArgs) =
                args.Value <- input value
                args

            ()
            n, List.Cons(apply, args)

        member _.Value((n, args), value) =
            let apply (args: AppServiceConnectionStringArgs) =
                args.Value <- io value
                args

            ()
            n, List.Cons(apply, args)

    let appServiceConnectionString = AppServiceConnectionStringBuilder()

    type AppServiceIdentityBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AppServiceIdentityArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("identityIds")>]
        member _.IdentityIds((n, args), identityIds) =
            let apply (args: AppServiceIdentityArgs) =
                args.IdentityIds <- inputList identityIds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("principalId")>]
        member _.PrincipalId((n, args), principalId) =
            let apply (args: AppServiceIdentityArgs) =
                args.PrincipalId <- input principalId
                args

            ()
            n, List.Cons(apply, args)

        member _.PrincipalId((n, args), principalId) =
            let apply (args: AppServiceIdentityArgs) =
                args.PrincipalId <- io principalId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tenantId")>]
        member _.TenantId((n, args), tenantId) =
            let apply (args: AppServiceIdentityArgs) =
                args.TenantId <- input tenantId
                args

            ()
            n, List.Cons(apply, args)

        member _.TenantId((n, args), tenantId) =
            let apply (args: AppServiceIdentityArgs) =
                args.TenantId <- io tenantId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: AppServiceIdentityArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: AppServiceIdentityArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let appServiceIdentity = AppServiceIdentityBuilder()

    type AppServiceLogsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AppServiceLogsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: AppServiceLogsArgs) =
                   args.ApplicationLogs <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: AppServiceLogsArgs) =
                   args.HttpLogs <- input arg
                   args

               ()
               func) ]

    let appServiceLogs = AppServiceLogsBuilder()

    type AppServiceLogsApplicationLogsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AppServiceLogsApplicationLogsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: AppServiceLogsApplicationLogsArgs) =
                   args.AzureBlobStorage <- input arg
                   args

               ()
               func) ]

    let appServiceLogsApplicationLogs = AppServiceLogsApplicationLogsBuilder()

    type AppServiceLogsApplicationLogsAzureBlobStorageBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AppServiceLogsApplicationLogsAzureBlobStorageArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("level")>]
        member _.Level((n, args), level) =
            let apply (args: AppServiceLogsApplicationLogsAzureBlobStorageArgs) =
                args.Level <- input level
                args

            ()
            n, List.Cons(apply, args)

        member _.Level((n, args), level) =
            let apply (args: AppServiceLogsApplicationLogsAzureBlobStorageArgs) =
                args.Level <- io level
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("retentionInDays")>]
        member _.RetentionInDays((n, args), retentionInDays) =
            let apply (args: AppServiceLogsApplicationLogsAzureBlobStorageArgs) =
                args.RetentionInDays <- input retentionInDays
                args

            ()
            n, List.Cons(apply, args)

        member _.RetentionInDays((n, args), retentionInDays) =
            let apply (args: AppServiceLogsApplicationLogsAzureBlobStorageArgs) =
                args.RetentionInDays <- io retentionInDays
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sasUrl")>]
        member _.SasUrl((n, args), sasUrl) =
            let apply (args: AppServiceLogsApplicationLogsAzureBlobStorageArgs) =
                args.SasUrl <- input sasUrl
                args

            ()
            n, List.Cons(apply, args)

        member _.SasUrl((n, args), sasUrl) =
            let apply (args: AppServiceLogsApplicationLogsAzureBlobStorageArgs) =
                args.SasUrl <- io sasUrl
                args

            ()
            n, List.Cons(apply, args)

    let appServiceLogsApplicationLogsAzureBlobStorage =
        AppServiceLogsApplicationLogsAzureBlobStorageBuilder()

    type AppServiceLogsHttpLogsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AppServiceLogsHttpLogsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: AppServiceLogsHttpLogsArgs) =
                   args.AzureBlobStorage <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: AppServiceLogsHttpLogsArgs) =
                   args.FileSystem <- input arg
                   args

               ()
               func) ]

    let appServiceLogsHttpLogs = AppServiceLogsHttpLogsBuilder()

    type AppServiceLogsHttpLogsAzureBlobStorageBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AppServiceLogsHttpLogsAzureBlobStorageArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("retentionInDays")>]
        member _.RetentionInDays((n, args), retentionInDays) =
            let apply (args: AppServiceLogsHttpLogsAzureBlobStorageArgs) =
                args.RetentionInDays <- input retentionInDays
                args

            ()
            n, List.Cons(apply, args)

        member _.RetentionInDays((n, args), retentionInDays) =
            let apply (args: AppServiceLogsHttpLogsAzureBlobStorageArgs) =
                args.RetentionInDays <- io retentionInDays
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sasUrl")>]
        member _.SasUrl((n, args), sasUrl) =
            let apply (args: AppServiceLogsHttpLogsAzureBlobStorageArgs) =
                args.SasUrl <- input sasUrl
                args

            ()
            n, List.Cons(apply, args)

        member _.SasUrl((n, args), sasUrl) =
            let apply (args: AppServiceLogsHttpLogsAzureBlobStorageArgs) =
                args.SasUrl <- io sasUrl
                args

            ()
            n, List.Cons(apply, args)

    let appServiceLogsHttpLogsAzureBlobStorage =
        AppServiceLogsHttpLogsAzureBlobStorageBuilder()

    type AppServiceLogsHttpLogsFileSystemBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AppServiceLogsHttpLogsFileSystemArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("retentionInDays")>]
        member _.RetentionInDays((n, args), retentionInDays) =
            let apply (args: AppServiceLogsHttpLogsFileSystemArgs) =
                args.RetentionInDays <- input retentionInDays
                args

            ()
            n, List.Cons(apply, args)

        member _.RetentionInDays((n, args), retentionInDays) =
            let apply (args: AppServiceLogsHttpLogsFileSystemArgs) =
                args.RetentionInDays <- io retentionInDays
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("retentionInMb")>]
        member _.RetentionInMb((n, args), retentionInMb) =
            let apply (args: AppServiceLogsHttpLogsFileSystemArgs) =
                args.RetentionInMb <- input retentionInMb
                args

            ()
            n, List.Cons(apply, args)

        member _.RetentionInMb((n, args), retentionInMb) =
            let apply (args: AppServiceLogsHttpLogsFileSystemArgs) =
                args.RetentionInMb <- io retentionInMb
                args

            ()
            n, List.Cons(apply, args)

    let appServiceLogsHttpLogsFileSystem =
        AppServiceLogsHttpLogsFileSystemBuilder()

    type AppServiceSiteConfigBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AppServiceSiteConfigArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("alwaysOn")>]
        member _.AlwaysOn((n, args), alwaysOn) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.AlwaysOn <- input alwaysOn
                args

            ()
            n, List.Cons(apply, args)

        member _.AlwaysOn((n, args), alwaysOn) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.AlwaysOn <- io alwaysOn
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("appCommandLine")>]
        member _.AppCommandLine((n, args), appCommandLine) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.AppCommandLine <- input appCommandLine
                args

            ()
            n, List.Cons(apply, args)

        member _.AppCommandLine((n, args), appCommandLine) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.AppCommandLine <- io appCommandLine
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("autoSwapSlotName")>]
        member _.AutoSwapSlotName((n, args), autoSwapSlotName) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.AutoSwapSlotName <- input autoSwapSlotName
                args

            ()
            n, List.Cons(apply, args)

        member _.AutoSwapSlotName((n, args), autoSwapSlotName) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.AutoSwapSlotName <- io autoSwapSlotName
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: AppServiceSiteConfigArgs) =
                   args.Cors <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("defaultDocuments")>]
        member _.DefaultDocuments((n, args), defaultDocuments) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.DefaultDocuments <- inputList defaultDocuments
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("dotnetFrameworkVersion")>]
        member _.DotnetFrameworkVersion((n, args), dotnetFrameworkVersion) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.DotnetFrameworkVersion <- input dotnetFrameworkVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.DotnetFrameworkVersion((n, args), dotnetFrameworkVersion) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.DotnetFrameworkVersion <- io dotnetFrameworkVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ftpsState")>]
        member _.FtpsState((n, args), ftpsState) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.FtpsState <- input ftpsState
                args

            ()
            n, List.Cons(apply, args)

        member _.FtpsState((n, args), ftpsState) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.FtpsState <- io ftpsState
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("healthCheckPath")>]
        member _.HealthCheckPath((n, args), healthCheckPath) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.HealthCheckPath <- input healthCheckPath
                args

            ()
            n, List.Cons(apply, args)

        member _.HealthCheckPath((n, args), healthCheckPath) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.HealthCheckPath <- io healthCheckPath
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("http2Enabled")>]
        member _.Http2Enabled((n, args), http2Enabled) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.Http2Enabled <- input http2Enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Http2Enabled((n, args), http2Enabled) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.Http2Enabled <- io http2Enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ipRestrictions")>]
        member _.IpRestrictions((n, args), ipRestrictions) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.IpRestrictions <- inputList ipRestrictions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("javaContainer")>]
        member _.JavaContainer((n, args), javaContainer) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.JavaContainer <- input javaContainer
                args

            ()
            n, List.Cons(apply, args)

        member _.JavaContainer((n, args), javaContainer) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.JavaContainer <- io javaContainer
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("javaContainerVersion")>]
        member _.JavaContainerVersion((n, args), javaContainerVersion) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.JavaContainerVersion <- input javaContainerVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.JavaContainerVersion((n, args), javaContainerVersion) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.JavaContainerVersion <- io javaContainerVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("javaVersion")>]
        member _.JavaVersion((n, args), javaVersion) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.JavaVersion <- input javaVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.JavaVersion((n, args), javaVersion) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.JavaVersion <- io javaVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("linuxFxVersion")>]
        member _.LinuxFxVersion((n, args), linuxFxVersion) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.LinuxFxVersion <- input linuxFxVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.LinuxFxVersion((n, args), linuxFxVersion) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.LinuxFxVersion <- io linuxFxVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("localMysqlEnabled")>]
        member _.LocalMysqlEnabled((n, args), localMysqlEnabled) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.LocalMysqlEnabled <- input localMysqlEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.LocalMysqlEnabled((n, args), localMysqlEnabled) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.LocalMysqlEnabled <- io localMysqlEnabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("managedPipelineMode")>]
        member _.ManagedPipelineMode((n, args), managedPipelineMode) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.ManagedPipelineMode <- input managedPipelineMode
                args

            ()
            n, List.Cons(apply, args)

        member _.ManagedPipelineMode((n, args), managedPipelineMode) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.ManagedPipelineMode <- io managedPipelineMode
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("minTlsVersion")>]
        member _.MinTlsVersion((n, args), minTlsVersion) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.MinTlsVersion <- input minTlsVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.MinTlsVersion((n, args), minTlsVersion) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.MinTlsVersion <- io minTlsVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("phpVersion")>]
        member _.PhpVersion((n, args), phpVersion) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.PhpVersion <- input phpVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.PhpVersion((n, args), phpVersion) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.PhpVersion <- io phpVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("pythonVersion")>]
        member _.PythonVersion((n, args), pythonVersion) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.PythonVersion <- input pythonVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.PythonVersion((n, args), pythonVersion) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.PythonVersion <- io pythonVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("remoteDebuggingEnabled")>]
        member _.RemoteDebuggingEnabled((n, args), remoteDebuggingEnabled) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.RemoteDebuggingEnabled <- input remoteDebuggingEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.RemoteDebuggingEnabled((n, args), remoteDebuggingEnabled) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.RemoteDebuggingEnabled <- io remoteDebuggingEnabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("remoteDebuggingVersion")>]
        member _.RemoteDebuggingVersion((n, args), remoteDebuggingVersion) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.RemoteDebuggingVersion <- input remoteDebuggingVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.RemoteDebuggingVersion((n, args), remoteDebuggingVersion) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.RemoteDebuggingVersion <- io remoteDebuggingVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("scmIpRestrictions")>]
        member _.ScmIpRestrictions((n, args), scmIpRestrictions) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.ScmIpRestrictions <- inputList scmIpRestrictions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("scmType")>]
        member _.ScmType((n, args), scmType) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.ScmType <- input scmType
                args

            ()
            n, List.Cons(apply, args)

        member _.ScmType((n, args), scmType) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.ScmType <- io scmType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("scmUseMainIpRestriction")>]
        member _.ScmUseMainIpRestriction((n, args), scmUseMainIpRestriction) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.ScmUseMainIpRestriction <- input scmUseMainIpRestriction
                args

            ()
            n, List.Cons(apply, args)

        member _.ScmUseMainIpRestriction((n, args), scmUseMainIpRestriction) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.ScmUseMainIpRestriction <- io scmUseMainIpRestriction
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("use32BitWorkerProcess")>]
        member _.Use32BitWorkerProcess((n, args), use32BitWorkerProcess) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.Use32BitWorkerProcess <- input use32BitWorkerProcess
                args

            ()
            n, List.Cons(apply, args)

        member _.Use32BitWorkerProcess((n, args), use32BitWorkerProcess) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.Use32BitWorkerProcess <- io use32BitWorkerProcess
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("websocketsEnabled")>]
        member _.WebsocketsEnabled((n, args), websocketsEnabled) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.WebsocketsEnabled <- input websocketsEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.WebsocketsEnabled((n, args), websocketsEnabled) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.WebsocketsEnabled <- io websocketsEnabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("windowsFxVersion")>]
        member _.WindowsFxVersion((n, args), windowsFxVersion) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.WindowsFxVersion <- input windowsFxVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.WindowsFxVersion((n, args), windowsFxVersion) =
            let apply (args: AppServiceSiteConfigArgs) =
                args.WindowsFxVersion <- io windowsFxVersion
                args

            ()
            n, List.Cons(apply, args)

    let appServiceSiteConfig = AppServiceSiteConfigBuilder()

    type AppServiceSiteConfigCorsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AppServiceSiteConfigCorsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("allowedOrigins")>]
        member _.AllowedOrigins((n, args), allowedOrigins) =
            let apply (args: AppServiceSiteConfigCorsArgs) =
                args.AllowedOrigins <- inputList allowedOrigins
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("supportCredentials")>]
        member _.SupportCredentials((n, args), supportCredentials) =
            let apply (args: AppServiceSiteConfigCorsArgs) =
                args.SupportCredentials <- input supportCredentials
                args

            ()
            n, List.Cons(apply, args)

        member _.SupportCredentials((n, args), supportCredentials) =
            let apply (args: AppServiceSiteConfigCorsArgs) =
                args.SupportCredentials <- io supportCredentials
                args

            ()
            n, List.Cons(apply, args)

    let appServiceSiteConfigCors = AppServiceSiteConfigCorsBuilder()

    type AppServiceSiteConfigIpRestrictionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AppServiceSiteConfigIpRestrictionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("action")>]
        member _.Action((n, args), action) =
            let apply (args: AppServiceSiteConfigIpRestrictionArgs) =
                args.Action <- input action
                args

            ()
            n, List.Cons(apply, args)

        member _.Action((n, args), action) =
            let apply (args: AppServiceSiteConfigIpRestrictionArgs) =
                args.Action <- io action
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ipAddress")>]
        member _.IpAddress((n, args), ipAddress) =
            let apply (args: AppServiceSiteConfigIpRestrictionArgs) =
                args.IpAddress <- input ipAddress
                args

            ()
            n, List.Cons(apply, args)

        member _.IpAddress((n, args), ipAddress) =
            let apply (args: AppServiceSiteConfigIpRestrictionArgs) =
                args.IpAddress <- io ipAddress
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: AppServiceSiteConfigIpRestrictionArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: AppServiceSiteConfigIpRestrictionArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("priority")>]
        member _.Priority((n, args), priority) =
            let apply (args: AppServiceSiteConfigIpRestrictionArgs) =
                args.Priority <- input priority
                args

            ()
            n, List.Cons(apply, args)

        member _.Priority((n, args), priority) =
            let apply (args: AppServiceSiteConfigIpRestrictionArgs) =
                args.Priority <- io priority
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkSubnetId")>]
        member _.VirtualNetworkSubnetId((n, args), virtualNetworkSubnetId) =
            let apply (args: AppServiceSiteConfigIpRestrictionArgs) =
                args.VirtualNetworkSubnetId <- input virtualNetworkSubnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.VirtualNetworkSubnetId((n, args), virtualNetworkSubnetId) =
            let apply (args: AppServiceSiteConfigIpRestrictionArgs) =
                args.VirtualNetworkSubnetId <- io virtualNetworkSubnetId
                args

            ()
            n, List.Cons(apply, args)

    let appServiceSiteConfigIpRestriction =
        AppServiceSiteConfigIpRestrictionBuilder()

    type AppServiceSiteConfigScmIpRestrictionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AppServiceSiteConfigScmIpRestrictionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("action")>]
        member _.Action((n, args), action) =
            let apply (args: AppServiceSiteConfigScmIpRestrictionArgs) =
                args.Action <- input action
                args

            ()
            n, List.Cons(apply, args)

        member _.Action((n, args), action) =
            let apply (args: AppServiceSiteConfigScmIpRestrictionArgs) =
                args.Action <- io action
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ipAddress")>]
        member _.IpAddress((n, args), ipAddress) =
            let apply (args: AppServiceSiteConfigScmIpRestrictionArgs) =
                args.IpAddress <- input ipAddress
                args

            ()
            n, List.Cons(apply, args)

        member _.IpAddress((n, args), ipAddress) =
            let apply (args: AppServiceSiteConfigScmIpRestrictionArgs) =
                args.IpAddress <- io ipAddress
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: AppServiceSiteConfigScmIpRestrictionArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: AppServiceSiteConfigScmIpRestrictionArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("priority")>]
        member _.Priority((n, args), priority) =
            let apply (args: AppServiceSiteConfigScmIpRestrictionArgs) =
                args.Priority <- input priority
                args

            ()
            n, List.Cons(apply, args)

        member _.Priority((n, args), priority) =
            let apply (args: AppServiceSiteConfigScmIpRestrictionArgs) =
                args.Priority <- io priority
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkSubnetId")>]
        member _.VirtualNetworkSubnetId((n, args), virtualNetworkSubnetId) =
            let apply (args: AppServiceSiteConfigScmIpRestrictionArgs) =
                args.VirtualNetworkSubnetId <- input virtualNetworkSubnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.VirtualNetworkSubnetId((n, args), virtualNetworkSubnetId) =
            let apply (args: AppServiceSiteConfigScmIpRestrictionArgs) =
                args.VirtualNetworkSubnetId <- io virtualNetworkSubnetId
                args

            ()
            n, List.Cons(apply, args)

    let appServiceSiteConfigScmIpRestriction =
        AppServiceSiteConfigScmIpRestrictionBuilder()

    type AppServiceSiteCredentialBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AppServiceSiteCredentialArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: AppServiceSiteCredentialArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: AppServiceSiteCredentialArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: AppServiceSiteCredentialArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: AppServiceSiteCredentialArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

    let appServiceSiteCredential = AppServiceSiteCredentialBuilder()

    type AppServiceSourceControlBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AppServiceSourceControlArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("branch")>]
        member _.Branch((n, args), branch) =
            let apply (args: AppServiceSourceControlArgs) =
                args.Branch <- input branch
                args

            ()
            n, List.Cons(apply, args)

        member _.Branch((n, args), branch) =
            let apply (args: AppServiceSourceControlArgs) =
                args.Branch <- io branch
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("repoUrl")>]
        member _.RepoUrl((n, args), repoUrl) =
            let apply (args: AppServiceSourceControlArgs) =
                args.RepoUrl <- input repoUrl
                args

            ()
            n, List.Cons(apply, args)

        member _.RepoUrl((n, args), repoUrl) =
            let apply (args: AppServiceSourceControlArgs) =
                args.RepoUrl <- io repoUrl
                args

            ()
            n, List.Cons(apply, args)

    let appServiceSourceControl = AppServiceSourceControlBuilder()

    type AppServiceStorageAccountBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AppServiceStorageAccountArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("accessKey")>]
        member _.AccessKey((n, args), accessKey) =
            let apply (args: AppServiceStorageAccountArgs) =
                args.AccessKey <- input accessKey
                args

            ()
            n, List.Cons(apply, args)

        member _.AccessKey((n, args), accessKey) =
            let apply (args: AppServiceStorageAccountArgs) =
                args.AccessKey <- io accessKey
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("accountName")>]
        member _.AccountName((n, args), accountName) =
            let apply (args: AppServiceStorageAccountArgs) =
                args.AccountName <- input accountName
                args

            ()
            n, List.Cons(apply, args)

        member _.AccountName((n, args), accountName) =
            let apply (args: AppServiceStorageAccountArgs) =
                args.AccountName <- io accountName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("mountPath")>]
        member _.MountPath((n, args), mountPath) =
            let apply (args: AppServiceStorageAccountArgs) =
                args.MountPath <- input mountPath
                args

            ()
            n, List.Cons(apply, args)

        member _.MountPath((n, args), mountPath) =
            let apply (args: AppServiceStorageAccountArgs) =
                args.MountPath <- io mountPath
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: AppServiceStorageAccountArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: AppServiceStorageAccountArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("shareName")>]
        member _.ShareName((n, args), shareName) =
            let apply (args: AppServiceStorageAccountArgs) =
                args.ShareName <- input shareName
                args

            ()
            n, List.Cons(apply, args)

        member _.ShareName((n, args), shareName) =
            let apply (args: AppServiceStorageAccountArgs) =
                args.ShareName <- io shareName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: AppServiceStorageAccountArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: AppServiceStorageAccountArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let appServiceStorageAccount = AppServiceStorageAccountBuilder()

    type CertificateOrderCertificateBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (CertificateOrderCertificateArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("certificateName")>]
        member _.CertificateName((n, args), certificateName) =
            let apply (args: CertificateOrderCertificateArgs) =
                args.CertificateName <- input certificateName
                args

            ()
            n, List.Cons(apply, args)

        member _.CertificateName((n, args), certificateName) =
            let apply (args: CertificateOrderCertificateArgs) =
                args.CertificateName <- io certificateName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("keyVaultId")>]
        member _.KeyVaultId((n, args), keyVaultId) =
            let apply (args: CertificateOrderCertificateArgs) =
                args.KeyVaultId <- input keyVaultId
                args

            ()
            n, List.Cons(apply, args)

        member _.KeyVaultId((n, args), keyVaultId) =
            let apply (args: CertificateOrderCertificateArgs) =
                args.KeyVaultId <- io keyVaultId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("keyVaultSecretName")>]
        member _.KeyVaultSecretName((n, args), keyVaultSecretName) =
            let apply (args: CertificateOrderCertificateArgs) =
                args.KeyVaultSecretName <- input keyVaultSecretName
                args

            ()
            n, List.Cons(apply, args)

        member _.KeyVaultSecretName((n, args), keyVaultSecretName) =
            let apply (args: CertificateOrderCertificateArgs) =
                args.KeyVaultSecretName <- io keyVaultSecretName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("provisioningState")>]
        member _.ProvisioningState((n, args), provisioningState) =
            let apply (args: CertificateOrderCertificateArgs) =
                args.ProvisioningState <- input provisioningState
                args

            ()
            n, List.Cons(apply, args)

        member _.ProvisioningState((n, args), provisioningState) =
            let apply (args: CertificateOrderCertificateArgs) =
                args.ProvisioningState <- io provisioningState
                args

            ()
            n, List.Cons(apply, args)

    let certificateOrderCertificate = CertificateOrderCertificateBuilder()

    type FunctionAppAuthSettingsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FunctionAppAuthSettingsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: FunctionAppAuthSettingsArgs) =
                   args.ActiveDirectory <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("additionalLoginParams")>]
        member _.AdditionalLoginParams((n, args), additionalLoginParams) =
            let apply (args: FunctionAppAuthSettingsArgs) =
                args.AdditionalLoginParams <- inputMap additionalLoginParams
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("allowedExternalRedirectUrls")>]
        member _.AllowedExternalRedirectUrls((n, args), allowedExternalRedirectUrls) =
            let apply (args: FunctionAppAuthSettingsArgs) =
                args.AllowedExternalRedirectUrls <- inputList allowedExternalRedirectUrls
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("defaultProvider")>]
        member _.DefaultProvider((n, args), defaultProvider) =
            let apply (args: FunctionAppAuthSettingsArgs) =
                args.DefaultProvider <- input defaultProvider
                args

            ()
            n, List.Cons(apply, args)

        member _.DefaultProvider((n, args), defaultProvider) =
            let apply (args: FunctionAppAuthSettingsArgs) =
                args.DefaultProvider <- io defaultProvider
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: FunctionAppAuthSettingsArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: FunctionAppAuthSettingsArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: FunctionAppAuthSettingsArgs) =
                   args.Facebook <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: FunctionAppAuthSettingsArgs) =
                   args.Google <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("issuer")>]
        member _.Issuer((n, args), issuer) =
            let apply (args: FunctionAppAuthSettingsArgs) =
                args.Issuer <- input issuer
                args

            ()
            n, List.Cons(apply, args)

        member _.Issuer((n, args), issuer) =
            let apply (args: FunctionAppAuthSettingsArgs) =
                args.Issuer <- io issuer
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: FunctionAppAuthSettingsArgs) =
                   args.Microsoft <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("runtimeVersion")>]
        member _.RuntimeVersion((n, args), runtimeVersion) =
            let apply (args: FunctionAppAuthSettingsArgs) =
                args.RuntimeVersion <- input runtimeVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.RuntimeVersion((n, args), runtimeVersion) =
            let apply (args: FunctionAppAuthSettingsArgs) =
                args.RuntimeVersion <- io runtimeVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tokenRefreshExtensionHours")>]
        member _.TokenRefreshExtensionHours((n, args), tokenRefreshExtensionHours) =
            let apply (args: FunctionAppAuthSettingsArgs) =
                args.TokenRefreshExtensionHours <- input tokenRefreshExtensionHours
                args

            ()
            n, List.Cons(apply, args)

        member _.TokenRefreshExtensionHours((n, args), tokenRefreshExtensionHours) =
            let apply (args: FunctionAppAuthSettingsArgs) =
                args.TokenRefreshExtensionHours <- io tokenRefreshExtensionHours
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tokenStoreEnabled")>]
        member _.TokenStoreEnabled((n, args), tokenStoreEnabled) =
            let apply (args: FunctionAppAuthSettingsArgs) =
                args.TokenStoreEnabled <- input tokenStoreEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.TokenStoreEnabled((n, args), tokenStoreEnabled) =
            let apply (args: FunctionAppAuthSettingsArgs) =
                args.TokenStoreEnabled <- io tokenStoreEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: FunctionAppAuthSettingsArgs) =
                   args.Twitter <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("unauthenticatedClientAction")>]
        member _.UnauthenticatedClientAction((n, args), unauthenticatedClientAction) =
            let apply (args: FunctionAppAuthSettingsArgs) =
                args.UnauthenticatedClientAction <- input unauthenticatedClientAction
                args

            ()
            n, List.Cons(apply, args)

        member _.UnauthenticatedClientAction((n, args), unauthenticatedClientAction) =
            let apply (args: FunctionAppAuthSettingsArgs) =
                args.UnauthenticatedClientAction <- io unauthenticatedClientAction
                args

            ()
            n, List.Cons(apply, args)

    let functionAppAuthSettings = FunctionAppAuthSettingsBuilder()

    type FunctionAppAuthSettingsActiveDirectoryBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FunctionAppAuthSettingsActiveDirectoryArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("allowedAudiences")>]
        member _.AllowedAudiences((n, args), allowedAudiences) =
            let apply (args: FunctionAppAuthSettingsActiveDirectoryArgs) =
                args.AllowedAudiences <- inputList allowedAudiences
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("clientId")>]
        member _.ClientId((n, args), clientId) =
            let apply (args: FunctionAppAuthSettingsActiveDirectoryArgs) =
                args.ClientId <- input clientId
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientId((n, args), clientId) =
            let apply (args: FunctionAppAuthSettingsActiveDirectoryArgs) =
                args.ClientId <- io clientId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("clientSecret")>]
        member _.ClientSecret((n, args), clientSecret) =
            let apply (args: FunctionAppAuthSettingsActiveDirectoryArgs) =
                args.ClientSecret <- input clientSecret
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientSecret((n, args), clientSecret) =
            let apply (args: FunctionAppAuthSettingsActiveDirectoryArgs) =
                args.ClientSecret <- io clientSecret
                args

            ()
            n, List.Cons(apply, args)

    let functionAppAuthSettingsActiveDirectory =
        FunctionAppAuthSettingsActiveDirectoryBuilder()

    type FunctionAppAuthSettingsFacebookBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FunctionAppAuthSettingsFacebookArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("appId")>]
        member _.AppId((n, args), appId) =
            let apply (args: FunctionAppAuthSettingsFacebookArgs) =
                args.AppId <- input appId
                args

            ()
            n, List.Cons(apply, args)

        member _.AppId((n, args), appId) =
            let apply (args: FunctionAppAuthSettingsFacebookArgs) =
                args.AppId <- io appId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("appSecret")>]
        member _.AppSecret((n, args), appSecret) =
            let apply (args: FunctionAppAuthSettingsFacebookArgs) =
                args.AppSecret <- input appSecret
                args

            ()
            n, List.Cons(apply, args)

        member _.AppSecret((n, args), appSecret) =
            let apply (args: FunctionAppAuthSettingsFacebookArgs) =
                args.AppSecret <- io appSecret
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("oauthScopes")>]
        member _.OauthScopes((n, args), oauthScopes) =
            let apply (args: FunctionAppAuthSettingsFacebookArgs) =
                args.OauthScopes <- inputList oauthScopes
                args

            ()
            n, List.Cons(apply, args)

    let functionAppAuthSettingsFacebook = FunctionAppAuthSettingsFacebookBuilder()

    type FunctionAppAuthSettingsGoogleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FunctionAppAuthSettingsGoogleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("clientId")>]
        member _.ClientId((n, args), clientId) =
            let apply (args: FunctionAppAuthSettingsGoogleArgs) =
                args.ClientId <- input clientId
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientId((n, args), clientId) =
            let apply (args: FunctionAppAuthSettingsGoogleArgs) =
                args.ClientId <- io clientId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("clientSecret")>]
        member _.ClientSecret((n, args), clientSecret) =
            let apply (args: FunctionAppAuthSettingsGoogleArgs) =
                args.ClientSecret <- input clientSecret
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientSecret((n, args), clientSecret) =
            let apply (args: FunctionAppAuthSettingsGoogleArgs) =
                args.ClientSecret <- io clientSecret
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("oauthScopes")>]
        member _.OauthScopes((n, args), oauthScopes) =
            let apply (args: FunctionAppAuthSettingsGoogleArgs) =
                args.OauthScopes <- inputList oauthScopes
                args

            ()
            n, List.Cons(apply, args)

    let functionAppAuthSettingsGoogle = FunctionAppAuthSettingsGoogleBuilder()

    type FunctionAppAuthSettingsMicrosoftBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FunctionAppAuthSettingsMicrosoftArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("clientId")>]
        member _.ClientId((n, args), clientId) =
            let apply (args: FunctionAppAuthSettingsMicrosoftArgs) =
                args.ClientId <- input clientId
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientId((n, args), clientId) =
            let apply (args: FunctionAppAuthSettingsMicrosoftArgs) =
                args.ClientId <- io clientId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("clientSecret")>]
        member _.ClientSecret((n, args), clientSecret) =
            let apply (args: FunctionAppAuthSettingsMicrosoftArgs) =
                args.ClientSecret <- input clientSecret
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientSecret((n, args), clientSecret) =
            let apply (args: FunctionAppAuthSettingsMicrosoftArgs) =
                args.ClientSecret <- io clientSecret
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("oauthScopes")>]
        member _.OauthScopes((n, args), oauthScopes) =
            let apply (args: FunctionAppAuthSettingsMicrosoftArgs) =
                args.OauthScopes <- inputList oauthScopes
                args

            ()
            n, List.Cons(apply, args)

    let functionAppAuthSettingsMicrosoft =
        FunctionAppAuthSettingsMicrosoftBuilder()

    type FunctionAppAuthSettingsTwitterBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FunctionAppAuthSettingsTwitterArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("consumerKey")>]
        member _.ConsumerKey((n, args), consumerKey) =
            let apply (args: FunctionAppAuthSettingsTwitterArgs) =
                args.ConsumerKey <- input consumerKey
                args

            ()
            n, List.Cons(apply, args)

        member _.ConsumerKey((n, args), consumerKey) =
            let apply (args: FunctionAppAuthSettingsTwitterArgs) =
                args.ConsumerKey <- io consumerKey
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("consumerSecret")>]
        member _.ConsumerSecret((n, args), consumerSecret) =
            let apply (args: FunctionAppAuthSettingsTwitterArgs) =
                args.ConsumerSecret <- input consumerSecret
                args

            ()
            n, List.Cons(apply, args)

        member _.ConsumerSecret((n, args), consumerSecret) =
            let apply (args: FunctionAppAuthSettingsTwitterArgs) =
                args.ConsumerSecret <- io consumerSecret
                args

            ()
            n, List.Cons(apply, args)

    let functionAppAuthSettingsTwitter = FunctionAppAuthSettingsTwitterBuilder()

    type FunctionAppConnectionStringBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FunctionAppConnectionStringArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: FunctionAppConnectionStringArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: FunctionAppConnectionStringArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: FunctionAppConnectionStringArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: FunctionAppConnectionStringArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((n, args), value) =
            let apply (args: FunctionAppConnectionStringArgs) =
                args.Value <- input value
                args

            ()
            n, List.Cons(apply, args)

        member _.Value((n, args), value) =
            let apply (args: FunctionAppConnectionStringArgs) =
                args.Value <- io value
                args

            ()
            n, List.Cons(apply, args)

    let functionAppConnectionString = FunctionAppConnectionStringBuilder()

    type FunctionAppIdentityBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FunctionAppIdentityArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("identityIds")>]
        member _.IdentityIds((n, args), identityIds) =
            let apply (args: FunctionAppIdentityArgs) =
                args.IdentityIds <- inputList identityIds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("principalId")>]
        member _.PrincipalId((n, args), principalId) =
            let apply (args: FunctionAppIdentityArgs) =
                args.PrincipalId <- input principalId
                args

            ()
            n, List.Cons(apply, args)

        member _.PrincipalId((n, args), principalId) =
            let apply (args: FunctionAppIdentityArgs) =
                args.PrincipalId <- io principalId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tenantId")>]
        member _.TenantId((n, args), tenantId) =
            let apply (args: FunctionAppIdentityArgs) =
                args.TenantId <- input tenantId
                args

            ()
            n, List.Cons(apply, args)

        member _.TenantId((n, args), tenantId) =
            let apply (args: FunctionAppIdentityArgs) =
                args.TenantId <- io tenantId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: FunctionAppIdentityArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: FunctionAppIdentityArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let functionAppIdentity = FunctionAppIdentityBuilder()

    type FunctionAppSiteConfigBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FunctionAppSiteConfigArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("alwaysOn")>]
        member _.AlwaysOn((n, args), alwaysOn) =
            let apply (args: FunctionAppSiteConfigArgs) =
                args.AlwaysOn <- input alwaysOn
                args

            ()
            n, List.Cons(apply, args)

        member _.AlwaysOn((n, args), alwaysOn) =
            let apply (args: FunctionAppSiteConfigArgs) =
                args.AlwaysOn <- io alwaysOn
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: FunctionAppSiteConfigArgs) =
                   args.Cors <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("ftpsState")>]
        member _.FtpsState((n, args), ftpsState) =
            let apply (args: FunctionAppSiteConfigArgs) =
                args.FtpsState <- input ftpsState
                args

            ()
            n, List.Cons(apply, args)

        member _.FtpsState((n, args), ftpsState) =
            let apply (args: FunctionAppSiteConfigArgs) =
                args.FtpsState <- io ftpsState
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("http2Enabled")>]
        member _.Http2Enabled((n, args), http2Enabled) =
            let apply (args: FunctionAppSiteConfigArgs) =
                args.Http2Enabled <- input http2Enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Http2Enabled((n, args), http2Enabled) =
            let apply (args: FunctionAppSiteConfigArgs) =
                args.Http2Enabled <- io http2Enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ipRestrictions")>]
        member _.IpRestrictions((n, args), ipRestrictions) =
            let apply (args: FunctionAppSiteConfigArgs) =
                args.IpRestrictions <- inputList ipRestrictions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("linuxFxVersion")>]
        member _.LinuxFxVersion((n, args), linuxFxVersion) =
            let apply (args: FunctionAppSiteConfigArgs) =
                args.LinuxFxVersion <- input linuxFxVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.LinuxFxVersion((n, args), linuxFxVersion) =
            let apply (args: FunctionAppSiteConfigArgs) =
                args.LinuxFxVersion <- io linuxFxVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("minTlsVersion")>]
        member _.MinTlsVersion((n, args), minTlsVersion) =
            let apply (args: FunctionAppSiteConfigArgs) =
                args.MinTlsVersion <- input minTlsVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.MinTlsVersion((n, args), minTlsVersion) =
            let apply (args: FunctionAppSiteConfigArgs) =
                args.MinTlsVersion <- io minTlsVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("preWarmedInstanceCount")>]
        member _.PreWarmedInstanceCount((n, args), preWarmedInstanceCount) =
            let apply (args: FunctionAppSiteConfigArgs) =
                args.PreWarmedInstanceCount <- input preWarmedInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        member _.PreWarmedInstanceCount((n, args), preWarmedInstanceCount) =
            let apply (args: FunctionAppSiteConfigArgs) =
                args.PreWarmedInstanceCount <- io preWarmedInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("use32BitWorkerProcess")>]
        member _.Use32BitWorkerProcess((n, args), use32BitWorkerProcess) =
            let apply (args: FunctionAppSiteConfigArgs) =
                args.Use32BitWorkerProcess <- input use32BitWorkerProcess
                args

            ()
            n, List.Cons(apply, args)

        member _.Use32BitWorkerProcess((n, args), use32BitWorkerProcess) =
            let apply (args: FunctionAppSiteConfigArgs) =
                args.Use32BitWorkerProcess <- io use32BitWorkerProcess
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("websocketsEnabled")>]
        member _.WebsocketsEnabled((n, args), websocketsEnabled) =
            let apply (args: FunctionAppSiteConfigArgs) =
                args.WebsocketsEnabled <- input websocketsEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.WebsocketsEnabled((n, args), websocketsEnabled) =
            let apply (args: FunctionAppSiteConfigArgs) =
                args.WebsocketsEnabled <- io websocketsEnabled
                args

            ()
            n, List.Cons(apply, args)

    let functionAppSiteConfig = FunctionAppSiteConfigBuilder()

    type FunctionAppSiteConfigCorsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FunctionAppSiteConfigCorsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("allowedOrigins")>]
        member _.AllowedOrigins((n, args), allowedOrigins) =
            let apply (args: FunctionAppSiteConfigCorsArgs) =
                args.AllowedOrigins <- inputList allowedOrigins
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("supportCredentials")>]
        member _.SupportCredentials((n, args), supportCredentials) =
            let apply (args: FunctionAppSiteConfigCorsArgs) =
                args.SupportCredentials <- input supportCredentials
                args

            ()
            n, List.Cons(apply, args)

        member _.SupportCredentials((n, args), supportCredentials) =
            let apply (args: FunctionAppSiteConfigCorsArgs) =
                args.SupportCredentials <- io supportCredentials
                args

            ()
            n, List.Cons(apply, args)

    let functionAppSiteConfigCors = FunctionAppSiteConfigCorsBuilder()

    type FunctionAppSiteConfigIpRestrictionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FunctionAppSiteConfigIpRestrictionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("ipAddress")>]
        member _.IpAddress((n, args), ipAddress) =
            let apply (args: FunctionAppSiteConfigIpRestrictionArgs) =
                args.IpAddress <- input ipAddress
                args

            ()
            n, List.Cons(apply, args)

        member _.IpAddress((n, args), ipAddress) =
            let apply (args: FunctionAppSiteConfigIpRestrictionArgs) =
                args.IpAddress <- io ipAddress
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: FunctionAppSiteConfigIpRestrictionArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: FunctionAppSiteConfigIpRestrictionArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

    let functionAppSiteConfigIpRestriction =
        FunctionAppSiteConfigIpRestrictionBuilder()

    type FunctionAppSiteCredentialBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FunctionAppSiteCredentialArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: FunctionAppSiteCredentialArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: FunctionAppSiteCredentialArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: FunctionAppSiteCredentialArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: FunctionAppSiteCredentialArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

    let functionAppSiteCredential = FunctionAppSiteCredentialBuilder()

    type FunctionAppSlotAuthSettingsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FunctionAppSlotAuthSettingsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: FunctionAppSlotAuthSettingsArgs) =
                   args.ActiveDirectory <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("additionalLoginParams")>]
        member _.AdditionalLoginParams((n, args), additionalLoginParams) =
            let apply (args: FunctionAppSlotAuthSettingsArgs) =
                args.AdditionalLoginParams <- inputMap additionalLoginParams
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("allowedExternalRedirectUrls")>]
        member _.AllowedExternalRedirectUrls((n, args), allowedExternalRedirectUrls) =
            let apply (args: FunctionAppSlotAuthSettingsArgs) =
                args.AllowedExternalRedirectUrls <- inputList allowedExternalRedirectUrls
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("defaultProvider")>]
        member _.DefaultProvider((n, args), defaultProvider) =
            let apply (args: FunctionAppSlotAuthSettingsArgs) =
                args.DefaultProvider <- input defaultProvider
                args

            ()
            n, List.Cons(apply, args)

        member _.DefaultProvider((n, args), defaultProvider) =
            let apply (args: FunctionAppSlotAuthSettingsArgs) =
                args.DefaultProvider <- io defaultProvider
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: FunctionAppSlotAuthSettingsArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: FunctionAppSlotAuthSettingsArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: FunctionAppSlotAuthSettingsArgs) =
                   args.Facebook <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: FunctionAppSlotAuthSettingsArgs) =
                   args.Google <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("issuer")>]
        member _.Issuer((n, args), issuer) =
            let apply (args: FunctionAppSlotAuthSettingsArgs) =
                args.Issuer <- input issuer
                args

            ()
            n, List.Cons(apply, args)

        member _.Issuer((n, args), issuer) =
            let apply (args: FunctionAppSlotAuthSettingsArgs) =
                args.Issuer <- io issuer
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: FunctionAppSlotAuthSettingsArgs) =
                   args.Microsoft <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("runtimeVersion")>]
        member _.RuntimeVersion((n, args), runtimeVersion) =
            let apply (args: FunctionAppSlotAuthSettingsArgs) =
                args.RuntimeVersion <- input runtimeVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.RuntimeVersion((n, args), runtimeVersion) =
            let apply (args: FunctionAppSlotAuthSettingsArgs) =
                args.RuntimeVersion <- io runtimeVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tokenRefreshExtensionHours")>]
        member _.TokenRefreshExtensionHours((n, args), tokenRefreshExtensionHours) =
            let apply (args: FunctionAppSlotAuthSettingsArgs) =
                args.TokenRefreshExtensionHours <- input tokenRefreshExtensionHours
                args

            ()
            n, List.Cons(apply, args)

        member _.TokenRefreshExtensionHours((n, args), tokenRefreshExtensionHours) =
            let apply (args: FunctionAppSlotAuthSettingsArgs) =
                args.TokenRefreshExtensionHours <- io tokenRefreshExtensionHours
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tokenStoreEnabled")>]
        member _.TokenStoreEnabled((n, args), tokenStoreEnabled) =
            let apply (args: FunctionAppSlotAuthSettingsArgs) =
                args.TokenStoreEnabled <- input tokenStoreEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.TokenStoreEnabled((n, args), tokenStoreEnabled) =
            let apply (args: FunctionAppSlotAuthSettingsArgs) =
                args.TokenStoreEnabled <- io tokenStoreEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: FunctionAppSlotAuthSettingsArgs) =
                   args.Twitter <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("unauthenticatedClientAction")>]
        member _.UnauthenticatedClientAction((n, args), unauthenticatedClientAction) =
            let apply (args: FunctionAppSlotAuthSettingsArgs) =
                args.UnauthenticatedClientAction <- input unauthenticatedClientAction
                args

            ()
            n, List.Cons(apply, args)

        member _.UnauthenticatedClientAction((n, args), unauthenticatedClientAction) =
            let apply (args: FunctionAppSlotAuthSettingsArgs) =
                args.UnauthenticatedClientAction <- io unauthenticatedClientAction
                args

            ()
            n, List.Cons(apply, args)

    let functionAppSlotAuthSettings = FunctionAppSlotAuthSettingsBuilder()

    type FunctionAppSlotAuthSettingsActiveDirectoryBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FunctionAppSlotAuthSettingsActiveDirectoryArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("allowedAudiences")>]
        member _.AllowedAudiences((n, args), allowedAudiences) =
            let apply (args: FunctionAppSlotAuthSettingsActiveDirectoryArgs) =
                args.AllowedAudiences <- inputList allowedAudiences
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("clientId")>]
        member _.ClientId((n, args), clientId) =
            let apply (args: FunctionAppSlotAuthSettingsActiveDirectoryArgs) =
                args.ClientId <- input clientId
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientId((n, args), clientId) =
            let apply (args: FunctionAppSlotAuthSettingsActiveDirectoryArgs) =
                args.ClientId <- io clientId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("clientSecret")>]
        member _.ClientSecret((n, args), clientSecret) =
            let apply (args: FunctionAppSlotAuthSettingsActiveDirectoryArgs) =
                args.ClientSecret <- input clientSecret
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientSecret((n, args), clientSecret) =
            let apply (args: FunctionAppSlotAuthSettingsActiveDirectoryArgs) =
                args.ClientSecret <- io clientSecret
                args

            ()
            n, List.Cons(apply, args)

    let functionAppSlotAuthSettingsActiveDirectory =
        FunctionAppSlotAuthSettingsActiveDirectoryBuilder()

    type FunctionAppSlotAuthSettingsFacebookBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FunctionAppSlotAuthSettingsFacebookArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("appId")>]
        member _.AppId((n, args), appId) =
            let apply (args: FunctionAppSlotAuthSettingsFacebookArgs) =
                args.AppId <- input appId
                args

            ()
            n, List.Cons(apply, args)

        member _.AppId((n, args), appId) =
            let apply (args: FunctionAppSlotAuthSettingsFacebookArgs) =
                args.AppId <- io appId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("appSecret")>]
        member _.AppSecret((n, args), appSecret) =
            let apply (args: FunctionAppSlotAuthSettingsFacebookArgs) =
                args.AppSecret <- input appSecret
                args

            ()
            n, List.Cons(apply, args)

        member _.AppSecret((n, args), appSecret) =
            let apply (args: FunctionAppSlotAuthSettingsFacebookArgs) =
                args.AppSecret <- io appSecret
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("oauthScopes")>]
        member _.OauthScopes((n, args), oauthScopes) =
            let apply (args: FunctionAppSlotAuthSettingsFacebookArgs) =
                args.OauthScopes <- inputList oauthScopes
                args

            ()
            n, List.Cons(apply, args)

    let functionAppSlotAuthSettingsFacebook =
        FunctionAppSlotAuthSettingsFacebookBuilder()

    type FunctionAppSlotAuthSettingsGoogleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FunctionAppSlotAuthSettingsGoogleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("clientId")>]
        member _.ClientId((n, args), clientId) =
            let apply (args: FunctionAppSlotAuthSettingsGoogleArgs) =
                args.ClientId <- input clientId
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientId((n, args), clientId) =
            let apply (args: FunctionAppSlotAuthSettingsGoogleArgs) =
                args.ClientId <- io clientId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("clientSecret")>]
        member _.ClientSecret((n, args), clientSecret) =
            let apply (args: FunctionAppSlotAuthSettingsGoogleArgs) =
                args.ClientSecret <- input clientSecret
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientSecret((n, args), clientSecret) =
            let apply (args: FunctionAppSlotAuthSettingsGoogleArgs) =
                args.ClientSecret <- io clientSecret
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("oauthScopes")>]
        member _.OauthScopes((n, args), oauthScopes) =
            let apply (args: FunctionAppSlotAuthSettingsGoogleArgs) =
                args.OauthScopes <- inputList oauthScopes
                args

            ()
            n, List.Cons(apply, args)

    let functionAppSlotAuthSettingsGoogle =
        FunctionAppSlotAuthSettingsGoogleBuilder()

    type FunctionAppSlotAuthSettingsMicrosoftBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FunctionAppSlotAuthSettingsMicrosoftArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("clientId")>]
        member _.ClientId((n, args), clientId) =
            let apply (args: FunctionAppSlotAuthSettingsMicrosoftArgs) =
                args.ClientId <- input clientId
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientId((n, args), clientId) =
            let apply (args: FunctionAppSlotAuthSettingsMicrosoftArgs) =
                args.ClientId <- io clientId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("clientSecret")>]
        member _.ClientSecret((n, args), clientSecret) =
            let apply (args: FunctionAppSlotAuthSettingsMicrosoftArgs) =
                args.ClientSecret <- input clientSecret
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientSecret((n, args), clientSecret) =
            let apply (args: FunctionAppSlotAuthSettingsMicrosoftArgs) =
                args.ClientSecret <- io clientSecret
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("oauthScopes")>]
        member _.OauthScopes((n, args), oauthScopes) =
            let apply (args: FunctionAppSlotAuthSettingsMicrosoftArgs) =
                args.OauthScopes <- inputList oauthScopes
                args

            ()
            n, List.Cons(apply, args)

    let functionAppSlotAuthSettingsMicrosoft =
        FunctionAppSlotAuthSettingsMicrosoftBuilder()

    type FunctionAppSlotAuthSettingsTwitterBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FunctionAppSlotAuthSettingsTwitterArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("consumerKey")>]
        member _.ConsumerKey((n, args), consumerKey) =
            let apply (args: FunctionAppSlotAuthSettingsTwitterArgs) =
                args.ConsumerKey <- input consumerKey
                args

            ()
            n, List.Cons(apply, args)

        member _.ConsumerKey((n, args), consumerKey) =
            let apply (args: FunctionAppSlotAuthSettingsTwitterArgs) =
                args.ConsumerKey <- io consumerKey
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("consumerSecret")>]
        member _.ConsumerSecret((n, args), consumerSecret) =
            let apply (args: FunctionAppSlotAuthSettingsTwitterArgs) =
                args.ConsumerSecret <- input consumerSecret
                args

            ()
            n, List.Cons(apply, args)

        member _.ConsumerSecret((n, args), consumerSecret) =
            let apply (args: FunctionAppSlotAuthSettingsTwitterArgs) =
                args.ConsumerSecret <- io consumerSecret
                args

            ()
            n, List.Cons(apply, args)

    let functionAppSlotAuthSettingsTwitter =
        FunctionAppSlotAuthSettingsTwitterBuilder()

    type FunctionAppSlotConnectionStringBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FunctionAppSlotConnectionStringArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: FunctionAppSlotConnectionStringArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: FunctionAppSlotConnectionStringArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: FunctionAppSlotConnectionStringArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: FunctionAppSlotConnectionStringArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((n, args), value) =
            let apply (args: FunctionAppSlotConnectionStringArgs) =
                args.Value <- input value
                args

            ()
            n, List.Cons(apply, args)

        member _.Value((n, args), value) =
            let apply (args: FunctionAppSlotConnectionStringArgs) =
                args.Value <- io value
                args

            ()
            n, List.Cons(apply, args)

    let functionAppSlotConnectionString = FunctionAppSlotConnectionStringBuilder()

    type FunctionAppSlotIdentityBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FunctionAppSlotIdentityArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("identityIds")>]
        member _.IdentityIds((n, args), identityIds) =
            let apply (args: FunctionAppSlotIdentityArgs) =
                args.IdentityIds <- inputList identityIds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("principalId")>]
        member _.PrincipalId((n, args), principalId) =
            let apply (args: FunctionAppSlotIdentityArgs) =
                args.PrincipalId <- input principalId
                args

            ()
            n, List.Cons(apply, args)

        member _.PrincipalId((n, args), principalId) =
            let apply (args: FunctionAppSlotIdentityArgs) =
                args.PrincipalId <- io principalId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tenantId")>]
        member _.TenantId((n, args), tenantId) =
            let apply (args: FunctionAppSlotIdentityArgs) =
                args.TenantId <- input tenantId
                args

            ()
            n, List.Cons(apply, args)

        member _.TenantId((n, args), tenantId) =
            let apply (args: FunctionAppSlotIdentityArgs) =
                args.TenantId <- io tenantId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: FunctionAppSlotIdentityArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: FunctionAppSlotIdentityArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let functionAppSlotIdentity = FunctionAppSlotIdentityBuilder()

    type FunctionAppSlotSiteConfigBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FunctionAppSlotSiteConfigArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("alwaysOn")>]
        member _.AlwaysOn((n, args), alwaysOn) =
            let apply (args: FunctionAppSlotSiteConfigArgs) =
                args.AlwaysOn <- input alwaysOn
                args

            ()
            n, List.Cons(apply, args)

        member _.AlwaysOn((n, args), alwaysOn) =
            let apply (args: FunctionAppSlotSiteConfigArgs) =
                args.AlwaysOn <- io alwaysOn
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: FunctionAppSlotSiteConfigArgs) =
                   args.Cors <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("ftpsState")>]
        member _.FtpsState((n, args), ftpsState) =
            let apply (args: FunctionAppSlotSiteConfigArgs) =
                args.FtpsState <- input ftpsState
                args

            ()
            n, List.Cons(apply, args)

        member _.FtpsState((n, args), ftpsState) =
            let apply (args: FunctionAppSlotSiteConfigArgs) =
                args.FtpsState <- io ftpsState
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("http2Enabled")>]
        member _.Http2Enabled((n, args), http2Enabled) =
            let apply (args: FunctionAppSlotSiteConfigArgs) =
                args.Http2Enabled <- input http2Enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Http2Enabled((n, args), http2Enabled) =
            let apply (args: FunctionAppSlotSiteConfigArgs) =
                args.Http2Enabled <- io http2Enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ipRestrictions")>]
        member _.IpRestrictions((n, args), ipRestrictions) =
            let apply (args: FunctionAppSlotSiteConfigArgs) =
                args.IpRestrictions <- inputList ipRestrictions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("linuxFxVersion")>]
        member _.LinuxFxVersion((n, args), linuxFxVersion) =
            let apply (args: FunctionAppSlotSiteConfigArgs) =
                args.LinuxFxVersion <- input linuxFxVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.LinuxFxVersion((n, args), linuxFxVersion) =
            let apply (args: FunctionAppSlotSiteConfigArgs) =
                args.LinuxFxVersion <- io linuxFxVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("minTlsVersion")>]
        member _.MinTlsVersion((n, args), minTlsVersion) =
            let apply (args: FunctionAppSlotSiteConfigArgs) =
                args.MinTlsVersion <- input minTlsVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.MinTlsVersion((n, args), minTlsVersion) =
            let apply (args: FunctionAppSlotSiteConfigArgs) =
                args.MinTlsVersion <- io minTlsVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("preWarmedInstanceCount")>]
        member _.PreWarmedInstanceCount((n, args), preWarmedInstanceCount) =
            let apply (args: FunctionAppSlotSiteConfigArgs) =
                args.PreWarmedInstanceCount <- input preWarmedInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        member _.PreWarmedInstanceCount((n, args), preWarmedInstanceCount) =
            let apply (args: FunctionAppSlotSiteConfigArgs) =
                args.PreWarmedInstanceCount <- io preWarmedInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("use32BitWorkerProcess")>]
        member _.Use32BitWorkerProcess((n, args), use32BitWorkerProcess) =
            let apply (args: FunctionAppSlotSiteConfigArgs) =
                args.Use32BitWorkerProcess <- input use32BitWorkerProcess
                args

            ()
            n, List.Cons(apply, args)

        member _.Use32BitWorkerProcess((n, args), use32BitWorkerProcess) =
            let apply (args: FunctionAppSlotSiteConfigArgs) =
                args.Use32BitWorkerProcess <- io use32BitWorkerProcess
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("websocketsEnabled")>]
        member _.WebsocketsEnabled((n, args), websocketsEnabled) =
            let apply (args: FunctionAppSlotSiteConfigArgs) =
                args.WebsocketsEnabled <- input websocketsEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.WebsocketsEnabled((n, args), websocketsEnabled) =
            let apply (args: FunctionAppSlotSiteConfigArgs) =
                args.WebsocketsEnabled <- io websocketsEnabled
                args

            ()
            n, List.Cons(apply, args)

    let functionAppSlotSiteConfig = FunctionAppSlotSiteConfigBuilder()

    type FunctionAppSlotSiteConfigCorsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FunctionAppSlotSiteConfigCorsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("allowedOrigins")>]
        member _.AllowedOrigins((n, args), allowedOrigins) =
            let apply (args: FunctionAppSlotSiteConfigCorsArgs) =
                args.AllowedOrigins <- inputList allowedOrigins
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("supportCredentials")>]
        member _.SupportCredentials((n, args), supportCredentials) =
            let apply (args: FunctionAppSlotSiteConfigCorsArgs) =
                args.SupportCredentials <- input supportCredentials
                args

            ()
            n, List.Cons(apply, args)

        member _.SupportCredentials((n, args), supportCredentials) =
            let apply (args: FunctionAppSlotSiteConfigCorsArgs) =
                args.SupportCredentials <- io supportCredentials
                args

            ()
            n, List.Cons(apply, args)

    let functionAppSlotSiteConfigCors = FunctionAppSlotSiteConfigCorsBuilder()

    type FunctionAppSlotSiteConfigIpRestrictionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FunctionAppSlotSiteConfigIpRestrictionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("ipAddress")>]
        member _.IpAddress((n, args), ipAddress) =
            let apply (args: FunctionAppSlotSiteConfigIpRestrictionArgs) =
                args.IpAddress <- input ipAddress
                args

            ()
            n, List.Cons(apply, args)

        member _.IpAddress((n, args), ipAddress) =
            let apply (args: FunctionAppSlotSiteConfigIpRestrictionArgs) =
                args.IpAddress <- io ipAddress
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: FunctionAppSlotSiteConfigIpRestrictionArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: FunctionAppSlotSiteConfigIpRestrictionArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

    let functionAppSlotSiteConfigIpRestriction =
        FunctionAppSlotSiteConfigIpRestrictionBuilder()

    type FunctionAppSlotSiteCredentialBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FunctionAppSlotSiteCredentialArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: FunctionAppSlotSiteCredentialArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: FunctionAppSlotSiteCredentialArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: FunctionAppSlotSiteCredentialArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: FunctionAppSlotSiteCredentialArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

    let functionAppSlotSiteCredential = FunctionAppSlotSiteCredentialBuilder()

    type PlanSkuBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (PlanSkuArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("capacity")>]
        member _.Capacity((n, args), capacity) =
            let apply (args: PlanSkuArgs) =
                args.Capacity <- input capacity
                args

            ()
            n, List.Cons(apply, args)

        member _.Capacity((n, args), capacity) =
            let apply (args: PlanSkuArgs) =
                args.Capacity <- io capacity
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("size")>]
        member _.Size((n, args), size) =
            let apply (args: PlanSkuArgs) =
                args.Size <- input size
                args

            ()
            n, List.Cons(apply, args)

        member _.Size((n, args), size) =
            let apply (args: PlanSkuArgs) =
                args.Size <- io size
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tier")>]
        member _.Tier((n, args), tier) =
            let apply (args: PlanSkuArgs) =
                args.Tier <- input tier
                args

            ()
            n, List.Cons(apply, args)

        member _.Tier((n, args), tier) =
            let apply (args: PlanSkuArgs) =
                args.Tier <- io tier
                args

            ()
            n, List.Cons(apply, args)

    let planSku = PlanSkuBuilder()

    type SlotAuthSettingsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SlotAuthSettingsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: SlotAuthSettingsArgs) =
                   args.ActiveDirectory <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("additionalLoginParams")>]
        member _.AdditionalLoginParams((n, args), additionalLoginParams) =
            let apply (args: SlotAuthSettingsArgs) =
                args.AdditionalLoginParams <- inputMap additionalLoginParams
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("allowedExternalRedirectUrls")>]
        member _.AllowedExternalRedirectUrls((n, args), allowedExternalRedirectUrls) =
            let apply (args: SlotAuthSettingsArgs) =
                args.AllowedExternalRedirectUrls <- inputList allowedExternalRedirectUrls
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("defaultProvider")>]
        member _.DefaultProvider((n, args), defaultProvider) =
            let apply (args: SlotAuthSettingsArgs) =
                args.DefaultProvider <- input defaultProvider
                args

            ()
            n, List.Cons(apply, args)

        member _.DefaultProvider((n, args), defaultProvider) =
            let apply (args: SlotAuthSettingsArgs) =
                args.DefaultProvider <- io defaultProvider
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: SlotAuthSettingsArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: SlotAuthSettingsArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: SlotAuthSettingsArgs) =
                   args.Facebook <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: SlotAuthSettingsArgs) =
                   args.Google <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("issuer")>]
        member _.Issuer((n, args), issuer) =
            let apply (args: SlotAuthSettingsArgs) =
                args.Issuer <- input issuer
                args

            ()
            n, List.Cons(apply, args)

        member _.Issuer((n, args), issuer) =
            let apply (args: SlotAuthSettingsArgs) =
                args.Issuer <- io issuer
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: SlotAuthSettingsArgs) =
                   args.Microsoft <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("runtimeVersion")>]
        member _.RuntimeVersion((n, args), runtimeVersion) =
            let apply (args: SlotAuthSettingsArgs) =
                args.RuntimeVersion <- input runtimeVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.RuntimeVersion((n, args), runtimeVersion) =
            let apply (args: SlotAuthSettingsArgs) =
                args.RuntimeVersion <- io runtimeVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tokenRefreshExtensionHours")>]
        member _.TokenRefreshExtensionHours((n, args), tokenRefreshExtensionHours) =
            let apply (args: SlotAuthSettingsArgs) =
                args.TokenRefreshExtensionHours <- input tokenRefreshExtensionHours
                args

            ()
            n, List.Cons(apply, args)

        member _.TokenRefreshExtensionHours((n, args), tokenRefreshExtensionHours) =
            let apply (args: SlotAuthSettingsArgs) =
                args.TokenRefreshExtensionHours <- io tokenRefreshExtensionHours
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tokenStoreEnabled")>]
        member _.TokenStoreEnabled((n, args), tokenStoreEnabled) =
            let apply (args: SlotAuthSettingsArgs) =
                args.TokenStoreEnabled <- input tokenStoreEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.TokenStoreEnabled((n, args), tokenStoreEnabled) =
            let apply (args: SlotAuthSettingsArgs) =
                args.TokenStoreEnabled <- io tokenStoreEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: SlotAuthSettingsArgs) =
                   args.Twitter <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("unauthenticatedClientAction")>]
        member _.UnauthenticatedClientAction((n, args), unauthenticatedClientAction) =
            let apply (args: SlotAuthSettingsArgs) =
                args.UnauthenticatedClientAction <- input unauthenticatedClientAction
                args

            ()
            n, List.Cons(apply, args)

        member _.UnauthenticatedClientAction((n, args), unauthenticatedClientAction) =
            let apply (args: SlotAuthSettingsArgs) =
                args.UnauthenticatedClientAction <- io unauthenticatedClientAction
                args

            ()
            n, List.Cons(apply, args)

    let slotAuthSettings = SlotAuthSettingsBuilder()

    type SlotAuthSettingsActiveDirectoryBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SlotAuthSettingsActiveDirectoryArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("allowedAudiences")>]
        member _.AllowedAudiences((n, args), allowedAudiences) =
            let apply (args: SlotAuthSettingsActiveDirectoryArgs) =
                args.AllowedAudiences <- inputList allowedAudiences
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("clientId")>]
        member _.ClientId((n, args), clientId) =
            let apply (args: SlotAuthSettingsActiveDirectoryArgs) =
                args.ClientId <- input clientId
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientId((n, args), clientId) =
            let apply (args: SlotAuthSettingsActiveDirectoryArgs) =
                args.ClientId <- io clientId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("clientSecret")>]
        member _.ClientSecret((n, args), clientSecret) =
            let apply (args: SlotAuthSettingsActiveDirectoryArgs) =
                args.ClientSecret <- input clientSecret
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientSecret((n, args), clientSecret) =
            let apply (args: SlotAuthSettingsActiveDirectoryArgs) =
                args.ClientSecret <- io clientSecret
                args

            ()
            n, List.Cons(apply, args)

    let slotAuthSettingsActiveDirectory = SlotAuthSettingsActiveDirectoryBuilder()

    type SlotAuthSettingsFacebookBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SlotAuthSettingsFacebookArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("appId")>]
        member _.AppId((n, args), appId) =
            let apply (args: SlotAuthSettingsFacebookArgs) =
                args.AppId <- input appId
                args

            ()
            n, List.Cons(apply, args)

        member _.AppId((n, args), appId) =
            let apply (args: SlotAuthSettingsFacebookArgs) =
                args.AppId <- io appId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("appSecret")>]
        member _.AppSecret((n, args), appSecret) =
            let apply (args: SlotAuthSettingsFacebookArgs) =
                args.AppSecret <- input appSecret
                args

            ()
            n, List.Cons(apply, args)

        member _.AppSecret((n, args), appSecret) =
            let apply (args: SlotAuthSettingsFacebookArgs) =
                args.AppSecret <- io appSecret
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("oauthScopes")>]
        member _.OauthScopes((n, args), oauthScopes) =
            let apply (args: SlotAuthSettingsFacebookArgs) =
                args.OauthScopes <- inputList oauthScopes
                args

            ()
            n, List.Cons(apply, args)

    let slotAuthSettingsFacebook = SlotAuthSettingsFacebookBuilder()

    type SlotAuthSettingsGoogleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SlotAuthSettingsGoogleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("clientId")>]
        member _.ClientId((n, args), clientId) =
            let apply (args: SlotAuthSettingsGoogleArgs) =
                args.ClientId <- input clientId
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientId((n, args), clientId) =
            let apply (args: SlotAuthSettingsGoogleArgs) =
                args.ClientId <- io clientId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("clientSecret")>]
        member _.ClientSecret((n, args), clientSecret) =
            let apply (args: SlotAuthSettingsGoogleArgs) =
                args.ClientSecret <- input clientSecret
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientSecret((n, args), clientSecret) =
            let apply (args: SlotAuthSettingsGoogleArgs) =
                args.ClientSecret <- io clientSecret
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("oauthScopes")>]
        member _.OauthScopes((n, args), oauthScopes) =
            let apply (args: SlotAuthSettingsGoogleArgs) =
                args.OauthScopes <- inputList oauthScopes
                args

            ()
            n, List.Cons(apply, args)

    let slotAuthSettingsGoogle = SlotAuthSettingsGoogleBuilder()

    type SlotAuthSettingsMicrosoftBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SlotAuthSettingsMicrosoftArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("clientId")>]
        member _.ClientId((n, args), clientId) =
            let apply (args: SlotAuthSettingsMicrosoftArgs) =
                args.ClientId <- input clientId
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientId((n, args), clientId) =
            let apply (args: SlotAuthSettingsMicrosoftArgs) =
                args.ClientId <- io clientId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("clientSecret")>]
        member _.ClientSecret((n, args), clientSecret) =
            let apply (args: SlotAuthSettingsMicrosoftArgs) =
                args.ClientSecret <- input clientSecret
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientSecret((n, args), clientSecret) =
            let apply (args: SlotAuthSettingsMicrosoftArgs) =
                args.ClientSecret <- io clientSecret
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("oauthScopes")>]
        member _.OauthScopes((n, args), oauthScopes) =
            let apply (args: SlotAuthSettingsMicrosoftArgs) =
                args.OauthScopes <- inputList oauthScopes
                args

            ()
            n, List.Cons(apply, args)

    let slotAuthSettingsMicrosoft = SlotAuthSettingsMicrosoftBuilder()

    type SlotAuthSettingsTwitterBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SlotAuthSettingsTwitterArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("consumerKey")>]
        member _.ConsumerKey((n, args), consumerKey) =
            let apply (args: SlotAuthSettingsTwitterArgs) =
                args.ConsumerKey <- input consumerKey
                args

            ()
            n, List.Cons(apply, args)

        member _.ConsumerKey((n, args), consumerKey) =
            let apply (args: SlotAuthSettingsTwitterArgs) =
                args.ConsumerKey <- io consumerKey
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("consumerSecret")>]
        member _.ConsumerSecret((n, args), consumerSecret) =
            let apply (args: SlotAuthSettingsTwitterArgs) =
                args.ConsumerSecret <- input consumerSecret
                args

            ()
            n, List.Cons(apply, args)

        member _.ConsumerSecret((n, args), consumerSecret) =
            let apply (args: SlotAuthSettingsTwitterArgs) =
                args.ConsumerSecret <- io consumerSecret
                args

            ()
            n, List.Cons(apply, args)

    let slotAuthSettingsTwitter = SlotAuthSettingsTwitterBuilder()

    type SlotConnectionStringBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SlotConnectionStringArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: SlotConnectionStringArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: SlotConnectionStringArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: SlotConnectionStringArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: SlotConnectionStringArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((n, args), value) =
            let apply (args: SlotConnectionStringArgs) =
                args.Value <- input value
                args

            ()
            n, List.Cons(apply, args)

        member _.Value((n, args), value) =
            let apply (args: SlotConnectionStringArgs) =
                args.Value <- io value
                args

            ()
            n, List.Cons(apply, args)

    let slotConnectionString = SlotConnectionStringBuilder()

    type SlotIdentityBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SlotIdentityArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("identityIds")>]
        member _.IdentityIds((n, args), identityIds) =
            let apply (args: SlotIdentityArgs) =
                args.IdentityIds <- inputList identityIds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("principalId")>]
        member _.PrincipalId((n, args), principalId) =
            let apply (args: SlotIdentityArgs) =
                args.PrincipalId <- input principalId
                args

            ()
            n, List.Cons(apply, args)

        member _.PrincipalId((n, args), principalId) =
            let apply (args: SlotIdentityArgs) =
                args.PrincipalId <- io principalId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tenantId")>]
        member _.TenantId((n, args), tenantId) =
            let apply (args: SlotIdentityArgs) =
                args.TenantId <- input tenantId
                args

            ()
            n, List.Cons(apply, args)

        member _.TenantId((n, args), tenantId) =
            let apply (args: SlotIdentityArgs) =
                args.TenantId <- io tenantId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: SlotIdentityArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: SlotIdentityArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let slotIdentity = SlotIdentityBuilder()

    type SlotLogsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SlotLogsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: SlotLogsArgs) =
                   args.ApplicationLogs <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: SlotLogsArgs) =
                   args.HttpLogs <- input arg
                   args

               ()
               func) ]

    let slotLogs = SlotLogsBuilder()

    type SlotLogsApplicationLogsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SlotLogsApplicationLogsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: SlotLogsApplicationLogsArgs) =
                   args.AzureBlobStorage <- input arg
                   args

               ()
               func) ]

    let slotLogsApplicationLogs = SlotLogsApplicationLogsBuilder()

    type SlotLogsApplicationLogsAzureBlobStorageBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SlotLogsApplicationLogsAzureBlobStorageArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("level")>]
        member _.Level((n, args), level) =
            let apply (args: SlotLogsApplicationLogsAzureBlobStorageArgs) =
                args.Level <- input level
                args

            ()
            n, List.Cons(apply, args)

        member _.Level((n, args), level) =
            let apply (args: SlotLogsApplicationLogsAzureBlobStorageArgs) =
                args.Level <- io level
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("retentionInDays")>]
        member _.RetentionInDays((n, args), retentionInDays) =
            let apply (args: SlotLogsApplicationLogsAzureBlobStorageArgs) =
                args.RetentionInDays <- input retentionInDays
                args

            ()
            n, List.Cons(apply, args)

        member _.RetentionInDays((n, args), retentionInDays) =
            let apply (args: SlotLogsApplicationLogsAzureBlobStorageArgs) =
                args.RetentionInDays <- io retentionInDays
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sasUrl")>]
        member _.SasUrl((n, args), sasUrl) =
            let apply (args: SlotLogsApplicationLogsAzureBlobStorageArgs) =
                args.SasUrl <- input sasUrl
                args

            ()
            n, List.Cons(apply, args)

        member _.SasUrl((n, args), sasUrl) =
            let apply (args: SlotLogsApplicationLogsAzureBlobStorageArgs) =
                args.SasUrl <- io sasUrl
                args

            ()
            n, List.Cons(apply, args)

    let slotLogsApplicationLogsAzureBlobStorage =
        SlotLogsApplicationLogsAzureBlobStorageBuilder()

    type SlotLogsHttpLogsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SlotLogsHttpLogsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: SlotLogsHttpLogsArgs) =
                   args.AzureBlobStorage <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: SlotLogsHttpLogsArgs) =
                   args.FileSystem <- input arg
                   args

               ()
               func) ]

    let slotLogsHttpLogs = SlotLogsHttpLogsBuilder()

    type SlotLogsHttpLogsAzureBlobStorageBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SlotLogsHttpLogsAzureBlobStorageArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("retentionInDays")>]
        member _.RetentionInDays((n, args), retentionInDays) =
            let apply (args: SlotLogsHttpLogsAzureBlobStorageArgs) =
                args.RetentionInDays <- input retentionInDays
                args

            ()
            n, List.Cons(apply, args)

        member _.RetentionInDays((n, args), retentionInDays) =
            let apply (args: SlotLogsHttpLogsAzureBlobStorageArgs) =
                args.RetentionInDays <- io retentionInDays
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sasUrl")>]
        member _.SasUrl((n, args), sasUrl) =
            let apply (args: SlotLogsHttpLogsAzureBlobStorageArgs) =
                args.SasUrl <- input sasUrl
                args

            ()
            n, List.Cons(apply, args)

        member _.SasUrl((n, args), sasUrl) =
            let apply (args: SlotLogsHttpLogsAzureBlobStorageArgs) =
                args.SasUrl <- io sasUrl
                args

            ()
            n, List.Cons(apply, args)

    let slotLogsHttpLogsAzureBlobStorage =
        SlotLogsHttpLogsAzureBlobStorageBuilder()

    type SlotLogsHttpLogsFileSystemBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SlotLogsHttpLogsFileSystemArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("retentionInDays")>]
        member _.RetentionInDays((n, args), retentionInDays) =
            let apply (args: SlotLogsHttpLogsFileSystemArgs) =
                args.RetentionInDays <- input retentionInDays
                args

            ()
            n, List.Cons(apply, args)

        member _.RetentionInDays((n, args), retentionInDays) =
            let apply (args: SlotLogsHttpLogsFileSystemArgs) =
                args.RetentionInDays <- io retentionInDays
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("retentionInMb")>]
        member _.RetentionInMb((n, args), retentionInMb) =
            let apply (args: SlotLogsHttpLogsFileSystemArgs) =
                args.RetentionInMb <- input retentionInMb
                args

            ()
            n, List.Cons(apply, args)

        member _.RetentionInMb((n, args), retentionInMb) =
            let apply (args: SlotLogsHttpLogsFileSystemArgs) =
                args.RetentionInMb <- io retentionInMb
                args

            ()
            n, List.Cons(apply, args)

    let slotLogsHttpLogsFileSystem = SlotLogsHttpLogsFileSystemBuilder()

    type SlotSiteConfigBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SlotSiteConfigArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("alwaysOn")>]
        member _.AlwaysOn((n, args), alwaysOn) =
            let apply (args: SlotSiteConfigArgs) =
                args.AlwaysOn <- input alwaysOn
                args

            ()
            n, List.Cons(apply, args)

        member _.AlwaysOn((n, args), alwaysOn) =
            let apply (args: SlotSiteConfigArgs) =
                args.AlwaysOn <- io alwaysOn
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("appCommandLine")>]
        member _.AppCommandLine((n, args), appCommandLine) =
            let apply (args: SlotSiteConfigArgs) =
                args.AppCommandLine <- input appCommandLine
                args

            ()
            n, List.Cons(apply, args)

        member _.AppCommandLine((n, args), appCommandLine) =
            let apply (args: SlotSiteConfigArgs) =
                args.AppCommandLine <- io appCommandLine
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("autoSwapSlotName")>]
        member _.AutoSwapSlotName((n, args), autoSwapSlotName) =
            let apply (args: SlotSiteConfigArgs) =
                args.AutoSwapSlotName <- input autoSwapSlotName
                args

            ()
            n, List.Cons(apply, args)

        member _.AutoSwapSlotName((n, args), autoSwapSlotName) =
            let apply (args: SlotSiteConfigArgs) =
                args.AutoSwapSlotName <- io autoSwapSlotName
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: SlotSiteConfigArgs) =
                   args.Cors <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("defaultDocuments")>]
        member _.DefaultDocuments((n, args), defaultDocuments) =
            let apply (args: SlotSiteConfigArgs) =
                args.DefaultDocuments <- inputList defaultDocuments
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("dotnetFrameworkVersion")>]
        member _.DotnetFrameworkVersion((n, args), dotnetFrameworkVersion) =
            let apply (args: SlotSiteConfigArgs) =
                args.DotnetFrameworkVersion <- input dotnetFrameworkVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.DotnetFrameworkVersion((n, args), dotnetFrameworkVersion) =
            let apply (args: SlotSiteConfigArgs) =
                args.DotnetFrameworkVersion <- io dotnetFrameworkVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ftpsState")>]
        member _.FtpsState((n, args), ftpsState) =
            let apply (args: SlotSiteConfigArgs) =
                args.FtpsState <- input ftpsState
                args

            ()
            n, List.Cons(apply, args)

        member _.FtpsState((n, args), ftpsState) =
            let apply (args: SlotSiteConfigArgs) =
                args.FtpsState <- io ftpsState
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("healthCheckPath")>]
        member _.HealthCheckPath((n, args), healthCheckPath) =
            let apply (args: SlotSiteConfigArgs) =
                args.HealthCheckPath <- input healthCheckPath
                args

            ()
            n, List.Cons(apply, args)

        member _.HealthCheckPath((n, args), healthCheckPath) =
            let apply (args: SlotSiteConfigArgs) =
                args.HealthCheckPath <- io healthCheckPath
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("http2Enabled")>]
        member _.Http2Enabled((n, args), http2Enabled) =
            let apply (args: SlotSiteConfigArgs) =
                args.Http2Enabled <- input http2Enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Http2Enabled((n, args), http2Enabled) =
            let apply (args: SlotSiteConfigArgs) =
                args.Http2Enabled <- io http2Enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ipRestrictions")>]
        member _.IpRestrictions((n, args), ipRestrictions) =
            let apply (args: SlotSiteConfigArgs) =
                args.IpRestrictions <- inputList ipRestrictions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("javaContainer")>]
        member _.JavaContainer((n, args), javaContainer) =
            let apply (args: SlotSiteConfigArgs) =
                args.JavaContainer <- input javaContainer
                args

            ()
            n, List.Cons(apply, args)

        member _.JavaContainer((n, args), javaContainer) =
            let apply (args: SlotSiteConfigArgs) =
                args.JavaContainer <- io javaContainer
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("javaContainerVersion")>]
        member _.JavaContainerVersion((n, args), javaContainerVersion) =
            let apply (args: SlotSiteConfigArgs) =
                args.JavaContainerVersion <- input javaContainerVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.JavaContainerVersion((n, args), javaContainerVersion) =
            let apply (args: SlotSiteConfigArgs) =
                args.JavaContainerVersion <- io javaContainerVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("javaVersion")>]
        member _.JavaVersion((n, args), javaVersion) =
            let apply (args: SlotSiteConfigArgs) =
                args.JavaVersion <- input javaVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.JavaVersion((n, args), javaVersion) =
            let apply (args: SlotSiteConfigArgs) =
                args.JavaVersion <- io javaVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("linuxFxVersion")>]
        member _.LinuxFxVersion((n, args), linuxFxVersion) =
            let apply (args: SlotSiteConfigArgs) =
                args.LinuxFxVersion <- input linuxFxVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.LinuxFxVersion((n, args), linuxFxVersion) =
            let apply (args: SlotSiteConfigArgs) =
                args.LinuxFxVersion <- io linuxFxVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("localMysqlEnabled")>]
        member _.LocalMysqlEnabled((n, args), localMysqlEnabled) =
            let apply (args: SlotSiteConfigArgs) =
                args.LocalMysqlEnabled <- input localMysqlEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.LocalMysqlEnabled((n, args), localMysqlEnabled) =
            let apply (args: SlotSiteConfigArgs) =
                args.LocalMysqlEnabled <- io localMysqlEnabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("managedPipelineMode")>]
        member _.ManagedPipelineMode((n, args), managedPipelineMode) =
            let apply (args: SlotSiteConfigArgs) =
                args.ManagedPipelineMode <- input managedPipelineMode
                args

            ()
            n, List.Cons(apply, args)

        member _.ManagedPipelineMode((n, args), managedPipelineMode) =
            let apply (args: SlotSiteConfigArgs) =
                args.ManagedPipelineMode <- io managedPipelineMode
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("minTlsVersion")>]
        member _.MinTlsVersion((n, args), minTlsVersion) =
            let apply (args: SlotSiteConfigArgs) =
                args.MinTlsVersion <- input minTlsVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.MinTlsVersion((n, args), minTlsVersion) =
            let apply (args: SlotSiteConfigArgs) =
                args.MinTlsVersion <- io minTlsVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("phpVersion")>]
        member _.PhpVersion((n, args), phpVersion) =
            let apply (args: SlotSiteConfigArgs) =
                args.PhpVersion <- input phpVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.PhpVersion((n, args), phpVersion) =
            let apply (args: SlotSiteConfigArgs) =
                args.PhpVersion <- io phpVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("pythonVersion")>]
        member _.PythonVersion((n, args), pythonVersion) =
            let apply (args: SlotSiteConfigArgs) =
                args.PythonVersion <- input pythonVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.PythonVersion((n, args), pythonVersion) =
            let apply (args: SlotSiteConfigArgs) =
                args.PythonVersion <- io pythonVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("remoteDebuggingEnabled")>]
        member _.RemoteDebuggingEnabled((n, args), remoteDebuggingEnabled) =
            let apply (args: SlotSiteConfigArgs) =
                args.RemoteDebuggingEnabled <- input remoteDebuggingEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.RemoteDebuggingEnabled((n, args), remoteDebuggingEnabled) =
            let apply (args: SlotSiteConfigArgs) =
                args.RemoteDebuggingEnabled <- io remoteDebuggingEnabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("remoteDebuggingVersion")>]
        member _.RemoteDebuggingVersion((n, args), remoteDebuggingVersion) =
            let apply (args: SlotSiteConfigArgs) =
                args.RemoteDebuggingVersion <- input remoteDebuggingVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.RemoteDebuggingVersion((n, args), remoteDebuggingVersion) =
            let apply (args: SlotSiteConfigArgs) =
                args.RemoteDebuggingVersion <- io remoteDebuggingVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("scmIpRestrictions")>]
        member _.ScmIpRestrictions((n, args), scmIpRestrictions) =
            let apply (args: SlotSiteConfigArgs) =
                args.ScmIpRestrictions <- inputList scmIpRestrictions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("scmType")>]
        member _.ScmType((n, args), scmType) =
            let apply (args: SlotSiteConfigArgs) =
                args.ScmType <- input scmType
                args

            ()
            n, List.Cons(apply, args)

        member _.ScmType((n, args), scmType) =
            let apply (args: SlotSiteConfigArgs) =
                args.ScmType <- io scmType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("scmUseMainIpRestriction")>]
        member _.ScmUseMainIpRestriction((n, args), scmUseMainIpRestriction) =
            let apply (args: SlotSiteConfigArgs) =
                args.ScmUseMainIpRestriction <- input scmUseMainIpRestriction
                args

            ()
            n, List.Cons(apply, args)

        member _.ScmUseMainIpRestriction((n, args), scmUseMainIpRestriction) =
            let apply (args: SlotSiteConfigArgs) =
                args.ScmUseMainIpRestriction <- io scmUseMainIpRestriction
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("use32BitWorkerProcess")>]
        member _.Use32BitWorkerProcess((n, args), use32BitWorkerProcess) =
            let apply (args: SlotSiteConfigArgs) =
                args.Use32BitWorkerProcess <- input use32BitWorkerProcess
                args

            ()
            n, List.Cons(apply, args)

        member _.Use32BitWorkerProcess((n, args), use32BitWorkerProcess) =
            let apply (args: SlotSiteConfigArgs) =
                args.Use32BitWorkerProcess <- io use32BitWorkerProcess
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("websocketsEnabled")>]
        member _.WebsocketsEnabled((n, args), websocketsEnabled) =
            let apply (args: SlotSiteConfigArgs) =
                args.WebsocketsEnabled <- input websocketsEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.WebsocketsEnabled((n, args), websocketsEnabled) =
            let apply (args: SlotSiteConfigArgs) =
                args.WebsocketsEnabled <- io websocketsEnabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("windowsFxVersion")>]
        member _.WindowsFxVersion((n, args), windowsFxVersion) =
            let apply (args: SlotSiteConfigArgs) =
                args.WindowsFxVersion <- input windowsFxVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.WindowsFxVersion((n, args), windowsFxVersion) =
            let apply (args: SlotSiteConfigArgs) =
                args.WindowsFxVersion <- io windowsFxVersion
                args

            ()
            n, List.Cons(apply, args)

    let slotSiteConfig = SlotSiteConfigBuilder()

    type SlotSiteConfigCorsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SlotSiteConfigCorsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("allowedOrigins")>]
        member _.AllowedOrigins((n, args), allowedOrigins) =
            let apply (args: SlotSiteConfigCorsArgs) =
                args.AllowedOrigins <- inputList allowedOrigins
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("supportCredentials")>]
        member _.SupportCredentials((n, args), supportCredentials) =
            let apply (args: SlotSiteConfigCorsArgs) =
                args.SupportCredentials <- input supportCredentials
                args

            ()
            n, List.Cons(apply, args)

        member _.SupportCredentials((n, args), supportCredentials) =
            let apply (args: SlotSiteConfigCorsArgs) =
                args.SupportCredentials <- io supportCredentials
                args

            ()
            n, List.Cons(apply, args)

    let slotSiteConfigCors = SlotSiteConfigCorsBuilder()

    type SlotSiteConfigIpRestrictionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SlotSiteConfigIpRestrictionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("action")>]
        member _.Action((n, args), action) =
            let apply (args: SlotSiteConfigIpRestrictionArgs) =
                args.Action <- input action
                args

            ()
            n, List.Cons(apply, args)

        member _.Action((n, args), action) =
            let apply (args: SlotSiteConfigIpRestrictionArgs) =
                args.Action <- io action
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ipAddress")>]
        member _.IpAddress((n, args), ipAddress) =
            let apply (args: SlotSiteConfigIpRestrictionArgs) =
                args.IpAddress <- input ipAddress
                args

            ()
            n, List.Cons(apply, args)

        member _.IpAddress((n, args), ipAddress) =
            let apply (args: SlotSiteConfigIpRestrictionArgs) =
                args.IpAddress <- io ipAddress
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: SlotSiteConfigIpRestrictionArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: SlotSiteConfigIpRestrictionArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("priority")>]
        member _.Priority((n, args), priority) =
            let apply (args: SlotSiteConfigIpRestrictionArgs) =
                args.Priority <- input priority
                args

            ()
            n, List.Cons(apply, args)

        member _.Priority((n, args), priority) =
            let apply (args: SlotSiteConfigIpRestrictionArgs) =
                args.Priority <- io priority
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkSubnetId")>]
        member _.VirtualNetworkSubnetId((n, args), virtualNetworkSubnetId) =
            let apply (args: SlotSiteConfigIpRestrictionArgs) =
                args.VirtualNetworkSubnetId <- input virtualNetworkSubnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.VirtualNetworkSubnetId((n, args), virtualNetworkSubnetId) =
            let apply (args: SlotSiteConfigIpRestrictionArgs) =
                args.VirtualNetworkSubnetId <- io virtualNetworkSubnetId
                args

            ()
            n, List.Cons(apply, args)

    let slotSiteConfigIpRestriction = SlotSiteConfigIpRestrictionBuilder()

    type SlotSiteConfigScmIpRestrictionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SlotSiteConfigScmIpRestrictionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("action")>]
        member _.Action((n, args), action) =
            let apply (args: SlotSiteConfigScmIpRestrictionArgs) =
                args.Action <- input action
                args

            ()
            n, List.Cons(apply, args)

        member _.Action((n, args), action) =
            let apply (args: SlotSiteConfigScmIpRestrictionArgs) =
                args.Action <- io action
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ipAddress")>]
        member _.IpAddress((n, args), ipAddress) =
            let apply (args: SlotSiteConfigScmIpRestrictionArgs) =
                args.IpAddress <- input ipAddress
                args

            ()
            n, List.Cons(apply, args)

        member _.IpAddress((n, args), ipAddress) =
            let apply (args: SlotSiteConfigScmIpRestrictionArgs) =
                args.IpAddress <- io ipAddress
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: SlotSiteConfigScmIpRestrictionArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: SlotSiteConfigScmIpRestrictionArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("priority")>]
        member _.Priority((n, args), priority) =
            let apply (args: SlotSiteConfigScmIpRestrictionArgs) =
                args.Priority <- input priority
                args

            ()
            n, List.Cons(apply, args)

        member _.Priority((n, args), priority) =
            let apply (args: SlotSiteConfigScmIpRestrictionArgs) =
                args.Priority <- io priority
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkSubnetId")>]
        member _.VirtualNetworkSubnetId((n, args), virtualNetworkSubnetId) =
            let apply (args: SlotSiteConfigScmIpRestrictionArgs) =
                args.VirtualNetworkSubnetId <- input virtualNetworkSubnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.VirtualNetworkSubnetId((n, args), virtualNetworkSubnetId) =
            let apply (args: SlotSiteConfigScmIpRestrictionArgs) =
                args.VirtualNetworkSubnetId <- io virtualNetworkSubnetId
                args

            ()
            n, List.Cons(apply, args)

    let slotSiteConfigScmIpRestriction = SlotSiteConfigScmIpRestrictionBuilder()

    type SlotSiteCredentialBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SlotSiteCredentialArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: SlotSiteCredentialArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: SlotSiteCredentialArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: SlotSiteCredentialArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: SlotSiteCredentialArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

    let slotSiteCredential = SlotSiteCredentialBuilder()

    type ActiveSlotBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ActiveSlot(name, (List.fold func (ActiveSlotArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("appServiceName")>]
        member _.AppServiceName((name, args), appServiceName) =
            let apply (args: ActiveSlotArgs) =
                args.AppServiceName <- input appServiceName
                args

            ()
            name, List.Cons(apply, args)

        member _.AppServiceName((name, args), appServiceName) =
            let apply (args: ActiveSlotArgs) =
                args.AppServiceName <- io appServiceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("appServiceSlotName")>]
        member _.AppServiceSlotName((name, args), appServiceSlotName) =
            let apply (args: ActiveSlotArgs) =
                args.AppServiceSlotName <- input appServiceSlotName
                args

            ()
            name, List.Cons(apply, args)

        member _.AppServiceSlotName((name, args), appServiceSlotName) =
            let apply (args: ActiveSlotArgs) =
                args.AppServiceSlotName <- io appServiceSlotName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ActiveSlotArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ActiveSlotArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let activeSlot = ActiveSlotBuilder()

    type AppServiceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            AppService(name, (List.fold func (AppServiceArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("appServicePlanId")>]
        member _.AppServicePlanId((name, args), appServicePlanId) =
            let apply (args: AppServiceArgs) =
                args.AppServicePlanId <- input appServicePlanId
                args

            ()
            name, List.Cons(apply, args)

        member _.AppServicePlanId((name, args), appServicePlanId) =
            let apply (args: AppServiceArgs) =
                args.AppServicePlanId <- io appServicePlanId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("appSettings")>]
        member _.AppSettings((name, args), appSettings) =
            let apply (args: AppServiceArgs) =
                args.AppSettings <- inputMap appSettings
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: AppServiceArgs) =
                   args.AuthSettings <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: AppServiceArgs) =
                   args.Backup <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("clientAffinityEnabled")>]
        member _.ClientAffinityEnabled((name, args), clientAffinityEnabled) =
            let apply (args: AppServiceArgs) =
                args.ClientAffinityEnabled <- input clientAffinityEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.ClientAffinityEnabled((name, args), clientAffinityEnabled) =
            let apply (args: AppServiceArgs) =
                args.ClientAffinityEnabled <- io clientAffinityEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("clientCertEnabled")>]
        member _.ClientCertEnabled((name, args), clientCertEnabled) =
            let apply (args: AppServiceArgs) =
                args.ClientCertEnabled <- input clientCertEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.ClientCertEnabled((name, args), clientCertEnabled) =
            let apply (args: AppServiceArgs) =
                args.ClientCertEnabled <- io clientCertEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("connectionStrings")>]
        member _.ConnectionStrings((name, args), connectionStrings) =
            let apply (args: AppServiceArgs) =
                args.ConnectionStrings <- inputList connectionStrings
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((name, args), enabled) =
            let apply (args: AppServiceArgs) =
                args.Enabled <- input enabled
                args

            ()
            name, List.Cons(apply, args)

        member _.Enabled((name, args), enabled) =
            let apply (args: AppServiceArgs) =
                args.Enabled <- io enabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("httpsOnly")>]
        member _.HttpsOnly((name, args), httpsOnly) =
            let apply (args: AppServiceArgs) =
                args.HttpsOnly <- input httpsOnly
                args

            ()
            name, List.Cons(apply, args)

        member _.HttpsOnly((name, args), httpsOnly) =
            let apply (args: AppServiceArgs) =
                args.HttpsOnly <- io httpsOnly
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: AppServiceArgs) =
                   args.Identity <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: AppServiceArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: AppServiceArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: AppServiceArgs) =
                   args.Logs <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: AppServiceArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: AppServiceArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AppServiceArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AppServiceArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: AppServiceArgs) =
                   args.SiteConfig <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("storageAccounts")>]
        member _.StorageAccounts((name, args), storageAccounts) =
            let apply (args: AppServiceArgs) =
                args.StorageAccounts <- inputList storageAccounts
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: AppServiceArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let appService = AppServiceBuilder()

    type CertificateBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Certificate(name, (List.fold func (CertificateArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("hostingEnvironmentProfileId")>]
        member _.HostingEnvironmentProfileId((name, args), hostingEnvironmentProfileId) =
            let apply (args: CertificateArgs) =
                args.HostingEnvironmentProfileId <- input hostingEnvironmentProfileId
                args

            ()
            name, List.Cons(apply, args)

        member _.HostingEnvironmentProfileId((name, args), hostingEnvironmentProfileId) =
            let apply (args: CertificateArgs) =
                args.HostingEnvironmentProfileId <- io hostingEnvironmentProfileId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("keyVaultSecretId")>]
        member _.KeyVaultSecretId((name, args), keyVaultSecretId) =
            let apply (args: CertificateArgs) =
                args.KeyVaultSecretId <- input keyVaultSecretId
                args

            ()
            name, List.Cons(apply, args)

        member _.KeyVaultSecretId((name, args), keyVaultSecretId) =
            let apply (args: CertificateArgs) =
                args.KeyVaultSecretId <- io keyVaultSecretId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: CertificateArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: CertificateArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: CertificateArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: CertificateArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("password")>]
        member _.Password((name, args), password) =
            let apply (args: CertificateArgs) =
                args.Password <- input password
                args

            ()
            name, List.Cons(apply, args)

        member _.Password((name, args), password) =
            let apply (args: CertificateArgs) =
                args.Password <- io password
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("pfxBlob")>]
        member _.PfxBlob((name, args), pfxBlob) =
            let apply (args: CertificateArgs) =
                args.PfxBlob <- input pfxBlob
                args

            ()
            name, List.Cons(apply, args)

        member _.PfxBlob((name, args), pfxBlob) =
            let apply (args: CertificateArgs) =
                args.PfxBlob <- io pfxBlob
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: CertificateArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: CertificateArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: CertificateArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let certificate = CertificateBuilder()

    type CertificateOrderBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            CertificateOrder(name, (List.fold func (CertificateOrderArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("autoRenew")>]
        member _.AutoRenew((name, args), autoRenew) =
            let apply (args: CertificateOrderArgs) =
                args.AutoRenew <- input autoRenew
                args

            ()
            name, List.Cons(apply, args)

        member _.AutoRenew((name, args), autoRenew) =
            let apply (args: CertificateOrderArgs) =
                args.AutoRenew <- io autoRenew
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("csr")>]
        member _.Csr((name, args), csr) =
            let apply (args: CertificateOrderArgs) =
                args.Csr <- input csr
                args

            ()
            name, List.Cons(apply, args)

        member _.Csr((name, args), csr) =
            let apply (args: CertificateOrderArgs) =
                args.Csr <- io csr
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("distinguishedName")>]
        member _.DistinguishedName((name, args), distinguishedName) =
            let apply (args: CertificateOrderArgs) =
                args.DistinguishedName <- input distinguishedName
                args

            ()
            name, List.Cons(apply, args)

        member _.DistinguishedName((name, args), distinguishedName) =
            let apply (args: CertificateOrderArgs) =
                args.DistinguishedName <- io distinguishedName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("keySize")>]
        member _.KeySize((name, args), keySize) =
            let apply (args: CertificateOrderArgs) =
                args.KeySize <- input keySize
                args

            ()
            name, List.Cons(apply, args)

        member _.KeySize((name, args), keySize) =
            let apply (args: CertificateOrderArgs) =
                args.KeySize <- io keySize
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: CertificateOrderArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: CertificateOrderArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: CertificateOrderArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: CertificateOrderArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("productType")>]
        member _.ProductType((name, args), productType) =
            let apply (args: CertificateOrderArgs) =
                args.ProductType <- input productType
                args

            ()
            name, List.Cons(apply, args)

        member _.ProductType((name, args), productType) =
            let apply (args: CertificateOrderArgs) =
                args.ProductType <- io productType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: CertificateOrderArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: CertificateOrderArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: CertificateOrderArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("validityInYears")>]
        member _.ValidityInYears((name, args), validityInYears) =
            let apply (args: CertificateOrderArgs) =
                args.ValidityInYears <- input validityInYears
                args

            ()
            name, List.Cons(apply, args)

        member _.ValidityInYears((name, args), validityInYears) =
            let apply (args: CertificateOrderArgs) =
                args.ValidityInYears <- io validityInYears
                args

            ()
            name, List.Cons(apply, args)

    let certificateOrder = CertificateOrderBuilder()

    type CustomHostnameBindingBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            CustomHostnameBinding(name, (List.fold func (CustomHostnameBindingArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("appServiceName")>]
        member _.AppServiceName((name, args), appServiceName) =
            let apply (args: CustomHostnameBindingArgs) =
                args.AppServiceName <- input appServiceName
                args

            ()
            name, List.Cons(apply, args)

        member _.AppServiceName((name, args), appServiceName) =
            let apply (args: CustomHostnameBindingArgs) =
                args.AppServiceName <- io appServiceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("hostname")>]
        member _.Hostname((name, args), hostname) =
            let apply (args: CustomHostnameBindingArgs) =
                args.Hostname <- input hostname
                args

            ()
            name, List.Cons(apply, args)

        member _.Hostname((name, args), hostname) =
            let apply (args: CustomHostnameBindingArgs) =
                args.Hostname <- io hostname
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: CustomHostnameBindingArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: CustomHostnameBindingArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sslState")>]
        member _.SslState((name, args), sslState) =
            let apply (args: CustomHostnameBindingArgs) =
                args.SslState <- input sslState
                args

            ()
            name, List.Cons(apply, args)

        member _.SslState((name, args), sslState) =
            let apply (args: CustomHostnameBindingArgs) =
                args.SslState <- io sslState
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("thumbprint")>]
        member _.Thumbprint((name, args), thumbprint) =
            let apply (args: CustomHostnameBindingArgs) =
                args.Thumbprint <- input thumbprint
                args

            ()
            name, List.Cons(apply, args)

        member _.Thumbprint((name, args), thumbprint) =
            let apply (args: CustomHostnameBindingArgs) =
                args.Thumbprint <- io thumbprint
                args

            ()
            name, List.Cons(apply, args)

    let customHostnameBinding = CustomHostnameBindingBuilder()

    type EnvironmentBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Environment(name, (List.fold func (EnvironmentArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("frontEndScaleFactor")>]
        member _.FrontEndScaleFactor((name, args), frontEndScaleFactor) =
            let apply (args: EnvironmentArgs) =
                args.FrontEndScaleFactor <- input frontEndScaleFactor
                args

            ()
            name, List.Cons(apply, args)

        member _.FrontEndScaleFactor((name, args), frontEndScaleFactor) =
            let apply (args: EnvironmentArgs) =
                args.FrontEndScaleFactor <- io frontEndScaleFactor
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("internalLoadBalancingMode")>]
        member _.InternalLoadBalancingMode((name, args), internalLoadBalancingMode) =
            let apply (args: EnvironmentArgs) =
                args.InternalLoadBalancingMode <- input internalLoadBalancingMode
                args

            ()
            name, List.Cons(apply, args)

        member _.InternalLoadBalancingMode((name, args), internalLoadBalancingMode) =
            let apply (args: EnvironmentArgs) =
                args.InternalLoadBalancingMode <- io internalLoadBalancingMode
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: EnvironmentArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: EnvironmentArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("pricingTier")>]
        member _.PricingTier((name, args), pricingTier) =
            let apply (args: EnvironmentArgs) =
                args.PricingTier <- input pricingTier
                args

            ()
            name, List.Cons(apply, args)

        member _.PricingTier((name, args), pricingTier) =
            let apply (args: EnvironmentArgs) =
                args.PricingTier <- io pricingTier
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: EnvironmentArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: EnvironmentArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((name, args), subnetId) =
            let apply (args: EnvironmentArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            name, List.Cons(apply, args)

        member _.SubnetId((name, args), subnetId) =
            let apply (args: EnvironmentArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: EnvironmentArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("userWhitelistedIpRanges")>]
        member _.UserWhitelistedIpRanges((name, args), userWhitelistedIpRanges) =
            let apply (args: EnvironmentArgs) =
                args.UserWhitelistedIpRanges <- inputList userWhitelistedIpRanges
                args

            ()
            name, List.Cons(apply, args)

    let environment = EnvironmentBuilder()

    type FunctionAppBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            FunctionApp(name, (List.fold func (FunctionAppArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("appServicePlanId")>]
        member _.AppServicePlanId((name, args), appServicePlanId) =
            let apply (args: FunctionAppArgs) =
                args.AppServicePlanId <- input appServicePlanId
                args

            ()
            name, List.Cons(apply, args)

        member _.AppServicePlanId((name, args), appServicePlanId) =
            let apply (args: FunctionAppArgs) =
                args.AppServicePlanId <- io appServicePlanId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("appSettings")>]
        member _.AppSettings((name, args), appSettings) =
            let apply (args: FunctionAppArgs) =
                args.AppSettings <- inputMap appSettings
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: FunctionAppArgs) =
                   args.AuthSettings <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("clientAffinityEnabled")>]
        member _.ClientAffinityEnabled((name, args), clientAffinityEnabled) =
            let apply (args: FunctionAppArgs) =
                args.ClientAffinityEnabled <- input clientAffinityEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.ClientAffinityEnabled((name, args), clientAffinityEnabled) =
            let apply (args: FunctionAppArgs) =
                args.ClientAffinityEnabled <- io clientAffinityEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("connectionStrings")>]
        member _.ConnectionStrings((name, args), connectionStrings) =
            let apply (args: FunctionAppArgs) =
                args.ConnectionStrings <- inputList connectionStrings
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("dailyMemoryTimeQuota")>]
        member _.DailyMemoryTimeQuota((name, args), dailyMemoryTimeQuota) =
            let apply (args: FunctionAppArgs) =
                args.DailyMemoryTimeQuota <- input dailyMemoryTimeQuota
                args

            ()
            name, List.Cons(apply, args)

        member _.DailyMemoryTimeQuota((name, args), dailyMemoryTimeQuota) =
            let apply (args: FunctionAppArgs) =
                args.DailyMemoryTimeQuota <- io dailyMemoryTimeQuota
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enableBuiltinLogging")>]
        member _.EnableBuiltinLogging((name, args), enableBuiltinLogging) =
            let apply (args: FunctionAppArgs) =
                args.EnableBuiltinLogging <- input enableBuiltinLogging
                args

            ()
            name, List.Cons(apply, args)

        member _.EnableBuiltinLogging((name, args), enableBuiltinLogging) =
            let apply (args: FunctionAppArgs) =
                args.EnableBuiltinLogging <- io enableBuiltinLogging
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((name, args), enabled) =
            let apply (args: FunctionAppArgs) =
                args.Enabled <- input enabled
                args

            ()
            name, List.Cons(apply, args)

        member _.Enabled((name, args), enabled) =
            let apply (args: FunctionAppArgs) =
                args.Enabled <- io enabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("httpsOnly")>]
        member _.HttpsOnly((name, args), httpsOnly) =
            let apply (args: FunctionAppArgs) =
                args.HttpsOnly <- input httpsOnly
                args

            ()
            name, List.Cons(apply, args)

        member _.HttpsOnly((name, args), httpsOnly) =
            let apply (args: FunctionAppArgs) =
                args.HttpsOnly <- io httpsOnly
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: FunctionAppArgs) =
                   args.Identity <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: FunctionAppArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: FunctionAppArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: FunctionAppArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: FunctionAppArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("osType")>]
        member _.OsType((name, args), osType) =
            let apply (args: FunctionAppArgs) =
                args.OsType <- input osType
                args

            ()
            name, List.Cons(apply, args)

        member _.OsType((name, args), osType) =
            let apply (args: FunctionAppArgs) =
                args.OsType <- io osType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FunctionAppArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FunctionAppArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: FunctionAppArgs) =
                   args.SiteConfig <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("storageAccountAccessKey")>]
        member _.StorageAccountAccessKey((name, args), storageAccountAccessKey) =
            let apply (args: FunctionAppArgs) =
                args.StorageAccountAccessKey <- input storageAccountAccessKey
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageAccountAccessKey((name, args), storageAccountAccessKey) =
            let apply (args: FunctionAppArgs) =
                args.StorageAccountAccessKey <- io storageAccountAccessKey
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageAccountName")>]
        member _.StorageAccountName((name, args), storageAccountName) =
            let apply (args: FunctionAppArgs) =
                args.StorageAccountName <- input storageAccountName
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageAccountName((name, args), storageAccountName) =
            let apply (args: FunctionAppArgs) =
                args.StorageAccountName <- io storageAccountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageConnectionString")>]
        member _.StorageConnectionString((name, args), storageConnectionString) =
            let apply (args: FunctionAppArgs) =
                args.StorageConnectionString <- input storageConnectionString
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageConnectionString((name, args), storageConnectionString) =
            let apply (args: FunctionAppArgs) =
                args.StorageConnectionString <- io storageConnectionString
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: FunctionAppArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("version")>]
        member _.Version((name, args), version) =
            let apply (args: FunctionAppArgs) =
                args.Version <- input version
                args

            ()
            name, List.Cons(apply, args)

        member _.Version((name, args), version) =
            let apply (args: FunctionAppArgs) =
                args.Version <- io version
                args

            ()
            name, List.Cons(apply, args)

    let functionApp = FunctionAppBuilder()

    type FunctionAppSlotBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            FunctionAppSlot(name, (List.fold func (FunctionAppSlotArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("appServicePlanId")>]
        member _.AppServicePlanId((name, args), appServicePlanId) =
            let apply (args: FunctionAppSlotArgs) =
                args.AppServicePlanId <- input appServicePlanId
                args

            ()
            name, List.Cons(apply, args)

        member _.AppServicePlanId((name, args), appServicePlanId) =
            let apply (args: FunctionAppSlotArgs) =
                args.AppServicePlanId <- io appServicePlanId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("appSettings")>]
        member _.AppSettings((name, args), appSettings) =
            let apply (args: FunctionAppSlotArgs) =
                args.AppSettings <- inputMap appSettings
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: FunctionAppSlotArgs) =
                   args.AuthSettings <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("clientAffinityEnabled")>]
        member _.ClientAffinityEnabled((name, args), clientAffinityEnabled) =
            let apply (args: FunctionAppSlotArgs) =
                args.ClientAffinityEnabled <- input clientAffinityEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.ClientAffinityEnabled((name, args), clientAffinityEnabled) =
            let apply (args: FunctionAppSlotArgs) =
                args.ClientAffinityEnabled <- io clientAffinityEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("connectionStrings")>]
        member _.ConnectionStrings((name, args), connectionStrings) =
            let apply (args: FunctionAppSlotArgs) =
                args.ConnectionStrings <- inputList connectionStrings
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("dailyMemoryTimeQuota")>]
        member _.DailyMemoryTimeQuota((name, args), dailyMemoryTimeQuota) =
            let apply (args: FunctionAppSlotArgs) =
                args.DailyMemoryTimeQuota <- input dailyMemoryTimeQuota
                args

            ()
            name, List.Cons(apply, args)

        member _.DailyMemoryTimeQuota((name, args), dailyMemoryTimeQuota) =
            let apply (args: FunctionAppSlotArgs) =
                args.DailyMemoryTimeQuota <- io dailyMemoryTimeQuota
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enableBuiltinLogging")>]
        member _.EnableBuiltinLogging((name, args), enableBuiltinLogging) =
            let apply (args: FunctionAppSlotArgs) =
                args.EnableBuiltinLogging <- input enableBuiltinLogging
                args

            ()
            name, List.Cons(apply, args)

        member _.EnableBuiltinLogging((name, args), enableBuiltinLogging) =
            let apply (args: FunctionAppSlotArgs) =
                args.EnableBuiltinLogging <- io enableBuiltinLogging
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((name, args), enabled) =
            let apply (args: FunctionAppSlotArgs) =
                args.Enabled <- input enabled
                args

            ()
            name, List.Cons(apply, args)

        member _.Enabled((name, args), enabled) =
            let apply (args: FunctionAppSlotArgs) =
                args.Enabled <- io enabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("functionAppName")>]
        member _.FunctionAppName((name, args), functionAppName) =
            let apply (args: FunctionAppSlotArgs) =
                args.FunctionAppName <- input functionAppName
                args

            ()
            name, List.Cons(apply, args)

        member _.FunctionAppName((name, args), functionAppName) =
            let apply (args: FunctionAppSlotArgs) =
                args.FunctionAppName <- io functionAppName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("httpsOnly")>]
        member _.HttpsOnly((name, args), httpsOnly) =
            let apply (args: FunctionAppSlotArgs) =
                args.HttpsOnly <- input httpsOnly
                args

            ()
            name, List.Cons(apply, args)

        member _.HttpsOnly((name, args), httpsOnly) =
            let apply (args: FunctionAppSlotArgs) =
                args.HttpsOnly <- io httpsOnly
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: FunctionAppSlotArgs) =
                   args.Identity <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: FunctionAppSlotArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: FunctionAppSlotArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: FunctionAppSlotArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: FunctionAppSlotArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("osType")>]
        member _.OsType((name, args), osType) =
            let apply (args: FunctionAppSlotArgs) =
                args.OsType <- input osType
                args

            ()
            name, List.Cons(apply, args)

        member _.OsType((name, args), osType) =
            let apply (args: FunctionAppSlotArgs) =
                args.OsType <- io osType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FunctionAppSlotArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FunctionAppSlotArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: FunctionAppSlotArgs) =
                   args.SiteConfig <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("storageAccountAccessKey")>]
        member _.StorageAccountAccessKey((name, args), storageAccountAccessKey) =
            let apply (args: FunctionAppSlotArgs) =
                args.StorageAccountAccessKey <- input storageAccountAccessKey
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageAccountAccessKey((name, args), storageAccountAccessKey) =
            let apply (args: FunctionAppSlotArgs) =
                args.StorageAccountAccessKey <- io storageAccountAccessKey
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageAccountName")>]
        member _.StorageAccountName((name, args), storageAccountName) =
            let apply (args: FunctionAppSlotArgs) =
                args.StorageAccountName <- input storageAccountName
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageAccountName((name, args), storageAccountName) =
            let apply (args: FunctionAppSlotArgs) =
                args.StorageAccountName <- io storageAccountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: FunctionAppSlotArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("version")>]
        member _.Version((name, args), version) =
            let apply (args: FunctionAppSlotArgs) =
                args.Version <- input version
                args

            ()
            name, List.Cons(apply, args)

        member _.Version((name, args), version) =
            let apply (args: FunctionAppSlotArgs) =
                args.Version <- io version
                args

            ()
            name, List.Cons(apply, args)

    let functionAppSlot = FunctionAppSlotBuilder()

    type HybridConnectionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            HybridConnection(name, (List.fold func (HybridConnectionArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("appServiceName")>]
        member _.AppServiceName((name, args), appServiceName) =
            let apply (args: HybridConnectionArgs) =
                args.AppServiceName <- input appServiceName
                args

            ()
            name, List.Cons(apply, args)

        member _.AppServiceName((name, args), appServiceName) =
            let apply (args: HybridConnectionArgs) =
                args.AppServiceName <- io appServiceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("hostname")>]
        member _.Hostname((name, args), hostname) =
            let apply (args: HybridConnectionArgs) =
                args.Hostname <- input hostname
                args

            ()
            name, List.Cons(apply, args)

        member _.Hostname((name, args), hostname) =
            let apply (args: HybridConnectionArgs) =
                args.Hostname <- io hostname
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("port")>]
        member _.Port((name, args), port) =
            let apply (args: HybridConnectionArgs) =
                args.Port <- input port
                args

            ()
            name, List.Cons(apply, args)

        member _.Port((name, args), port) =
            let apply (args: HybridConnectionArgs) =
                args.Port <- io port
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("relayId")>]
        member _.RelayId((name, args), relayId) =
            let apply (args: HybridConnectionArgs) =
                args.RelayId <- input relayId
                args

            ()
            name, List.Cons(apply, args)

        member _.RelayId((name, args), relayId) =
            let apply (args: HybridConnectionArgs) =
                args.RelayId <- io relayId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: HybridConnectionArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: HybridConnectionArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sendKeyName")>]
        member _.SendKeyName((name, args), sendKeyName) =
            let apply (args: HybridConnectionArgs) =
                args.SendKeyName <- input sendKeyName
                args

            ()
            name, List.Cons(apply, args)

        member _.SendKeyName((name, args), sendKeyName) =
            let apply (args: HybridConnectionArgs) =
                args.SendKeyName <- io sendKeyName
                args

            ()
            name, List.Cons(apply, args)

    let hybridConnection = HybridConnectionBuilder()

    type PlanBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Plan(name, (List.fold func (PlanArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("appServiceEnvironmentId")>]
        member _.AppServiceEnvironmentId((name, args), appServiceEnvironmentId) =
            let apply (args: PlanArgs) =
                args.AppServiceEnvironmentId <- input appServiceEnvironmentId
                args

            ()
            name, List.Cons(apply, args)

        member _.AppServiceEnvironmentId((name, args), appServiceEnvironmentId) =
            let apply (args: PlanArgs) =
                args.AppServiceEnvironmentId <- io appServiceEnvironmentId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("isXenon")>]
        member _.IsXenon((name, args), isXenon) =
            let apply (args: PlanArgs) =
                args.IsXenon <- input isXenon
                args

            ()
            name, List.Cons(apply, args)

        member _.IsXenon((name, args), isXenon) =
            let apply (args: PlanArgs) =
                args.IsXenon <- io isXenon
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("kind")>]
        member _.Kind((name, args), kind) =
            let apply (args: PlanArgs) =
                args.Kind <- input kind
                args

            ()
            name, List.Cons(apply, args)

        member _.Kind((name, args), kind) =
            let apply (args: PlanArgs) =
                args.Kind <- io kind
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: PlanArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: PlanArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("maximumElasticWorkerCount")>]
        member _.MaximumElasticWorkerCount((name, args), maximumElasticWorkerCount) =
            let apply (args: PlanArgs) =
                args.MaximumElasticWorkerCount <- input maximumElasticWorkerCount
                args

            ()
            name, List.Cons(apply, args)

        member _.MaximumElasticWorkerCount((name, args), maximumElasticWorkerCount) =
            let apply (args: PlanArgs) =
                args.MaximumElasticWorkerCount <- io maximumElasticWorkerCount
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: PlanArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: PlanArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("perSiteScaling")>]
        member _.PerSiteScaling((name, args), perSiteScaling) =
            let apply (args: PlanArgs) =
                args.PerSiteScaling <- input perSiteScaling
                args

            ()
            name, List.Cons(apply, args)

        member _.PerSiteScaling((name, args), perSiteScaling) =
            let apply (args: PlanArgs) =
                args.PerSiteScaling <- io perSiteScaling
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("reserved")>]
        member _.Reserved((name, args), reserved) =
            let apply (args: PlanArgs) =
                args.Reserved <- input reserved
                args

            ()
            name, List.Cons(apply, args)

        member _.Reserved((name, args), reserved) =
            let apply (args: PlanArgs) =
                args.Reserved <- io reserved
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: PlanArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: PlanArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: PlanArgs) =
                   args.Sku <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: PlanArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let plan = PlanBuilder()

    type SlotBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Slot(name, (List.fold func (SlotArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("appServiceName")>]
        member _.AppServiceName((name, args), appServiceName) =
            let apply (args: SlotArgs) =
                args.AppServiceName <- input appServiceName
                args

            ()
            name, List.Cons(apply, args)

        member _.AppServiceName((name, args), appServiceName) =
            let apply (args: SlotArgs) =
                args.AppServiceName <- io appServiceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("appServicePlanId")>]
        member _.AppServicePlanId((name, args), appServicePlanId) =
            let apply (args: SlotArgs) =
                args.AppServicePlanId <- input appServicePlanId
                args

            ()
            name, List.Cons(apply, args)

        member _.AppServicePlanId((name, args), appServicePlanId) =
            let apply (args: SlotArgs) =
                args.AppServicePlanId <- io appServicePlanId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("appSettings")>]
        member _.AppSettings((name, args), appSettings) =
            let apply (args: SlotArgs) =
                args.AppSettings <- inputMap appSettings
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: SlotArgs) =
                   args.AuthSettings <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("clientAffinityEnabled")>]
        member _.ClientAffinityEnabled((name, args), clientAffinityEnabled) =
            let apply (args: SlotArgs) =
                args.ClientAffinityEnabled <- input clientAffinityEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.ClientAffinityEnabled((name, args), clientAffinityEnabled) =
            let apply (args: SlotArgs) =
                args.ClientAffinityEnabled <- io clientAffinityEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("connectionStrings")>]
        member _.ConnectionStrings((name, args), connectionStrings) =
            let apply (args: SlotArgs) =
                args.ConnectionStrings <- inputList connectionStrings
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((name, args), enabled) =
            let apply (args: SlotArgs) =
                args.Enabled <- input enabled
                args

            ()
            name, List.Cons(apply, args)

        member _.Enabled((name, args), enabled) =
            let apply (args: SlotArgs) =
                args.Enabled <- io enabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("httpsOnly")>]
        member _.HttpsOnly((name, args), httpsOnly) =
            let apply (args: SlotArgs) =
                args.HttpsOnly <- input httpsOnly
                args

            ()
            name, List.Cons(apply, args)

        member _.HttpsOnly((name, args), httpsOnly) =
            let apply (args: SlotArgs) =
                args.HttpsOnly <- io httpsOnly
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: SlotArgs) =
                   args.Identity <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: SlotArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: SlotArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: SlotArgs) =
                   args.Logs <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: SlotArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: SlotArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SlotArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SlotArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: SlotArgs) =
                   args.SiteConfig <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: SlotArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let slot = SlotBuilder()

    type SourceCodeTokenBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            SourceCodeToken(name, (List.fold func (SourceCodeTokenArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("token")>]
        member _.Token((name, args), token) =
            let apply (args: SourceCodeTokenArgs) =
                args.Token <- input token
                args

            ()
            name, List.Cons(apply, args)

        member _.Token((name, args), token) =
            let apply (args: SourceCodeTokenArgs) =
                args.Token <- io token
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tokenSecret")>]
        member _.TokenSecret((name, args), tokenSecret) =
            let apply (args: SourceCodeTokenArgs) =
                args.TokenSecret <- input tokenSecret
                args

            ()
            name, List.Cons(apply, args)

        member _.TokenSecret((name, args), tokenSecret) =
            let apply (args: SourceCodeTokenArgs) =
                args.TokenSecret <- io tokenSecret
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((name, args), ``type``) =
            let apply (args: SourceCodeTokenArgs) =
                args.Type <- input ``type``
                args

            ()
            name, List.Cons(apply, args)

        member _.Type((name, args), ``type``) =
            let apply (args: SourceCodeTokenArgs) =
                args.Type <- io ``type``
                args

            ()
            name, List.Cons(apply, args)

    let sourceCodeToken = SourceCodeTokenBuilder()

    type VirtualNetworkSwiftConnectionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            VirtualNetworkSwiftConnection(name, (List.fold func (VirtualNetworkSwiftConnectionArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("appServiceId")>]
        member _.AppServiceId((name, args), appServiceId) =
            let apply (args: VirtualNetworkSwiftConnectionArgs) =
                args.AppServiceId <- input appServiceId
                args

            ()
            name, List.Cons(apply, args)

        member _.AppServiceId((name, args), appServiceId) =
            let apply (args: VirtualNetworkSwiftConnectionArgs) =
                args.AppServiceId <- io appServiceId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((name, args), subnetId) =
            let apply (args: VirtualNetworkSwiftConnectionArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            name, List.Cons(apply, args)

        member _.SubnetId((name, args), subnetId) =
            let apply (args: VirtualNetworkSwiftConnectionArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            name, List.Cons(apply, args)

    let virtualNetworkSwiftConnection = VirtualNetworkSwiftConnectionBuilder()

module Authorization =
    open Pulumi.Azure.Authorization
    open Pulumi.Azure.Authorization.Inputs

    type RoleDefinitionPermissionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (RoleDefinitionPermissionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("actions")>]
        member _.Actions((n, args), actions) =
            let apply (args: RoleDefinitionPermissionArgs) =
                args.Actions <- inputList actions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("dataActions")>]
        member _.DataActions((n, args), dataActions) =
            let apply (args: RoleDefinitionPermissionArgs) =
                args.DataActions <- inputList dataActions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("notActions")>]
        member _.NotActions((n, args), notActions) =
            let apply (args: RoleDefinitionPermissionArgs) =
                args.NotActions <- inputList notActions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("notDataActions")>]
        member _.NotDataActions((n, args), notDataActions) =
            let apply (args: RoleDefinitionPermissionArgs) =
                args.NotDataActions <- inputList notDataActions
                args

            ()
            n, List.Cons(apply, args)

    let roleDefinitionPermission = RoleDefinitionPermissionBuilder()

    type AssignmentBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Assignment(name, (List.fold func (AssignmentArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: AssignmentArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: AssignmentArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("principalId")>]
        member _.PrincipalId((name, args), principalId) =
            let apply (args: AssignmentArgs) =
                args.PrincipalId <- input principalId
                args

            ()
            name, List.Cons(apply, args)

        member _.PrincipalId((name, args), principalId) =
            let apply (args: AssignmentArgs) =
                args.PrincipalId <- io principalId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("roleDefinitionId")>]
        member _.RoleDefinitionId((name, args), roleDefinitionId) =
            let apply (args: AssignmentArgs) =
                args.RoleDefinitionId <- input roleDefinitionId
                args

            ()
            name, List.Cons(apply, args)

        member _.RoleDefinitionId((name, args), roleDefinitionId) =
            let apply (args: AssignmentArgs) =
                args.RoleDefinitionId <- io roleDefinitionId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("roleDefinitionName")>]
        member _.RoleDefinitionName((name, args), roleDefinitionName) =
            let apply (args: AssignmentArgs) =
                args.RoleDefinitionName <- input roleDefinitionName
                args

            ()
            name, List.Cons(apply, args)

        member _.RoleDefinitionName((name, args), roleDefinitionName) =
            let apply (args: AssignmentArgs) =
                args.RoleDefinitionName <- io roleDefinitionName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("scope")>]
        member _.Scope((name, args), scope) =
            let apply (args: AssignmentArgs) =
                args.Scope <- input scope
                args

            ()
            name, List.Cons(apply, args)

        member _.Scope((name, args), scope) =
            let apply (args: AssignmentArgs) =
                args.Scope <- io scope
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("skipServicePrincipalAadCheck")>]
        member _.SkipServicePrincipalAadCheck((name, args), skipServicePrincipalAadCheck) =
            let apply (args: AssignmentArgs) =
                args.SkipServicePrincipalAadCheck <- input skipServicePrincipalAadCheck
                args

            ()
            name, List.Cons(apply, args)

        member _.SkipServicePrincipalAadCheck((name, args), skipServicePrincipalAadCheck) =
            let apply (args: AssignmentArgs) =
                args.SkipServicePrincipalAadCheck <- io skipServicePrincipalAadCheck
                args

            ()
            name, List.Cons(apply, args)

    let assignment = AssignmentBuilder()

    type RoleDefinitionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            RoleDefinition(name, (List.fold func (RoleDefinitionArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("assignableScopes")>]
        member _.AssignableScopes((name, args), assignableScopes) =
            let apply (args: RoleDefinitionArgs) =
                args.AssignableScopes <- inputList assignableScopes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: RoleDefinitionArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: RoleDefinitionArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: RoleDefinitionArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: RoleDefinitionArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("permissions")>]
        member _.Permissions((name, args), permissions) =
            let apply (args: RoleDefinitionArgs) =
                args.Permissions <- inputList permissions
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("roleDefinitionId")>]
        member _.RoleDefinitionId((name, args), roleDefinitionId) =
            let apply (args: RoleDefinitionArgs) =
                args.RoleDefinitionId <- input roleDefinitionId
                args

            ()
            name, List.Cons(apply, args)

        member _.RoleDefinitionId((name, args), roleDefinitionId) =
            let apply (args: RoleDefinitionArgs) =
                args.RoleDefinitionId <- io roleDefinitionId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("scope")>]
        member _.Scope((name, args), scope) =
            let apply (args: RoleDefinitionArgs) =
                args.Scope <- input scope
                args

            ()
            name, List.Cons(apply, args)

        member _.Scope((name, args), scope) =
            let apply (args: RoleDefinitionArgs) =
                args.Scope <- io scope
                args

            ()
            name, List.Cons(apply, args)

    let roleDefinition = RoleDefinitionBuilder()

    type UserAssignedIdentityBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            UserAssignedIdentity(name, (List.fold func (UserAssignedIdentityArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: UserAssignedIdentityArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: UserAssignedIdentityArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: UserAssignedIdentityArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: UserAssignedIdentityArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: UserAssignedIdentityArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: UserAssignedIdentityArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: UserAssignedIdentityArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let userAssignedIdentity = UserAssignedIdentityBuilder()

module Automation =
    open Pulumi.Azure.Automation
    open Pulumi.Azure.Automation.Inputs

    type ModuleModuleLinkBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ModuleModuleLinkArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: ModuleModuleLinkArgs) =
                   args.Hash <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("uri")>]
        member _.Uri((n, args), uri) =
            let apply (args: ModuleModuleLinkArgs) =
                args.Uri <- input uri
                args

            ()
            n, List.Cons(apply, args)

        member _.Uri((n, args), uri) =
            let apply (args: ModuleModuleLinkArgs) =
                args.Uri <- io uri
                args

            ()
            n, List.Cons(apply, args)

    let moduleModuleLink = ModuleModuleLinkBuilder()

    type ModuleModuleLinkHashBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ModuleModuleLinkHashArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("algorithm")>]
        member _.Algorithm((n, args), algorithm) =
            let apply (args: ModuleModuleLinkHashArgs) =
                args.Algorithm <- input algorithm
                args

            ()
            n, List.Cons(apply, args)

        member _.Algorithm((n, args), algorithm) =
            let apply (args: ModuleModuleLinkHashArgs) =
                args.Algorithm <- io algorithm
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((n, args), value) =
            let apply (args: ModuleModuleLinkHashArgs) =
                args.Value <- input value
                args

            ()
            n, List.Cons(apply, args)

        member _.Value((n, args), value) =
            let apply (args: ModuleModuleLinkHashArgs) =
                args.Value <- io value
                args

            ()
            n, List.Cons(apply, args)

    let moduleModuleLinkHash = ModuleModuleLinkHashBuilder()

    type RunBookPublishContentLinkBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (RunBookPublishContentLinkArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: RunBookPublishContentLinkArgs) =
                   args.Hash <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("uri")>]
        member _.Uri((n, args), uri) =
            let apply (args: RunBookPublishContentLinkArgs) =
                args.Uri <- input uri
                args

            ()
            n, List.Cons(apply, args)

        member _.Uri((n, args), uri) =
            let apply (args: RunBookPublishContentLinkArgs) =
                args.Uri <- io uri
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("version")>]
        member _.Version((n, args), version) =
            let apply (args: RunBookPublishContentLinkArgs) =
                args.Version <- input version
                args

            ()
            n, List.Cons(apply, args)

        member _.Version((n, args), version) =
            let apply (args: RunBookPublishContentLinkArgs) =
                args.Version <- io version
                args

            ()
            n, List.Cons(apply, args)

    let runBookPublishContentLink = RunBookPublishContentLinkBuilder()

    type RunBookPublishContentLinkHashBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (RunBookPublishContentLinkHashArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("algorithm")>]
        member _.Algorithm((n, args), algorithm) =
            let apply (args: RunBookPublishContentLinkHashArgs) =
                args.Algorithm <- input algorithm
                args

            ()
            n, List.Cons(apply, args)

        member _.Algorithm((n, args), algorithm) =
            let apply (args: RunBookPublishContentLinkHashArgs) =
                args.Algorithm <- io algorithm
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((n, args), value) =
            let apply (args: RunBookPublishContentLinkHashArgs) =
                args.Value <- input value
                args

            ()
            n, List.Cons(apply, args)

        member _.Value((n, args), value) =
            let apply (args: RunBookPublishContentLinkHashArgs) =
                args.Value <- io value
                args

            ()
            n, List.Cons(apply, args)

    let runBookPublishContentLinkHash = RunBookPublishContentLinkHashBuilder()

    type ScheduleMonthlyOccurrenceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ScheduleMonthlyOccurrenceArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("day")>]
        member _.Day((n, args), day) =
            let apply (args: ScheduleMonthlyOccurrenceArgs) =
                args.Day <- input day
                args

            ()
            n, List.Cons(apply, args)

        member _.Day((n, args), day) =
            let apply (args: ScheduleMonthlyOccurrenceArgs) =
                args.Day <- io day
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("occurrence")>]
        member _.Occurrence((n, args), occurrence) =
            let apply (args: ScheduleMonthlyOccurrenceArgs) =
                args.Occurrence <- input occurrence
                args

            ()
            n, List.Cons(apply, args)

        member _.Occurrence((n, args), occurrence) =
            let apply (args: ScheduleMonthlyOccurrenceArgs) =
                args.Occurrence <- io occurrence
                args

            ()
            n, List.Cons(apply, args)

    let scheduleMonthlyOccurrence = ScheduleMonthlyOccurrenceBuilder()

    type AccountBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Account(name, (List.fold func (AccountArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: AccountArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: AccountArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: AccountArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: AccountArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AccountArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AccountArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("skuName")>]
        member _.SkuName((name, args), skuName) =
            let apply (args: AccountArgs) =
                args.SkuName <- input skuName
                args

            ()
            name, List.Cons(apply, args)

        member _.SkuName((name, args), skuName) =
            let apply (args: AccountArgs) =
                args.SkuName <- io skuName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: AccountArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let account = AccountBuilder()

    type BoolVariableBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            BoolVariable(name, (List.fold func (BoolVariableArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("automationAccountName")>]
        member _.AutomationAccountName((name, args), automationAccountName) =
            let apply (args: BoolVariableArgs) =
                args.AutomationAccountName <- input automationAccountName
                args

            ()
            name, List.Cons(apply, args)

        member _.AutomationAccountName((name, args), automationAccountName) =
            let apply (args: BoolVariableArgs) =
                args.AutomationAccountName <- io automationAccountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: BoolVariableArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: BoolVariableArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("encrypted")>]
        member _.Encrypted((name, args), encrypted) =
            let apply (args: BoolVariableArgs) =
                args.Encrypted <- input encrypted
                args

            ()
            name, List.Cons(apply, args)

        member _.Encrypted((name, args), encrypted) =
            let apply (args: BoolVariableArgs) =
                args.Encrypted <- io encrypted
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: BoolVariableArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: BoolVariableArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: BoolVariableArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: BoolVariableArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((name, args), value) =
            let apply (args: BoolVariableArgs) =
                args.Value <- input value
                args

            ()
            name, List.Cons(apply, args)

        member _.Value((name, args), value) =
            let apply (args: BoolVariableArgs) =
                args.Value <- io value
                args

            ()
            name, List.Cons(apply, args)

    let boolVariable = BoolVariableBuilder()

    type CertificateBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Certificate(name, (List.fold func (CertificateArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("automationAccountName")>]
        member _.AutomationAccountName((name, args), automationAccountName) =
            let apply (args: CertificateArgs) =
                args.AutomationAccountName <- input automationAccountName
                args

            ()
            name, List.Cons(apply, args)

        member _.AutomationAccountName((name, args), automationAccountName) =
            let apply (args: CertificateArgs) =
                args.AutomationAccountName <- io automationAccountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("base64")>]
        member _.Base64((name, args), base64) =
            let apply (args: CertificateArgs) =
                args.Base64 <- input base64
                args

            ()
            name, List.Cons(apply, args)

        member _.Base64((name, args), base64) =
            let apply (args: CertificateArgs) =
                args.Base64 <- io base64
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: CertificateArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: CertificateArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: CertificateArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: CertificateArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: CertificateArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: CertificateArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let certificate = CertificateBuilder()

    type CredentialBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Credential(name, (List.fold func (CredentialArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("automationAccountName")>]
        member _.AutomationAccountName((name, args), automationAccountName) =
            let apply (args: CredentialArgs) =
                args.AutomationAccountName <- input automationAccountName
                args

            ()
            name, List.Cons(apply, args)

        member _.AutomationAccountName((name, args), automationAccountName) =
            let apply (args: CredentialArgs) =
                args.AutomationAccountName <- io automationAccountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: CredentialArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: CredentialArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: CredentialArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: CredentialArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("password")>]
        member _.Password((name, args), password) =
            let apply (args: CredentialArgs) =
                args.Password <- input password
                args

            ()
            name, List.Cons(apply, args)

        member _.Password((name, args), password) =
            let apply (args: CredentialArgs) =
                args.Password <- io password
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: CredentialArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: CredentialArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((name, args), username) =
            let apply (args: CredentialArgs) =
                args.Username <- input username
                args

            ()
            name, List.Cons(apply, args)

        member _.Username((name, args), username) =
            let apply (args: CredentialArgs) =
                args.Username <- io username
                args

            ()
            name, List.Cons(apply, args)

    let credential = CredentialBuilder()

    type DateTimeVariableBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            DateTimeVariable(name, (List.fold func (DateTimeVariableArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("automationAccountName")>]
        member _.AutomationAccountName((name, args), automationAccountName) =
            let apply (args: DateTimeVariableArgs) =
                args.AutomationAccountName <- input automationAccountName
                args

            ()
            name, List.Cons(apply, args)

        member _.AutomationAccountName((name, args), automationAccountName) =
            let apply (args: DateTimeVariableArgs) =
                args.AutomationAccountName <- io automationAccountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: DateTimeVariableArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: DateTimeVariableArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("encrypted")>]
        member _.Encrypted((name, args), encrypted) =
            let apply (args: DateTimeVariableArgs) =
                args.Encrypted <- input encrypted
                args

            ()
            name, List.Cons(apply, args)

        member _.Encrypted((name, args), encrypted) =
            let apply (args: DateTimeVariableArgs) =
                args.Encrypted <- io encrypted
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: DateTimeVariableArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: DateTimeVariableArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DateTimeVariableArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DateTimeVariableArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((name, args), value) =
            let apply (args: DateTimeVariableArgs) =
                args.Value <- input value
                args

            ()
            name, List.Cons(apply, args)

        member _.Value((name, args), value) =
            let apply (args: DateTimeVariableArgs) =
                args.Value <- io value
                args

            ()
            name, List.Cons(apply, args)

    let dateTimeVariable = DateTimeVariableBuilder()

    type DscConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            DscConfiguration(name, (List.fold func (DscConfigurationArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("automationAccountName")>]
        member _.AutomationAccountName((name, args), automationAccountName) =
            let apply (args: DscConfigurationArgs) =
                args.AutomationAccountName <- input automationAccountName
                args

            ()
            name, List.Cons(apply, args)

        member _.AutomationAccountName((name, args), automationAccountName) =
            let apply (args: DscConfigurationArgs) =
                args.AutomationAccountName <- io automationAccountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("contentEmbedded")>]
        member _.ContentEmbedded((name, args), contentEmbedded) =
            let apply (args: DscConfigurationArgs) =
                args.ContentEmbedded <- input contentEmbedded
                args

            ()
            name, List.Cons(apply, args)

        member _.ContentEmbedded((name, args), contentEmbedded) =
            let apply (args: DscConfigurationArgs) =
                args.ContentEmbedded <- io contentEmbedded
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: DscConfigurationArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: DscConfigurationArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: DscConfigurationArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: DscConfigurationArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("logVerbose")>]
        member _.LogVerbose((name, args), logVerbose) =
            let apply (args: DscConfigurationArgs) =
                args.LogVerbose <- input logVerbose
                args

            ()
            name, List.Cons(apply, args)

        member _.LogVerbose((name, args), logVerbose) =
            let apply (args: DscConfigurationArgs) =
                args.LogVerbose <- io logVerbose
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: DscConfigurationArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: DscConfigurationArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DscConfigurationArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DscConfigurationArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: DscConfigurationArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let dscConfiguration = DscConfigurationBuilder()

    type DscNodeConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            DscNodeConfiguration(name, (List.fold func (DscNodeConfigurationArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("automationAccountName")>]
        member _.AutomationAccountName((name, args), automationAccountName) =
            let apply (args: DscNodeConfigurationArgs) =
                args.AutomationAccountName <- input automationAccountName
                args

            ()
            name, List.Cons(apply, args)

        member _.AutomationAccountName((name, args), automationAccountName) =
            let apply (args: DscNodeConfigurationArgs) =
                args.AutomationAccountName <- io automationAccountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("contentEmbedded")>]
        member _.ContentEmbedded((name, args), contentEmbedded) =
            let apply (args: DscNodeConfigurationArgs) =
                args.ContentEmbedded <- input contentEmbedded
                args

            ()
            name, List.Cons(apply, args)

        member _.ContentEmbedded((name, args), contentEmbedded) =
            let apply (args: DscNodeConfigurationArgs) =
                args.ContentEmbedded <- io contentEmbedded
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: DscNodeConfigurationArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: DscNodeConfigurationArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DscNodeConfigurationArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DscNodeConfigurationArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let dscNodeConfiguration = DscNodeConfigurationBuilder()

    type IntVariableBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            IntVariable(name, (List.fold func (IntVariableArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("automationAccountName")>]
        member _.AutomationAccountName((name, args), automationAccountName) =
            let apply (args: IntVariableArgs) =
                args.AutomationAccountName <- input automationAccountName
                args

            ()
            name, List.Cons(apply, args)

        member _.AutomationAccountName((name, args), automationAccountName) =
            let apply (args: IntVariableArgs) =
                args.AutomationAccountName <- io automationAccountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: IntVariableArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: IntVariableArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("encrypted")>]
        member _.Encrypted((name, args), encrypted) =
            let apply (args: IntVariableArgs) =
                args.Encrypted <- input encrypted
                args

            ()
            name, List.Cons(apply, args)

        member _.Encrypted((name, args), encrypted) =
            let apply (args: IntVariableArgs) =
                args.Encrypted <- io encrypted
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: IntVariableArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: IntVariableArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: IntVariableArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: IntVariableArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((name, args), value) =
            let apply (args: IntVariableArgs) =
                args.Value <- input value
                args

            ()
            name, List.Cons(apply, args)

        member _.Value((name, args), value) =
            let apply (args: IntVariableArgs) =
                args.Value <- io value
                args

            ()
            name, List.Cons(apply, args)

    let intVariable = IntVariableBuilder()

    type JobScheduleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            JobSchedule(name, (List.fold func (JobScheduleArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("automationAccountName")>]
        member _.AutomationAccountName((name, args), automationAccountName) =
            let apply (args: JobScheduleArgs) =
                args.AutomationAccountName <- input automationAccountName
                args

            ()
            name, List.Cons(apply, args)

        member _.AutomationAccountName((name, args), automationAccountName) =
            let apply (args: JobScheduleArgs) =
                args.AutomationAccountName <- io automationAccountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("jobScheduleId")>]
        member _.JobScheduleId((name, args), jobScheduleId) =
            let apply (args: JobScheduleArgs) =
                args.JobScheduleId <- input jobScheduleId
                args

            ()
            name, List.Cons(apply, args)

        member _.JobScheduleId((name, args), jobScheduleId) =
            let apply (args: JobScheduleArgs) =
                args.JobScheduleId <- io jobScheduleId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("parameters")>]
        member _.Parameters((name, args), parameters) =
            let apply (args: JobScheduleArgs) =
                args.Parameters <- inputMap parameters
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: JobScheduleArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: JobScheduleArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("runOn")>]
        member _.RunOn((name, args), runOn) =
            let apply (args: JobScheduleArgs) =
                args.RunOn <- input runOn
                args

            ()
            name, List.Cons(apply, args)

        member _.RunOn((name, args), runOn) =
            let apply (args: JobScheduleArgs) =
                args.RunOn <- io runOn
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("runbookName")>]
        member _.RunbookName((name, args), runbookName) =
            let apply (args: JobScheduleArgs) =
                args.RunbookName <- input runbookName
                args

            ()
            name, List.Cons(apply, args)

        member _.RunbookName((name, args), runbookName) =
            let apply (args: JobScheduleArgs) =
                args.RunbookName <- io runbookName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("scheduleName")>]
        member _.ScheduleName((name, args), scheduleName) =
            let apply (args: JobScheduleArgs) =
                args.ScheduleName <- input scheduleName
                args

            ()
            name, List.Cons(apply, args)

        member _.ScheduleName((name, args), scheduleName) =
            let apply (args: JobScheduleArgs) =
                args.ScheduleName <- io scheduleName
                args

            ()
            name, List.Cons(apply, args)

    let jobSchedule = JobScheduleBuilder()

    type ModuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Module(name, (List.fold func (ModuleArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("automationAccountName")>]
        member _.AutomationAccountName((name, args), automationAccountName) =
            let apply (args: ModuleArgs) =
                args.AutomationAccountName <- input automationAccountName
                args

            ()
            name, List.Cons(apply, args)

        member _.AutomationAccountName((name, args), automationAccountName) =
            let apply (args: ModuleArgs) =
                args.AutomationAccountName <- io automationAccountName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ModuleArgs) =
                   args.ModuleLink <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ModuleArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ModuleArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ModuleArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ModuleArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let ``module`` = ModuleBuilder()

    type RunBookBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            RunBook(name, (List.fold func (RunBookArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("automationAccountName")>]
        member _.AutomationAccountName((name, args), automationAccountName) =
            let apply (args: RunBookArgs) =
                args.AutomationAccountName <- input automationAccountName
                args

            ()
            name, List.Cons(apply, args)

        member _.AutomationAccountName((name, args), automationAccountName) =
            let apply (args: RunBookArgs) =
                args.AutomationAccountName <- io automationAccountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("content")>]
        member _.Content((name, args), content) =
            let apply (args: RunBookArgs) =
                args.Content <- input content
                args

            ()
            name, List.Cons(apply, args)

        member _.Content((name, args), content) =
            let apply (args: RunBookArgs) =
                args.Content <- io content
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: RunBookArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: RunBookArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: RunBookArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: RunBookArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("logProgress")>]
        member _.LogProgress((name, args), logProgress) =
            let apply (args: RunBookArgs) =
                args.LogProgress <- input logProgress
                args

            ()
            name, List.Cons(apply, args)

        member _.LogProgress((name, args), logProgress) =
            let apply (args: RunBookArgs) =
                args.LogProgress <- io logProgress
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("logVerbose")>]
        member _.LogVerbose((name, args), logVerbose) =
            let apply (args: RunBookArgs) =
                args.LogVerbose <- input logVerbose
                args

            ()
            name, List.Cons(apply, args)

        member _.LogVerbose((name, args), logVerbose) =
            let apply (args: RunBookArgs) =
                args.LogVerbose <- io logVerbose
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: RunBookArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: RunBookArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: RunBookArgs) =
                   args.PublishContentLink <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: RunBookArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: RunBookArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("runbookType")>]
        member _.RunbookType((name, args), runbookType) =
            let apply (args: RunBookArgs) =
                args.RunbookType <- input runbookType
                args

            ()
            name, List.Cons(apply, args)

        member _.RunbookType((name, args), runbookType) =
            let apply (args: RunBookArgs) =
                args.RunbookType <- io runbookType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: RunBookArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let runBook = RunBookBuilder()

    type ScheduleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Schedule(name, (List.fold func (ScheduleArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("automationAccountName")>]
        member _.AutomationAccountName((name, args), automationAccountName) =
            let apply (args: ScheduleArgs) =
                args.AutomationAccountName <- input automationAccountName
                args

            ()
            name, List.Cons(apply, args)

        member _.AutomationAccountName((name, args), automationAccountName) =
            let apply (args: ScheduleArgs) =
                args.AutomationAccountName <- io automationAccountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: ScheduleArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: ScheduleArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("expiryTime")>]
        member _.ExpiryTime((name, args), expiryTime) =
            let apply (args: ScheduleArgs) =
                args.ExpiryTime <- input expiryTime
                args

            ()
            name, List.Cons(apply, args)

        member _.ExpiryTime((name, args), expiryTime) =
            let apply (args: ScheduleArgs) =
                args.ExpiryTime <- io expiryTime
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("frequency")>]
        member _.Frequency((name, args), frequency) =
            let apply (args: ScheduleArgs) =
                args.Frequency <- input frequency
                args

            ()
            name, List.Cons(apply, args)

        member _.Frequency((name, args), frequency) =
            let apply (args: ScheduleArgs) =
                args.Frequency <- io frequency
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("interval")>]
        member _.Interval((name, args), interval) =
            let apply (args: ScheduleArgs) =
                args.Interval <- input interval
                args

            ()
            name, List.Cons(apply, args)

        member _.Interval((name, args), interval) =
            let apply (args: ScheduleArgs) =
                args.Interval <- io interval
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("monthDays")>]
        member _.MonthDays((name, args), monthDays) =
            let apply (args: ScheduleArgs) =
                args.MonthDays <- inputList monthDays
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("monthlyOccurrences")>]
        member _.MonthlyOccurrences((name, args), monthlyOccurrences) =
            let apply (args: ScheduleArgs) =
                args.MonthlyOccurrences <- inputList monthlyOccurrences
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ScheduleArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ScheduleArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ScheduleArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ScheduleArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("startTime")>]
        member _.StartTime((name, args), startTime) =
            let apply (args: ScheduleArgs) =
                args.StartTime <- input startTime
                args

            ()
            name, List.Cons(apply, args)

        member _.StartTime((name, args), startTime) =
            let apply (args: ScheduleArgs) =
                args.StartTime <- io startTime
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("timezone")>]
        member _.Timezone((name, args), timezone) =
            let apply (args: ScheduleArgs) =
                args.Timezone <- input timezone
                args

            ()
            name, List.Cons(apply, args)

        member _.Timezone((name, args), timezone) =
            let apply (args: ScheduleArgs) =
                args.Timezone <- io timezone
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("weekDays")>]
        member _.WeekDays((name, args), weekDays) =
            let apply (args: ScheduleArgs) =
                args.WeekDays <- inputList weekDays
                args

            ()
            name, List.Cons(apply, args)

    let schedule = ScheduleBuilder()

    type StringVariableBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            StringVariable(name, (List.fold func (StringVariableArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("automationAccountName")>]
        member _.AutomationAccountName((name, args), automationAccountName) =
            let apply (args: StringVariableArgs) =
                args.AutomationAccountName <- input automationAccountName
                args

            ()
            name, List.Cons(apply, args)

        member _.AutomationAccountName((name, args), automationAccountName) =
            let apply (args: StringVariableArgs) =
                args.AutomationAccountName <- io automationAccountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: StringVariableArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: StringVariableArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("encrypted")>]
        member _.Encrypted((name, args), encrypted) =
            let apply (args: StringVariableArgs) =
                args.Encrypted <- input encrypted
                args

            ()
            name, List.Cons(apply, args)

        member _.Encrypted((name, args), encrypted) =
            let apply (args: StringVariableArgs) =
                args.Encrypted <- io encrypted
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: StringVariableArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: StringVariableArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: StringVariableArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: StringVariableArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((name, args), value) =
            let apply (args: StringVariableArgs) =
                args.Value <- input value
                args

            ()
            name, List.Cons(apply, args)

        member _.Value((name, args), value) =
            let apply (args: StringVariableArgs) =
                args.Value <- io value
                args

            ()
            name, List.Cons(apply, args)

    let stringVariable = StringVariableBuilder()

module Backup =
    open Pulumi.Azure.Backup
    open Pulumi.Azure.Backup.Inputs

    type PolicyFileShareBackupBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (PolicyFileShareBackupArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("frequency")>]
        member _.Frequency((n, args), frequency) =
            let apply (args: PolicyFileShareBackupArgs) =
                args.Frequency <- input frequency
                args

            ()
            n, List.Cons(apply, args)

        member _.Frequency((n, args), frequency) =
            let apply (args: PolicyFileShareBackupArgs) =
                args.Frequency <- io frequency
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("time")>]
        member _.Time((n, args), time) =
            let apply (args: PolicyFileShareBackupArgs) =
                args.Time <- input time
                args

            ()
            n, List.Cons(apply, args)

        member _.Time((n, args), time) =
            let apply (args: PolicyFileShareBackupArgs) =
                args.Time <- io time
                args

            ()
            n, List.Cons(apply, args)

    let policyFileShareBackup = PolicyFileShareBackupBuilder()

    type PolicyFileShareRetentionDailyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (PolicyFileShareRetentionDailyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("count")>]
        member _.Count((n, args), count) =
            let apply (args: PolicyFileShareRetentionDailyArgs) =
                args.Count <- input count
                args

            ()
            n, List.Cons(apply, args)

        member _.Count((n, args), count) =
            let apply (args: PolicyFileShareRetentionDailyArgs) =
                args.Count <- io count
                args

            ()
            n, List.Cons(apply, args)

    let policyFileShareRetentionDaily = PolicyFileShareRetentionDailyBuilder()

    type PolicyVMBackupBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (PolicyVMBackupArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("frequency")>]
        member _.Frequency((n, args), frequency) =
            let apply (args: PolicyVMBackupArgs) =
                args.Frequency <- input frequency
                args

            ()
            n, List.Cons(apply, args)

        member _.Frequency((n, args), frequency) =
            let apply (args: PolicyVMBackupArgs) =
                args.Frequency <- io frequency
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("time")>]
        member _.Time((n, args), time) =
            let apply (args: PolicyVMBackupArgs) =
                args.Time <- input time
                args

            ()
            n, List.Cons(apply, args)

        member _.Time((n, args), time) =
            let apply (args: PolicyVMBackupArgs) =
                args.Time <- io time
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("weekdays")>]
        member _.Weekdays((n, args), weekdays) =
            let apply (args: PolicyVMBackupArgs) =
                args.Weekdays <- inputList weekdays
                args

            ()
            n, List.Cons(apply, args)

    let policyVMBackup = PolicyVMBackupBuilder()

    type PolicyVMRetentionDailyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (PolicyVMRetentionDailyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("count")>]
        member _.Count((n, args), count) =
            let apply (args: PolicyVMRetentionDailyArgs) =
                args.Count <- input count
                args

            ()
            n, List.Cons(apply, args)

        member _.Count((n, args), count) =
            let apply (args: PolicyVMRetentionDailyArgs) =
                args.Count <- io count
                args

            ()
            n, List.Cons(apply, args)

    let policyVMRetentionDaily = PolicyVMRetentionDailyBuilder()

    type PolicyVMRetentionMonthlyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (PolicyVMRetentionMonthlyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("count")>]
        member _.Count((n, args), count) =
            let apply (args: PolicyVMRetentionMonthlyArgs) =
                args.Count <- input count
                args

            ()
            n, List.Cons(apply, args)

        member _.Count((n, args), count) =
            let apply (args: PolicyVMRetentionMonthlyArgs) =
                args.Count <- io count
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("weekdays")>]
        member _.Weekdays((n, args), weekdays) =
            let apply (args: PolicyVMRetentionMonthlyArgs) =
                args.Weekdays <- inputList weekdays
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("weeks")>]
        member _.Weeks((n, args), weeks) =
            let apply (args: PolicyVMRetentionMonthlyArgs) =
                args.Weeks <- inputList weeks
                args

            ()
            n, List.Cons(apply, args)

    let policyVMRetentionMonthly = PolicyVMRetentionMonthlyBuilder()

    type PolicyVMRetentionWeeklyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (PolicyVMRetentionWeeklyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("count")>]
        member _.Count((n, args), count) =
            let apply (args: PolicyVMRetentionWeeklyArgs) =
                args.Count <- input count
                args

            ()
            n, List.Cons(apply, args)

        member _.Count((n, args), count) =
            let apply (args: PolicyVMRetentionWeeklyArgs) =
                args.Count <- io count
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("weekdays")>]
        member _.Weekdays((n, args), weekdays) =
            let apply (args: PolicyVMRetentionWeeklyArgs) =
                args.Weekdays <- inputList weekdays
                args

            ()
            n, List.Cons(apply, args)

    let policyVMRetentionWeekly = PolicyVMRetentionWeeklyBuilder()

    type PolicyVMRetentionYearlyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (PolicyVMRetentionYearlyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("count")>]
        member _.Count((n, args), count) =
            let apply (args: PolicyVMRetentionYearlyArgs) =
                args.Count <- input count
                args

            ()
            n, List.Cons(apply, args)

        member _.Count((n, args), count) =
            let apply (args: PolicyVMRetentionYearlyArgs) =
                args.Count <- io count
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("months")>]
        member _.Months((n, args), months) =
            let apply (args: PolicyVMRetentionYearlyArgs) =
                args.Months <- inputList months
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("weekdays")>]
        member _.Weekdays((n, args), weekdays) =
            let apply (args: PolicyVMRetentionYearlyArgs) =
                args.Weekdays <- inputList weekdays
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("weeks")>]
        member _.Weeks((n, args), weeks) =
            let apply (args: PolicyVMRetentionYearlyArgs) =
                args.Weeks <- inputList weeks
                args

            ()
            n, List.Cons(apply, args)

    let policyVMRetentionYearly = PolicyVMRetentionYearlyBuilder()

    type ContainerStorageAccountBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ContainerStorageAccount(name, (List.fold func (ContainerStorageAccountArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("recoveryVaultName")>]
        member _.RecoveryVaultName((name, args), recoveryVaultName) =
            let apply (args: ContainerStorageAccountArgs) =
                args.RecoveryVaultName <- input recoveryVaultName
                args

            ()
            name, List.Cons(apply, args)

        member _.RecoveryVaultName((name, args), recoveryVaultName) =
            let apply (args: ContainerStorageAccountArgs) =
                args.RecoveryVaultName <- io recoveryVaultName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ContainerStorageAccountArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ContainerStorageAccountArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageAccountId")>]
        member _.StorageAccountId((name, args), storageAccountId) =
            let apply (args: ContainerStorageAccountArgs) =
                args.StorageAccountId <- input storageAccountId
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageAccountId((name, args), storageAccountId) =
            let apply (args: ContainerStorageAccountArgs) =
                args.StorageAccountId <- io storageAccountId
                args

            ()
            name, List.Cons(apply, args)

    let containerStorageAccount = ContainerStorageAccountBuilder()

    type PolicyFileShareBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            PolicyFileShare(name, (List.fold func (PolicyFileShareArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: PolicyFileShareArgs) =
                   args.Backup <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: PolicyFileShareArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: PolicyFileShareArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("recoveryVaultName")>]
        member _.RecoveryVaultName((name, args), recoveryVaultName) =
            let apply (args: PolicyFileShareArgs) =
                args.RecoveryVaultName <- input recoveryVaultName
                args

            ()
            name, List.Cons(apply, args)

        member _.RecoveryVaultName((name, args), recoveryVaultName) =
            let apply (args: PolicyFileShareArgs) =
                args.RecoveryVaultName <- io recoveryVaultName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: PolicyFileShareArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: PolicyFileShareArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: PolicyFileShareArgs) =
                   args.RetentionDaily <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("timezone")>]
        member _.Timezone((name, args), timezone) =
            let apply (args: PolicyFileShareArgs) =
                args.Timezone <- input timezone
                args

            ()
            name, List.Cons(apply, args)

        member _.Timezone((name, args), timezone) =
            let apply (args: PolicyFileShareArgs) =
                args.Timezone <- io timezone
                args

            ()
            name, List.Cons(apply, args)

    let policyFileShare = PolicyFileShareBuilder()

    type PolicyVMBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            PolicyVM(name, (List.fold func (PolicyVMArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: PolicyVMArgs) =
                   args.Backup <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: PolicyVMArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: PolicyVMArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("recoveryVaultName")>]
        member _.RecoveryVaultName((name, args), recoveryVaultName) =
            let apply (args: PolicyVMArgs) =
                args.RecoveryVaultName <- input recoveryVaultName
                args

            ()
            name, List.Cons(apply, args)

        member _.RecoveryVaultName((name, args), recoveryVaultName) =
            let apply (args: PolicyVMArgs) =
                args.RecoveryVaultName <- io recoveryVaultName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: PolicyVMArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: PolicyVMArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: PolicyVMArgs) =
                   args.RetentionDaily <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: PolicyVMArgs) =
                   args.RetentionMonthly <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: PolicyVMArgs) =
                   args.RetentionWeekly <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: PolicyVMArgs) =
                   args.RetentionYearly <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: PolicyVMArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("timezone")>]
        member _.Timezone((name, args), timezone) =
            let apply (args: PolicyVMArgs) =
                args.Timezone <- input timezone
                args

            ()
            name, List.Cons(apply, args)

        member _.Timezone((name, args), timezone) =
            let apply (args: PolicyVMArgs) =
                args.Timezone <- io timezone
                args

            ()
            name, List.Cons(apply, args)

    let policyVM = PolicyVMBuilder()

    type ProtectedFileShareBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ProtectedFileShare(name, (List.fold func (ProtectedFileShareArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("backupPolicyId")>]
        member _.BackupPolicyId((name, args), backupPolicyId) =
            let apply (args: ProtectedFileShareArgs) =
                args.BackupPolicyId <- input backupPolicyId
                args

            ()
            name, List.Cons(apply, args)

        member _.BackupPolicyId((name, args), backupPolicyId) =
            let apply (args: ProtectedFileShareArgs) =
                args.BackupPolicyId <- io backupPolicyId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("recoveryVaultName")>]
        member _.RecoveryVaultName((name, args), recoveryVaultName) =
            let apply (args: ProtectedFileShareArgs) =
                args.RecoveryVaultName <- input recoveryVaultName
                args

            ()
            name, List.Cons(apply, args)

        member _.RecoveryVaultName((name, args), recoveryVaultName) =
            let apply (args: ProtectedFileShareArgs) =
                args.RecoveryVaultName <- io recoveryVaultName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ProtectedFileShareArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ProtectedFileShareArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sourceFileShareName")>]
        member _.SourceFileShareName((name, args), sourceFileShareName) =
            let apply (args: ProtectedFileShareArgs) =
                args.SourceFileShareName <- input sourceFileShareName
                args

            ()
            name, List.Cons(apply, args)

        member _.SourceFileShareName((name, args), sourceFileShareName) =
            let apply (args: ProtectedFileShareArgs) =
                args.SourceFileShareName <- io sourceFileShareName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sourceStorageAccountId")>]
        member _.SourceStorageAccountId((name, args), sourceStorageAccountId) =
            let apply (args: ProtectedFileShareArgs) =
                args.SourceStorageAccountId <- input sourceStorageAccountId
                args

            ()
            name, List.Cons(apply, args)

        member _.SourceStorageAccountId((name, args), sourceStorageAccountId) =
            let apply (args: ProtectedFileShareArgs) =
                args.SourceStorageAccountId <- io sourceStorageAccountId
                args

            ()
            name, List.Cons(apply, args)

    let protectedFileShare = ProtectedFileShareBuilder()

    type ProtectedVMBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ProtectedVM(name, (List.fold func (ProtectedVMArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("backupPolicyId")>]
        member _.BackupPolicyId((name, args), backupPolicyId) =
            let apply (args: ProtectedVMArgs) =
                args.BackupPolicyId <- input backupPolicyId
                args

            ()
            name, List.Cons(apply, args)

        member _.BackupPolicyId((name, args), backupPolicyId) =
            let apply (args: ProtectedVMArgs) =
                args.BackupPolicyId <- io backupPolicyId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("recoveryVaultName")>]
        member _.RecoveryVaultName((name, args), recoveryVaultName) =
            let apply (args: ProtectedVMArgs) =
                args.RecoveryVaultName <- input recoveryVaultName
                args

            ()
            name, List.Cons(apply, args)

        member _.RecoveryVaultName((name, args), recoveryVaultName) =
            let apply (args: ProtectedVMArgs) =
                args.RecoveryVaultName <- io recoveryVaultName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ProtectedVMArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ProtectedVMArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sourceVmId")>]
        member _.SourceVmId((name, args), sourceVmId) =
            let apply (args: ProtectedVMArgs) =
                args.SourceVmId <- input sourceVmId
                args

            ()
            name, List.Cons(apply, args)

        member _.SourceVmId((name, args), sourceVmId) =
            let apply (args: ProtectedVMArgs) =
                args.SourceVmId <- io sourceVmId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ProtectedVMArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let protectedVM = ProtectedVMBuilder()

module Batch =
    open Pulumi.Azure.Batch
    open Pulumi.Azure.Batch.Inputs

    type AccountKeyVaultReferenceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AccountKeyVaultReferenceArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: AccountKeyVaultReferenceArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: AccountKeyVaultReferenceArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("url")>]
        member _.Url((n, args), url) =
            let apply (args: AccountKeyVaultReferenceArgs) =
                args.Url <- input url
                args

            ()
            n, List.Cons(apply, args)

        member _.Url((n, args), url) =
            let apply (args: AccountKeyVaultReferenceArgs) =
                args.Url <- io url
                args

            ()
            n, List.Cons(apply, args)

    let accountKeyVaultReference = AccountKeyVaultReferenceBuilder()

    type PoolAutoScaleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (PoolAutoScaleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("evaluationInterval")>]
        member _.EvaluationInterval((n, args), evaluationInterval) =
            let apply (args: PoolAutoScaleArgs) =
                args.EvaluationInterval <- input evaluationInterval
                args

            ()
            n, List.Cons(apply, args)

        member _.EvaluationInterval((n, args), evaluationInterval) =
            let apply (args: PoolAutoScaleArgs) =
                args.EvaluationInterval <- io evaluationInterval
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("formula")>]
        member _.Formula((n, args), formula) =
            let apply (args: PoolAutoScaleArgs) =
                args.Formula <- input formula
                args

            ()
            n, List.Cons(apply, args)

        member _.Formula((n, args), formula) =
            let apply (args: PoolAutoScaleArgs) =
                args.Formula <- io formula
                args

            ()
            n, List.Cons(apply, args)

    let poolAutoScale = PoolAutoScaleBuilder()

    type PoolCertificateBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (PoolCertificateArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: PoolCertificateArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: PoolCertificateArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storeLocation")>]
        member _.StoreLocation((n, args), storeLocation) =
            let apply (args: PoolCertificateArgs) =
                args.StoreLocation <- input storeLocation
                args

            ()
            n, List.Cons(apply, args)

        member _.StoreLocation((n, args), storeLocation) =
            let apply (args: PoolCertificateArgs) =
                args.StoreLocation <- io storeLocation
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storeName")>]
        member _.StoreName((n, args), storeName) =
            let apply (args: PoolCertificateArgs) =
                args.StoreName <- input storeName
                args

            ()
            n, List.Cons(apply, args)

        member _.StoreName((n, args), storeName) =
            let apply (args: PoolCertificateArgs) =
                args.StoreName <- io storeName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("visibilities")>]
        member _.Visibilities((n, args), visibilities) =
            let apply (args: PoolCertificateArgs) =
                args.Visibilities <- inputList visibilities
                args

            ()
            n, List.Cons(apply, args)

    let poolCertificate = PoolCertificateBuilder()

    type PoolContainerConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (PoolContainerConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("containerImageNames")>]
        member _.ContainerImageNames((n, args), containerImageNames) =
            let apply (args: PoolContainerConfigurationArgs) =
                args.ContainerImageNames <- inputList containerImageNames
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("containerRegistries")>]
        member _.ContainerRegistries((n, args), containerRegistries) =
            let apply (args: PoolContainerConfigurationArgs) =
                args.ContainerRegistries <- inputList containerRegistries
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: PoolContainerConfigurationArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: PoolContainerConfigurationArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let poolContainerConfiguration = PoolContainerConfigurationBuilder()

    type PoolContainerConfigurationContainerRegistryBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (PoolContainerConfigurationContainerRegistryArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: PoolContainerConfigurationContainerRegistryArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: PoolContainerConfigurationContainerRegistryArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("registryServer")>]
        member _.RegistryServer((n, args), registryServer) =
            let apply (args: PoolContainerConfigurationContainerRegistryArgs) =
                args.RegistryServer <- input registryServer
                args

            ()
            n, List.Cons(apply, args)

        member _.RegistryServer((n, args), registryServer) =
            let apply (args: PoolContainerConfigurationContainerRegistryArgs) =
                args.RegistryServer <- io registryServer
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("userName")>]
        member _.UserName((n, args), userName) =
            let apply (args: PoolContainerConfigurationContainerRegistryArgs) =
                args.UserName <- input userName
                args

            ()
            n, List.Cons(apply, args)

        member _.UserName((n, args), userName) =
            let apply (args: PoolContainerConfigurationContainerRegistryArgs) =
                args.UserName <- io userName
                args

            ()
            n, List.Cons(apply, args)

    let poolContainerConfigurationContainerRegistry =
        PoolContainerConfigurationContainerRegistryBuilder()

    type PoolFixedScaleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (PoolFixedScaleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("resizeTimeout")>]
        member _.ResizeTimeout((n, args), resizeTimeout) =
            let apply (args: PoolFixedScaleArgs) =
                args.ResizeTimeout <- input resizeTimeout
                args

            ()
            n, List.Cons(apply, args)

        member _.ResizeTimeout((n, args), resizeTimeout) =
            let apply (args: PoolFixedScaleArgs) =
                args.ResizeTimeout <- io resizeTimeout
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("targetDedicatedNodes")>]
        member _.TargetDedicatedNodes((n, args), targetDedicatedNodes) =
            let apply (args: PoolFixedScaleArgs) =
                args.TargetDedicatedNodes <- input targetDedicatedNodes
                args

            ()
            n, List.Cons(apply, args)

        member _.TargetDedicatedNodes((n, args), targetDedicatedNodes) =
            let apply (args: PoolFixedScaleArgs) =
                args.TargetDedicatedNodes <- io targetDedicatedNodes
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("targetLowPriorityNodes")>]
        member _.TargetLowPriorityNodes((n, args), targetLowPriorityNodes) =
            let apply (args: PoolFixedScaleArgs) =
                args.TargetLowPriorityNodes <- input targetLowPriorityNodes
                args

            ()
            n, List.Cons(apply, args)

        member _.TargetLowPriorityNodes((n, args), targetLowPriorityNodes) =
            let apply (args: PoolFixedScaleArgs) =
                args.TargetLowPriorityNodes <- io targetLowPriorityNodes
                args

            ()
            n, List.Cons(apply, args)

    let poolFixedScale = PoolFixedScaleBuilder()

    type PoolNetworkConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (PoolNetworkConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("endpointConfigurations")>]
        member _.EndpointConfigurations((n, args), endpointConfigurations) =
            let apply (args: PoolNetworkConfigurationArgs) =
                args.EndpointConfigurations <- inputList endpointConfigurations
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publicIps")>]
        member _.PublicIps((n, args), publicIps) =
            let apply (args: PoolNetworkConfigurationArgs) =
                args.PublicIps <- inputList publicIps
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: PoolNetworkConfigurationArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: PoolNetworkConfigurationArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

    let poolNetworkConfiguration = PoolNetworkConfigurationBuilder()

    type PoolNetworkConfigurationEndpointConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (PoolNetworkConfigurationEndpointConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("backendPort")>]
        member _.BackendPort((n, args), backendPort) =
            let apply (args: PoolNetworkConfigurationEndpointConfigurationArgs) =
                args.BackendPort <- input backendPort
                args

            ()
            n, List.Cons(apply, args)

        member _.BackendPort((n, args), backendPort) =
            let apply (args: PoolNetworkConfigurationEndpointConfigurationArgs) =
                args.BackendPort <- io backendPort
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("frontendPortRange")>]
        member _.FrontendPortRange((n, args), frontendPortRange) =
            let apply (args: PoolNetworkConfigurationEndpointConfigurationArgs) =
                args.FrontendPortRange <- input frontendPortRange
                args

            ()
            n, List.Cons(apply, args)

        member _.FrontendPortRange((n, args), frontendPortRange) =
            let apply (args: PoolNetworkConfigurationEndpointConfigurationArgs) =
                args.FrontendPortRange <- io frontendPortRange
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: PoolNetworkConfigurationEndpointConfigurationArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: PoolNetworkConfigurationEndpointConfigurationArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("networkSecurityGroupRules")>]
        member _.NetworkSecurityGroupRules((n, args), networkSecurityGroupRules) =
            let apply (args: PoolNetworkConfigurationEndpointConfigurationArgs) =
                args.NetworkSecurityGroupRules <- inputList networkSecurityGroupRules
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("protocol")>]
        member _.Protocol((n, args), protocol) =
            let apply (args: PoolNetworkConfigurationEndpointConfigurationArgs) =
                args.Protocol <- input protocol
                args

            ()
            n, List.Cons(apply, args)

        member _.Protocol((n, args), protocol) =
            let apply (args: PoolNetworkConfigurationEndpointConfigurationArgs) =
                args.Protocol <- io protocol
                args

            ()
            n, List.Cons(apply, args)

    let poolNetworkConfigurationEndpointConfiguration =
        PoolNetworkConfigurationEndpointConfigurationBuilder()

    type PoolNetworkConfigurationEndpointConfigurationNetworkSecurityGroupRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (PoolNetworkConfigurationEndpointConfigurationNetworkSecurityGroupRuleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("access")>]
        member _.Access((n, args), access) =
            let apply (args: PoolNetworkConfigurationEndpointConfigurationNetworkSecurityGroupRuleArgs) =
                args.Access <- input access
                args

            ()
            n, List.Cons(apply, args)

        member _.Access((n, args), access) =
            let apply (args: PoolNetworkConfigurationEndpointConfigurationNetworkSecurityGroupRuleArgs) =
                args.Access <- io access
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("priority")>]
        member _.Priority((n, args), priority) =
            let apply (args: PoolNetworkConfigurationEndpointConfigurationNetworkSecurityGroupRuleArgs) =
                args.Priority <- input priority
                args

            ()
            n, List.Cons(apply, args)

        member _.Priority((n, args), priority) =
            let apply (args: PoolNetworkConfigurationEndpointConfigurationNetworkSecurityGroupRuleArgs) =
                args.Priority <- io priority
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sourceAddressPrefix")>]
        member _.SourceAddressPrefix((n, args), sourceAddressPrefix) =
            let apply (args: PoolNetworkConfigurationEndpointConfigurationNetworkSecurityGroupRuleArgs) =
                args.SourceAddressPrefix <- input sourceAddressPrefix
                args

            ()
            n, List.Cons(apply, args)

        member _.SourceAddressPrefix((n, args), sourceAddressPrefix) =
            let apply (args: PoolNetworkConfigurationEndpointConfigurationNetworkSecurityGroupRuleArgs) =
                args.SourceAddressPrefix <- io sourceAddressPrefix
                args

            ()
            n, List.Cons(apply, args)

    let poolNetworkConfigurationEndpointConfigurationNetworkSecurityGroupRule =
        PoolNetworkConfigurationEndpointConfigurationNetworkSecurityGroupRuleBuilder()

    type PoolStartTaskBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (PoolStartTaskArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("commandLine")>]
        member _.CommandLine((n, args), commandLine) =
            let apply (args: PoolStartTaskArgs) =
                args.CommandLine <- input commandLine
                args

            ()
            n, List.Cons(apply, args)

        member _.CommandLine((n, args), commandLine) =
            let apply (args: PoolStartTaskArgs) =
                args.CommandLine <- io commandLine
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("environment")>]
        member _.Environment((n, args), environment) =
            let apply (args: PoolStartTaskArgs) =
                args.Environment <- inputMap environment
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("maxTaskRetryCount")>]
        member _.MaxTaskRetryCount((n, args), maxTaskRetryCount) =
            let apply (args: PoolStartTaskArgs) =
                args.MaxTaskRetryCount <- input maxTaskRetryCount
                args

            ()
            n, List.Cons(apply, args)

        member _.MaxTaskRetryCount((n, args), maxTaskRetryCount) =
            let apply (args: PoolStartTaskArgs) =
                args.MaxTaskRetryCount <- io maxTaskRetryCount
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("resourceFiles")>]
        member _.ResourceFiles((n, args), resourceFiles) =
            let apply (args: PoolStartTaskArgs) =
                args.ResourceFiles <- inputList resourceFiles
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: PoolStartTaskArgs) =
                   args.UserIdentity <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("waitForSuccess")>]
        member _.WaitForSuccess((n, args), waitForSuccess) =
            let apply (args: PoolStartTaskArgs) =
                args.WaitForSuccess <- input waitForSuccess
                args

            ()
            n, List.Cons(apply, args)

        member _.WaitForSuccess((n, args), waitForSuccess) =
            let apply (args: PoolStartTaskArgs) =
                args.WaitForSuccess <- io waitForSuccess
                args

            ()
            n, List.Cons(apply, args)

    let poolStartTask = PoolStartTaskBuilder()

    type PoolStartTaskResourceFileBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (PoolStartTaskResourceFileArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("autoStorageContainerName")>]
        member _.AutoStorageContainerName((n, args), autoStorageContainerName) =
            let apply (args: PoolStartTaskResourceFileArgs) =
                args.AutoStorageContainerName <- input autoStorageContainerName
                args

            ()
            n, List.Cons(apply, args)

        member _.AutoStorageContainerName((n, args), autoStorageContainerName) =
            let apply (args: PoolStartTaskResourceFileArgs) =
                args.AutoStorageContainerName <- io autoStorageContainerName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("blobPrefix")>]
        member _.BlobPrefix((n, args), blobPrefix) =
            let apply (args: PoolStartTaskResourceFileArgs) =
                args.BlobPrefix <- input blobPrefix
                args

            ()
            n, List.Cons(apply, args)

        member _.BlobPrefix((n, args), blobPrefix) =
            let apply (args: PoolStartTaskResourceFileArgs) =
                args.BlobPrefix <- io blobPrefix
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("fileMode")>]
        member _.FileMode((n, args), fileMode) =
            let apply (args: PoolStartTaskResourceFileArgs) =
                args.FileMode <- input fileMode
                args

            ()
            n, List.Cons(apply, args)

        member _.FileMode((n, args), fileMode) =
            let apply (args: PoolStartTaskResourceFileArgs) =
                args.FileMode <- io fileMode
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("filePath")>]
        member _.FilePath((n, args), filePath) =
            let apply (args: PoolStartTaskResourceFileArgs) =
                args.FilePath <- input filePath
                args

            ()
            n, List.Cons(apply, args)

        member _.FilePath((n, args), filePath) =
            let apply (args: PoolStartTaskResourceFileArgs) =
                args.FilePath <- io filePath
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("httpUrl")>]
        member _.HttpUrl((n, args), httpUrl) =
            let apply (args: PoolStartTaskResourceFileArgs) =
                args.HttpUrl <- input httpUrl
                args

            ()
            n, List.Cons(apply, args)

        member _.HttpUrl((n, args), httpUrl) =
            let apply (args: PoolStartTaskResourceFileArgs) =
                args.HttpUrl <- io httpUrl
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageContainerUrl")>]
        member _.StorageContainerUrl((n, args), storageContainerUrl) =
            let apply (args: PoolStartTaskResourceFileArgs) =
                args.StorageContainerUrl <- input storageContainerUrl
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageContainerUrl((n, args), storageContainerUrl) =
            let apply (args: PoolStartTaskResourceFileArgs) =
                args.StorageContainerUrl <- io storageContainerUrl
                args

            ()
            n, List.Cons(apply, args)

    let poolStartTaskResourceFile = PoolStartTaskResourceFileBuilder()

    type PoolStartTaskUserIdentityBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (PoolStartTaskUserIdentityArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: PoolStartTaskUserIdentityArgs) =
                   args.AutoUser <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("userName")>]
        member _.UserName((n, args), userName) =
            let apply (args: PoolStartTaskUserIdentityArgs) =
                args.UserName <- input userName
                args

            ()
            n, List.Cons(apply, args)

        member _.UserName((n, args), userName) =
            let apply (args: PoolStartTaskUserIdentityArgs) =
                args.UserName <- io userName
                args

            ()
            n, List.Cons(apply, args)

    let poolStartTaskUserIdentity = PoolStartTaskUserIdentityBuilder()

    type PoolStartTaskUserIdentityAutoUserBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (PoolStartTaskUserIdentityAutoUserArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("elevationLevel")>]
        member _.ElevationLevel((n, args), elevationLevel) =
            let apply (args: PoolStartTaskUserIdentityAutoUserArgs) =
                args.ElevationLevel <- input elevationLevel
                args

            ()
            n, List.Cons(apply, args)

        member _.ElevationLevel((n, args), elevationLevel) =
            let apply (args: PoolStartTaskUserIdentityAutoUserArgs) =
                args.ElevationLevel <- io elevationLevel
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("scope")>]
        member _.Scope((n, args), scope) =
            let apply (args: PoolStartTaskUserIdentityAutoUserArgs) =
                args.Scope <- input scope
                args

            ()
            n, List.Cons(apply, args)

        member _.Scope((n, args), scope) =
            let apply (args: PoolStartTaskUserIdentityAutoUserArgs) =
                args.Scope <- io scope
                args

            ()
            n, List.Cons(apply, args)

    let poolStartTaskUserIdentityAutoUser =
        PoolStartTaskUserIdentityAutoUserBuilder()

    type PoolStorageImageReferenceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (PoolStorageImageReferenceArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: PoolStorageImageReferenceArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: PoolStorageImageReferenceArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("offer")>]
        member _.Offer((n, args), offer) =
            let apply (args: PoolStorageImageReferenceArgs) =
                args.Offer <- input offer
                args

            ()
            n, List.Cons(apply, args)

        member _.Offer((n, args), offer) =
            let apply (args: PoolStorageImageReferenceArgs) =
                args.Offer <- io offer
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publisher")>]
        member _.Publisher((n, args), publisher) =
            let apply (args: PoolStorageImageReferenceArgs) =
                args.Publisher <- input publisher
                args

            ()
            n, List.Cons(apply, args)

        member _.Publisher((n, args), publisher) =
            let apply (args: PoolStorageImageReferenceArgs) =
                args.Publisher <- io publisher
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sku")>]
        member _.Sku((n, args), sku) =
            let apply (args: PoolStorageImageReferenceArgs) =
                args.Sku <- input sku
                args

            ()
            n, List.Cons(apply, args)

        member _.Sku((n, args), sku) =
            let apply (args: PoolStorageImageReferenceArgs) =
                args.Sku <- io sku
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("version")>]
        member _.Version((n, args), version) =
            let apply (args: PoolStorageImageReferenceArgs) =
                args.Version <- input version
                args

            ()
            n, List.Cons(apply, args)

        member _.Version((n, args), version) =
            let apply (args: PoolStorageImageReferenceArgs) =
                args.Version <- io version
                args

            ()
            n, List.Cons(apply, args)

    let poolStorageImageReference = PoolStorageImageReferenceBuilder()

    type AccountBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Account(name, (List.fold func (AccountArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: AccountArgs) =
                   args.KeyVaultReference <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: AccountArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: AccountArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: AccountArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: AccountArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("poolAllocationMode")>]
        member _.PoolAllocationMode((name, args), poolAllocationMode) =
            let apply (args: AccountArgs) =
                args.PoolAllocationMode <- input poolAllocationMode
                args

            ()
            name, List.Cons(apply, args)

        member _.PoolAllocationMode((name, args), poolAllocationMode) =
            let apply (args: AccountArgs) =
                args.PoolAllocationMode <- io poolAllocationMode
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AccountArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AccountArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageAccountId")>]
        member _.StorageAccountId((name, args), storageAccountId) =
            let apply (args: AccountArgs) =
                args.StorageAccountId <- input storageAccountId
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageAccountId((name, args), storageAccountId) =
            let apply (args: AccountArgs) =
                args.StorageAccountId <- io storageAccountId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: AccountArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let account = AccountBuilder()

    type ApplicationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Application(name, (List.fold func (ApplicationArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("accountName")>]
        member _.AccountName((name, args), accountName) =
            let apply (args: ApplicationArgs) =
                args.AccountName <- input accountName
                args

            ()
            name, List.Cons(apply, args)

        member _.AccountName((name, args), accountName) =
            let apply (args: ApplicationArgs) =
                args.AccountName <- io accountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("allowUpdates")>]
        member _.AllowUpdates((name, args), allowUpdates) =
            let apply (args: ApplicationArgs) =
                args.AllowUpdates <- input allowUpdates
                args

            ()
            name, List.Cons(apply, args)

        member _.AllowUpdates((name, args), allowUpdates) =
            let apply (args: ApplicationArgs) =
                args.AllowUpdates <- io allowUpdates
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("defaultVersion")>]
        member _.DefaultVersion((name, args), defaultVersion) =
            let apply (args: ApplicationArgs) =
                args.DefaultVersion <- input defaultVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.DefaultVersion((name, args), defaultVersion) =
            let apply (args: ApplicationArgs) =
                args.DefaultVersion <- io defaultVersion
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("displayName")>]
        member _.DisplayName((name, args), displayName) =
            let apply (args: ApplicationArgs) =
                args.DisplayName <- input displayName
                args

            ()
            name, List.Cons(apply, args)

        member _.DisplayName((name, args), displayName) =
            let apply (args: ApplicationArgs) =
                args.DisplayName <- io displayName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ApplicationArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ApplicationArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ApplicationArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ApplicationArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let application = ApplicationBuilder()

    type CertificateBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Certificate(name, (List.fold func (CertificateArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("accountName")>]
        member _.AccountName((name, args), accountName) =
            let apply (args: CertificateArgs) =
                args.AccountName <- input accountName
                args

            ()
            name, List.Cons(apply, args)

        member _.AccountName((name, args), accountName) =
            let apply (args: CertificateArgs) =
                args.AccountName <- io accountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("batchCertificate")>]
        member _.BatchCertificate((name, args), batchCertificate) =
            let apply (args: CertificateArgs) =
                args.BatchCertificate <- input batchCertificate
                args

            ()
            name, List.Cons(apply, args)

        member _.BatchCertificate((name, args), batchCertificate) =
            let apply (args: CertificateArgs) =
                args.BatchCertificate <- io batchCertificate
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("format")>]
        member _.Format((name, args), format) =
            let apply (args: CertificateArgs) =
                args.Format <- input format
                args

            ()
            name, List.Cons(apply, args)

        member _.Format((name, args), format) =
            let apply (args: CertificateArgs) =
                args.Format <- io format
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("password")>]
        member _.Password((name, args), password) =
            let apply (args: CertificateArgs) =
                args.Password <- input password
                args

            ()
            name, List.Cons(apply, args)

        member _.Password((name, args), password) =
            let apply (args: CertificateArgs) =
                args.Password <- io password
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: CertificateArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: CertificateArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("thumbprint")>]
        member _.Thumbprint((name, args), thumbprint) =
            let apply (args: CertificateArgs) =
                args.Thumbprint <- input thumbprint
                args

            ()
            name, List.Cons(apply, args)

        member _.Thumbprint((name, args), thumbprint) =
            let apply (args: CertificateArgs) =
                args.Thumbprint <- io thumbprint
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("thumbprintAlgorithm")>]
        member _.ThumbprintAlgorithm((name, args), thumbprintAlgorithm) =
            let apply (args: CertificateArgs) =
                args.ThumbprintAlgorithm <- input thumbprintAlgorithm
                args

            ()
            name, List.Cons(apply, args)

        member _.ThumbprintAlgorithm((name, args), thumbprintAlgorithm) =
            let apply (args: CertificateArgs) =
                args.ThumbprintAlgorithm <- io thumbprintAlgorithm
                args

            ()
            name, List.Cons(apply, args)

    let certificate = CertificateBuilder()

    type PoolBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Pool(name, (List.fold func (PoolArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("accountName")>]
        member _.AccountName((name, args), accountName) =
            let apply (args: PoolArgs) =
                args.AccountName <- input accountName
                args

            ()
            name, List.Cons(apply, args)

        member _.AccountName((name, args), accountName) =
            let apply (args: PoolArgs) =
                args.AccountName <- io accountName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: PoolArgs) =
                   args.AutoScale <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("certificates")>]
        member _.Certificates((name, args), certificates) =
            let apply (args: PoolArgs) =
                args.Certificates <- inputList certificates
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: PoolArgs) =
                   args.ContainerConfiguration <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("displayName")>]
        member _.DisplayName((name, args), displayName) =
            let apply (args: PoolArgs) =
                args.DisplayName <- input displayName
                args

            ()
            name, List.Cons(apply, args)

        member _.DisplayName((name, args), displayName) =
            let apply (args: PoolArgs) =
                args.DisplayName <- io displayName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: PoolArgs) =
                   args.FixedScale <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("maxTasksPerNode")>]
        member _.MaxTasksPerNode((name, args), maxTasksPerNode) =
            let apply (args: PoolArgs) =
                args.MaxTasksPerNode <- input maxTasksPerNode
                args

            ()
            name, List.Cons(apply, args)

        member _.MaxTasksPerNode((name, args), maxTasksPerNode) =
            let apply (args: PoolArgs) =
                args.MaxTasksPerNode <- io maxTasksPerNode
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("metadata")>]
        member _.Metadata((name, args), metadata) =
            let apply (args: PoolArgs) =
                args.Metadata <- inputMap metadata
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: PoolArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: PoolArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: PoolArgs) =
                   args.NetworkConfiguration <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("nodeAgentSkuId")>]
        member _.NodeAgentSkuId((name, args), nodeAgentSkuId) =
            let apply (args: PoolArgs) =
                args.NodeAgentSkuId <- input nodeAgentSkuId
                args

            ()
            name, List.Cons(apply, args)

        member _.NodeAgentSkuId((name, args), nodeAgentSkuId) =
            let apply (args: PoolArgs) =
                args.NodeAgentSkuId <- io nodeAgentSkuId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: PoolArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: PoolArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: PoolArgs) =
                   args.StartTask <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("stopPendingResizeOperation")>]
        member _.StopPendingResizeOperation((name, args), stopPendingResizeOperation) =
            let apply (args: PoolArgs) =
                args.StopPendingResizeOperation <- input stopPendingResizeOperation
                args

            ()
            name, List.Cons(apply, args)

        member _.StopPendingResizeOperation((name, args), stopPendingResizeOperation) =
            let apply (args: PoolArgs) =
                args.StopPendingResizeOperation <- io stopPendingResizeOperation
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: PoolArgs) =
                   args.StorageImageReference <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("vmSize")>]
        member _.VmSize((name, args), vmSize) =
            let apply (args: PoolArgs) =
                args.VmSize <- input vmSize
                args

            ()
            name, List.Cons(apply, args)

        member _.VmSize((name, args), vmSize) =
            let apply (args: PoolArgs) =
                args.VmSize <- io vmSize
                args

            ()
            name, List.Cons(apply, args)

    let pool = PoolBuilder()

module Blueprint =
    open Pulumi.Azure.Blueprint
    open Pulumi.Azure.Blueprint.Inputs

    type AssignmentIdentityBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AssignmentIdentityArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("identityIds")>]
        member _.IdentityIds((n, args), identityIds) =
            let apply (args: AssignmentIdentityArgs) =
                args.IdentityIds <- inputList identityIds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("principalId")>]
        member _.PrincipalId((n, args), principalId) =
            let apply (args: AssignmentIdentityArgs) =
                args.PrincipalId <- input principalId
                args

            ()
            n, List.Cons(apply, args)

        member _.PrincipalId((n, args), principalId) =
            let apply (args: AssignmentIdentityArgs) =
                args.PrincipalId <- io principalId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tenantId")>]
        member _.TenantId((n, args), tenantId) =
            let apply (args: AssignmentIdentityArgs) =
                args.TenantId <- input tenantId
                args

            ()
            n, List.Cons(apply, args)

        member _.TenantId((n, args), tenantId) =
            let apply (args: AssignmentIdentityArgs) =
                args.TenantId <- io tenantId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: AssignmentIdentityArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: AssignmentIdentityArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let assignmentIdentity = AssignmentIdentityBuilder()

    type AssignmentBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Assignment(name, (List.fold func (AssignmentArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: AssignmentArgs) =
                   args.Identity <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: AssignmentArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: AssignmentArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("lockExcludePrincipals")>]
        member _.LockExcludePrincipals((name, args), lockExcludePrincipals) =
            let apply (args: AssignmentArgs) =
                args.LockExcludePrincipals <- inputList lockExcludePrincipals
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("lockMode")>]
        member _.LockMode((name, args), lockMode) =
            let apply (args: AssignmentArgs) =
                args.LockMode <- input lockMode
                args

            ()
            name, List.Cons(apply, args)

        member _.LockMode((name, args), lockMode) =
            let apply (args: AssignmentArgs) =
                args.LockMode <- io lockMode
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: AssignmentArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: AssignmentArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("parameterValues")>]
        member _.ParameterValues((name, args), parameterValues) =
            let apply (args: AssignmentArgs) =
                args.ParameterValues <- input parameterValues
                args

            ()
            name, List.Cons(apply, args)

        member _.ParameterValues((name, args), parameterValues) =
            let apply (args: AssignmentArgs) =
                args.ParameterValues <- io parameterValues
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroups")>]
        member _.ResourceGroups((name, args), resourceGroups) =
            let apply (args: AssignmentArgs) =
                args.ResourceGroups <- input resourceGroups
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroups((name, args), resourceGroups) =
            let apply (args: AssignmentArgs) =
                args.ResourceGroups <- io resourceGroups
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("targetSubscriptionId")>]
        member _.TargetSubscriptionId((name, args), targetSubscriptionId) =
            let apply (args: AssignmentArgs) =
                args.TargetSubscriptionId <- input targetSubscriptionId
                args

            ()
            name, List.Cons(apply, args)

        member _.TargetSubscriptionId((name, args), targetSubscriptionId) =
            let apply (args: AssignmentArgs) =
                args.TargetSubscriptionId <- io targetSubscriptionId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("versionId")>]
        member _.VersionId((name, args), versionId) =
            let apply (args: AssignmentArgs) =
                args.VersionId <- input versionId
                args

            ()
            name, List.Cons(apply, args)

        member _.VersionId((name, args), versionId) =
            let apply (args: AssignmentArgs) =
                args.VersionId <- io versionId
                args

            ()
            name, List.Cons(apply, args)

    let assignment = AssignmentBuilder()

module Bot =
    open Pulumi.Azure.Bot
    open Pulumi.Azure.Bot.Inputs

    type ChannelDirectLineSiteBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ChannelDirectLineSiteArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: ChannelDirectLineSiteArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: ChannelDirectLineSiteArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enhancedAuthenticationEnabled")>]
        member _.EnhancedAuthenticationEnabled((n, args), enhancedAuthenticationEnabled) =
            let apply (args: ChannelDirectLineSiteArgs) =
                args.EnhancedAuthenticationEnabled <- input enhancedAuthenticationEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.EnhancedAuthenticationEnabled((n, args), enhancedAuthenticationEnabled) =
            let apply (args: ChannelDirectLineSiteArgs) =
                args.EnhancedAuthenticationEnabled <- io enhancedAuthenticationEnabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: ChannelDirectLineSiteArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: ChannelDirectLineSiteArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("key")>]
        member _.Key((n, args), key) =
            let apply (args: ChannelDirectLineSiteArgs) =
                args.Key <- input key
                args

            ()
            n, List.Cons(apply, args)

        member _.Key((n, args), key) =
            let apply (args: ChannelDirectLineSiteArgs) =
                args.Key <- io key
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("key2")>]
        member _.Key2((n, args), key2) =
            let apply (args: ChannelDirectLineSiteArgs) =
                args.Key2 <- input key2
                args

            ()
            n, List.Cons(apply, args)

        member _.Key2((n, args), key2) =
            let apply (args: ChannelDirectLineSiteArgs) =
                args.Key2 <- io key2
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ChannelDirectLineSiteArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ChannelDirectLineSiteArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("trustedOrigins")>]
        member _.TrustedOrigins((n, args), trustedOrigins) =
            let apply (args: ChannelDirectLineSiteArgs) =
                args.TrustedOrigins <- inputList trustedOrigins
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("v1Allowed")>]
        member _.V1Allowed((n, args), v1Allowed) =
            let apply (args: ChannelDirectLineSiteArgs) =
                args.V1Allowed <- input v1Allowed
                args

            ()
            n, List.Cons(apply, args)

        member _.V1Allowed((n, args), v1Allowed) =
            let apply (args: ChannelDirectLineSiteArgs) =
                args.V1Allowed <- io v1Allowed
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("v3Allowed")>]
        member _.V3Allowed((n, args), v3Allowed) =
            let apply (args: ChannelDirectLineSiteArgs) =
                args.V3Allowed <- input v3Allowed
                args

            ()
            n, List.Cons(apply, args)

        member _.V3Allowed((n, args), v3Allowed) =
            let apply (args: ChannelDirectLineSiteArgs) =
                args.V3Allowed <- io v3Allowed
                args

            ()
            n, List.Cons(apply, args)

    let channelDirectLineSite = ChannelDirectLineSiteBuilder()

    type ChannelDirectLineBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ChannelDirectLine(name, (List.fold func (ChannelDirectLineArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("botName")>]
        member _.BotName((name, args), botName) =
            let apply (args: ChannelDirectLineArgs) =
                args.BotName <- input botName
                args

            ()
            name, List.Cons(apply, args)

        member _.BotName((name, args), botName) =
            let apply (args: ChannelDirectLineArgs) =
                args.BotName <- io botName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ChannelDirectLineArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ChannelDirectLineArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ChannelDirectLineArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ChannelDirectLineArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sites")>]
        member _.Sites((name, args), sites) =
            let apply (args: ChannelDirectLineArgs) =
                args.Sites <- inputList sites
                args

            ()
            name, List.Cons(apply, args)

    let channelDirectLine = ChannelDirectLineBuilder()

    type ChannelEmailBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ChannelEmail(name, (List.fold func (ChannelEmailArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("botName")>]
        member _.BotName((name, args), botName) =
            let apply (args: ChannelEmailArgs) =
                args.BotName <- input botName
                args

            ()
            name, List.Cons(apply, args)

        member _.BotName((name, args), botName) =
            let apply (args: ChannelEmailArgs) =
                args.BotName <- io botName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("emailAddress")>]
        member _.EmailAddress((name, args), emailAddress) =
            let apply (args: ChannelEmailArgs) =
                args.EmailAddress <- input emailAddress
                args

            ()
            name, List.Cons(apply, args)

        member _.EmailAddress((name, args), emailAddress) =
            let apply (args: ChannelEmailArgs) =
                args.EmailAddress <- io emailAddress
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("emailPassword")>]
        member _.EmailPassword((name, args), emailPassword) =
            let apply (args: ChannelEmailArgs) =
                args.EmailPassword <- input emailPassword
                args

            ()
            name, List.Cons(apply, args)

        member _.EmailPassword((name, args), emailPassword) =
            let apply (args: ChannelEmailArgs) =
                args.EmailPassword <- io emailPassword
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ChannelEmailArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ChannelEmailArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ChannelEmailArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ChannelEmailArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let channelEmail = ChannelEmailBuilder()

    type ChannelSlackBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ChannelSlack(name, (List.fold func (ChannelSlackArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("botName")>]
        member _.BotName((name, args), botName) =
            let apply (args: ChannelSlackArgs) =
                args.BotName <- input botName
                args

            ()
            name, List.Cons(apply, args)

        member _.BotName((name, args), botName) =
            let apply (args: ChannelSlackArgs) =
                args.BotName <- io botName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("clientId")>]
        member _.ClientId((name, args), clientId) =
            let apply (args: ChannelSlackArgs) =
                args.ClientId <- input clientId
                args

            ()
            name, List.Cons(apply, args)

        member _.ClientId((name, args), clientId) =
            let apply (args: ChannelSlackArgs) =
                args.ClientId <- io clientId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("clientSecret")>]
        member _.ClientSecret((name, args), clientSecret) =
            let apply (args: ChannelSlackArgs) =
                args.ClientSecret <- input clientSecret
                args

            ()
            name, List.Cons(apply, args)

        member _.ClientSecret((name, args), clientSecret) =
            let apply (args: ChannelSlackArgs) =
                args.ClientSecret <- io clientSecret
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("landingPageUrl")>]
        member _.LandingPageUrl((name, args), landingPageUrl) =
            let apply (args: ChannelSlackArgs) =
                args.LandingPageUrl <- input landingPageUrl
                args

            ()
            name, List.Cons(apply, args)

        member _.LandingPageUrl((name, args), landingPageUrl) =
            let apply (args: ChannelSlackArgs) =
                args.LandingPageUrl <- io landingPageUrl
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ChannelSlackArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ChannelSlackArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ChannelSlackArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ChannelSlackArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("verificationToken")>]
        member _.VerificationToken((name, args), verificationToken) =
            let apply (args: ChannelSlackArgs) =
                args.VerificationToken <- input verificationToken
                args

            ()
            name, List.Cons(apply, args)

        member _.VerificationToken((name, args), verificationToken) =
            let apply (args: ChannelSlackArgs) =
                args.VerificationToken <- io verificationToken
                args

            ()
            name, List.Cons(apply, args)

    let channelSlack = ChannelSlackBuilder()

    type ChannelTeamsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ChannelTeams(name, (List.fold func (ChannelTeamsArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("botName")>]
        member _.BotName((name, args), botName) =
            let apply (args: ChannelTeamsArgs) =
                args.BotName <- input botName
                args

            ()
            name, List.Cons(apply, args)

        member _.BotName((name, args), botName) =
            let apply (args: ChannelTeamsArgs) =
                args.BotName <- io botName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("callingWebHook")>]
        member _.CallingWebHook((name, args), callingWebHook) =
            let apply (args: ChannelTeamsArgs) =
                args.CallingWebHook <- input callingWebHook
                args

            ()
            name, List.Cons(apply, args)

        member _.CallingWebHook((name, args), callingWebHook) =
            let apply (args: ChannelTeamsArgs) =
                args.CallingWebHook <- io callingWebHook
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enableCalling")>]
        member _.EnableCalling((name, args), enableCalling) =
            let apply (args: ChannelTeamsArgs) =
                args.EnableCalling <- input enableCalling
                args

            ()
            name, List.Cons(apply, args)

        member _.EnableCalling((name, args), enableCalling) =
            let apply (args: ChannelTeamsArgs) =
                args.EnableCalling <- io enableCalling
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ChannelTeamsArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ChannelTeamsArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ChannelTeamsArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ChannelTeamsArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let channelTeams = ChannelTeamsBuilder()

    type ChannelsRegistrationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ChannelsRegistration(name, (List.fold func (ChannelsRegistrationArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("developerAppInsightsApiKey")>]
        member _.DeveloperAppInsightsApiKey((name, args), developerAppInsightsApiKey) =
            let apply (args: ChannelsRegistrationArgs) =
                args.DeveloperAppInsightsApiKey <- input developerAppInsightsApiKey
                args

            ()
            name, List.Cons(apply, args)

        member _.DeveloperAppInsightsApiKey((name, args), developerAppInsightsApiKey) =
            let apply (args: ChannelsRegistrationArgs) =
                args.DeveloperAppInsightsApiKey <- io developerAppInsightsApiKey
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("developerAppInsightsApplicationId")>]
        member _.DeveloperAppInsightsApplicationId((name, args), developerAppInsightsApplicationId) =
            let apply (args: ChannelsRegistrationArgs) =
                args.DeveloperAppInsightsApplicationId <- input developerAppInsightsApplicationId
                args

            ()
            name, List.Cons(apply, args)

        member _.DeveloperAppInsightsApplicationId((name, args), developerAppInsightsApplicationId) =
            let apply (args: ChannelsRegistrationArgs) =
                args.DeveloperAppInsightsApplicationId <- io developerAppInsightsApplicationId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("developerAppInsightsKey")>]
        member _.DeveloperAppInsightsKey((name, args), developerAppInsightsKey) =
            let apply (args: ChannelsRegistrationArgs) =
                args.DeveloperAppInsightsKey <- input developerAppInsightsKey
                args

            ()
            name, List.Cons(apply, args)

        member _.DeveloperAppInsightsKey((name, args), developerAppInsightsKey) =
            let apply (args: ChannelsRegistrationArgs) =
                args.DeveloperAppInsightsKey <- io developerAppInsightsKey
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("displayName")>]
        member _.DisplayName((name, args), displayName) =
            let apply (args: ChannelsRegistrationArgs) =
                args.DisplayName <- input displayName
                args

            ()
            name, List.Cons(apply, args)

        member _.DisplayName((name, args), displayName) =
            let apply (args: ChannelsRegistrationArgs) =
                args.DisplayName <- io displayName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("endpoint")>]
        member _.Endpoint((name, args), endpoint) =
            let apply (args: ChannelsRegistrationArgs) =
                args.Endpoint <- input endpoint
                args

            ()
            name, List.Cons(apply, args)

        member _.Endpoint((name, args), endpoint) =
            let apply (args: ChannelsRegistrationArgs) =
                args.Endpoint <- io endpoint
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ChannelsRegistrationArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ChannelsRegistrationArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("microsoftAppId")>]
        member _.MicrosoftAppId((name, args), microsoftAppId) =
            let apply (args: ChannelsRegistrationArgs) =
                args.MicrosoftAppId <- input microsoftAppId
                args

            ()
            name, List.Cons(apply, args)

        member _.MicrosoftAppId((name, args), microsoftAppId) =
            let apply (args: ChannelsRegistrationArgs) =
                args.MicrosoftAppId <- io microsoftAppId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ChannelsRegistrationArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ChannelsRegistrationArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ChannelsRegistrationArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ChannelsRegistrationArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sku")>]
        member _.Sku((name, args), sku) =
            let apply (args: ChannelsRegistrationArgs) =
                args.Sku <- input sku
                args

            ()
            name, List.Cons(apply, args)

        member _.Sku((name, args), sku) =
            let apply (args: ChannelsRegistrationArgs) =
                args.Sku <- io sku
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ChannelsRegistrationArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let channelsRegistration = ChannelsRegistrationBuilder()

    type ConnectionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Connection(name, (List.fold func (ConnectionArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("botName")>]
        member _.BotName((name, args), botName) =
            let apply (args: ConnectionArgs) =
                args.BotName <- input botName
                args

            ()
            name, List.Cons(apply, args)

        member _.BotName((name, args), botName) =
            let apply (args: ConnectionArgs) =
                args.BotName <- io botName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("clientId")>]
        member _.ClientId((name, args), clientId) =
            let apply (args: ConnectionArgs) =
                args.ClientId <- input clientId
                args

            ()
            name, List.Cons(apply, args)

        member _.ClientId((name, args), clientId) =
            let apply (args: ConnectionArgs) =
                args.ClientId <- io clientId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("clientSecret")>]
        member _.ClientSecret((name, args), clientSecret) =
            let apply (args: ConnectionArgs) =
                args.ClientSecret <- input clientSecret
                args

            ()
            name, List.Cons(apply, args)

        member _.ClientSecret((name, args), clientSecret) =
            let apply (args: ConnectionArgs) =
                args.ClientSecret <- io clientSecret
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ConnectionArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ConnectionArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ConnectionArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ConnectionArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("parameters")>]
        member _.Parameters((name, args), parameters) =
            let apply (args: ConnectionArgs) =
                args.Parameters <- inputMap parameters
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ConnectionArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ConnectionArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("scopes")>]
        member _.Scopes((name, args), scopes) =
            let apply (args: ConnectionArgs) =
                args.Scopes <- input scopes
                args

            ()
            name, List.Cons(apply, args)

        member _.Scopes((name, args), scopes) =
            let apply (args: ConnectionArgs) =
                args.Scopes <- io scopes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serviceProviderName")>]
        member _.ServiceProviderName((name, args), serviceProviderName) =
            let apply (args: ConnectionArgs) =
                args.ServiceProviderName <- input serviceProviderName
                args

            ()
            name, List.Cons(apply, args)

        member _.ServiceProviderName((name, args), serviceProviderName) =
            let apply (args: ConnectionArgs) =
                args.ServiceProviderName <- io serviceProviderName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ConnectionArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let connection = ConnectionBuilder()

    type WebAppBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            WebApp(name, (List.fold func (WebAppArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("developerAppInsightsApiKey")>]
        member _.DeveloperAppInsightsApiKey((name, args), developerAppInsightsApiKey) =
            let apply (args: WebAppArgs) =
                args.DeveloperAppInsightsApiKey <- input developerAppInsightsApiKey
                args

            ()
            name, List.Cons(apply, args)

        member _.DeveloperAppInsightsApiKey((name, args), developerAppInsightsApiKey) =
            let apply (args: WebAppArgs) =
                args.DeveloperAppInsightsApiKey <- io developerAppInsightsApiKey
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("developerAppInsightsApplicationId")>]
        member _.DeveloperAppInsightsApplicationId((name, args), developerAppInsightsApplicationId) =
            let apply (args: WebAppArgs) =
                args.DeveloperAppInsightsApplicationId <- input developerAppInsightsApplicationId
                args

            ()
            name, List.Cons(apply, args)

        member _.DeveloperAppInsightsApplicationId((name, args), developerAppInsightsApplicationId) =
            let apply (args: WebAppArgs) =
                args.DeveloperAppInsightsApplicationId <- io developerAppInsightsApplicationId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("developerAppInsightsKey")>]
        member _.DeveloperAppInsightsKey((name, args), developerAppInsightsKey) =
            let apply (args: WebAppArgs) =
                args.DeveloperAppInsightsKey <- input developerAppInsightsKey
                args

            ()
            name, List.Cons(apply, args)

        member _.DeveloperAppInsightsKey((name, args), developerAppInsightsKey) =
            let apply (args: WebAppArgs) =
                args.DeveloperAppInsightsKey <- io developerAppInsightsKey
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("displayName")>]
        member _.DisplayName((name, args), displayName) =
            let apply (args: WebAppArgs) =
                args.DisplayName <- input displayName
                args

            ()
            name, List.Cons(apply, args)

        member _.DisplayName((name, args), displayName) =
            let apply (args: WebAppArgs) =
                args.DisplayName <- io displayName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("endpoint")>]
        member _.Endpoint((name, args), endpoint) =
            let apply (args: WebAppArgs) =
                args.Endpoint <- input endpoint
                args

            ()
            name, List.Cons(apply, args)

        member _.Endpoint((name, args), endpoint) =
            let apply (args: WebAppArgs) =
                args.Endpoint <- io endpoint
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: WebAppArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: WebAppArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("luisAppIds")>]
        member _.LuisAppIds((name, args), luisAppIds) =
            let apply (args: WebAppArgs) =
                args.LuisAppIds <- inputList luisAppIds
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("luisKey")>]
        member _.LuisKey((name, args), luisKey) =
            let apply (args: WebAppArgs) =
                args.LuisKey <- input luisKey
                args

            ()
            name, List.Cons(apply, args)

        member _.LuisKey((name, args), luisKey) =
            let apply (args: WebAppArgs) =
                args.LuisKey <- io luisKey
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("microsoftAppId")>]
        member _.MicrosoftAppId((name, args), microsoftAppId) =
            let apply (args: WebAppArgs) =
                args.MicrosoftAppId <- input microsoftAppId
                args

            ()
            name, List.Cons(apply, args)

        member _.MicrosoftAppId((name, args), microsoftAppId) =
            let apply (args: WebAppArgs) =
                args.MicrosoftAppId <- io microsoftAppId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: WebAppArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: WebAppArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: WebAppArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: WebAppArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sku")>]
        member _.Sku((name, args), sku) =
            let apply (args: WebAppArgs) =
                args.Sku <- input sku
                args

            ()
            name, List.Cons(apply, args)

        member _.Sku((name, args), sku) =
            let apply (args: WebAppArgs) =
                args.Sku <- io sku
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: WebAppArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let webApp = WebAppBuilder()

module Cdn =
    open Pulumi.Azure.Cdn
    open Pulumi.Azure.Cdn.Inputs

    type EndpointDeliveryRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointDeliveryRuleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: EndpointDeliveryRuleArgs) =
                   args.CacheExpirationAction <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: EndpointDeliveryRuleArgs) =
                   args.CacheKeyQueryStringAction <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("cookiesConditions")>]
        member _.CookiesConditions((n, args), cookiesConditions) =
            let apply (args: EndpointDeliveryRuleArgs) =
                args.CookiesConditions <- inputList cookiesConditions
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: EndpointDeliveryRuleArgs) =
                   args.DeviceCondition <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("httpVersionConditions")>]
        member _.HttpVersionConditions((n, args), httpVersionConditions) =
            let apply (args: EndpointDeliveryRuleArgs) =
                args.HttpVersionConditions <- inputList httpVersionConditions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("modifyRequestHeaderActions")>]
        member _.ModifyRequestHeaderActions((n, args), modifyRequestHeaderActions) =
            let apply (args: EndpointDeliveryRuleArgs) =
                args.ModifyRequestHeaderActions <- inputList modifyRequestHeaderActions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("modifyResponseHeaderActions")>]
        member _.ModifyResponseHeaderActions((n, args), modifyResponseHeaderActions) =
            let apply (args: EndpointDeliveryRuleArgs) =
                args.ModifyResponseHeaderActions <- inputList modifyResponseHeaderActions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: EndpointDeliveryRuleArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: EndpointDeliveryRuleArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("order")>]
        member _.Order((n, args), order) =
            let apply (args: EndpointDeliveryRuleArgs) =
                args.Order <- input order
                args

            ()
            n, List.Cons(apply, args)

        member _.Order((n, args), order) =
            let apply (args: EndpointDeliveryRuleArgs) =
                args.Order <- io order
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("postArgConditions")>]
        member _.PostArgConditions((n, args), postArgConditions) =
            let apply (args: EndpointDeliveryRuleArgs) =
                args.PostArgConditions <- inputList postArgConditions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("queryStringConditions")>]
        member _.QueryStringConditions((n, args), queryStringConditions) =
            let apply (args: EndpointDeliveryRuleArgs) =
                args.QueryStringConditions <- inputList queryStringConditions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("remoteAddressConditions")>]
        member _.RemoteAddressConditions((n, args), remoteAddressConditions) =
            let apply (args: EndpointDeliveryRuleArgs) =
                args.RemoteAddressConditions <- inputList remoteAddressConditions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("requestBodyConditions")>]
        member _.RequestBodyConditions((n, args), requestBodyConditions) =
            let apply (args: EndpointDeliveryRuleArgs) =
                args.RequestBodyConditions <- inputList requestBodyConditions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("requestHeaderConditions")>]
        member _.RequestHeaderConditions((n, args), requestHeaderConditions) =
            let apply (args: EndpointDeliveryRuleArgs) =
                args.RequestHeaderConditions <- inputList requestHeaderConditions
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: EndpointDeliveryRuleArgs) =
                   args.RequestMethodCondition <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: EndpointDeliveryRuleArgs) =
                   args.RequestSchemeCondition <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("requestUriConditions")>]
        member _.RequestUriConditions((n, args), requestUriConditions) =
            let apply (args: EndpointDeliveryRuleArgs) =
                args.RequestUriConditions <- inputList requestUriConditions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("urlFileExtensionConditions")>]
        member _.UrlFileExtensionConditions((n, args), urlFileExtensionConditions) =
            let apply (args: EndpointDeliveryRuleArgs) =
                args.UrlFileExtensionConditions <- inputList urlFileExtensionConditions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("urlFileNameConditions")>]
        member _.UrlFileNameConditions((n, args), urlFileNameConditions) =
            let apply (args: EndpointDeliveryRuleArgs) =
                args.UrlFileNameConditions <- inputList urlFileNameConditions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("urlPathConditions")>]
        member _.UrlPathConditions((n, args), urlPathConditions) =
            let apply (args: EndpointDeliveryRuleArgs) =
                args.UrlPathConditions <- inputList urlPathConditions
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: EndpointDeliveryRuleArgs) =
                   args.UrlRedirectAction <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: EndpointDeliveryRuleArgs) =
                   args.UrlRewriteAction <- input arg
                   args

               ()
               func) ]

    let endpointDeliveryRule = EndpointDeliveryRuleBuilder()

    type EndpointDeliveryRuleCacheExpirationActionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointDeliveryRuleCacheExpirationActionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("behavior")>]
        member _.Behavior((n, args), behavior) =
            let apply (args: EndpointDeliveryRuleCacheExpirationActionArgs) =
                args.Behavior <- input behavior
                args

            ()
            n, List.Cons(apply, args)

        member _.Behavior((n, args), behavior) =
            let apply (args: EndpointDeliveryRuleCacheExpirationActionArgs) =
                args.Behavior <- io behavior
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("duration")>]
        member _.Duration((n, args), duration) =
            let apply (args: EndpointDeliveryRuleCacheExpirationActionArgs) =
                args.Duration <- input duration
                args

            ()
            n, List.Cons(apply, args)

        member _.Duration((n, args), duration) =
            let apply (args: EndpointDeliveryRuleCacheExpirationActionArgs) =
                args.Duration <- io duration
                args

            ()
            n, List.Cons(apply, args)

    let endpointDeliveryRuleCacheExpirationAction =
        EndpointDeliveryRuleCacheExpirationActionBuilder()

    type EndpointDeliveryRuleCacheKeyQueryStringActionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointDeliveryRuleCacheKeyQueryStringActionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("behavior")>]
        member _.Behavior((n, args), behavior) =
            let apply (args: EndpointDeliveryRuleCacheKeyQueryStringActionArgs) =
                args.Behavior <- input behavior
                args

            ()
            n, List.Cons(apply, args)

        member _.Behavior((n, args), behavior) =
            let apply (args: EndpointDeliveryRuleCacheKeyQueryStringActionArgs) =
                args.Behavior <- io behavior
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("parameters")>]
        member _.Parameters((n, args), parameters) =
            let apply (args: EndpointDeliveryRuleCacheKeyQueryStringActionArgs) =
                args.Parameters <- input parameters
                args

            ()
            n, List.Cons(apply, args)

        member _.Parameters((n, args), parameters) =
            let apply (args: EndpointDeliveryRuleCacheKeyQueryStringActionArgs) =
                args.Parameters <- io parameters
                args

            ()
            n, List.Cons(apply, args)

    let endpointDeliveryRuleCacheKeyQueryStringAction =
        EndpointDeliveryRuleCacheKeyQueryStringActionBuilder()

    type EndpointDeliveryRuleCookiesConditionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointDeliveryRuleCookiesConditionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("matchValues")>]
        member _.MatchValues((n, args), matchValues) =
            let apply (args: EndpointDeliveryRuleCookiesConditionArgs) =
                args.MatchValues <- inputList matchValues
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("negateCondition")>]
        member _.NegateCondition((n, args), negateCondition) =
            let apply (args: EndpointDeliveryRuleCookiesConditionArgs) =
                args.NegateCondition <- input negateCondition
                args

            ()
            n, List.Cons(apply, args)

        member _.NegateCondition((n, args), negateCondition) =
            let apply (args: EndpointDeliveryRuleCookiesConditionArgs) =
                args.NegateCondition <- io negateCondition
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: EndpointDeliveryRuleCookiesConditionArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: EndpointDeliveryRuleCookiesConditionArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("selector")>]
        member _.Selector((n, args), selector) =
            let apply (args: EndpointDeliveryRuleCookiesConditionArgs) =
                args.Selector <- input selector
                args

            ()
            n, List.Cons(apply, args)

        member _.Selector((n, args), selector) =
            let apply (args: EndpointDeliveryRuleCookiesConditionArgs) =
                args.Selector <- io selector
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("transforms")>]
        member _.Transforms((n, args), transforms) =
            let apply (args: EndpointDeliveryRuleCookiesConditionArgs) =
                args.Transforms <- inputList transforms
                args

            ()
            n, List.Cons(apply, args)

    let endpointDeliveryRuleCookiesCondition =
        EndpointDeliveryRuleCookiesConditionBuilder()

    type EndpointDeliveryRuleDeviceConditionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointDeliveryRuleDeviceConditionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("matchValues")>]
        member _.MatchValues((n, args), matchValues) =
            let apply (args: EndpointDeliveryRuleDeviceConditionArgs) =
                args.MatchValues <- inputList matchValues
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("negateCondition")>]
        member _.NegateCondition((n, args), negateCondition) =
            let apply (args: EndpointDeliveryRuleDeviceConditionArgs) =
                args.NegateCondition <- input negateCondition
                args

            ()
            n, List.Cons(apply, args)

        member _.NegateCondition((n, args), negateCondition) =
            let apply (args: EndpointDeliveryRuleDeviceConditionArgs) =
                args.NegateCondition <- io negateCondition
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: EndpointDeliveryRuleDeviceConditionArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: EndpointDeliveryRuleDeviceConditionArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

    let endpointDeliveryRuleDeviceCondition =
        EndpointDeliveryRuleDeviceConditionBuilder()

    type EndpointDeliveryRuleHttpVersionConditionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointDeliveryRuleHttpVersionConditionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("matchValues")>]
        member _.MatchValues((n, args), matchValues) =
            let apply (args: EndpointDeliveryRuleHttpVersionConditionArgs) =
                args.MatchValues <- inputList matchValues
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("negateCondition")>]
        member _.NegateCondition((n, args), negateCondition) =
            let apply (args: EndpointDeliveryRuleHttpVersionConditionArgs) =
                args.NegateCondition <- input negateCondition
                args

            ()
            n, List.Cons(apply, args)

        member _.NegateCondition((n, args), negateCondition) =
            let apply (args: EndpointDeliveryRuleHttpVersionConditionArgs) =
                args.NegateCondition <- io negateCondition
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: EndpointDeliveryRuleHttpVersionConditionArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: EndpointDeliveryRuleHttpVersionConditionArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

    let endpointDeliveryRuleHttpVersionCondition =
        EndpointDeliveryRuleHttpVersionConditionBuilder()

    type EndpointDeliveryRuleModifyRequestHeaderActionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointDeliveryRuleModifyRequestHeaderActionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("action")>]
        member _.Action((n, args), action) =
            let apply (args: EndpointDeliveryRuleModifyRequestHeaderActionArgs) =
                args.Action <- input action
                args

            ()
            n, List.Cons(apply, args)

        member _.Action((n, args), action) =
            let apply (args: EndpointDeliveryRuleModifyRequestHeaderActionArgs) =
                args.Action <- io action
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: EndpointDeliveryRuleModifyRequestHeaderActionArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: EndpointDeliveryRuleModifyRequestHeaderActionArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((n, args), value) =
            let apply (args: EndpointDeliveryRuleModifyRequestHeaderActionArgs) =
                args.Value <- input value
                args

            ()
            n, List.Cons(apply, args)

        member _.Value((n, args), value) =
            let apply (args: EndpointDeliveryRuleModifyRequestHeaderActionArgs) =
                args.Value <- io value
                args

            ()
            n, List.Cons(apply, args)

    let endpointDeliveryRuleModifyRequestHeaderAction =
        EndpointDeliveryRuleModifyRequestHeaderActionBuilder()

    type EndpointDeliveryRuleModifyResponseHeaderActionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointDeliveryRuleModifyResponseHeaderActionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("action")>]
        member _.Action((n, args), action) =
            let apply (args: EndpointDeliveryRuleModifyResponseHeaderActionArgs) =
                args.Action <- input action
                args

            ()
            n, List.Cons(apply, args)

        member _.Action((n, args), action) =
            let apply (args: EndpointDeliveryRuleModifyResponseHeaderActionArgs) =
                args.Action <- io action
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: EndpointDeliveryRuleModifyResponseHeaderActionArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: EndpointDeliveryRuleModifyResponseHeaderActionArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((n, args), value) =
            let apply (args: EndpointDeliveryRuleModifyResponseHeaderActionArgs) =
                args.Value <- input value
                args

            ()
            n, List.Cons(apply, args)

        member _.Value((n, args), value) =
            let apply (args: EndpointDeliveryRuleModifyResponseHeaderActionArgs) =
                args.Value <- io value
                args

            ()
            n, List.Cons(apply, args)

    let endpointDeliveryRuleModifyResponseHeaderAction =
        EndpointDeliveryRuleModifyResponseHeaderActionBuilder()

    type EndpointDeliveryRulePostArgConditionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointDeliveryRulePostArgConditionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("matchValues")>]
        member _.MatchValues((n, args), matchValues) =
            let apply (args: EndpointDeliveryRulePostArgConditionArgs) =
                args.MatchValues <- inputList matchValues
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("negateCondition")>]
        member _.NegateCondition((n, args), negateCondition) =
            let apply (args: EndpointDeliveryRulePostArgConditionArgs) =
                args.NegateCondition <- input negateCondition
                args

            ()
            n, List.Cons(apply, args)

        member _.NegateCondition((n, args), negateCondition) =
            let apply (args: EndpointDeliveryRulePostArgConditionArgs) =
                args.NegateCondition <- io negateCondition
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: EndpointDeliveryRulePostArgConditionArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: EndpointDeliveryRulePostArgConditionArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("selector")>]
        member _.Selector((n, args), selector) =
            let apply (args: EndpointDeliveryRulePostArgConditionArgs) =
                args.Selector <- input selector
                args

            ()
            n, List.Cons(apply, args)

        member _.Selector((n, args), selector) =
            let apply (args: EndpointDeliveryRulePostArgConditionArgs) =
                args.Selector <- io selector
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("transforms")>]
        member _.Transforms((n, args), transforms) =
            let apply (args: EndpointDeliveryRulePostArgConditionArgs) =
                args.Transforms <- inputList transforms
                args

            ()
            n, List.Cons(apply, args)

    let endpointDeliveryRulePostArgCondition =
        EndpointDeliveryRulePostArgConditionBuilder()

    type EndpointDeliveryRuleQueryStringConditionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointDeliveryRuleQueryStringConditionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("matchValues")>]
        member _.MatchValues((n, args), matchValues) =
            let apply (args: EndpointDeliveryRuleQueryStringConditionArgs) =
                args.MatchValues <- inputList matchValues
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("negateCondition")>]
        member _.NegateCondition((n, args), negateCondition) =
            let apply (args: EndpointDeliveryRuleQueryStringConditionArgs) =
                args.NegateCondition <- input negateCondition
                args

            ()
            n, List.Cons(apply, args)

        member _.NegateCondition((n, args), negateCondition) =
            let apply (args: EndpointDeliveryRuleQueryStringConditionArgs) =
                args.NegateCondition <- io negateCondition
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: EndpointDeliveryRuleQueryStringConditionArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: EndpointDeliveryRuleQueryStringConditionArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("transforms")>]
        member _.Transforms((n, args), transforms) =
            let apply (args: EndpointDeliveryRuleQueryStringConditionArgs) =
                args.Transforms <- inputList transforms
                args

            ()
            n, List.Cons(apply, args)

    let endpointDeliveryRuleQueryStringCondition =
        EndpointDeliveryRuleQueryStringConditionBuilder()

    type EndpointDeliveryRuleRemoteAddressConditionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointDeliveryRuleRemoteAddressConditionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("matchValues")>]
        member _.MatchValues((n, args), matchValues) =
            let apply (args: EndpointDeliveryRuleRemoteAddressConditionArgs) =
                args.MatchValues <- inputList matchValues
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("negateCondition")>]
        member _.NegateCondition((n, args), negateCondition) =
            let apply (args: EndpointDeliveryRuleRemoteAddressConditionArgs) =
                args.NegateCondition <- input negateCondition
                args

            ()
            n, List.Cons(apply, args)

        member _.NegateCondition((n, args), negateCondition) =
            let apply (args: EndpointDeliveryRuleRemoteAddressConditionArgs) =
                args.NegateCondition <- io negateCondition
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: EndpointDeliveryRuleRemoteAddressConditionArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: EndpointDeliveryRuleRemoteAddressConditionArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

    let endpointDeliveryRuleRemoteAddressCondition =
        EndpointDeliveryRuleRemoteAddressConditionBuilder()

    type EndpointDeliveryRuleRequestBodyConditionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointDeliveryRuleRequestBodyConditionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("matchValues")>]
        member _.MatchValues((n, args), matchValues) =
            let apply (args: EndpointDeliveryRuleRequestBodyConditionArgs) =
                args.MatchValues <- inputList matchValues
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("negateCondition")>]
        member _.NegateCondition((n, args), negateCondition) =
            let apply (args: EndpointDeliveryRuleRequestBodyConditionArgs) =
                args.NegateCondition <- input negateCondition
                args

            ()
            n, List.Cons(apply, args)

        member _.NegateCondition((n, args), negateCondition) =
            let apply (args: EndpointDeliveryRuleRequestBodyConditionArgs) =
                args.NegateCondition <- io negateCondition
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: EndpointDeliveryRuleRequestBodyConditionArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: EndpointDeliveryRuleRequestBodyConditionArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("transforms")>]
        member _.Transforms((n, args), transforms) =
            let apply (args: EndpointDeliveryRuleRequestBodyConditionArgs) =
                args.Transforms <- inputList transforms
                args

            ()
            n, List.Cons(apply, args)

    let endpointDeliveryRuleRequestBodyCondition =
        EndpointDeliveryRuleRequestBodyConditionBuilder()

    type EndpointDeliveryRuleRequestHeaderConditionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointDeliveryRuleRequestHeaderConditionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("matchValues")>]
        member _.MatchValues((n, args), matchValues) =
            let apply (args: EndpointDeliveryRuleRequestHeaderConditionArgs) =
                args.MatchValues <- inputList matchValues
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("negateCondition")>]
        member _.NegateCondition((n, args), negateCondition) =
            let apply (args: EndpointDeliveryRuleRequestHeaderConditionArgs) =
                args.NegateCondition <- input negateCondition
                args

            ()
            n, List.Cons(apply, args)

        member _.NegateCondition((n, args), negateCondition) =
            let apply (args: EndpointDeliveryRuleRequestHeaderConditionArgs) =
                args.NegateCondition <- io negateCondition
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: EndpointDeliveryRuleRequestHeaderConditionArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: EndpointDeliveryRuleRequestHeaderConditionArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("selector")>]
        member _.Selector((n, args), selector) =
            let apply (args: EndpointDeliveryRuleRequestHeaderConditionArgs) =
                args.Selector <- input selector
                args

            ()
            n, List.Cons(apply, args)

        member _.Selector((n, args), selector) =
            let apply (args: EndpointDeliveryRuleRequestHeaderConditionArgs) =
                args.Selector <- io selector
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("transforms")>]
        member _.Transforms((n, args), transforms) =
            let apply (args: EndpointDeliveryRuleRequestHeaderConditionArgs) =
                args.Transforms <- inputList transforms
                args

            ()
            n, List.Cons(apply, args)

    let endpointDeliveryRuleRequestHeaderCondition =
        EndpointDeliveryRuleRequestHeaderConditionBuilder()

    type EndpointDeliveryRuleRequestMethodConditionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointDeliveryRuleRequestMethodConditionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("matchValues")>]
        member _.MatchValues((n, args), matchValues) =
            let apply (args: EndpointDeliveryRuleRequestMethodConditionArgs) =
                args.MatchValues <- inputList matchValues
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("negateCondition")>]
        member _.NegateCondition((n, args), negateCondition) =
            let apply (args: EndpointDeliveryRuleRequestMethodConditionArgs) =
                args.NegateCondition <- input negateCondition
                args

            ()
            n, List.Cons(apply, args)

        member _.NegateCondition((n, args), negateCondition) =
            let apply (args: EndpointDeliveryRuleRequestMethodConditionArgs) =
                args.NegateCondition <- io negateCondition
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: EndpointDeliveryRuleRequestMethodConditionArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: EndpointDeliveryRuleRequestMethodConditionArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

    let endpointDeliveryRuleRequestMethodCondition =
        EndpointDeliveryRuleRequestMethodConditionBuilder()

    type EndpointDeliveryRuleRequestSchemeConditionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointDeliveryRuleRequestSchemeConditionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("matchValues")>]
        member _.MatchValues((n, args), matchValues) =
            let apply (args: EndpointDeliveryRuleRequestSchemeConditionArgs) =
                args.MatchValues <- inputList matchValues
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("negateCondition")>]
        member _.NegateCondition((n, args), negateCondition) =
            let apply (args: EndpointDeliveryRuleRequestSchemeConditionArgs) =
                args.NegateCondition <- input negateCondition
                args

            ()
            n, List.Cons(apply, args)

        member _.NegateCondition((n, args), negateCondition) =
            let apply (args: EndpointDeliveryRuleRequestSchemeConditionArgs) =
                args.NegateCondition <- io negateCondition
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: EndpointDeliveryRuleRequestSchemeConditionArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: EndpointDeliveryRuleRequestSchemeConditionArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

    let endpointDeliveryRuleRequestSchemeCondition =
        EndpointDeliveryRuleRequestSchemeConditionBuilder()

    type EndpointDeliveryRuleRequestUriConditionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointDeliveryRuleRequestUriConditionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("matchValues")>]
        member _.MatchValues((n, args), matchValues) =
            let apply (args: EndpointDeliveryRuleRequestUriConditionArgs) =
                args.MatchValues <- inputList matchValues
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("negateCondition")>]
        member _.NegateCondition((n, args), negateCondition) =
            let apply (args: EndpointDeliveryRuleRequestUriConditionArgs) =
                args.NegateCondition <- input negateCondition
                args

            ()
            n, List.Cons(apply, args)

        member _.NegateCondition((n, args), negateCondition) =
            let apply (args: EndpointDeliveryRuleRequestUriConditionArgs) =
                args.NegateCondition <- io negateCondition
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: EndpointDeliveryRuleRequestUriConditionArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: EndpointDeliveryRuleRequestUriConditionArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("transforms")>]
        member _.Transforms((n, args), transforms) =
            let apply (args: EndpointDeliveryRuleRequestUriConditionArgs) =
                args.Transforms <- inputList transforms
                args

            ()
            n, List.Cons(apply, args)

    let endpointDeliveryRuleRequestUriCondition =
        EndpointDeliveryRuleRequestUriConditionBuilder()

    type EndpointDeliveryRuleUrlFileExtensionConditionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointDeliveryRuleUrlFileExtensionConditionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("matchValues")>]
        member _.MatchValues((n, args), matchValues) =
            let apply (args: EndpointDeliveryRuleUrlFileExtensionConditionArgs) =
                args.MatchValues <- inputList matchValues
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("negateCondition")>]
        member _.NegateCondition((n, args), negateCondition) =
            let apply (args: EndpointDeliveryRuleUrlFileExtensionConditionArgs) =
                args.NegateCondition <- input negateCondition
                args

            ()
            n, List.Cons(apply, args)

        member _.NegateCondition((n, args), negateCondition) =
            let apply (args: EndpointDeliveryRuleUrlFileExtensionConditionArgs) =
                args.NegateCondition <- io negateCondition
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: EndpointDeliveryRuleUrlFileExtensionConditionArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: EndpointDeliveryRuleUrlFileExtensionConditionArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("transforms")>]
        member _.Transforms((n, args), transforms) =
            let apply (args: EndpointDeliveryRuleUrlFileExtensionConditionArgs) =
                args.Transforms <- inputList transforms
                args

            ()
            n, List.Cons(apply, args)

    let endpointDeliveryRuleUrlFileExtensionCondition =
        EndpointDeliveryRuleUrlFileExtensionConditionBuilder()

    type EndpointDeliveryRuleUrlFileNameConditionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointDeliveryRuleUrlFileNameConditionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("matchValues")>]
        member _.MatchValues((n, args), matchValues) =
            let apply (args: EndpointDeliveryRuleUrlFileNameConditionArgs) =
                args.MatchValues <- inputList matchValues
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("negateCondition")>]
        member _.NegateCondition((n, args), negateCondition) =
            let apply (args: EndpointDeliveryRuleUrlFileNameConditionArgs) =
                args.NegateCondition <- input negateCondition
                args

            ()
            n, List.Cons(apply, args)

        member _.NegateCondition((n, args), negateCondition) =
            let apply (args: EndpointDeliveryRuleUrlFileNameConditionArgs) =
                args.NegateCondition <- io negateCondition
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: EndpointDeliveryRuleUrlFileNameConditionArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: EndpointDeliveryRuleUrlFileNameConditionArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("transforms")>]
        member _.Transforms((n, args), transforms) =
            let apply (args: EndpointDeliveryRuleUrlFileNameConditionArgs) =
                args.Transforms <- inputList transforms
                args

            ()
            n, List.Cons(apply, args)

    let endpointDeliveryRuleUrlFileNameCondition =
        EndpointDeliveryRuleUrlFileNameConditionBuilder()

    type EndpointDeliveryRuleUrlPathConditionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointDeliveryRuleUrlPathConditionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("matchValues")>]
        member _.MatchValues((n, args), matchValues) =
            let apply (args: EndpointDeliveryRuleUrlPathConditionArgs) =
                args.MatchValues <- inputList matchValues
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("negateCondition")>]
        member _.NegateCondition((n, args), negateCondition) =
            let apply (args: EndpointDeliveryRuleUrlPathConditionArgs) =
                args.NegateCondition <- input negateCondition
                args

            ()
            n, List.Cons(apply, args)

        member _.NegateCondition((n, args), negateCondition) =
            let apply (args: EndpointDeliveryRuleUrlPathConditionArgs) =
                args.NegateCondition <- io negateCondition
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: EndpointDeliveryRuleUrlPathConditionArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: EndpointDeliveryRuleUrlPathConditionArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("transforms")>]
        member _.Transforms((n, args), transforms) =
            let apply (args: EndpointDeliveryRuleUrlPathConditionArgs) =
                args.Transforms <- inputList transforms
                args

            ()
            n, List.Cons(apply, args)

    let endpointDeliveryRuleUrlPathCondition =
        EndpointDeliveryRuleUrlPathConditionBuilder()

    type EndpointDeliveryRuleUrlRedirectActionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointDeliveryRuleUrlRedirectActionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("fragment")>]
        member _.Fragment((n, args), fragment) =
            let apply (args: EndpointDeliveryRuleUrlRedirectActionArgs) =
                args.Fragment <- input fragment
                args

            ()
            n, List.Cons(apply, args)

        member _.Fragment((n, args), fragment) =
            let apply (args: EndpointDeliveryRuleUrlRedirectActionArgs) =
                args.Fragment <- io fragment
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("hostname")>]
        member _.Hostname((n, args), hostname) =
            let apply (args: EndpointDeliveryRuleUrlRedirectActionArgs) =
                args.Hostname <- input hostname
                args

            ()
            n, List.Cons(apply, args)

        member _.Hostname((n, args), hostname) =
            let apply (args: EndpointDeliveryRuleUrlRedirectActionArgs) =
                args.Hostname <- io hostname
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("path")>]
        member _.Path((n, args), path) =
            let apply (args: EndpointDeliveryRuleUrlRedirectActionArgs) =
                args.Path <- input path
                args

            ()
            n, List.Cons(apply, args)

        member _.Path((n, args), path) =
            let apply (args: EndpointDeliveryRuleUrlRedirectActionArgs) =
                args.Path <- io path
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("protocol")>]
        member _.Protocol((n, args), protocol) =
            let apply (args: EndpointDeliveryRuleUrlRedirectActionArgs) =
                args.Protocol <- input protocol
                args

            ()
            n, List.Cons(apply, args)

        member _.Protocol((n, args), protocol) =
            let apply (args: EndpointDeliveryRuleUrlRedirectActionArgs) =
                args.Protocol <- io protocol
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("queryString")>]
        member _.QueryString((n, args), queryString) =
            let apply (args: EndpointDeliveryRuleUrlRedirectActionArgs) =
                args.QueryString <- input queryString
                args

            ()
            n, List.Cons(apply, args)

        member _.QueryString((n, args), queryString) =
            let apply (args: EndpointDeliveryRuleUrlRedirectActionArgs) =
                args.QueryString <- io queryString
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("redirectType")>]
        member _.RedirectType((n, args), redirectType) =
            let apply (args: EndpointDeliveryRuleUrlRedirectActionArgs) =
                args.RedirectType <- input redirectType
                args

            ()
            n, List.Cons(apply, args)

        member _.RedirectType((n, args), redirectType) =
            let apply (args: EndpointDeliveryRuleUrlRedirectActionArgs) =
                args.RedirectType <- io redirectType
                args

            ()
            n, List.Cons(apply, args)

    let endpointDeliveryRuleUrlRedirectAction =
        EndpointDeliveryRuleUrlRedirectActionBuilder()

    type EndpointDeliveryRuleUrlRewriteActionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointDeliveryRuleUrlRewriteActionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("destination")>]
        member _.Destination((n, args), destination) =
            let apply (args: EndpointDeliveryRuleUrlRewriteActionArgs) =
                args.Destination <- input destination
                args

            ()
            n, List.Cons(apply, args)

        member _.Destination((n, args), destination) =
            let apply (args: EndpointDeliveryRuleUrlRewriteActionArgs) =
                args.Destination <- io destination
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("preserveUnmatchedPath")>]
        member _.PreserveUnmatchedPath((n, args), preserveUnmatchedPath) =
            let apply (args: EndpointDeliveryRuleUrlRewriteActionArgs) =
                args.PreserveUnmatchedPath <- input preserveUnmatchedPath
                args

            ()
            n, List.Cons(apply, args)

        member _.PreserveUnmatchedPath((n, args), preserveUnmatchedPath) =
            let apply (args: EndpointDeliveryRuleUrlRewriteActionArgs) =
                args.PreserveUnmatchedPath <- io preserveUnmatchedPath
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sourcePattern")>]
        member _.SourcePattern((n, args), sourcePattern) =
            let apply (args: EndpointDeliveryRuleUrlRewriteActionArgs) =
                args.SourcePattern <- input sourcePattern
                args

            ()
            n, List.Cons(apply, args)

        member _.SourcePattern((n, args), sourcePattern) =
            let apply (args: EndpointDeliveryRuleUrlRewriteActionArgs) =
                args.SourcePattern <- io sourcePattern
                args

            ()
            n, List.Cons(apply, args)

    let endpointDeliveryRuleUrlRewriteAction =
        EndpointDeliveryRuleUrlRewriteActionBuilder()

    type EndpointGeoFilterBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointGeoFilterArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("action")>]
        member _.Action((n, args), action) =
            let apply (args: EndpointGeoFilterArgs) =
                args.Action <- input action
                args

            ()
            n, List.Cons(apply, args)

        member _.Action((n, args), action) =
            let apply (args: EndpointGeoFilterArgs) =
                args.Action <- io action
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("countryCodes")>]
        member _.CountryCodes((n, args), countryCodes) =
            let apply (args: EndpointGeoFilterArgs) =
                args.CountryCodes <- inputList countryCodes
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("relativePath")>]
        member _.RelativePath((n, args), relativePath) =
            let apply (args: EndpointGeoFilterArgs) =
                args.RelativePath <- input relativePath
                args

            ()
            n, List.Cons(apply, args)

        member _.RelativePath((n, args), relativePath) =
            let apply (args: EndpointGeoFilterArgs) =
                args.RelativePath <- io relativePath
                args

            ()
            n, List.Cons(apply, args)

    let endpointGeoFilter = EndpointGeoFilterBuilder()

    type EndpointGlobalDeliveryRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointGlobalDeliveryRuleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: EndpointGlobalDeliveryRuleArgs) =
                   args.CacheExpirationAction <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: EndpointGlobalDeliveryRuleArgs) =
                   args.CacheKeyQueryStringAction <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("modifyRequestHeaderActions")>]
        member _.ModifyRequestHeaderActions((n, args), modifyRequestHeaderActions) =
            let apply (args: EndpointGlobalDeliveryRuleArgs) =
                args.ModifyRequestHeaderActions <- inputList modifyRequestHeaderActions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("modifyResponseHeaderActions")>]
        member _.ModifyResponseHeaderActions((n, args), modifyResponseHeaderActions) =
            let apply (args: EndpointGlobalDeliveryRuleArgs) =
                args.ModifyResponseHeaderActions <- inputList modifyResponseHeaderActions
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: EndpointGlobalDeliveryRuleArgs) =
                   args.UrlRedirectAction <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: EndpointGlobalDeliveryRuleArgs) =
                   args.UrlRewriteAction <- input arg
                   args

               ()
               func) ]

    let endpointGlobalDeliveryRule = EndpointGlobalDeliveryRuleBuilder()

    type EndpointGlobalDeliveryRuleCacheExpirationActionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointGlobalDeliveryRuleCacheExpirationActionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("behavior")>]
        member _.Behavior((n, args), behavior) =
            let apply (args: EndpointGlobalDeliveryRuleCacheExpirationActionArgs) =
                args.Behavior <- input behavior
                args

            ()
            n, List.Cons(apply, args)

        member _.Behavior((n, args), behavior) =
            let apply (args: EndpointGlobalDeliveryRuleCacheExpirationActionArgs) =
                args.Behavior <- io behavior
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("duration")>]
        member _.Duration((n, args), duration) =
            let apply (args: EndpointGlobalDeliveryRuleCacheExpirationActionArgs) =
                args.Duration <- input duration
                args

            ()
            n, List.Cons(apply, args)

        member _.Duration((n, args), duration) =
            let apply (args: EndpointGlobalDeliveryRuleCacheExpirationActionArgs) =
                args.Duration <- io duration
                args

            ()
            n, List.Cons(apply, args)

    let endpointGlobalDeliveryRuleCacheExpirationAction =
        EndpointGlobalDeliveryRuleCacheExpirationActionBuilder()

    type EndpointGlobalDeliveryRuleCacheKeyQueryStringActionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointGlobalDeliveryRuleCacheKeyQueryStringActionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("behavior")>]
        member _.Behavior((n, args), behavior) =
            let apply (args: EndpointGlobalDeliveryRuleCacheKeyQueryStringActionArgs) =
                args.Behavior <- input behavior
                args

            ()
            n, List.Cons(apply, args)

        member _.Behavior((n, args), behavior) =
            let apply (args: EndpointGlobalDeliveryRuleCacheKeyQueryStringActionArgs) =
                args.Behavior <- io behavior
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("parameters")>]
        member _.Parameters((n, args), parameters) =
            let apply (args: EndpointGlobalDeliveryRuleCacheKeyQueryStringActionArgs) =
                args.Parameters <- input parameters
                args

            ()
            n, List.Cons(apply, args)

        member _.Parameters((n, args), parameters) =
            let apply (args: EndpointGlobalDeliveryRuleCacheKeyQueryStringActionArgs) =
                args.Parameters <- io parameters
                args

            ()
            n, List.Cons(apply, args)

    let endpointGlobalDeliveryRuleCacheKeyQueryStringAction =
        EndpointGlobalDeliveryRuleCacheKeyQueryStringActionBuilder()

    type EndpointGlobalDeliveryRuleModifyRequestHeaderActionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointGlobalDeliveryRuleModifyRequestHeaderActionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("action")>]
        member _.Action((n, args), action) =
            let apply (args: EndpointGlobalDeliveryRuleModifyRequestHeaderActionArgs) =
                args.Action <- input action
                args

            ()
            n, List.Cons(apply, args)

        member _.Action((n, args), action) =
            let apply (args: EndpointGlobalDeliveryRuleModifyRequestHeaderActionArgs) =
                args.Action <- io action
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: EndpointGlobalDeliveryRuleModifyRequestHeaderActionArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: EndpointGlobalDeliveryRuleModifyRequestHeaderActionArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((n, args), value) =
            let apply (args: EndpointGlobalDeliveryRuleModifyRequestHeaderActionArgs) =
                args.Value <- input value
                args

            ()
            n, List.Cons(apply, args)

        member _.Value((n, args), value) =
            let apply (args: EndpointGlobalDeliveryRuleModifyRequestHeaderActionArgs) =
                args.Value <- io value
                args

            ()
            n, List.Cons(apply, args)

    let endpointGlobalDeliveryRuleModifyRequestHeaderAction =
        EndpointGlobalDeliveryRuleModifyRequestHeaderActionBuilder()

    type EndpointGlobalDeliveryRuleModifyResponseHeaderActionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointGlobalDeliveryRuleModifyResponseHeaderActionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("action")>]
        member _.Action((n, args), action) =
            let apply (args: EndpointGlobalDeliveryRuleModifyResponseHeaderActionArgs) =
                args.Action <- input action
                args

            ()
            n, List.Cons(apply, args)

        member _.Action((n, args), action) =
            let apply (args: EndpointGlobalDeliveryRuleModifyResponseHeaderActionArgs) =
                args.Action <- io action
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: EndpointGlobalDeliveryRuleModifyResponseHeaderActionArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: EndpointGlobalDeliveryRuleModifyResponseHeaderActionArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((n, args), value) =
            let apply (args: EndpointGlobalDeliveryRuleModifyResponseHeaderActionArgs) =
                args.Value <- input value
                args

            ()
            n, List.Cons(apply, args)

        member _.Value((n, args), value) =
            let apply (args: EndpointGlobalDeliveryRuleModifyResponseHeaderActionArgs) =
                args.Value <- io value
                args

            ()
            n, List.Cons(apply, args)

    let endpointGlobalDeliveryRuleModifyResponseHeaderAction =
        EndpointGlobalDeliveryRuleModifyResponseHeaderActionBuilder()

    type EndpointGlobalDeliveryRuleUrlRedirectActionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointGlobalDeliveryRuleUrlRedirectActionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("fragment")>]
        member _.Fragment((n, args), fragment) =
            let apply (args: EndpointGlobalDeliveryRuleUrlRedirectActionArgs) =
                args.Fragment <- input fragment
                args

            ()
            n, List.Cons(apply, args)

        member _.Fragment((n, args), fragment) =
            let apply (args: EndpointGlobalDeliveryRuleUrlRedirectActionArgs) =
                args.Fragment <- io fragment
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("hostname")>]
        member _.Hostname((n, args), hostname) =
            let apply (args: EndpointGlobalDeliveryRuleUrlRedirectActionArgs) =
                args.Hostname <- input hostname
                args

            ()
            n, List.Cons(apply, args)

        member _.Hostname((n, args), hostname) =
            let apply (args: EndpointGlobalDeliveryRuleUrlRedirectActionArgs) =
                args.Hostname <- io hostname
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("path")>]
        member _.Path((n, args), path) =
            let apply (args: EndpointGlobalDeliveryRuleUrlRedirectActionArgs) =
                args.Path <- input path
                args

            ()
            n, List.Cons(apply, args)

        member _.Path((n, args), path) =
            let apply (args: EndpointGlobalDeliveryRuleUrlRedirectActionArgs) =
                args.Path <- io path
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("protocol")>]
        member _.Protocol((n, args), protocol) =
            let apply (args: EndpointGlobalDeliveryRuleUrlRedirectActionArgs) =
                args.Protocol <- input protocol
                args

            ()
            n, List.Cons(apply, args)

        member _.Protocol((n, args), protocol) =
            let apply (args: EndpointGlobalDeliveryRuleUrlRedirectActionArgs) =
                args.Protocol <- io protocol
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("queryString")>]
        member _.QueryString((n, args), queryString) =
            let apply (args: EndpointGlobalDeliveryRuleUrlRedirectActionArgs) =
                args.QueryString <- input queryString
                args

            ()
            n, List.Cons(apply, args)

        member _.QueryString((n, args), queryString) =
            let apply (args: EndpointGlobalDeliveryRuleUrlRedirectActionArgs) =
                args.QueryString <- io queryString
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("redirectType")>]
        member _.RedirectType((n, args), redirectType) =
            let apply (args: EndpointGlobalDeliveryRuleUrlRedirectActionArgs) =
                args.RedirectType <- input redirectType
                args

            ()
            n, List.Cons(apply, args)

        member _.RedirectType((n, args), redirectType) =
            let apply (args: EndpointGlobalDeliveryRuleUrlRedirectActionArgs) =
                args.RedirectType <- io redirectType
                args

            ()
            n, List.Cons(apply, args)

    let endpointGlobalDeliveryRuleUrlRedirectAction =
        EndpointGlobalDeliveryRuleUrlRedirectActionBuilder()

    type EndpointGlobalDeliveryRuleUrlRewriteActionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointGlobalDeliveryRuleUrlRewriteActionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("destination")>]
        member _.Destination((n, args), destination) =
            let apply (args: EndpointGlobalDeliveryRuleUrlRewriteActionArgs) =
                args.Destination <- input destination
                args

            ()
            n, List.Cons(apply, args)

        member _.Destination((n, args), destination) =
            let apply (args: EndpointGlobalDeliveryRuleUrlRewriteActionArgs) =
                args.Destination <- io destination
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("preserveUnmatchedPath")>]
        member _.PreserveUnmatchedPath((n, args), preserveUnmatchedPath) =
            let apply (args: EndpointGlobalDeliveryRuleUrlRewriteActionArgs) =
                args.PreserveUnmatchedPath <- input preserveUnmatchedPath
                args

            ()
            n, List.Cons(apply, args)

        member _.PreserveUnmatchedPath((n, args), preserveUnmatchedPath) =
            let apply (args: EndpointGlobalDeliveryRuleUrlRewriteActionArgs) =
                args.PreserveUnmatchedPath <- io preserveUnmatchedPath
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sourcePattern")>]
        member _.SourcePattern((n, args), sourcePattern) =
            let apply (args: EndpointGlobalDeliveryRuleUrlRewriteActionArgs) =
                args.SourcePattern <- input sourcePattern
                args

            ()
            n, List.Cons(apply, args)

        member _.SourcePattern((n, args), sourcePattern) =
            let apply (args: EndpointGlobalDeliveryRuleUrlRewriteActionArgs) =
                args.SourcePattern <- io sourcePattern
                args

            ()
            n, List.Cons(apply, args)

    let endpointGlobalDeliveryRuleUrlRewriteAction =
        EndpointGlobalDeliveryRuleUrlRewriteActionBuilder()

    type EndpointOriginBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointOriginArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("hostName")>]
        member _.HostName((n, args), hostName) =
            let apply (args: EndpointOriginArgs) =
                args.HostName <- input hostName
                args

            ()
            n, List.Cons(apply, args)

        member _.HostName((n, args), hostName) =
            let apply (args: EndpointOriginArgs) =
                args.HostName <- io hostName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("httpPort")>]
        member _.HttpPort((n, args), httpPort) =
            let apply (args: EndpointOriginArgs) =
                args.HttpPort <- input httpPort
                args

            ()
            n, List.Cons(apply, args)

        member _.HttpPort((n, args), httpPort) =
            let apply (args: EndpointOriginArgs) =
                args.HttpPort <- io httpPort
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("httpsPort")>]
        member _.HttpsPort((n, args), httpsPort) =
            let apply (args: EndpointOriginArgs) =
                args.HttpsPort <- input httpsPort
                args

            ()
            n, List.Cons(apply, args)

        member _.HttpsPort((n, args), httpsPort) =
            let apply (args: EndpointOriginArgs) =
                args.HttpsPort <- io httpsPort
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: EndpointOriginArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: EndpointOriginArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

    let endpointOrigin = EndpointOriginBuilder()

    type EndpointBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Endpoint(name, (List.fold func (EndpointArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("contentTypesToCompresses")>]
        member _.ContentTypesToCompresses((name, args), contentTypesToCompresses) =
            let apply (args: EndpointArgs) =
                args.ContentTypesToCompresses <- inputList contentTypesToCompresses
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("deliveryRules")>]
        member _.DeliveryRules((name, args), deliveryRules) =
            let apply (args: EndpointArgs) =
                args.DeliveryRules <- inputList deliveryRules
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("geoFilters")>]
        member _.GeoFilters((name, args), geoFilters) =
            let apply (args: EndpointArgs) =
                args.GeoFilters <- inputList geoFilters
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: EndpointArgs) =
                   args.GlobalDeliveryRule <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("isCompressionEnabled")>]
        member _.IsCompressionEnabled((name, args), isCompressionEnabled) =
            let apply (args: EndpointArgs) =
                args.IsCompressionEnabled <- input isCompressionEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.IsCompressionEnabled((name, args), isCompressionEnabled) =
            let apply (args: EndpointArgs) =
                args.IsCompressionEnabled <- io isCompressionEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("isHttpAllowed")>]
        member _.IsHttpAllowed((name, args), isHttpAllowed) =
            let apply (args: EndpointArgs) =
                args.IsHttpAllowed <- input isHttpAllowed
                args

            ()
            name, List.Cons(apply, args)

        member _.IsHttpAllowed((name, args), isHttpAllowed) =
            let apply (args: EndpointArgs) =
                args.IsHttpAllowed <- io isHttpAllowed
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("isHttpsAllowed")>]
        member _.IsHttpsAllowed((name, args), isHttpsAllowed) =
            let apply (args: EndpointArgs) =
                args.IsHttpsAllowed <- input isHttpsAllowed
                args

            ()
            name, List.Cons(apply, args)

        member _.IsHttpsAllowed((name, args), isHttpsAllowed) =
            let apply (args: EndpointArgs) =
                args.IsHttpsAllowed <- io isHttpsAllowed
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: EndpointArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: EndpointArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: EndpointArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: EndpointArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("optimizationType")>]
        member _.OptimizationType((name, args), optimizationType) =
            let apply (args: EndpointArgs) =
                args.OptimizationType <- input optimizationType
                args

            ()
            name, List.Cons(apply, args)

        member _.OptimizationType((name, args), optimizationType) =
            let apply (args: EndpointArgs) =
                args.OptimizationType <- io optimizationType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("originHostHeader")>]
        member _.OriginHostHeader((name, args), originHostHeader) =
            let apply (args: EndpointArgs) =
                args.OriginHostHeader <- input originHostHeader
                args

            ()
            name, List.Cons(apply, args)

        member _.OriginHostHeader((name, args), originHostHeader) =
            let apply (args: EndpointArgs) =
                args.OriginHostHeader <- io originHostHeader
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("originPath")>]
        member _.OriginPath((name, args), originPath) =
            let apply (args: EndpointArgs) =
                args.OriginPath <- input originPath
                args

            ()
            name, List.Cons(apply, args)

        member _.OriginPath((name, args), originPath) =
            let apply (args: EndpointArgs) =
                args.OriginPath <- io originPath
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("origins")>]
        member _.Origins((name, args), origins) =
            let apply (args: EndpointArgs) =
                args.Origins <- inputList origins
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("probePath")>]
        member _.ProbePath((name, args), probePath) =
            let apply (args: EndpointArgs) =
                args.ProbePath <- input probePath
                args

            ()
            name, List.Cons(apply, args)

        member _.ProbePath((name, args), probePath) =
            let apply (args: EndpointArgs) =
                args.ProbePath <- io probePath
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("profileName")>]
        member _.ProfileName((name, args), profileName) =
            let apply (args: EndpointArgs) =
                args.ProfileName <- input profileName
                args

            ()
            name, List.Cons(apply, args)

        member _.ProfileName((name, args), profileName) =
            let apply (args: EndpointArgs) =
                args.ProfileName <- io profileName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("querystringCachingBehaviour")>]
        member _.QuerystringCachingBehaviour((name, args), querystringCachingBehaviour) =
            let apply (args: EndpointArgs) =
                args.QuerystringCachingBehaviour <- input querystringCachingBehaviour
                args

            ()
            name, List.Cons(apply, args)

        member _.QuerystringCachingBehaviour((name, args), querystringCachingBehaviour) =
            let apply (args: EndpointArgs) =
                args.QuerystringCachingBehaviour <- io querystringCachingBehaviour
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: EndpointArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: EndpointArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: EndpointArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let endpoint = EndpointBuilder()

    type ProfileBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Profile(name, (List.fold func (ProfileArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ProfileArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ProfileArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ProfileArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ProfileArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ProfileArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ProfileArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sku")>]
        member _.Sku((name, args), sku) =
            let apply (args: ProfileArgs) =
                args.Sku <- input sku
                args

            ()
            name, List.Cons(apply, args)

        member _.Sku((name, args), sku) =
            let apply (args: ProfileArgs) =
                args.Sku <- io sku
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ProfileArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let profile = ProfileBuilder()

module Compute =
    open Pulumi.Azure.Compute
    open Pulumi.Azure.Compute.Inputs

    type BastionHostIpConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (BastionHostIpConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: BastionHostIpConfigurationArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: BastionHostIpConfigurationArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publicIpAddressId")>]
        member _.PublicIpAddressId((n, args), publicIpAddressId) =
            let apply (args: BastionHostIpConfigurationArgs) =
                args.PublicIpAddressId <- input publicIpAddressId
                args

            ()
            n, List.Cons(apply, args)

        member _.PublicIpAddressId((n, args), publicIpAddressId) =
            let apply (args: BastionHostIpConfigurationArgs) =
                args.PublicIpAddressId <- io publicIpAddressId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: BastionHostIpConfigurationArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: BastionHostIpConfigurationArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

    let bastionHostIpConfiguration = BastionHostIpConfigurationBuilder()

    type DiskEncryptionSetIdentityBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (DiskEncryptionSetIdentityArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("principalId")>]
        member _.PrincipalId((n, args), principalId) =
            let apply (args: DiskEncryptionSetIdentityArgs) =
                args.PrincipalId <- input principalId
                args

            ()
            n, List.Cons(apply, args)

        member _.PrincipalId((n, args), principalId) =
            let apply (args: DiskEncryptionSetIdentityArgs) =
                args.PrincipalId <- io principalId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tenantId")>]
        member _.TenantId((n, args), tenantId) =
            let apply (args: DiskEncryptionSetIdentityArgs) =
                args.TenantId <- input tenantId
                args

            ()
            n, List.Cons(apply, args)

        member _.TenantId((n, args), tenantId) =
            let apply (args: DiskEncryptionSetIdentityArgs) =
                args.TenantId <- io tenantId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: DiskEncryptionSetIdentityArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: DiskEncryptionSetIdentityArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let diskEncryptionSetIdentity = DiskEncryptionSetIdentityBuilder()

    type ImageDataDiskBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ImageDataDiskArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("blobUri")>]
        member _.BlobUri((n, args), blobUri) =
            let apply (args: ImageDataDiskArgs) =
                args.BlobUri <- input blobUri
                args

            ()
            n, List.Cons(apply, args)

        member _.BlobUri((n, args), blobUri) =
            let apply (args: ImageDataDiskArgs) =
                args.BlobUri <- io blobUri
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("caching")>]
        member _.Caching((n, args), caching) =
            let apply (args: ImageDataDiskArgs) =
                args.Caching <- input caching
                args

            ()
            n, List.Cons(apply, args)

        member _.Caching((n, args), caching) =
            let apply (args: ImageDataDiskArgs) =
                args.Caching <- io caching
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("lun")>]
        member _.Lun((n, args), lun) =
            let apply (args: ImageDataDiskArgs) =
                args.Lun <- input lun
                args

            ()
            n, List.Cons(apply, args)

        member _.Lun((n, args), lun) =
            let apply (args: ImageDataDiskArgs) =
                args.Lun <- io lun
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("managedDiskId")>]
        member _.ManagedDiskId((n, args), managedDiskId) =
            let apply (args: ImageDataDiskArgs) =
                args.ManagedDiskId <- input managedDiskId
                args

            ()
            n, List.Cons(apply, args)

        member _.ManagedDiskId((n, args), managedDiskId) =
            let apply (args: ImageDataDiskArgs) =
                args.ManagedDiskId <- io managedDiskId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sizeGb")>]
        member _.SizeGb((n, args), sizeGb) =
            let apply (args: ImageDataDiskArgs) =
                args.SizeGb <- input sizeGb
                args

            ()
            n, List.Cons(apply, args)

        member _.SizeGb((n, args), sizeGb) =
            let apply (args: ImageDataDiskArgs) =
                args.SizeGb <- io sizeGb
                args

            ()
            n, List.Cons(apply, args)

    let imageDataDisk = ImageDataDiskBuilder()

    type ImageOsDiskBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ImageOsDiskArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("blobUri")>]
        member _.BlobUri((n, args), blobUri) =
            let apply (args: ImageOsDiskArgs) =
                args.BlobUri <- input blobUri
                args

            ()
            n, List.Cons(apply, args)

        member _.BlobUri((n, args), blobUri) =
            let apply (args: ImageOsDiskArgs) =
                args.BlobUri <- io blobUri
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("caching")>]
        member _.Caching((n, args), caching) =
            let apply (args: ImageOsDiskArgs) =
                args.Caching <- input caching
                args

            ()
            n, List.Cons(apply, args)

        member _.Caching((n, args), caching) =
            let apply (args: ImageOsDiskArgs) =
                args.Caching <- io caching
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("managedDiskId")>]
        member _.ManagedDiskId((n, args), managedDiskId) =
            let apply (args: ImageOsDiskArgs) =
                args.ManagedDiskId <- input managedDiskId
                args

            ()
            n, List.Cons(apply, args)

        member _.ManagedDiskId((n, args), managedDiskId) =
            let apply (args: ImageOsDiskArgs) =
                args.ManagedDiskId <- io managedDiskId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("osState")>]
        member _.OsState((n, args), osState) =
            let apply (args: ImageOsDiskArgs) =
                args.OsState <- input osState
                args

            ()
            n, List.Cons(apply, args)

        member _.OsState((n, args), osState) =
            let apply (args: ImageOsDiskArgs) =
                args.OsState <- io osState
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("osType")>]
        member _.OsType((n, args), osType) =
            let apply (args: ImageOsDiskArgs) =
                args.OsType <- input osType
                args

            ()
            n, List.Cons(apply, args)

        member _.OsType((n, args), osType) =
            let apply (args: ImageOsDiskArgs) =
                args.OsType <- io osType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sizeGb")>]
        member _.SizeGb((n, args), sizeGb) =
            let apply (args: ImageOsDiskArgs) =
                args.SizeGb <- input sizeGb
                args

            ()
            n, List.Cons(apply, args)

        member _.SizeGb((n, args), sizeGb) =
            let apply (args: ImageOsDiskArgs) =
                args.SizeGb <- io sizeGb
                args

            ()
            n, List.Cons(apply, args)

    let imageOsDisk = ImageOsDiskBuilder()

    type LinuxVirtualMachineAdditionalCapabilitiesBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LinuxVirtualMachineAdditionalCapabilitiesArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("ultraSsdEnabled")>]
        member _.UltraSsdEnabled((n, args), ultraSsdEnabled) =
            let apply (args: LinuxVirtualMachineAdditionalCapabilitiesArgs) =
                args.UltraSsdEnabled <- input ultraSsdEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.UltraSsdEnabled((n, args), ultraSsdEnabled) =
            let apply (args: LinuxVirtualMachineAdditionalCapabilitiesArgs) =
                args.UltraSsdEnabled <- io ultraSsdEnabled
                args

            ()
            n, List.Cons(apply, args)

    let linuxVirtualMachineAdditionalCapabilities =
        LinuxVirtualMachineAdditionalCapabilitiesBuilder()

    type LinuxVirtualMachineAdminSshKeyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LinuxVirtualMachineAdminSshKeyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("publicKey")>]
        member _.PublicKey((n, args), publicKey) =
            let apply (args: LinuxVirtualMachineAdminSshKeyArgs) =
                args.PublicKey <- input publicKey
                args

            ()
            n, List.Cons(apply, args)

        member _.PublicKey((n, args), publicKey) =
            let apply (args: LinuxVirtualMachineAdminSshKeyArgs) =
                args.PublicKey <- io publicKey
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: LinuxVirtualMachineAdminSshKeyArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: LinuxVirtualMachineAdminSshKeyArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

    let linuxVirtualMachineAdminSshKey = LinuxVirtualMachineAdminSshKeyBuilder()

    type LinuxVirtualMachineBootDiagnosticsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LinuxVirtualMachineBootDiagnosticsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("storageAccountUri")>]
        member _.StorageAccountUri((n, args), storageAccountUri) =
            let apply (args: LinuxVirtualMachineBootDiagnosticsArgs) =
                args.StorageAccountUri <- input storageAccountUri
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountUri((n, args), storageAccountUri) =
            let apply (args: LinuxVirtualMachineBootDiagnosticsArgs) =
                args.StorageAccountUri <- io storageAccountUri
                args

            ()
            n, List.Cons(apply, args)

    let linuxVirtualMachineBootDiagnostics =
        LinuxVirtualMachineBootDiagnosticsBuilder()

    type LinuxVirtualMachineIdentityBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LinuxVirtualMachineIdentityArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("identityIds")>]
        member _.IdentityIds((n, args), identityIds) =
            let apply (args: LinuxVirtualMachineIdentityArgs) =
                args.IdentityIds <- inputList identityIds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("principalId")>]
        member _.PrincipalId((n, args), principalId) =
            let apply (args: LinuxVirtualMachineIdentityArgs) =
                args.PrincipalId <- input principalId
                args

            ()
            n, List.Cons(apply, args)

        member _.PrincipalId((n, args), principalId) =
            let apply (args: LinuxVirtualMachineIdentityArgs) =
                args.PrincipalId <- io principalId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tenantId")>]
        member _.TenantId((n, args), tenantId) =
            let apply (args: LinuxVirtualMachineIdentityArgs) =
                args.TenantId <- input tenantId
                args

            ()
            n, List.Cons(apply, args)

        member _.TenantId((n, args), tenantId) =
            let apply (args: LinuxVirtualMachineIdentityArgs) =
                args.TenantId <- io tenantId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: LinuxVirtualMachineIdentityArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: LinuxVirtualMachineIdentityArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let linuxVirtualMachineIdentity = LinuxVirtualMachineIdentityBuilder()

    type LinuxVirtualMachineOsDiskBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LinuxVirtualMachineOsDiskArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("caching")>]
        member _.Caching((n, args), caching) =
            let apply (args: LinuxVirtualMachineOsDiskArgs) =
                args.Caching <- input caching
                args

            ()
            n, List.Cons(apply, args)

        member _.Caching((n, args), caching) =
            let apply (args: LinuxVirtualMachineOsDiskArgs) =
                args.Caching <- io caching
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: LinuxVirtualMachineOsDiskArgs) =
                   args.DiffDiskSettings <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("diskEncryptionSetId")>]
        member _.DiskEncryptionSetId((n, args), diskEncryptionSetId) =
            let apply (args: LinuxVirtualMachineOsDiskArgs) =
                args.DiskEncryptionSetId <- input diskEncryptionSetId
                args

            ()
            n, List.Cons(apply, args)

        member _.DiskEncryptionSetId((n, args), diskEncryptionSetId) =
            let apply (args: LinuxVirtualMachineOsDiskArgs) =
                args.DiskEncryptionSetId <- io diskEncryptionSetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("diskSizeGb")>]
        member _.DiskSizeGb((n, args), diskSizeGb) =
            let apply (args: LinuxVirtualMachineOsDiskArgs) =
                args.DiskSizeGb <- input diskSizeGb
                args

            ()
            n, List.Cons(apply, args)

        member _.DiskSizeGb((n, args), diskSizeGb) =
            let apply (args: LinuxVirtualMachineOsDiskArgs) =
                args.DiskSizeGb <- io diskSizeGb
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: LinuxVirtualMachineOsDiskArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: LinuxVirtualMachineOsDiskArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageAccountType")>]
        member _.StorageAccountType((n, args), storageAccountType) =
            let apply (args: LinuxVirtualMachineOsDiskArgs) =
                args.StorageAccountType <- input storageAccountType
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountType((n, args), storageAccountType) =
            let apply (args: LinuxVirtualMachineOsDiskArgs) =
                args.StorageAccountType <- io storageAccountType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("writeAcceleratorEnabled")>]
        member _.WriteAcceleratorEnabled((n, args), writeAcceleratorEnabled) =
            let apply (args: LinuxVirtualMachineOsDiskArgs) =
                args.WriteAcceleratorEnabled <- input writeAcceleratorEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.WriteAcceleratorEnabled((n, args), writeAcceleratorEnabled) =
            let apply (args: LinuxVirtualMachineOsDiskArgs) =
                args.WriteAcceleratorEnabled <- io writeAcceleratorEnabled
                args

            ()
            n, List.Cons(apply, args)

    let linuxVirtualMachineOsDisk = LinuxVirtualMachineOsDiskBuilder()

    type LinuxVirtualMachineOsDiskDiffDiskSettingsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LinuxVirtualMachineOsDiskDiffDiskSettingsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("option")>]
        member _.Option((n, args), option) =
            let apply (args: LinuxVirtualMachineOsDiskDiffDiskSettingsArgs) =
                args.Option <- input option
                args

            ()
            n, List.Cons(apply, args)

        member _.Option((n, args), option) =
            let apply (args: LinuxVirtualMachineOsDiskDiffDiskSettingsArgs) =
                args.Option <- io option
                args

            ()
            n, List.Cons(apply, args)

    let linuxVirtualMachineOsDiskDiffDiskSettings =
        LinuxVirtualMachineOsDiskDiffDiskSettingsBuilder()

    type LinuxVirtualMachinePlanBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LinuxVirtualMachinePlanArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: LinuxVirtualMachinePlanArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: LinuxVirtualMachinePlanArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("product")>]
        member _.Product((n, args), product) =
            let apply (args: LinuxVirtualMachinePlanArgs) =
                args.Product <- input product
                args

            ()
            n, List.Cons(apply, args)

        member _.Product((n, args), product) =
            let apply (args: LinuxVirtualMachinePlanArgs) =
                args.Product <- io product
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publisher")>]
        member _.Publisher((n, args), publisher) =
            let apply (args: LinuxVirtualMachinePlanArgs) =
                args.Publisher <- input publisher
                args

            ()
            n, List.Cons(apply, args)

        member _.Publisher((n, args), publisher) =
            let apply (args: LinuxVirtualMachinePlanArgs) =
                args.Publisher <- io publisher
                args

            ()
            n, List.Cons(apply, args)

    let linuxVirtualMachinePlan = LinuxVirtualMachinePlanBuilder()

    type LinuxVirtualMachineScaleSetAdditionalCapabilitiesBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LinuxVirtualMachineScaleSetAdditionalCapabilitiesArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("ultraSsdEnabled")>]
        member _.UltraSsdEnabled((n, args), ultraSsdEnabled) =
            let apply (args: LinuxVirtualMachineScaleSetAdditionalCapabilitiesArgs) =
                args.UltraSsdEnabled <- input ultraSsdEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.UltraSsdEnabled((n, args), ultraSsdEnabled) =
            let apply (args: LinuxVirtualMachineScaleSetAdditionalCapabilitiesArgs) =
                args.UltraSsdEnabled <- io ultraSsdEnabled
                args

            ()
            n, List.Cons(apply, args)

    let linuxVirtualMachineScaleSetAdditionalCapabilities =
        LinuxVirtualMachineScaleSetAdditionalCapabilitiesBuilder()

    type LinuxVirtualMachineScaleSetAdminSshKeyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LinuxVirtualMachineScaleSetAdminSshKeyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("publicKey")>]
        member _.PublicKey((n, args), publicKey) =
            let apply (args: LinuxVirtualMachineScaleSetAdminSshKeyArgs) =
                args.PublicKey <- input publicKey
                args

            ()
            n, List.Cons(apply, args)

        member _.PublicKey((n, args), publicKey) =
            let apply (args: LinuxVirtualMachineScaleSetAdminSshKeyArgs) =
                args.PublicKey <- io publicKey
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: LinuxVirtualMachineScaleSetAdminSshKeyArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: LinuxVirtualMachineScaleSetAdminSshKeyArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

    let linuxVirtualMachineScaleSetAdminSshKey =
        LinuxVirtualMachineScaleSetAdminSshKeyBuilder()

    type LinuxVirtualMachineScaleSetAutomaticInstanceRepairBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LinuxVirtualMachineScaleSetAutomaticInstanceRepairArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: LinuxVirtualMachineScaleSetAutomaticInstanceRepairArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: LinuxVirtualMachineScaleSetAutomaticInstanceRepairArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("gracePeriod")>]
        member _.GracePeriod((n, args), gracePeriod) =
            let apply (args: LinuxVirtualMachineScaleSetAutomaticInstanceRepairArgs) =
                args.GracePeriod <- input gracePeriod
                args

            ()
            n, List.Cons(apply, args)

        member _.GracePeriod((n, args), gracePeriod) =
            let apply (args: LinuxVirtualMachineScaleSetAutomaticInstanceRepairArgs) =
                args.GracePeriod <- io gracePeriod
                args

            ()
            n, List.Cons(apply, args)

    let linuxVirtualMachineScaleSetAutomaticInstanceRepair =
        LinuxVirtualMachineScaleSetAutomaticInstanceRepairBuilder()

    type LinuxVirtualMachineScaleSetAutomaticOsUpgradePolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LinuxVirtualMachineScaleSetAutomaticOsUpgradePolicyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("disableAutomaticRollback")>]
        member _.DisableAutomaticRollback((n, args), disableAutomaticRollback) =
            let apply (args: LinuxVirtualMachineScaleSetAutomaticOsUpgradePolicyArgs) =
                args.DisableAutomaticRollback <- input disableAutomaticRollback
                args

            ()
            n, List.Cons(apply, args)

        member _.DisableAutomaticRollback((n, args), disableAutomaticRollback) =
            let apply (args: LinuxVirtualMachineScaleSetAutomaticOsUpgradePolicyArgs) =
                args.DisableAutomaticRollback <- io disableAutomaticRollback
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enableAutomaticOsUpgrade")>]
        member _.EnableAutomaticOsUpgrade((n, args), enableAutomaticOsUpgrade) =
            let apply (args: LinuxVirtualMachineScaleSetAutomaticOsUpgradePolicyArgs) =
                args.EnableAutomaticOsUpgrade <- input enableAutomaticOsUpgrade
                args

            ()
            n, List.Cons(apply, args)

        member _.EnableAutomaticOsUpgrade((n, args), enableAutomaticOsUpgrade) =
            let apply (args: LinuxVirtualMachineScaleSetAutomaticOsUpgradePolicyArgs) =
                args.EnableAutomaticOsUpgrade <- io enableAutomaticOsUpgrade
                args

            ()
            n, List.Cons(apply, args)

    let linuxVirtualMachineScaleSetAutomaticOsUpgradePolicy =
        LinuxVirtualMachineScaleSetAutomaticOsUpgradePolicyBuilder()

    type LinuxVirtualMachineScaleSetBootDiagnosticsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LinuxVirtualMachineScaleSetBootDiagnosticsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("storageAccountUri")>]
        member _.StorageAccountUri((n, args), storageAccountUri) =
            let apply (args: LinuxVirtualMachineScaleSetBootDiagnosticsArgs) =
                args.StorageAccountUri <- input storageAccountUri
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountUri((n, args), storageAccountUri) =
            let apply (args: LinuxVirtualMachineScaleSetBootDiagnosticsArgs) =
                args.StorageAccountUri <- io storageAccountUri
                args

            ()
            n, List.Cons(apply, args)

    let linuxVirtualMachineScaleSetBootDiagnostics =
        LinuxVirtualMachineScaleSetBootDiagnosticsBuilder()

    type LinuxVirtualMachineScaleSetDataDiskBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LinuxVirtualMachineScaleSetDataDiskArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("caching")>]
        member _.Caching((n, args), caching) =
            let apply (args: LinuxVirtualMachineScaleSetDataDiskArgs) =
                args.Caching <- input caching
                args

            ()
            n, List.Cons(apply, args)

        member _.Caching((n, args), caching) =
            let apply (args: LinuxVirtualMachineScaleSetDataDiskArgs) =
                args.Caching <- io caching
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("createOption")>]
        member _.CreateOption((n, args), createOption) =
            let apply (args: LinuxVirtualMachineScaleSetDataDiskArgs) =
                args.CreateOption <- input createOption
                args

            ()
            n, List.Cons(apply, args)

        member _.CreateOption((n, args), createOption) =
            let apply (args: LinuxVirtualMachineScaleSetDataDiskArgs) =
                args.CreateOption <- io createOption
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("diskEncryptionSetId")>]
        member _.DiskEncryptionSetId((n, args), diskEncryptionSetId) =
            let apply (args: LinuxVirtualMachineScaleSetDataDiskArgs) =
                args.DiskEncryptionSetId <- input diskEncryptionSetId
                args

            ()
            n, List.Cons(apply, args)

        member _.DiskEncryptionSetId((n, args), diskEncryptionSetId) =
            let apply (args: LinuxVirtualMachineScaleSetDataDiskArgs) =
                args.DiskEncryptionSetId <- io diskEncryptionSetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("diskSizeGb")>]
        member _.DiskSizeGb((n, args), diskSizeGb) =
            let apply (args: LinuxVirtualMachineScaleSetDataDiskArgs) =
                args.DiskSizeGb <- input diskSizeGb
                args

            ()
            n, List.Cons(apply, args)

        member _.DiskSizeGb((n, args), diskSizeGb) =
            let apply (args: LinuxVirtualMachineScaleSetDataDiskArgs) =
                args.DiskSizeGb <- io diskSizeGb
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("lun")>]
        member _.Lun((n, args), lun) =
            let apply (args: LinuxVirtualMachineScaleSetDataDiskArgs) =
                args.Lun <- input lun
                args

            ()
            n, List.Cons(apply, args)

        member _.Lun((n, args), lun) =
            let apply (args: LinuxVirtualMachineScaleSetDataDiskArgs) =
                args.Lun <- io lun
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageAccountType")>]
        member _.StorageAccountType((n, args), storageAccountType) =
            let apply (args: LinuxVirtualMachineScaleSetDataDiskArgs) =
                args.StorageAccountType <- input storageAccountType
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountType((n, args), storageAccountType) =
            let apply (args: LinuxVirtualMachineScaleSetDataDiskArgs) =
                args.StorageAccountType <- io storageAccountType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("writeAcceleratorEnabled")>]
        member _.WriteAcceleratorEnabled((n, args), writeAcceleratorEnabled) =
            let apply (args: LinuxVirtualMachineScaleSetDataDiskArgs) =
                args.WriteAcceleratorEnabled <- input writeAcceleratorEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.WriteAcceleratorEnabled((n, args), writeAcceleratorEnabled) =
            let apply (args: LinuxVirtualMachineScaleSetDataDiskArgs) =
                args.WriteAcceleratorEnabled <- io writeAcceleratorEnabled
                args

            ()
            n, List.Cons(apply, args)

    let linuxVirtualMachineScaleSetDataDisk =
        LinuxVirtualMachineScaleSetDataDiskBuilder()

    type LinuxVirtualMachineScaleSetIdentityBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LinuxVirtualMachineScaleSetIdentityArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("identityIds")>]
        member _.IdentityIds((n, args), identityIds) =
            let apply (args: LinuxVirtualMachineScaleSetIdentityArgs) =
                args.IdentityIds <- inputList identityIds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("principalId")>]
        member _.PrincipalId((n, args), principalId) =
            let apply (args: LinuxVirtualMachineScaleSetIdentityArgs) =
                args.PrincipalId <- input principalId
                args

            ()
            n, List.Cons(apply, args)

        member _.PrincipalId((n, args), principalId) =
            let apply (args: LinuxVirtualMachineScaleSetIdentityArgs) =
                args.PrincipalId <- io principalId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: LinuxVirtualMachineScaleSetIdentityArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: LinuxVirtualMachineScaleSetIdentityArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let linuxVirtualMachineScaleSetIdentity =
        LinuxVirtualMachineScaleSetIdentityBuilder()

    type LinuxVirtualMachineScaleSetNetworkInterfaceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LinuxVirtualMachineScaleSetNetworkInterfaceArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("dnsServers")>]
        member _.DnsServers((n, args), dnsServers) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceArgs) =
                args.DnsServers <- inputList dnsServers
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enableAcceleratedNetworking")>]
        member _.EnableAcceleratedNetworking((n, args), enableAcceleratedNetworking) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceArgs) =
                args.EnableAcceleratedNetworking <- input enableAcceleratedNetworking
                args

            ()
            n, List.Cons(apply, args)

        member _.EnableAcceleratedNetworking((n, args), enableAcceleratedNetworking) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceArgs) =
                args.EnableAcceleratedNetworking <- io enableAcceleratedNetworking
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enableIpForwarding")>]
        member _.EnableIpForwarding((n, args), enableIpForwarding) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceArgs) =
                args.EnableIpForwarding <- input enableIpForwarding
                args

            ()
            n, List.Cons(apply, args)

        member _.EnableIpForwarding((n, args), enableIpForwarding) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceArgs) =
                args.EnableIpForwarding <- io enableIpForwarding
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ipConfigurations")>]
        member _.IpConfigurations((n, args), ipConfigurations) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceArgs) =
                args.IpConfigurations <- inputList ipConfigurations
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("networkSecurityGroupId")>]
        member _.NetworkSecurityGroupId((n, args), networkSecurityGroupId) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceArgs) =
                args.NetworkSecurityGroupId <- input networkSecurityGroupId
                args

            ()
            n, List.Cons(apply, args)

        member _.NetworkSecurityGroupId((n, args), networkSecurityGroupId) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceArgs) =
                args.NetworkSecurityGroupId <- io networkSecurityGroupId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("primary")>]
        member _.Primary((n, args), primary) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceArgs) =
                args.Primary <- input primary
                args

            ()
            n, List.Cons(apply, args)

        member _.Primary((n, args), primary) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceArgs) =
                args.Primary <- io primary
                args

            ()
            n, List.Cons(apply, args)

    let linuxVirtualMachineScaleSetNetworkInterface =
        LinuxVirtualMachineScaleSetNetworkInterfaceBuilder()

    type LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("applicationGatewayBackendAddressPoolIds")>]
        member _.ApplicationGatewayBackendAddressPoolIds((n, args), applicationGatewayBackendAddressPoolIds) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs) =
                args.ApplicationGatewayBackendAddressPoolIds <- inputList applicationGatewayBackendAddressPoolIds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("applicationSecurityGroupIds")>]
        member _.ApplicationSecurityGroupIds((n, args), applicationSecurityGroupIds) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs) =
                args.ApplicationSecurityGroupIds <- inputList applicationSecurityGroupIds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("loadBalancerBackendAddressPoolIds")>]
        member _.LoadBalancerBackendAddressPoolIds((n, args), loadBalancerBackendAddressPoolIds) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs) =
                args.LoadBalancerBackendAddressPoolIds <- inputList loadBalancerBackendAddressPoolIds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("loadBalancerInboundNatRulesIds")>]
        member _.LoadBalancerInboundNatRulesIds((n, args), loadBalancerInboundNatRulesIds) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs) =
                args.LoadBalancerInboundNatRulesIds <- inputList loadBalancerInboundNatRulesIds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("primary")>]
        member _.Primary((n, args), primary) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs) =
                args.Primary <- input primary
                args

            ()
            n, List.Cons(apply, args)

        member _.Primary((n, args), primary) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs) =
                args.Primary <- io primary
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publicIpAddresses")>]
        member _.PublicIpAddresses((n, args), publicIpAddresses) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs) =
                args.PublicIpAddresses <- inputList publicIpAddresses
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("version")>]
        member _.Version((n, args), version) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs) =
                args.Version <- input version
                args

            ()
            n, List.Cons(apply, args)

        member _.Version((n, args), version) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs) =
                args.Version <- io version
                args

            ()
            n, List.Cons(apply, args)

    let linuxVirtualMachineScaleSetNetworkInterfaceIpConfiguration =
        LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationBuilder()

    type LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("domainNameLabel")>]
        member _.DomainNameLabel((n, args), domainNameLabel) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs) =
                args.DomainNameLabel <- input domainNameLabel
                args

            ()
            n, List.Cons(apply, args)

        member _.DomainNameLabel((n, args), domainNameLabel) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs) =
                args.DomainNameLabel <- io domainNameLabel
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("idleTimeoutInMinutes")>]
        member _.IdleTimeoutInMinutes((n, args), idleTimeoutInMinutes) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs) =
                args.IdleTimeoutInMinutes <- input idleTimeoutInMinutes
                args

            ()
            n, List.Cons(apply, args)

        member _.IdleTimeoutInMinutes((n, args), idleTimeoutInMinutes) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs) =
                args.IdleTimeoutInMinutes <- io idleTimeoutInMinutes
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ipTags")>]
        member _.IpTags((n, args), ipTags) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs) =
                args.IpTags <- inputList ipTags
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publicIpPrefixId")>]
        member _.PublicIpPrefixId((n, args), publicIpPrefixId) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs) =
                args.PublicIpPrefixId <- input publicIpPrefixId
                args

            ()
            n, List.Cons(apply, args)

        member _.PublicIpPrefixId((n, args), publicIpPrefixId) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs) =
                args.PublicIpPrefixId <- io publicIpPrefixId
                args

            ()
            n, List.Cons(apply, args)

    let linuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress =
        LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressBuilder()

    type LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("tag")>]
        member _.Tag((n, args), tag) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagArgs) =
                args.Tag <- input tag
                args

            ()
            n, List.Cons(apply, args)

        member _.Tag((n, args), tag) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagArgs) =
                args.Tag <- io tag
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let linuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag =
        LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagBuilder()

    type LinuxVirtualMachineScaleSetOsDiskBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LinuxVirtualMachineScaleSetOsDiskArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("caching")>]
        member _.Caching((n, args), caching) =
            let apply (args: LinuxVirtualMachineScaleSetOsDiskArgs) =
                args.Caching <- input caching
                args

            ()
            n, List.Cons(apply, args)

        member _.Caching((n, args), caching) =
            let apply (args: LinuxVirtualMachineScaleSetOsDiskArgs) =
                args.Caching <- io caching
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: LinuxVirtualMachineScaleSetOsDiskArgs) =
                   args.DiffDiskSettings <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("diskEncryptionSetId")>]
        member _.DiskEncryptionSetId((n, args), diskEncryptionSetId) =
            let apply (args: LinuxVirtualMachineScaleSetOsDiskArgs) =
                args.DiskEncryptionSetId <- input diskEncryptionSetId
                args

            ()
            n, List.Cons(apply, args)

        member _.DiskEncryptionSetId((n, args), diskEncryptionSetId) =
            let apply (args: LinuxVirtualMachineScaleSetOsDiskArgs) =
                args.DiskEncryptionSetId <- io diskEncryptionSetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("diskSizeGb")>]
        member _.DiskSizeGb((n, args), diskSizeGb) =
            let apply (args: LinuxVirtualMachineScaleSetOsDiskArgs) =
                args.DiskSizeGb <- input diskSizeGb
                args

            ()
            n, List.Cons(apply, args)

        member _.DiskSizeGb((n, args), diskSizeGb) =
            let apply (args: LinuxVirtualMachineScaleSetOsDiskArgs) =
                args.DiskSizeGb <- io diskSizeGb
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageAccountType")>]
        member _.StorageAccountType((n, args), storageAccountType) =
            let apply (args: LinuxVirtualMachineScaleSetOsDiskArgs) =
                args.StorageAccountType <- input storageAccountType
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountType((n, args), storageAccountType) =
            let apply (args: LinuxVirtualMachineScaleSetOsDiskArgs) =
                args.StorageAccountType <- io storageAccountType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("writeAcceleratorEnabled")>]
        member _.WriteAcceleratorEnabled((n, args), writeAcceleratorEnabled) =
            let apply (args: LinuxVirtualMachineScaleSetOsDiskArgs) =
                args.WriteAcceleratorEnabled <- input writeAcceleratorEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.WriteAcceleratorEnabled((n, args), writeAcceleratorEnabled) =
            let apply (args: LinuxVirtualMachineScaleSetOsDiskArgs) =
                args.WriteAcceleratorEnabled <- io writeAcceleratorEnabled
                args

            ()
            n, List.Cons(apply, args)

    let linuxVirtualMachineScaleSetOsDisk =
        LinuxVirtualMachineScaleSetOsDiskBuilder()

    type LinuxVirtualMachineScaleSetOsDiskDiffDiskSettingsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LinuxVirtualMachineScaleSetOsDiskDiffDiskSettingsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("option")>]
        member _.Option((n, args), option) =
            let apply (args: LinuxVirtualMachineScaleSetOsDiskDiffDiskSettingsArgs) =
                args.Option <- input option
                args

            ()
            n, List.Cons(apply, args)

        member _.Option((n, args), option) =
            let apply (args: LinuxVirtualMachineScaleSetOsDiskDiffDiskSettingsArgs) =
                args.Option <- io option
                args

            ()
            n, List.Cons(apply, args)

    let linuxVirtualMachineScaleSetOsDiskDiffDiskSettings =
        LinuxVirtualMachineScaleSetOsDiskDiffDiskSettingsBuilder()

    type LinuxVirtualMachineScaleSetPlanBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LinuxVirtualMachineScaleSetPlanArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: LinuxVirtualMachineScaleSetPlanArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: LinuxVirtualMachineScaleSetPlanArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("product")>]
        member _.Product((n, args), product) =
            let apply (args: LinuxVirtualMachineScaleSetPlanArgs) =
                args.Product <- input product
                args

            ()
            n, List.Cons(apply, args)

        member _.Product((n, args), product) =
            let apply (args: LinuxVirtualMachineScaleSetPlanArgs) =
                args.Product <- io product
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publisher")>]
        member _.Publisher((n, args), publisher) =
            let apply (args: LinuxVirtualMachineScaleSetPlanArgs) =
                args.Publisher <- input publisher
                args

            ()
            n, List.Cons(apply, args)

        member _.Publisher((n, args), publisher) =
            let apply (args: LinuxVirtualMachineScaleSetPlanArgs) =
                args.Publisher <- io publisher
                args

            ()
            n, List.Cons(apply, args)

    let linuxVirtualMachineScaleSetPlan = LinuxVirtualMachineScaleSetPlanBuilder()

    type LinuxVirtualMachineScaleSetRollingUpgradePolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LinuxVirtualMachineScaleSetRollingUpgradePolicyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("maxBatchInstancePercent")>]
        member _.MaxBatchInstancePercent((n, args), maxBatchInstancePercent) =
            let apply (args: LinuxVirtualMachineScaleSetRollingUpgradePolicyArgs) =
                args.MaxBatchInstancePercent <- input maxBatchInstancePercent
                args

            ()
            n, List.Cons(apply, args)

        member _.MaxBatchInstancePercent((n, args), maxBatchInstancePercent) =
            let apply (args: LinuxVirtualMachineScaleSetRollingUpgradePolicyArgs) =
                args.MaxBatchInstancePercent <- io maxBatchInstancePercent
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("maxUnhealthyInstancePercent")>]
        member _.MaxUnhealthyInstancePercent((n, args), maxUnhealthyInstancePercent) =
            let apply (args: LinuxVirtualMachineScaleSetRollingUpgradePolicyArgs) =
                args.MaxUnhealthyInstancePercent <- input maxUnhealthyInstancePercent
                args

            ()
            n, List.Cons(apply, args)

        member _.MaxUnhealthyInstancePercent((n, args), maxUnhealthyInstancePercent) =
            let apply (args: LinuxVirtualMachineScaleSetRollingUpgradePolicyArgs) =
                args.MaxUnhealthyInstancePercent <- io maxUnhealthyInstancePercent
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("maxUnhealthyUpgradedInstancePercent")>]
        member _.MaxUnhealthyUpgradedInstancePercent((n, args), maxUnhealthyUpgradedInstancePercent) =
            let apply (args: LinuxVirtualMachineScaleSetRollingUpgradePolicyArgs) =
                args.MaxUnhealthyUpgradedInstancePercent <- input maxUnhealthyUpgradedInstancePercent
                args

            ()
            n, List.Cons(apply, args)

        member _.MaxUnhealthyUpgradedInstancePercent((n, args), maxUnhealthyUpgradedInstancePercent) =
            let apply (args: LinuxVirtualMachineScaleSetRollingUpgradePolicyArgs) =
                args.MaxUnhealthyUpgradedInstancePercent <- io maxUnhealthyUpgradedInstancePercent
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("pauseTimeBetweenBatches")>]
        member _.PauseTimeBetweenBatches((n, args), pauseTimeBetweenBatches) =
            let apply (args: LinuxVirtualMachineScaleSetRollingUpgradePolicyArgs) =
                args.PauseTimeBetweenBatches <- input pauseTimeBetweenBatches
                args

            ()
            n, List.Cons(apply, args)

        member _.PauseTimeBetweenBatches((n, args), pauseTimeBetweenBatches) =
            let apply (args: LinuxVirtualMachineScaleSetRollingUpgradePolicyArgs) =
                args.PauseTimeBetweenBatches <- io pauseTimeBetweenBatches
                args

            ()
            n, List.Cons(apply, args)

    let linuxVirtualMachineScaleSetRollingUpgradePolicy =
        LinuxVirtualMachineScaleSetRollingUpgradePolicyBuilder()

    type LinuxVirtualMachineScaleSetSecretBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LinuxVirtualMachineScaleSetSecretArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("certificates")>]
        member _.Certificates((n, args), certificates) =
            let apply (args: LinuxVirtualMachineScaleSetSecretArgs) =
                args.Certificates <- inputList certificates
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("keyVaultId")>]
        member _.KeyVaultId((n, args), keyVaultId) =
            let apply (args: LinuxVirtualMachineScaleSetSecretArgs) =
                args.KeyVaultId <- input keyVaultId
                args

            ()
            n, List.Cons(apply, args)

        member _.KeyVaultId((n, args), keyVaultId) =
            let apply (args: LinuxVirtualMachineScaleSetSecretArgs) =
                args.KeyVaultId <- io keyVaultId
                args

            ()
            n, List.Cons(apply, args)

    let linuxVirtualMachineScaleSetSecret =
        LinuxVirtualMachineScaleSetSecretBuilder()

    type LinuxVirtualMachineScaleSetSecretCertificateBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LinuxVirtualMachineScaleSetSecretCertificateArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("url")>]
        member _.Url((n, args), url) =
            let apply (args: LinuxVirtualMachineScaleSetSecretCertificateArgs) =
                args.Url <- input url
                args

            ()
            n, List.Cons(apply, args)

        member _.Url((n, args), url) =
            let apply (args: LinuxVirtualMachineScaleSetSecretCertificateArgs) =
                args.Url <- io url
                args

            ()
            n, List.Cons(apply, args)

    let linuxVirtualMachineScaleSetSecretCertificate =
        LinuxVirtualMachineScaleSetSecretCertificateBuilder()

    type LinuxVirtualMachineScaleSetSourceImageReferenceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LinuxVirtualMachineScaleSetSourceImageReferenceArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("offer")>]
        member _.Offer((n, args), offer) =
            let apply (args: LinuxVirtualMachineScaleSetSourceImageReferenceArgs) =
                args.Offer <- input offer
                args

            ()
            n, List.Cons(apply, args)

        member _.Offer((n, args), offer) =
            let apply (args: LinuxVirtualMachineScaleSetSourceImageReferenceArgs) =
                args.Offer <- io offer
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publisher")>]
        member _.Publisher((n, args), publisher) =
            let apply (args: LinuxVirtualMachineScaleSetSourceImageReferenceArgs) =
                args.Publisher <- input publisher
                args

            ()
            n, List.Cons(apply, args)

        member _.Publisher((n, args), publisher) =
            let apply (args: LinuxVirtualMachineScaleSetSourceImageReferenceArgs) =
                args.Publisher <- io publisher
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sku")>]
        member _.Sku((n, args), sku) =
            let apply (args: LinuxVirtualMachineScaleSetSourceImageReferenceArgs) =
                args.Sku <- input sku
                args

            ()
            n, List.Cons(apply, args)

        member _.Sku((n, args), sku) =
            let apply (args: LinuxVirtualMachineScaleSetSourceImageReferenceArgs) =
                args.Sku <- io sku
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("version")>]
        member _.Version((n, args), version) =
            let apply (args: LinuxVirtualMachineScaleSetSourceImageReferenceArgs) =
                args.Version <- input version
                args

            ()
            n, List.Cons(apply, args)

        member _.Version((n, args), version) =
            let apply (args: LinuxVirtualMachineScaleSetSourceImageReferenceArgs) =
                args.Version <- io version
                args

            ()
            n, List.Cons(apply, args)

    let linuxVirtualMachineScaleSetSourceImageReference =
        LinuxVirtualMachineScaleSetSourceImageReferenceBuilder()

    type LinuxVirtualMachineScaleSetTerminateNotificationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LinuxVirtualMachineScaleSetTerminateNotificationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: LinuxVirtualMachineScaleSetTerminateNotificationArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: LinuxVirtualMachineScaleSetTerminateNotificationArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("timeout")>]
        member _.Timeout((n, args), timeout) =
            let apply (args: LinuxVirtualMachineScaleSetTerminateNotificationArgs) =
                args.Timeout <- input timeout
                args

            ()
            n, List.Cons(apply, args)

        member _.Timeout((n, args), timeout) =
            let apply (args: LinuxVirtualMachineScaleSetTerminateNotificationArgs) =
                args.Timeout <- io timeout
                args

            ()
            n, List.Cons(apply, args)

    let linuxVirtualMachineScaleSetTerminateNotification =
        LinuxVirtualMachineScaleSetTerminateNotificationBuilder()

    type LinuxVirtualMachineSecretBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LinuxVirtualMachineSecretArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("certificates")>]
        member _.Certificates((n, args), certificates) =
            let apply (args: LinuxVirtualMachineSecretArgs) =
                args.Certificates <- inputList certificates
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("keyVaultId")>]
        member _.KeyVaultId((n, args), keyVaultId) =
            let apply (args: LinuxVirtualMachineSecretArgs) =
                args.KeyVaultId <- input keyVaultId
                args

            ()
            n, List.Cons(apply, args)

        member _.KeyVaultId((n, args), keyVaultId) =
            let apply (args: LinuxVirtualMachineSecretArgs) =
                args.KeyVaultId <- io keyVaultId
                args

            ()
            n, List.Cons(apply, args)

    let linuxVirtualMachineSecret = LinuxVirtualMachineSecretBuilder()

    type LinuxVirtualMachineSecretCertificateBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LinuxVirtualMachineSecretCertificateArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("url")>]
        member _.Url((n, args), url) =
            let apply (args: LinuxVirtualMachineSecretCertificateArgs) =
                args.Url <- input url
                args

            ()
            n, List.Cons(apply, args)

        member _.Url((n, args), url) =
            let apply (args: LinuxVirtualMachineSecretCertificateArgs) =
                args.Url <- io url
                args

            ()
            n, List.Cons(apply, args)

    let linuxVirtualMachineSecretCertificate =
        LinuxVirtualMachineSecretCertificateBuilder()

    type LinuxVirtualMachineSourceImageReferenceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LinuxVirtualMachineSourceImageReferenceArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("offer")>]
        member _.Offer((n, args), offer) =
            let apply (args: LinuxVirtualMachineSourceImageReferenceArgs) =
                args.Offer <- input offer
                args

            ()
            n, List.Cons(apply, args)

        member _.Offer((n, args), offer) =
            let apply (args: LinuxVirtualMachineSourceImageReferenceArgs) =
                args.Offer <- io offer
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publisher")>]
        member _.Publisher((n, args), publisher) =
            let apply (args: LinuxVirtualMachineSourceImageReferenceArgs) =
                args.Publisher <- input publisher
                args

            ()
            n, List.Cons(apply, args)

        member _.Publisher((n, args), publisher) =
            let apply (args: LinuxVirtualMachineSourceImageReferenceArgs) =
                args.Publisher <- io publisher
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sku")>]
        member _.Sku((n, args), sku) =
            let apply (args: LinuxVirtualMachineSourceImageReferenceArgs) =
                args.Sku <- input sku
                args

            ()
            n, List.Cons(apply, args)

        member _.Sku((n, args), sku) =
            let apply (args: LinuxVirtualMachineSourceImageReferenceArgs) =
                args.Sku <- io sku
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("version")>]
        member _.Version((n, args), version) =
            let apply (args: LinuxVirtualMachineSourceImageReferenceArgs) =
                args.Version <- input version
                args

            ()
            n, List.Cons(apply, args)

        member _.Version((n, args), version) =
            let apply (args: LinuxVirtualMachineSourceImageReferenceArgs) =
                args.Version <- io version
                args

            ()
            n, List.Cons(apply, args)

    let linuxVirtualMachineSourceImageReference =
        LinuxVirtualMachineSourceImageReferenceBuilder()

    type ManagedDiskEncryptionSettingsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ManagedDiskEncryptionSettingsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: ManagedDiskEncryptionSettingsArgs) =
                   args.DiskEncryptionKey <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: ManagedDiskEncryptionSettingsArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: ManagedDiskEncryptionSettingsArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ManagedDiskEncryptionSettingsArgs) =
                   args.KeyEncryptionKey <- input arg
                   args

               ()
               func) ]

    let managedDiskEncryptionSettings = ManagedDiskEncryptionSettingsBuilder()

    type ManagedDiskEncryptionSettingsDiskEncryptionKeyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ManagedDiskEncryptionSettingsDiskEncryptionKeyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("secretUrl")>]
        member _.SecretUrl((n, args), secretUrl) =
            let apply (args: ManagedDiskEncryptionSettingsDiskEncryptionKeyArgs) =
                args.SecretUrl <- input secretUrl
                args

            ()
            n, List.Cons(apply, args)

        member _.SecretUrl((n, args), secretUrl) =
            let apply (args: ManagedDiskEncryptionSettingsDiskEncryptionKeyArgs) =
                args.SecretUrl <- io secretUrl
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sourceVaultId")>]
        member _.SourceVaultId((n, args), sourceVaultId) =
            let apply (args: ManagedDiskEncryptionSettingsDiskEncryptionKeyArgs) =
                args.SourceVaultId <- input sourceVaultId
                args

            ()
            n, List.Cons(apply, args)

        member _.SourceVaultId((n, args), sourceVaultId) =
            let apply (args: ManagedDiskEncryptionSettingsDiskEncryptionKeyArgs) =
                args.SourceVaultId <- io sourceVaultId
                args

            ()
            n, List.Cons(apply, args)

    let managedDiskEncryptionSettingsDiskEncryptionKey =
        ManagedDiskEncryptionSettingsDiskEncryptionKeyBuilder()

    type ManagedDiskEncryptionSettingsKeyEncryptionKeyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ManagedDiskEncryptionSettingsKeyEncryptionKeyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("keyUrl")>]
        member _.KeyUrl((n, args), keyUrl) =
            let apply (args: ManagedDiskEncryptionSettingsKeyEncryptionKeyArgs) =
                args.KeyUrl <- input keyUrl
                args

            ()
            n, List.Cons(apply, args)

        member _.KeyUrl((n, args), keyUrl) =
            let apply (args: ManagedDiskEncryptionSettingsKeyEncryptionKeyArgs) =
                args.KeyUrl <- io keyUrl
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sourceVaultId")>]
        member _.SourceVaultId((n, args), sourceVaultId) =
            let apply (args: ManagedDiskEncryptionSettingsKeyEncryptionKeyArgs) =
                args.SourceVaultId <- input sourceVaultId
                args

            ()
            n, List.Cons(apply, args)

        member _.SourceVaultId((n, args), sourceVaultId) =
            let apply (args: ManagedDiskEncryptionSettingsKeyEncryptionKeyArgs) =
                args.SourceVaultId <- io sourceVaultId
                args

            ()
            n, List.Cons(apply, args)

    let managedDiskEncryptionSettingsKeyEncryptionKey =
        ManagedDiskEncryptionSettingsKeyEncryptionKeyBuilder()

    type ScaleSetBootDiagnosticsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ScaleSetBootDiagnosticsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: ScaleSetBootDiagnosticsArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: ScaleSetBootDiagnosticsArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageUri")>]
        member _.StorageUri((n, args), storageUri) =
            let apply (args: ScaleSetBootDiagnosticsArgs) =
                args.StorageUri <- input storageUri
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageUri((n, args), storageUri) =
            let apply (args: ScaleSetBootDiagnosticsArgs) =
                args.StorageUri <- io storageUri
                args

            ()
            n, List.Cons(apply, args)

    let scaleSetBootDiagnostics = ScaleSetBootDiagnosticsBuilder()

    type ScaleSetExtensionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ScaleSetExtensionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("autoUpgradeMinorVersion")>]
        member _.AutoUpgradeMinorVersion((n, args), autoUpgradeMinorVersion) =
            let apply (args: ScaleSetExtensionArgs) =
                args.AutoUpgradeMinorVersion <- input autoUpgradeMinorVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.AutoUpgradeMinorVersion((n, args), autoUpgradeMinorVersion) =
            let apply (args: ScaleSetExtensionArgs) =
                args.AutoUpgradeMinorVersion <- io autoUpgradeMinorVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ScaleSetExtensionArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ScaleSetExtensionArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("protectedSettings")>]
        member _.ProtectedSettings((n, args), protectedSettings) =
            let apply (args: ScaleSetExtensionArgs) =
                args.ProtectedSettings <- input protectedSettings
                args

            ()
            n, List.Cons(apply, args)

        member _.ProtectedSettings((n, args), protectedSettings) =
            let apply (args: ScaleSetExtensionArgs) =
                args.ProtectedSettings <- io protectedSettings
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("provisionAfterExtensions")>]
        member _.ProvisionAfterExtensions((n, args), provisionAfterExtensions) =
            let apply (args: ScaleSetExtensionArgs) =
                args.ProvisionAfterExtensions <- inputList provisionAfterExtensions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publisher")>]
        member _.Publisher((n, args), publisher) =
            let apply (args: ScaleSetExtensionArgs) =
                args.Publisher <- input publisher
                args

            ()
            n, List.Cons(apply, args)

        member _.Publisher((n, args), publisher) =
            let apply (args: ScaleSetExtensionArgs) =
                args.Publisher <- io publisher
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("settings")>]
        member _.Settings((n, args), settings) =
            let apply (args: ScaleSetExtensionArgs) =
                args.Settings <- input settings
                args

            ()
            n, List.Cons(apply, args)

        member _.Settings((n, args), settings) =
            let apply (args: ScaleSetExtensionArgs) =
                args.Settings <- io settings
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: ScaleSetExtensionArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: ScaleSetExtensionArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("typeHandlerVersion")>]
        member _.TypeHandlerVersion((n, args), typeHandlerVersion) =
            let apply (args: ScaleSetExtensionArgs) =
                args.TypeHandlerVersion <- input typeHandlerVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.TypeHandlerVersion((n, args), typeHandlerVersion) =
            let apply (args: ScaleSetExtensionArgs) =
                args.TypeHandlerVersion <- io typeHandlerVersion
                args

            ()
            n, List.Cons(apply, args)

    let scaleSetExtension = ScaleSetExtensionBuilder()

    type ScaleSetIdentityBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ScaleSetIdentityArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("identityIds")>]
        member _.IdentityIds((n, args), identityIds) =
            let apply (args: ScaleSetIdentityArgs) =
                args.IdentityIds <- inputList identityIds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("principalId")>]
        member _.PrincipalId((n, args), principalId) =
            let apply (args: ScaleSetIdentityArgs) =
                args.PrincipalId <- input principalId
                args

            ()
            n, List.Cons(apply, args)

        member _.PrincipalId((n, args), principalId) =
            let apply (args: ScaleSetIdentityArgs) =
                args.PrincipalId <- io principalId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: ScaleSetIdentityArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: ScaleSetIdentityArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let scaleSetIdentity = ScaleSetIdentityBuilder()

    type ScaleSetNetworkProfileBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ScaleSetNetworkProfileArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("acceleratedNetworking")>]
        member _.AcceleratedNetworking((n, args), acceleratedNetworking) =
            let apply (args: ScaleSetNetworkProfileArgs) =
                args.AcceleratedNetworking <- input acceleratedNetworking
                args

            ()
            n, List.Cons(apply, args)

        member _.AcceleratedNetworking((n, args), acceleratedNetworking) =
            let apply (args: ScaleSetNetworkProfileArgs) =
                args.AcceleratedNetworking <- io acceleratedNetworking
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ScaleSetNetworkProfileArgs) =
                   args.DnsSettings <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("ipConfigurations")>]
        member _.IpConfigurations((n, args), ipConfigurations) =
            let apply (args: ScaleSetNetworkProfileArgs) =
                args.IpConfigurations <- inputList ipConfigurations
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ipForwarding")>]
        member _.IpForwarding((n, args), ipForwarding) =
            let apply (args: ScaleSetNetworkProfileArgs) =
                args.IpForwarding <- input ipForwarding
                args

            ()
            n, List.Cons(apply, args)

        member _.IpForwarding((n, args), ipForwarding) =
            let apply (args: ScaleSetNetworkProfileArgs) =
                args.IpForwarding <- io ipForwarding
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ScaleSetNetworkProfileArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ScaleSetNetworkProfileArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("networkSecurityGroupId")>]
        member _.NetworkSecurityGroupId((n, args), networkSecurityGroupId) =
            let apply (args: ScaleSetNetworkProfileArgs) =
                args.NetworkSecurityGroupId <- input networkSecurityGroupId
                args

            ()
            n, List.Cons(apply, args)

        member _.NetworkSecurityGroupId((n, args), networkSecurityGroupId) =
            let apply (args: ScaleSetNetworkProfileArgs) =
                args.NetworkSecurityGroupId <- io networkSecurityGroupId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("primary")>]
        member _.Primary((n, args), primary) =
            let apply (args: ScaleSetNetworkProfileArgs) =
                args.Primary <- input primary
                args

            ()
            n, List.Cons(apply, args)

        member _.Primary((n, args), primary) =
            let apply (args: ScaleSetNetworkProfileArgs) =
                args.Primary <- io primary
                args

            ()
            n, List.Cons(apply, args)

    let scaleSetNetworkProfile = ScaleSetNetworkProfileBuilder()

    type ScaleSetNetworkProfileDnsSettingsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ScaleSetNetworkProfileDnsSettingsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("dnsServers")>]
        member _.DnsServers((n, args), dnsServers) =
            let apply (args: ScaleSetNetworkProfileDnsSettingsArgs) =
                args.DnsServers <- inputList dnsServers
                args

            ()
            n, List.Cons(apply, args)

    let scaleSetNetworkProfileDnsSettings =
        ScaleSetNetworkProfileDnsSettingsBuilder()

    type ScaleSetNetworkProfileIpConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ScaleSetNetworkProfileIpConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("applicationGatewayBackendAddressPoolIds")>]
        member _.ApplicationGatewayBackendAddressPoolIds((n, args), applicationGatewayBackendAddressPoolIds) =
            let apply (args: ScaleSetNetworkProfileIpConfigurationArgs) =
                args.ApplicationGatewayBackendAddressPoolIds <- inputList applicationGatewayBackendAddressPoolIds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("applicationSecurityGroupIds")>]
        member _.ApplicationSecurityGroupIds((n, args), applicationSecurityGroupIds) =
            let apply (args: ScaleSetNetworkProfileIpConfigurationArgs) =
                args.ApplicationSecurityGroupIds <- inputList applicationSecurityGroupIds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("loadBalancerBackendAddressPoolIds")>]
        member _.LoadBalancerBackendAddressPoolIds((n, args), loadBalancerBackendAddressPoolIds) =
            let apply (args: ScaleSetNetworkProfileIpConfigurationArgs) =
                args.LoadBalancerBackendAddressPoolIds <- inputList loadBalancerBackendAddressPoolIds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("loadBalancerInboundNatRulesIds")>]
        member _.LoadBalancerInboundNatRulesIds((n, args), loadBalancerInboundNatRulesIds) =
            let apply (args: ScaleSetNetworkProfileIpConfigurationArgs) =
                args.LoadBalancerInboundNatRulesIds <- inputList loadBalancerInboundNatRulesIds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ScaleSetNetworkProfileIpConfigurationArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ScaleSetNetworkProfileIpConfigurationArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("primary")>]
        member _.Primary((n, args), primary) =
            let apply (args: ScaleSetNetworkProfileIpConfigurationArgs) =
                args.Primary <- input primary
                args

            ()
            n, List.Cons(apply, args)

        member _.Primary((n, args), primary) =
            let apply (args: ScaleSetNetworkProfileIpConfigurationArgs) =
                args.Primary <- io primary
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ScaleSetNetworkProfileIpConfigurationArgs) =
                   args.PublicIpAddressConfiguration <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: ScaleSetNetworkProfileIpConfigurationArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: ScaleSetNetworkProfileIpConfigurationArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

    let scaleSetNetworkProfileIpConfiguration =
        ScaleSetNetworkProfileIpConfigurationBuilder()

    type ScaleSetNetworkProfileIpConfigurationPublicIpAddressConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ScaleSetNetworkProfileIpConfigurationPublicIpAddressConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("domainNameLabel")>]
        member _.DomainNameLabel((n, args), domainNameLabel) =
            let apply (args: ScaleSetNetworkProfileIpConfigurationPublicIpAddressConfigurationArgs) =
                args.DomainNameLabel <- input domainNameLabel
                args

            ()
            n, List.Cons(apply, args)

        member _.DomainNameLabel((n, args), domainNameLabel) =
            let apply (args: ScaleSetNetworkProfileIpConfigurationPublicIpAddressConfigurationArgs) =
                args.DomainNameLabel <- io domainNameLabel
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("idleTimeout")>]
        member _.IdleTimeout((n, args), idleTimeout) =
            let apply (args: ScaleSetNetworkProfileIpConfigurationPublicIpAddressConfigurationArgs) =
                args.IdleTimeout <- input idleTimeout
                args

            ()
            n, List.Cons(apply, args)

        member _.IdleTimeout((n, args), idleTimeout) =
            let apply (args: ScaleSetNetworkProfileIpConfigurationPublicIpAddressConfigurationArgs) =
                args.IdleTimeout <- io idleTimeout
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ScaleSetNetworkProfileIpConfigurationPublicIpAddressConfigurationArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ScaleSetNetworkProfileIpConfigurationPublicIpAddressConfigurationArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

    let scaleSetNetworkProfileIpConfigurationPublicIpAddressConfiguration =
        ScaleSetNetworkProfileIpConfigurationPublicIpAddressConfigurationBuilder()

    type ScaleSetOsProfileBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ScaleSetOsProfileArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("adminPassword")>]
        member _.AdminPassword((n, args), adminPassword) =
            let apply (args: ScaleSetOsProfileArgs) =
                args.AdminPassword <- input adminPassword
                args

            ()
            n, List.Cons(apply, args)

        member _.AdminPassword((n, args), adminPassword) =
            let apply (args: ScaleSetOsProfileArgs) =
                args.AdminPassword <- io adminPassword
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("adminUsername")>]
        member _.AdminUsername((n, args), adminUsername) =
            let apply (args: ScaleSetOsProfileArgs) =
                args.AdminUsername <- input adminUsername
                args

            ()
            n, List.Cons(apply, args)

        member _.AdminUsername((n, args), adminUsername) =
            let apply (args: ScaleSetOsProfileArgs) =
                args.AdminUsername <- io adminUsername
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("computerNamePrefix")>]
        member _.ComputerNamePrefix((n, args), computerNamePrefix) =
            let apply (args: ScaleSetOsProfileArgs) =
                args.ComputerNamePrefix <- input computerNamePrefix
                args

            ()
            n, List.Cons(apply, args)

        member _.ComputerNamePrefix((n, args), computerNamePrefix) =
            let apply (args: ScaleSetOsProfileArgs) =
                args.ComputerNamePrefix <- io computerNamePrefix
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("customData")>]
        member _.CustomData((n, args), customData) =
            let apply (args: ScaleSetOsProfileArgs) =
                args.CustomData <- input customData
                args

            ()
            n, List.Cons(apply, args)

        member _.CustomData((n, args), customData) =
            let apply (args: ScaleSetOsProfileArgs) =
                args.CustomData <- io customData
                args

            ()
            n, List.Cons(apply, args)

    let scaleSetOsProfile = ScaleSetOsProfileBuilder()

    type ScaleSetOsProfileLinuxConfigBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ScaleSetOsProfileLinuxConfigArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("disablePasswordAuthentication")>]
        member _.DisablePasswordAuthentication((n, args), disablePasswordAuthentication) =
            let apply (args: ScaleSetOsProfileLinuxConfigArgs) =
                args.DisablePasswordAuthentication <- input disablePasswordAuthentication
                args

            ()
            n, List.Cons(apply, args)

        member _.DisablePasswordAuthentication((n, args), disablePasswordAuthentication) =
            let apply (args: ScaleSetOsProfileLinuxConfigArgs) =
                args.DisablePasswordAuthentication <- io disablePasswordAuthentication
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sshKeys")>]
        member _.SshKeys((n, args), sshKeys) =
            let apply (args: ScaleSetOsProfileLinuxConfigArgs) =
                args.SshKeys <- inputList sshKeys
                args

            ()
            n, List.Cons(apply, args)

    let scaleSetOsProfileLinuxConfig = ScaleSetOsProfileLinuxConfigBuilder()

    type ScaleSetOsProfileLinuxConfigSshKeyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ScaleSetOsProfileLinuxConfigSshKeyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("keyData")>]
        member _.KeyData((n, args), keyData) =
            let apply (args: ScaleSetOsProfileLinuxConfigSshKeyArgs) =
                args.KeyData <- input keyData
                args

            ()
            n, List.Cons(apply, args)

        member _.KeyData((n, args), keyData) =
            let apply (args: ScaleSetOsProfileLinuxConfigSshKeyArgs) =
                args.KeyData <- io keyData
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("path")>]
        member _.Path((n, args), path) =
            let apply (args: ScaleSetOsProfileLinuxConfigSshKeyArgs) =
                args.Path <- input path
                args

            ()
            n, List.Cons(apply, args)

        member _.Path((n, args), path) =
            let apply (args: ScaleSetOsProfileLinuxConfigSshKeyArgs) =
                args.Path <- io path
                args

            ()
            n, List.Cons(apply, args)

    let scaleSetOsProfileLinuxConfigSshKey =
        ScaleSetOsProfileLinuxConfigSshKeyBuilder()

    type ScaleSetOsProfileSecretBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ScaleSetOsProfileSecretArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("sourceVaultId")>]
        member _.SourceVaultId((n, args), sourceVaultId) =
            let apply (args: ScaleSetOsProfileSecretArgs) =
                args.SourceVaultId <- input sourceVaultId
                args

            ()
            n, List.Cons(apply, args)

        member _.SourceVaultId((n, args), sourceVaultId) =
            let apply (args: ScaleSetOsProfileSecretArgs) =
                args.SourceVaultId <- io sourceVaultId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vaultCertificates")>]
        member _.VaultCertificates((n, args), vaultCertificates) =
            let apply (args: ScaleSetOsProfileSecretArgs) =
                args.VaultCertificates <- inputList vaultCertificates
                args

            ()
            n, List.Cons(apply, args)

    let scaleSetOsProfileSecret = ScaleSetOsProfileSecretBuilder()

    type ScaleSetOsProfileSecretVaultCertificateBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ScaleSetOsProfileSecretVaultCertificateArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("certificateStore")>]
        member _.CertificateStore((n, args), certificateStore) =
            let apply (args: ScaleSetOsProfileSecretVaultCertificateArgs) =
                args.CertificateStore <- input certificateStore
                args

            ()
            n, List.Cons(apply, args)

        member _.CertificateStore((n, args), certificateStore) =
            let apply (args: ScaleSetOsProfileSecretVaultCertificateArgs) =
                args.CertificateStore <- io certificateStore
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("certificateUrl")>]
        member _.CertificateUrl((n, args), certificateUrl) =
            let apply (args: ScaleSetOsProfileSecretVaultCertificateArgs) =
                args.CertificateUrl <- input certificateUrl
                args

            ()
            n, List.Cons(apply, args)

        member _.CertificateUrl((n, args), certificateUrl) =
            let apply (args: ScaleSetOsProfileSecretVaultCertificateArgs) =
                args.CertificateUrl <- io certificateUrl
                args

            ()
            n, List.Cons(apply, args)

    let scaleSetOsProfileSecretVaultCertificate =
        ScaleSetOsProfileSecretVaultCertificateBuilder()

    type ScaleSetOsProfileWindowsConfigBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ScaleSetOsProfileWindowsConfigArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("additionalUnattendConfigs")>]
        member _.AdditionalUnattendConfigs((n, args), additionalUnattendConfigs) =
            let apply (args: ScaleSetOsProfileWindowsConfigArgs) =
                args.AdditionalUnattendConfigs <- inputList additionalUnattendConfigs
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enableAutomaticUpgrades")>]
        member _.EnableAutomaticUpgrades((n, args), enableAutomaticUpgrades) =
            let apply (args: ScaleSetOsProfileWindowsConfigArgs) =
                args.EnableAutomaticUpgrades <- input enableAutomaticUpgrades
                args

            ()
            n, List.Cons(apply, args)

        member _.EnableAutomaticUpgrades((n, args), enableAutomaticUpgrades) =
            let apply (args: ScaleSetOsProfileWindowsConfigArgs) =
                args.EnableAutomaticUpgrades <- io enableAutomaticUpgrades
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("provisionVmAgent")>]
        member _.ProvisionVmAgent((n, args), provisionVmAgent) =
            let apply (args: ScaleSetOsProfileWindowsConfigArgs) =
                args.ProvisionVmAgent <- input provisionVmAgent
                args

            ()
            n, List.Cons(apply, args)

        member _.ProvisionVmAgent((n, args), provisionVmAgent) =
            let apply (args: ScaleSetOsProfileWindowsConfigArgs) =
                args.ProvisionVmAgent <- io provisionVmAgent
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("winrms")>]
        member _.Winrms((n, args), winrms) =
            let apply (args: ScaleSetOsProfileWindowsConfigArgs) =
                args.Winrms <- inputList winrms
                args

            ()
            n, List.Cons(apply, args)

    let scaleSetOsProfileWindowsConfig = ScaleSetOsProfileWindowsConfigBuilder()

    type ScaleSetOsProfileWindowsConfigAdditionalUnattendConfigBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ScaleSetOsProfileWindowsConfigAdditionalUnattendConfigArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("component")>]
        member _.Component((n, args), ``component``) =
            let apply (args: ScaleSetOsProfileWindowsConfigAdditionalUnattendConfigArgs) =
                args.Component <- input ``component``
                args

            ()
            n, List.Cons(apply, args)

        member _.Component((n, args), ``component``) =
            let apply (args: ScaleSetOsProfileWindowsConfigAdditionalUnattendConfigArgs) =
                args.Component <- io ``component``
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("content")>]
        member _.Content((n, args), content) =
            let apply (args: ScaleSetOsProfileWindowsConfigAdditionalUnattendConfigArgs) =
                args.Content <- input content
                args

            ()
            n, List.Cons(apply, args)

        member _.Content((n, args), content) =
            let apply (args: ScaleSetOsProfileWindowsConfigAdditionalUnattendConfigArgs) =
                args.Content <- io content
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("pass")>]
        member _.Pass((n, args), pass) =
            let apply (args: ScaleSetOsProfileWindowsConfigAdditionalUnattendConfigArgs) =
                args.Pass <- input pass
                args

            ()
            n, List.Cons(apply, args)

        member _.Pass((n, args), pass) =
            let apply (args: ScaleSetOsProfileWindowsConfigAdditionalUnattendConfigArgs) =
                args.Pass <- io pass
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("settingName")>]
        member _.SettingName((n, args), settingName) =
            let apply (args: ScaleSetOsProfileWindowsConfigAdditionalUnattendConfigArgs) =
                args.SettingName <- input settingName
                args

            ()
            n, List.Cons(apply, args)

        member _.SettingName((n, args), settingName) =
            let apply (args: ScaleSetOsProfileWindowsConfigAdditionalUnattendConfigArgs) =
                args.SettingName <- io settingName
                args

            ()
            n, List.Cons(apply, args)

    let scaleSetOsProfileWindowsConfigAdditionalUnattendConfig =
        ScaleSetOsProfileWindowsConfigAdditionalUnattendConfigBuilder()

    type ScaleSetOsProfileWindowsConfigWinrmBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ScaleSetOsProfileWindowsConfigWinrmArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("certificateUrl")>]
        member _.CertificateUrl((n, args), certificateUrl) =
            let apply (args: ScaleSetOsProfileWindowsConfigWinrmArgs) =
                args.CertificateUrl <- input certificateUrl
                args

            ()
            n, List.Cons(apply, args)

        member _.CertificateUrl((n, args), certificateUrl) =
            let apply (args: ScaleSetOsProfileWindowsConfigWinrmArgs) =
                args.CertificateUrl <- io certificateUrl
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("protocol")>]
        member _.Protocol((n, args), protocol) =
            let apply (args: ScaleSetOsProfileWindowsConfigWinrmArgs) =
                args.Protocol <- input protocol
                args

            ()
            n, List.Cons(apply, args)

        member _.Protocol((n, args), protocol) =
            let apply (args: ScaleSetOsProfileWindowsConfigWinrmArgs) =
                args.Protocol <- io protocol
                args

            ()
            n, List.Cons(apply, args)

    let scaleSetOsProfileWindowsConfigWinrm =
        ScaleSetOsProfileWindowsConfigWinrmBuilder()

    type ScaleSetPlanBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ScaleSetPlanArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ScaleSetPlanArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ScaleSetPlanArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("product")>]
        member _.Product((n, args), product) =
            let apply (args: ScaleSetPlanArgs) =
                args.Product <- input product
                args

            ()
            n, List.Cons(apply, args)

        member _.Product((n, args), product) =
            let apply (args: ScaleSetPlanArgs) =
                args.Product <- io product
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publisher")>]
        member _.Publisher((n, args), publisher) =
            let apply (args: ScaleSetPlanArgs) =
                args.Publisher <- input publisher
                args

            ()
            n, List.Cons(apply, args)

        member _.Publisher((n, args), publisher) =
            let apply (args: ScaleSetPlanArgs) =
                args.Publisher <- io publisher
                args

            ()
            n, List.Cons(apply, args)

    let scaleSetPlan = ScaleSetPlanBuilder()

    type ScaleSetRollingUpgradePolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ScaleSetRollingUpgradePolicyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("maxBatchInstancePercent")>]
        member _.MaxBatchInstancePercent((n, args), maxBatchInstancePercent) =
            let apply (args: ScaleSetRollingUpgradePolicyArgs) =
                args.MaxBatchInstancePercent <- input maxBatchInstancePercent
                args

            ()
            n, List.Cons(apply, args)

        member _.MaxBatchInstancePercent((n, args), maxBatchInstancePercent) =
            let apply (args: ScaleSetRollingUpgradePolicyArgs) =
                args.MaxBatchInstancePercent <- io maxBatchInstancePercent
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("maxUnhealthyInstancePercent")>]
        member _.MaxUnhealthyInstancePercent((n, args), maxUnhealthyInstancePercent) =
            let apply (args: ScaleSetRollingUpgradePolicyArgs) =
                args.MaxUnhealthyInstancePercent <- input maxUnhealthyInstancePercent
                args

            ()
            n, List.Cons(apply, args)

        member _.MaxUnhealthyInstancePercent((n, args), maxUnhealthyInstancePercent) =
            let apply (args: ScaleSetRollingUpgradePolicyArgs) =
                args.MaxUnhealthyInstancePercent <- io maxUnhealthyInstancePercent
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("maxUnhealthyUpgradedInstancePercent")>]
        member _.MaxUnhealthyUpgradedInstancePercent((n, args), maxUnhealthyUpgradedInstancePercent) =
            let apply (args: ScaleSetRollingUpgradePolicyArgs) =
                args.MaxUnhealthyUpgradedInstancePercent <- input maxUnhealthyUpgradedInstancePercent
                args

            ()
            n, List.Cons(apply, args)

        member _.MaxUnhealthyUpgradedInstancePercent((n, args), maxUnhealthyUpgradedInstancePercent) =
            let apply (args: ScaleSetRollingUpgradePolicyArgs) =
                args.MaxUnhealthyUpgradedInstancePercent <- io maxUnhealthyUpgradedInstancePercent
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("pauseTimeBetweenBatches")>]
        member _.PauseTimeBetweenBatches((n, args), pauseTimeBetweenBatches) =
            let apply (args: ScaleSetRollingUpgradePolicyArgs) =
                args.PauseTimeBetweenBatches <- input pauseTimeBetweenBatches
                args

            ()
            n, List.Cons(apply, args)

        member _.PauseTimeBetweenBatches((n, args), pauseTimeBetweenBatches) =
            let apply (args: ScaleSetRollingUpgradePolicyArgs) =
                args.PauseTimeBetweenBatches <- io pauseTimeBetweenBatches
                args

            ()
            n, List.Cons(apply, args)

    let scaleSetRollingUpgradePolicy = ScaleSetRollingUpgradePolicyBuilder()

    type ScaleSetSkuBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ScaleSetSkuArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("capacity")>]
        member _.Capacity((n, args), capacity) =
            let apply (args: ScaleSetSkuArgs) =
                args.Capacity <- input capacity
                args

            ()
            n, List.Cons(apply, args)

        member _.Capacity((n, args), capacity) =
            let apply (args: ScaleSetSkuArgs) =
                args.Capacity <- io capacity
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ScaleSetSkuArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ScaleSetSkuArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tier")>]
        member _.Tier((n, args), tier) =
            let apply (args: ScaleSetSkuArgs) =
                args.Tier <- input tier
                args

            ()
            n, List.Cons(apply, args)

        member _.Tier((n, args), tier) =
            let apply (args: ScaleSetSkuArgs) =
                args.Tier <- io tier
                args

            ()
            n, List.Cons(apply, args)

    let scaleSetSku = ScaleSetSkuBuilder()

    type ScaleSetStorageProfileDataDiskBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ScaleSetStorageProfileDataDiskArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("caching")>]
        member _.Caching((n, args), caching) =
            let apply (args: ScaleSetStorageProfileDataDiskArgs) =
                args.Caching <- input caching
                args

            ()
            n, List.Cons(apply, args)

        member _.Caching((n, args), caching) =
            let apply (args: ScaleSetStorageProfileDataDiskArgs) =
                args.Caching <- io caching
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("createOption")>]
        member _.CreateOption((n, args), createOption) =
            let apply (args: ScaleSetStorageProfileDataDiskArgs) =
                args.CreateOption <- input createOption
                args

            ()
            n, List.Cons(apply, args)

        member _.CreateOption((n, args), createOption) =
            let apply (args: ScaleSetStorageProfileDataDiskArgs) =
                args.CreateOption <- io createOption
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("diskSizeGb")>]
        member _.DiskSizeGb((n, args), diskSizeGb) =
            let apply (args: ScaleSetStorageProfileDataDiskArgs) =
                args.DiskSizeGb <- input diskSizeGb
                args

            ()
            n, List.Cons(apply, args)

        member _.DiskSizeGb((n, args), diskSizeGb) =
            let apply (args: ScaleSetStorageProfileDataDiskArgs) =
                args.DiskSizeGb <- io diskSizeGb
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("lun")>]
        member _.Lun((n, args), lun) =
            let apply (args: ScaleSetStorageProfileDataDiskArgs) =
                args.Lun <- input lun
                args

            ()
            n, List.Cons(apply, args)

        member _.Lun((n, args), lun) =
            let apply (args: ScaleSetStorageProfileDataDiskArgs) =
                args.Lun <- io lun
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("managedDiskType")>]
        member _.ManagedDiskType((n, args), managedDiskType) =
            let apply (args: ScaleSetStorageProfileDataDiskArgs) =
                args.ManagedDiskType <- input managedDiskType
                args

            ()
            n, List.Cons(apply, args)

        member _.ManagedDiskType((n, args), managedDiskType) =
            let apply (args: ScaleSetStorageProfileDataDiskArgs) =
                args.ManagedDiskType <- io managedDiskType
                args

            ()
            n, List.Cons(apply, args)

    let scaleSetStorageProfileDataDisk = ScaleSetStorageProfileDataDiskBuilder()

    type ScaleSetStorageProfileImageReferenceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ScaleSetStorageProfileImageReferenceArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: ScaleSetStorageProfileImageReferenceArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: ScaleSetStorageProfileImageReferenceArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("offer")>]
        member _.Offer((n, args), offer) =
            let apply (args: ScaleSetStorageProfileImageReferenceArgs) =
                args.Offer <- input offer
                args

            ()
            n, List.Cons(apply, args)

        member _.Offer((n, args), offer) =
            let apply (args: ScaleSetStorageProfileImageReferenceArgs) =
                args.Offer <- io offer
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publisher")>]
        member _.Publisher((n, args), publisher) =
            let apply (args: ScaleSetStorageProfileImageReferenceArgs) =
                args.Publisher <- input publisher
                args

            ()
            n, List.Cons(apply, args)

        member _.Publisher((n, args), publisher) =
            let apply (args: ScaleSetStorageProfileImageReferenceArgs) =
                args.Publisher <- io publisher
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sku")>]
        member _.Sku((n, args), sku) =
            let apply (args: ScaleSetStorageProfileImageReferenceArgs) =
                args.Sku <- input sku
                args

            ()
            n, List.Cons(apply, args)

        member _.Sku((n, args), sku) =
            let apply (args: ScaleSetStorageProfileImageReferenceArgs) =
                args.Sku <- io sku
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("version")>]
        member _.Version((n, args), version) =
            let apply (args: ScaleSetStorageProfileImageReferenceArgs) =
                args.Version <- input version
                args

            ()
            n, List.Cons(apply, args)

        member _.Version((n, args), version) =
            let apply (args: ScaleSetStorageProfileImageReferenceArgs) =
                args.Version <- io version
                args

            ()
            n, List.Cons(apply, args)

    let scaleSetStorageProfileImageReference =
        ScaleSetStorageProfileImageReferenceBuilder()

    type ScaleSetStorageProfileOsDiskBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ScaleSetStorageProfileOsDiskArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("caching")>]
        member _.Caching((n, args), caching) =
            let apply (args: ScaleSetStorageProfileOsDiskArgs) =
                args.Caching <- input caching
                args

            ()
            n, List.Cons(apply, args)

        member _.Caching((n, args), caching) =
            let apply (args: ScaleSetStorageProfileOsDiskArgs) =
                args.Caching <- io caching
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("createOption")>]
        member _.CreateOption((n, args), createOption) =
            let apply (args: ScaleSetStorageProfileOsDiskArgs) =
                args.CreateOption <- input createOption
                args

            ()
            n, List.Cons(apply, args)

        member _.CreateOption((n, args), createOption) =
            let apply (args: ScaleSetStorageProfileOsDiskArgs) =
                args.CreateOption <- io createOption
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("image")>]
        member _.Image((n, args), image) =
            let apply (args: ScaleSetStorageProfileOsDiskArgs) =
                args.Image <- input image
                args

            ()
            n, List.Cons(apply, args)

        member _.Image((n, args), image) =
            let apply (args: ScaleSetStorageProfileOsDiskArgs) =
                args.Image <- io image
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("managedDiskType")>]
        member _.ManagedDiskType((n, args), managedDiskType) =
            let apply (args: ScaleSetStorageProfileOsDiskArgs) =
                args.ManagedDiskType <- input managedDiskType
                args

            ()
            n, List.Cons(apply, args)

        member _.ManagedDiskType((n, args), managedDiskType) =
            let apply (args: ScaleSetStorageProfileOsDiskArgs) =
                args.ManagedDiskType <- io managedDiskType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ScaleSetStorageProfileOsDiskArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ScaleSetStorageProfileOsDiskArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("osType")>]
        member _.OsType((n, args), osType) =
            let apply (args: ScaleSetStorageProfileOsDiskArgs) =
                args.OsType <- input osType
                args

            ()
            n, List.Cons(apply, args)

        member _.OsType((n, args), osType) =
            let apply (args: ScaleSetStorageProfileOsDiskArgs) =
                args.OsType <- io osType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vhdContainers")>]
        member _.VhdContainers((n, args), vhdContainers) =
            let apply (args: ScaleSetStorageProfileOsDiskArgs) =
                args.VhdContainers <- inputList vhdContainers
                args

            ()
            n, List.Cons(apply, args)

    let scaleSetStorageProfileOsDisk = ScaleSetStorageProfileOsDiskBuilder()

    type SharedImageIdentifierBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SharedImageIdentifierArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("offer")>]
        member _.Offer((n, args), offer) =
            let apply (args: SharedImageIdentifierArgs) =
                args.Offer <- input offer
                args

            ()
            n, List.Cons(apply, args)

        member _.Offer((n, args), offer) =
            let apply (args: SharedImageIdentifierArgs) =
                args.Offer <- io offer
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publisher")>]
        member _.Publisher((n, args), publisher) =
            let apply (args: SharedImageIdentifierArgs) =
                args.Publisher <- input publisher
                args

            ()
            n, List.Cons(apply, args)

        member _.Publisher((n, args), publisher) =
            let apply (args: SharedImageIdentifierArgs) =
                args.Publisher <- io publisher
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sku")>]
        member _.Sku((n, args), sku) =
            let apply (args: SharedImageIdentifierArgs) =
                args.Sku <- input sku
                args

            ()
            n, List.Cons(apply, args)

        member _.Sku((n, args), sku) =
            let apply (args: SharedImageIdentifierArgs) =
                args.Sku <- io sku
                args

            ()
            n, List.Cons(apply, args)

    let sharedImageIdentifier = SharedImageIdentifierBuilder()

    type SharedImageVersionTargetRegionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SharedImageVersionTargetRegionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: SharedImageVersionTargetRegionArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: SharedImageVersionTargetRegionArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("regionalReplicaCount")>]
        member _.RegionalReplicaCount((n, args), regionalReplicaCount) =
            let apply (args: SharedImageVersionTargetRegionArgs) =
                args.RegionalReplicaCount <- input regionalReplicaCount
                args

            ()
            n, List.Cons(apply, args)

        member _.RegionalReplicaCount((n, args), regionalReplicaCount) =
            let apply (args: SharedImageVersionTargetRegionArgs) =
                args.RegionalReplicaCount <- io regionalReplicaCount
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageAccountType")>]
        member _.StorageAccountType((n, args), storageAccountType) =
            let apply (args: SharedImageVersionTargetRegionArgs) =
                args.StorageAccountType <- input storageAccountType
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountType((n, args), storageAccountType) =
            let apply (args: SharedImageVersionTargetRegionArgs) =
                args.StorageAccountType <- io storageAccountType
                args

            ()
            n, List.Cons(apply, args)

    let sharedImageVersionTargetRegion = SharedImageVersionTargetRegionBuilder()

    type SnapshotEncryptionSettingsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SnapshotEncryptionSettingsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: SnapshotEncryptionSettingsArgs) =
                   args.DiskEncryptionKey <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: SnapshotEncryptionSettingsArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: SnapshotEncryptionSettingsArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: SnapshotEncryptionSettingsArgs) =
                   args.KeyEncryptionKey <- input arg
                   args

               ()
               func) ]

    let snapshotEncryptionSettings = SnapshotEncryptionSettingsBuilder()

    type SnapshotEncryptionSettingsDiskEncryptionKeyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SnapshotEncryptionSettingsDiskEncryptionKeyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("secretUrl")>]
        member _.SecretUrl((n, args), secretUrl) =
            let apply (args: SnapshotEncryptionSettingsDiskEncryptionKeyArgs) =
                args.SecretUrl <- input secretUrl
                args

            ()
            n, List.Cons(apply, args)

        member _.SecretUrl((n, args), secretUrl) =
            let apply (args: SnapshotEncryptionSettingsDiskEncryptionKeyArgs) =
                args.SecretUrl <- io secretUrl
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sourceVaultId")>]
        member _.SourceVaultId((n, args), sourceVaultId) =
            let apply (args: SnapshotEncryptionSettingsDiskEncryptionKeyArgs) =
                args.SourceVaultId <- input sourceVaultId
                args

            ()
            n, List.Cons(apply, args)

        member _.SourceVaultId((n, args), sourceVaultId) =
            let apply (args: SnapshotEncryptionSettingsDiskEncryptionKeyArgs) =
                args.SourceVaultId <- io sourceVaultId
                args

            ()
            n, List.Cons(apply, args)

    let snapshotEncryptionSettingsDiskEncryptionKey =
        SnapshotEncryptionSettingsDiskEncryptionKeyBuilder()

    type SnapshotEncryptionSettingsKeyEncryptionKeyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SnapshotEncryptionSettingsKeyEncryptionKeyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("keyUrl")>]
        member _.KeyUrl((n, args), keyUrl) =
            let apply (args: SnapshotEncryptionSettingsKeyEncryptionKeyArgs) =
                args.KeyUrl <- input keyUrl
                args

            ()
            n, List.Cons(apply, args)

        member _.KeyUrl((n, args), keyUrl) =
            let apply (args: SnapshotEncryptionSettingsKeyEncryptionKeyArgs) =
                args.KeyUrl <- io keyUrl
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sourceVaultId")>]
        member _.SourceVaultId((n, args), sourceVaultId) =
            let apply (args: SnapshotEncryptionSettingsKeyEncryptionKeyArgs) =
                args.SourceVaultId <- input sourceVaultId
                args

            ()
            n, List.Cons(apply, args)

        member _.SourceVaultId((n, args), sourceVaultId) =
            let apply (args: SnapshotEncryptionSettingsKeyEncryptionKeyArgs) =
                args.SourceVaultId <- io sourceVaultId
                args

            ()
            n, List.Cons(apply, args)

    let snapshotEncryptionSettingsKeyEncryptionKey =
        SnapshotEncryptionSettingsKeyEncryptionKeyBuilder()

    type VirtualMachineAdditionalCapabilitiesBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VirtualMachineAdditionalCapabilitiesArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("ultraSsdEnabled")>]
        member _.UltraSsdEnabled((n, args), ultraSsdEnabled) =
            let apply (args: VirtualMachineAdditionalCapabilitiesArgs) =
                args.UltraSsdEnabled <- input ultraSsdEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.UltraSsdEnabled((n, args), ultraSsdEnabled) =
            let apply (args: VirtualMachineAdditionalCapabilitiesArgs) =
                args.UltraSsdEnabled <- io ultraSsdEnabled
                args

            ()
            n, List.Cons(apply, args)

    let virtualMachineAdditionalCapabilities =
        VirtualMachineAdditionalCapabilitiesBuilder()

    type VirtualMachineBootDiagnosticsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VirtualMachineBootDiagnosticsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: VirtualMachineBootDiagnosticsArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: VirtualMachineBootDiagnosticsArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageUri")>]
        member _.StorageUri((n, args), storageUri) =
            let apply (args: VirtualMachineBootDiagnosticsArgs) =
                args.StorageUri <- input storageUri
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageUri((n, args), storageUri) =
            let apply (args: VirtualMachineBootDiagnosticsArgs) =
                args.StorageUri <- io storageUri
                args

            ()
            n, List.Cons(apply, args)

    let virtualMachineBootDiagnostics = VirtualMachineBootDiagnosticsBuilder()

    type VirtualMachineIdentityBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VirtualMachineIdentityArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("identityIds")>]
        member _.IdentityIds((n, args), identityIds) =
            let apply (args: VirtualMachineIdentityArgs) =
                args.IdentityIds <- inputList identityIds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("principalId")>]
        member _.PrincipalId((n, args), principalId) =
            let apply (args: VirtualMachineIdentityArgs) =
                args.PrincipalId <- input principalId
                args

            ()
            n, List.Cons(apply, args)

        member _.PrincipalId((n, args), principalId) =
            let apply (args: VirtualMachineIdentityArgs) =
                args.PrincipalId <- io principalId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: VirtualMachineIdentityArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: VirtualMachineIdentityArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let virtualMachineIdentity = VirtualMachineIdentityBuilder()

    type VirtualMachineOsProfileBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VirtualMachineOsProfileArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("adminPassword")>]
        member _.AdminPassword((n, args), adminPassword) =
            let apply (args: VirtualMachineOsProfileArgs) =
                args.AdminPassword <- input adminPassword
                args

            ()
            n, List.Cons(apply, args)

        member _.AdminPassword((n, args), adminPassword) =
            let apply (args: VirtualMachineOsProfileArgs) =
                args.AdminPassword <- io adminPassword
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("adminUsername")>]
        member _.AdminUsername((n, args), adminUsername) =
            let apply (args: VirtualMachineOsProfileArgs) =
                args.AdminUsername <- input adminUsername
                args

            ()
            n, List.Cons(apply, args)

        member _.AdminUsername((n, args), adminUsername) =
            let apply (args: VirtualMachineOsProfileArgs) =
                args.AdminUsername <- io adminUsername
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("computerName")>]
        member _.ComputerName((n, args), computerName) =
            let apply (args: VirtualMachineOsProfileArgs) =
                args.ComputerName <- input computerName
                args

            ()
            n, List.Cons(apply, args)

        member _.ComputerName((n, args), computerName) =
            let apply (args: VirtualMachineOsProfileArgs) =
                args.ComputerName <- io computerName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("customData")>]
        member _.CustomData((n, args), customData) =
            let apply (args: VirtualMachineOsProfileArgs) =
                args.CustomData <- input customData
                args

            ()
            n, List.Cons(apply, args)

        member _.CustomData((n, args), customData) =
            let apply (args: VirtualMachineOsProfileArgs) =
                args.CustomData <- io customData
                args

            ()
            n, List.Cons(apply, args)

    let virtualMachineOsProfile = VirtualMachineOsProfileBuilder()

    type VirtualMachineOsProfileLinuxConfigBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VirtualMachineOsProfileLinuxConfigArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("disablePasswordAuthentication")>]
        member _.DisablePasswordAuthentication((n, args), disablePasswordAuthentication) =
            let apply (args: VirtualMachineOsProfileLinuxConfigArgs) =
                args.DisablePasswordAuthentication <- input disablePasswordAuthentication
                args

            ()
            n, List.Cons(apply, args)

        member _.DisablePasswordAuthentication((n, args), disablePasswordAuthentication) =
            let apply (args: VirtualMachineOsProfileLinuxConfigArgs) =
                args.DisablePasswordAuthentication <- io disablePasswordAuthentication
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sshKeys")>]
        member _.SshKeys((n, args), sshKeys) =
            let apply (args: VirtualMachineOsProfileLinuxConfigArgs) =
                args.SshKeys <- inputList sshKeys
                args

            ()
            n, List.Cons(apply, args)

    let virtualMachineOsProfileLinuxConfig =
        VirtualMachineOsProfileLinuxConfigBuilder()

    type VirtualMachineOsProfileLinuxConfigSshKeyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VirtualMachineOsProfileLinuxConfigSshKeyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("keyData")>]
        member _.KeyData((n, args), keyData) =
            let apply (args: VirtualMachineOsProfileLinuxConfigSshKeyArgs) =
                args.KeyData <- input keyData
                args

            ()
            n, List.Cons(apply, args)

        member _.KeyData((n, args), keyData) =
            let apply (args: VirtualMachineOsProfileLinuxConfigSshKeyArgs) =
                args.KeyData <- io keyData
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("path")>]
        member _.Path((n, args), path) =
            let apply (args: VirtualMachineOsProfileLinuxConfigSshKeyArgs) =
                args.Path <- input path
                args

            ()
            n, List.Cons(apply, args)

        member _.Path((n, args), path) =
            let apply (args: VirtualMachineOsProfileLinuxConfigSshKeyArgs) =
                args.Path <- io path
                args

            ()
            n, List.Cons(apply, args)

    let virtualMachineOsProfileLinuxConfigSshKey =
        VirtualMachineOsProfileLinuxConfigSshKeyBuilder()

    type VirtualMachineOsProfileSecretBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VirtualMachineOsProfileSecretArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("sourceVaultId")>]
        member _.SourceVaultId((n, args), sourceVaultId) =
            let apply (args: VirtualMachineOsProfileSecretArgs) =
                args.SourceVaultId <- input sourceVaultId
                args

            ()
            n, List.Cons(apply, args)

        member _.SourceVaultId((n, args), sourceVaultId) =
            let apply (args: VirtualMachineOsProfileSecretArgs) =
                args.SourceVaultId <- io sourceVaultId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vaultCertificates")>]
        member _.VaultCertificates((n, args), vaultCertificates) =
            let apply (args: VirtualMachineOsProfileSecretArgs) =
                args.VaultCertificates <- inputList vaultCertificates
                args

            ()
            n, List.Cons(apply, args)

    let virtualMachineOsProfileSecret = VirtualMachineOsProfileSecretBuilder()

    type VirtualMachineOsProfileSecretVaultCertificateBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VirtualMachineOsProfileSecretVaultCertificateArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("certificateStore")>]
        member _.CertificateStore((n, args), certificateStore) =
            let apply (args: VirtualMachineOsProfileSecretVaultCertificateArgs) =
                args.CertificateStore <- input certificateStore
                args

            ()
            n, List.Cons(apply, args)

        member _.CertificateStore((n, args), certificateStore) =
            let apply (args: VirtualMachineOsProfileSecretVaultCertificateArgs) =
                args.CertificateStore <- io certificateStore
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("certificateUrl")>]
        member _.CertificateUrl((n, args), certificateUrl) =
            let apply (args: VirtualMachineOsProfileSecretVaultCertificateArgs) =
                args.CertificateUrl <- input certificateUrl
                args

            ()
            n, List.Cons(apply, args)

        member _.CertificateUrl((n, args), certificateUrl) =
            let apply (args: VirtualMachineOsProfileSecretVaultCertificateArgs) =
                args.CertificateUrl <- io certificateUrl
                args

            ()
            n, List.Cons(apply, args)

    let virtualMachineOsProfileSecretVaultCertificate =
        VirtualMachineOsProfileSecretVaultCertificateBuilder()

    type VirtualMachineOsProfileWindowsConfigBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VirtualMachineOsProfileWindowsConfigArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("additionalUnattendConfigs")>]
        member _.AdditionalUnattendConfigs((n, args), additionalUnattendConfigs) =
            let apply (args: VirtualMachineOsProfileWindowsConfigArgs) =
                args.AdditionalUnattendConfigs <- inputList additionalUnattendConfigs
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enableAutomaticUpgrades")>]
        member _.EnableAutomaticUpgrades((n, args), enableAutomaticUpgrades) =
            let apply (args: VirtualMachineOsProfileWindowsConfigArgs) =
                args.EnableAutomaticUpgrades <- input enableAutomaticUpgrades
                args

            ()
            n, List.Cons(apply, args)

        member _.EnableAutomaticUpgrades((n, args), enableAutomaticUpgrades) =
            let apply (args: VirtualMachineOsProfileWindowsConfigArgs) =
                args.EnableAutomaticUpgrades <- io enableAutomaticUpgrades
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("provisionVmAgent")>]
        member _.ProvisionVmAgent((n, args), provisionVmAgent) =
            let apply (args: VirtualMachineOsProfileWindowsConfigArgs) =
                args.ProvisionVmAgent <- input provisionVmAgent
                args

            ()
            n, List.Cons(apply, args)

        member _.ProvisionVmAgent((n, args), provisionVmAgent) =
            let apply (args: VirtualMachineOsProfileWindowsConfigArgs) =
                args.ProvisionVmAgent <- io provisionVmAgent
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("timezone")>]
        member _.Timezone((n, args), timezone) =
            let apply (args: VirtualMachineOsProfileWindowsConfigArgs) =
                args.Timezone <- input timezone
                args

            ()
            n, List.Cons(apply, args)

        member _.Timezone((n, args), timezone) =
            let apply (args: VirtualMachineOsProfileWindowsConfigArgs) =
                args.Timezone <- io timezone
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("winrms")>]
        member _.Winrms((n, args), winrms) =
            let apply (args: VirtualMachineOsProfileWindowsConfigArgs) =
                args.Winrms <- inputList winrms
                args

            ()
            n, List.Cons(apply, args)

    let virtualMachineOsProfileWindowsConfig =
        VirtualMachineOsProfileWindowsConfigBuilder()

    type VirtualMachineOsProfileWindowsConfigAdditionalUnattendConfigBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VirtualMachineOsProfileWindowsConfigAdditionalUnattendConfigArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("component")>]
        member _.Component((n, args), ``component``) =
            let apply (args: VirtualMachineOsProfileWindowsConfigAdditionalUnattendConfigArgs) =
                args.Component <- input ``component``
                args

            ()
            n, List.Cons(apply, args)

        member _.Component((n, args), ``component``) =
            let apply (args: VirtualMachineOsProfileWindowsConfigAdditionalUnattendConfigArgs) =
                args.Component <- io ``component``
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("content")>]
        member _.Content((n, args), content) =
            let apply (args: VirtualMachineOsProfileWindowsConfigAdditionalUnattendConfigArgs) =
                args.Content <- input content
                args

            ()
            n, List.Cons(apply, args)

        member _.Content((n, args), content) =
            let apply (args: VirtualMachineOsProfileWindowsConfigAdditionalUnattendConfigArgs) =
                args.Content <- io content
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("pass")>]
        member _.Pass((n, args), pass) =
            let apply (args: VirtualMachineOsProfileWindowsConfigAdditionalUnattendConfigArgs) =
                args.Pass <- input pass
                args

            ()
            n, List.Cons(apply, args)

        member _.Pass((n, args), pass) =
            let apply (args: VirtualMachineOsProfileWindowsConfigAdditionalUnattendConfigArgs) =
                args.Pass <- io pass
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("settingName")>]
        member _.SettingName((n, args), settingName) =
            let apply (args: VirtualMachineOsProfileWindowsConfigAdditionalUnattendConfigArgs) =
                args.SettingName <- input settingName
                args

            ()
            n, List.Cons(apply, args)

        member _.SettingName((n, args), settingName) =
            let apply (args: VirtualMachineOsProfileWindowsConfigAdditionalUnattendConfigArgs) =
                args.SettingName <- io settingName
                args

            ()
            n, List.Cons(apply, args)

    let virtualMachineOsProfileWindowsConfigAdditionalUnattendConfig =
        VirtualMachineOsProfileWindowsConfigAdditionalUnattendConfigBuilder()

    type VirtualMachineOsProfileWindowsConfigWinrmBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VirtualMachineOsProfileWindowsConfigWinrmArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("certificateUrl")>]
        member _.CertificateUrl((n, args), certificateUrl) =
            let apply (args: VirtualMachineOsProfileWindowsConfigWinrmArgs) =
                args.CertificateUrl <- input certificateUrl
                args

            ()
            n, List.Cons(apply, args)

        member _.CertificateUrl((n, args), certificateUrl) =
            let apply (args: VirtualMachineOsProfileWindowsConfigWinrmArgs) =
                args.CertificateUrl <- io certificateUrl
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("protocol")>]
        member _.Protocol((n, args), protocol) =
            let apply (args: VirtualMachineOsProfileWindowsConfigWinrmArgs) =
                args.Protocol <- input protocol
                args

            ()
            n, List.Cons(apply, args)

        member _.Protocol((n, args), protocol) =
            let apply (args: VirtualMachineOsProfileWindowsConfigWinrmArgs) =
                args.Protocol <- io protocol
                args

            ()
            n, List.Cons(apply, args)

    let virtualMachineOsProfileWindowsConfigWinrm =
        VirtualMachineOsProfileWindowsConfigWinrmBuilder()

    type VirtualMachinePlanBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VirtualMachinePlanArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: VirtualMachinePlanArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: VirtualMachinePlanArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("product")>]
        member _.Product((n, args), product) =
            let apply (args: VirtualMachinePlanArgs) =
                args.Product <- input product
                args

            ()
            n, List.Cons(apply, args)

        member _.Product((n, args), product) =
            let apply (args: VirtualMachinePlanArgs) =
                args.Product <- io product
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publisher")>]
        member _.Publisher((n, args), publisher) =
            let apply (args: VirtualMachinePlanArgs) =
                args.Publisher <- input publisher
                args

            ()
            n, List.Cons(apply, args)

        member _.Publisher((n, args), publisher) =
            let apply (args: VirtualMachinePlanArgs) =
                args.Publisher <- io publisher
                args

            ()
            n, List.Cons(apply, args)

    let virtualMachinePlan = VirtualMachinePlanBuilder()

    type VirtualMachineStorageDataDiskBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VirtualMachineStorageDataDiskArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("caching")>]
        member _.Caching((n, args), caching) =
            let apply (args: VirtualMachineStorageDataDiskArgs) =
                args.Caching <- input caching
                args

            ()
            n, List.Cons(apply, args)

        member _.Caching((n, args), caching) =
            let apply (args: VirtualMachineStorageDataDiskArgs) =
                args.Caching <- io caching
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("createOption")>]
        member _.CreateOption((n, args), createOption) =
            let apply (args: VirtualMachineStorageDataDiskArgs) =
                args.CreateOption <- input createOption
                args

            ()
            n, List.Cons(apply, args)

        member _.CreateOption((n, args), createOption) =
            let apply (args: VirtualMachineStorageDataDiskArgs) =
                args.CreateOption <- io createOption
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("diskSizeGb")>]
        member _.DiskSizeGb((n, args), diskSizeGb) =
            let apply (args: VirtualMachineStorageDataDiskArgs) =
                args.DiskSizeGb <- input diskSizeGb
                args

            ()
            n, List.Cons(apply, args)

        member _.DiskSizeGb((n, args), diskSizeGb) =
            let apply (args: VirtualMachineStorageDataDiskArgs) =
                args.DiskSizeGb <- io diskSizeGb
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("lun")>]
        member _.Lun((n, args), lun) =
            let apply (args: VirtualMachineStorageDataDiskArgs) =
                args.Lun <- input lun
                args

            ()
            n, List.Cons(apply, args)

        member _.Lun((n, args), lun) =
            let apply (args: VirtualMachineStorageDataDiskArgs) =
                args.Lun <- io lun
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("managedDiskId")>]
        member _.ManagedDiskId((n, args), managedDiskId) =
            let apply (args: VirtualMachineStorageDataDiskArgs) =
                args.ManagedDiskId <- input managedDiskId
                args

            ()
            n, List.Cons(apply, args)

        member _.ManagedDiskId((n, args), managedDiskId) =
            let apply (args: VirtualMachineStorageDataDiskArgs) =
                args.ManagedDiskId <- io managedDiskId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("managedDiskType")>]
        member _.ManagedDiskType((n, args), managedDiskType) =
            let apply (args: VirtualMachineStorageDataDiskArgs) =
                args.ManagedDiskType <- input managedDiskType
                args

            ()
            n, List.Cons(apply, args)

        member _.ManagedDiskType((n, args), managedDiskType) =
            let apply (args: VirtualMachineStorageDataDiskArgs) =
                args.ManagedDiskType <- io managedDiskType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: VirtualMachineStorageDataDiskArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: VirtualMachineStorageDataDiskArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vhdUri")>]
        member _.VhdUri((n, args), vhdUri) =
            let apply (args: VirtualMachineStorageDataDiskArgs) =
                args.VhdUri <- input vhdUri
                args

            ()
            n, List.Cons(apply, args)

        member _.VhdUri((n, args), vhdUri) =
            let apply (args: VirtualMachineStorageDataDiskArgs) =
                args.VhdUri <- io vhdUri
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("writeAcceleratorEnabled")>]
        member _.WriteAcceleratorEnabled((n, args), writeAcceleratorEnabled) =
            let apply (args: VirtualMachineStorageDataDiskArgs) =
                args.WriteAcceleratorEnabled <- input writeAcceleratorEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.WriteAcceleratorEnabled((n, args), writeAcceleratorEnabled) =
            let apply (args: VirtualMachineStorageDataDiskArgs) =
                args.WriteAcceleratorEnabled <- io writeAcceleratorEnabled
                args

            ()
            n, List.Cons(apply, args)

    let virtualMachineStorageDataDisk = VirtualMachineStorageDataDiskBuilder()

    type VirtualMachineStorageImageReferenceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VirtualMachineStorageImageReferenceArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: VirtualMachineStorageImageReferenceArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: VirtualMachineStorageImageReferenceArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("offer")>]
        member _.Offer((n, args), offer) =
            let apply (args: VirtualMachineStorageImageReferenceArgs) =
                args.Offer <- input offer
                args

            ()
            n, List.Cons(apply, args)

        member _.Offer((n, args), offer) =
            let apply (args: VirtualMachineStorageImageReferenceArgs) =
                args.Offer <- io offer
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publisher")>]
        member _.Publisher((n, args), publisher) =
            let apply (args: VirtualMachineStorageImageReferenceArgs) =
                args.Publisher <- input publisher
                args

            ()
            n, List.Cons(apply, args)

        member _.Publisher((n, args), publisher) =
            let apply (args: VirtualMachineStorageImageReferenceArgs) =
                args.Publisher <- io publisher
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sku")>]
        member _.Sku((n, args), sku) =
            let apply (args: VirtualMachineStorageImageReferenceArgs) =
                args.Sku <- input sku
                args

            ()
            n, List.Cons(apply, args)

        member _.Sku((n, args), sku) =
            let apply (args: VirtualMachineStorageImageReferenceArgs) =
                args.Sku <- io sku
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("version")>]
        member _.Version((n, args), version) =
            let apply (args: VirtualMachineStorageImageReferenceArgs) =
                args.Version <- input version
                args

            ()
            n, List.Cons(apply, args)

        member _.Version((n, args), version) =
            let apply (args: VirtualMachineStorageImageReferenceArgs) =
                args.Version <- io version
                args

            ()
            n, List.Cons(apply, args)

    let virtualMachineStorageImageReference =
        VirtualMachineStorageImageReferenceBuilder()

    type VirtualMachineStorageOsDiskBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VirtualMachineStorageOsDiskArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("caching")>]
        member _.Caching((n, args), caching) =
            let apply (args: VirtualMachineStorageOsDiskArgs) =
                args.Caching <- input caching
                args

            ()
            n, List.Cons(apply, args)

        member _.Caching((n, args), caching) =
            let apply (args: VirtualMachineStorageOsDiskArgs) =
                args.Caching <- io caching
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("createOption")>]
        member _.CreateOption((n, args), createOption) =
            let apply (args: VirtualMachineStorageOsDiskArgs) =
                args.CreateOption <- input createOption
                args

            ()
            n, List.Cons(apply, args)

        member _.CreateOption((n, args), createOption) =
            let apply (args: VirtualMachineStorageOsDiskArgs) =
                args.CreateOption <- io createOption
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("diskSizeGb")>]
        member _.DiskSizeGb((n, args), diskSizeGb) =
            let apply (args: VirtualMachineStorageOsDiskArgs) =
                args.DiskSizeGb <- input diskSizeGb
                args

            ()
            n, List.Cons(apply, args)

        member _.DiskSizeGb((n, args), diskSizeGb) =
            let apply (args: VirtualMachineStorageOsDiskArgs) =
                args.DiskSizeGb <- io diskSizeGb
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("imageUri")>]
        member _.ImageUri((n, args), imageUri) =
            let apply (args: VirtualMachineStorageOsDiskArgs) =
                args.ImageUri <- input imageUri
                args

            ()
            n, List.Cons(apply, args)

        member _.ImageUri((n, args), imageUri) =
            let apply (args: VirtualMachineStorageOsDiskArgs) =
                args.ImageUri <- io imageUri
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("managedDiskId")>]
        member _.ManagedDiskId((n, args), managedDiskId) =
            let apply (args: VirtualMachineStorageOsDiskArgs) =
                args.ManagedDiskId <- input managedDiskId
                args

            ()
            n, List.Cons(apply, args)

        member _.ManagedDiskId((n, args), managedDiskId) =
            let apply (args: VirtualMachineStorageOsDiskArgs) =
                args.ManagedDiskId <- io managedDiskId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("managedDiskType")>]
        member _.ManagedDiskType((n, args), managedDiskType) =
            let apply (args: VirtualMachineStorageOsDiskArgs) =
                args.ManagedDiskType <- input managedDiskType
                args

            ()
            n, List.Cons(apply, args)

        member _.ManagedDiskType((n, args), managedDiskType) =
            let apply (args: VirtualMachineStorageOsDiskArgs) =
                args.ManagedDiskType <- io managedDiskType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: VirtualMachineStorageOsDiskArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: VirtualMachineStorageOsDiskArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("osType")>]
        member _.OsType((n, args), osType) =
            let apply (args: VirtualMachineStorageOsDiskArgs) =
                args.OsType <- input osType
                args

            ()
            n, List.Cons(apply, args)

        member _.OsType((n, args), osType) =
            let apply (args: VirtualMachineStorageOsDiskArgs) =
                args.OsType <- io osType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vhdUri")>]
        member _.VhdUri((n, args), vhdUri) =
            let apply (args: VirtualMachineStorageOsDiskArgs) =
                args.VhdUri <- input vhdUri
                args

            ()
            n, List.Cons(apply, args)

        member _.VhdUri((n, args), vhdUri) =
            let apply (args: VirtualMachineStorageOsDiskArgs) =
                args.VhdUri <- io vhdUri
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("writeAcceleratorEnabled")>]
        member _.WriteAcceleratorEnabled((n, args), writeAcceleratorEnabled) =
            let apply (args: VirtualMachineStorageOsDiskArgs) =
                args.WriteAcceleratorEnabled <- input writeAcceleratorEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.WriteAcceleratorEnabled((n, args), writeAcceleratorEnabled) =
            let apply (args: VirtualMachineStorageOsDiskArgs) =
                args.WriteAcceleratorEnabled <- io writeAcceleratorEnabled
                args

            ()
            n, List.Cons(apply, args)

    let virtualMachineStorageOsDisk = VirtualMachineStorageOsDiskBuilder()

    type WindowsVirtualMachineAdditionalCapabilitiesBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (WindowsVirtualMachineAdditionalCapabilitiesArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("ultraSsdEnabled")>]
        member _.UltraSsdEnabled((n, args), ultraSsdEnabled) =
            let apply (args: WindowsVirtualMachineAdditionalCapabilitiesArgs) =
                args.UltraSsdEnabled <- input ultraSsdEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.UltraSsdEnabled((n, args), ultraSsdEnabled) =
            let apply (args: WindowsVirtualMachineAdditionalCapabilitiesArgs) =
                args.UltraSsdEnabled <- io ultraSsdEnabled
                args

            ()
            n, List.Cons(apply, args)

    let windowsVirtualMachineAdditionalCapabilities =
        WindowsVirtualMachineAdditionalCapabilitiesBuilder()

    type WindowsVirtualMachineAdditionalUnattendContentBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (WindowsVirtualMachineAdditionalUnattendContentArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("content")>]
        member _.Content((n, args), content) =
            let apply (args: WindowsVirtualMachineAdditionalUnattendContentArgs) =
                args.Content <- input content
                args

            ()
            n, List.Cons(apply, args)

        member _.Content((n, args), content) =
            let apply (args: WindowsVirtualMachineAdditionalUnattendContentArgs) =
                args.Content <- io content
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("setting")>]
        member _.Setting((n, args), setting) =
            let apply (args: WindowsVirtualMachineAdditionalUnattendContentArgs) =
                args.Setting <- input setting
                args

            ()
            n, List.Cons(apply, args)

        member _.Setting((n, args), setting) =
            let apply (args: WindowsVirtualMachineAdditionalUnattendContentArgs) =
                args.Setting <- io setting
                args

            ()
            n, List.Cons(apply, args)

    let windowsVirtualMachineAdditionalUnattendContent =
        WindowsVirtualMachineAdditionalUnattendContentBuilder()

    type WindowsVirtualMachineBootDiagnosticsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (WindowsVirtualMachineBootDiagnosticsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("storageAccountUri")>]
        member _.StorageAccountUri((n, args), storageAccountUri) =
            let apply (args: WindowsVirtualMachineBootDiagnosticsArgs) =
                args.StorageAccountUri <- input storageAccountUri
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountUri((n, args), storageAccountUri) =
            let apply (args: WindowsVirtualMachineBootDiagnosticsArgs) =
                args.StorageAccountUri <- io storageAccountUri
                args

            ()
            n, List.Cons(apply, args)

    let windowsVirtualMachineBootDiagnostics =
        WindowsVirtualMachineBootDiagnosticsBuilder()

    type WindowsVirtualMachineIdentityBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (WindowsVirtualMachineIdentityArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("identityIds")>]
        member _.IdentityIds((n, args), identityIds) =
            let apply (args: WindowsVirtualMachineIdentityArgs) =
                args.IdentityIds <- inputList identityIds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("principalId")>]
        member _.PrincipalId((n, args), principalId) =
            let apply (args: WindowsVirtualMachineIdentityArgs) =
                args.PrincipalId <- input principalId
                args

            ()
            n, List.Cons(apply, args)

        member _.PrincipalId((n, args), principalId) =
            let apply (args: WindowsVirtualMachineIdentityArgs) =
                args.PrincipalId <- io principalId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tenantId")>]
        member _.TenantId((n, args), tenantId) =
            let apply (args: WindowsVirtualMachineIdentityArgs) =
                args.TenantId <- input tenantId
                args

            ()
            n, List.Cons(apply, args)

        member _.TenantId((n, args), tenantId) =
            let apply (args: WindowsVirtualMachineIdentityArgs) =
                args.TenantId <- io tenantId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: WindowsVirtualMachineIdentityArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: WindowsVirtualMachineIdentityArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let windowsVirtualMachineIdentity = WindowsVirtualMachineIdentityBuilder()

    type WindowsVirtualMachineOsDiskBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (WindowsVirtualMachineOsDiskArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("caching")>]
        member _.Caching((n, args), caching) =
            let apply (args: WindowsVirtualMachineOsDiskArgs) =
                args.Caching <- input caching
                args

            ()
            n, List.Cons(apply, args)

        member _.Caching((n, args), caching) =
            let apply (args: WindowsVirtualMachineOsDiskArgs) =
                args.Caching <- io caching
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: WindowsVirtualMachineOsDiskArgs) =
                   args.DiffDiskSettings <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("diskEncryptionSetId")>]
        member _.DiskEncryptionSetId((n, args), diskEncryptionSetId) =
            let apply (args: WindowsVirtualMachineOsDiskArgs) =
                args.DiskEncryptionSetId <- input diskEncryptionSetId
                args

            ()
            n, List.Cons(apply, args)

        member _.DiskEncryptionSetId((n, args), diskEncryptionSetId) =
            let apply (args: WindowsVirtualMachineOsDiskArgs) =
                args.DiskEncryptionSetId <- io diskEncryptionSetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("diskSizeGb")>]
        member _.DiskSizeGb((n, args), diskSizeGb) =
            let apply (args: WindowsVirtualMachineOsDiskArgs) =
                args.DiskSizeGb <- input diskSizeGb
                args

            ()
            n, List.Cons(apply, args)

        member _.DiskSizeGb((n, args), diskSizeGb) =
            let apply (args: WindowsVirtualMachineOsDiskArgs) =
                args.DiskSizeGb <- io diskSizeGb
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: WindowsVirtualMachineOsDiskArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: WindowsVirtualMachineOsDiskArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageAccountType")>]
        member _.StorageAccountType((n, args), storageAccountType) =
            let apply (args: WindowsVirtualMachineOsDiskArgs) =
                args.StorageAccountType <- input storageAccountType
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountType((n, args), storageAccountType) =
            let apply (args: WindowsVirtualMachineOsDiskArgs) =
                args.StorageAccountType <- io storageAccountType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("writeAcceleratorEnabled")>]
        member _.WriteAcceleratorEnabled((n, args), writeAcceleratorEnabled) =
            let apply (args: WindowsVirtualMachineOsDiskArgs) =
                args.WriteAcceleratorEnabled <- input writeAcceleratorEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.WriteAcceleratorEnabled((n, args), writeAcceleratorEnabled) =
            let apply (args: WindowsVirtualMachineOsDiskArgs) =
                args.WriteAcceleratorEnabled <- io writeAcceleratorEnabled
                args

            ()
            n, List.Cons(apply, args)

    let windowsVirtualMachineOsDisk = WindowsVirtualMachineOsDiskBuilder()

    type WindowsVirtualMachineOsDiskDiffDiskSettingsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (WindowsVirtualMachineOsDiskDiffDiskSettingsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("option")>]
        member _.Option((n, args), option) =
            let apply (args: WindowsVirtualMachineOsDiskDiffDiskSettingsArgs) =
                args.Option <- input option
                args

            ()
            n, List.Cons(apply, args)

        member _.Option((n, args), option) =
            let apply (args: WindowsVirtualMachineOsDiskDiffDiskSettingsArgs) =
                args.Option <- io option
                args

            ()
            n, List.Cons(apply, args)

    let windowsVirtualMachineOsDiskDiffDiskSettings =
        WindowsVirtualMachineOsDiskDiffDiskSettingsBuilder()

    type WindowsVirtualMachinePlanBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (WindowsVirtualMachinePlanArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: WindowsVirtualMachinePlanArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: WindowsVirtualMachinePlanArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("product")>]
        member _.Product((n, args), product) =
            let apply (args: WindowsVirtualMachinePlanArgs) =
                args.Product <- input product
                args

            ()
            n, List.Cons(apply, args)

        member _.Product((n, args), product) =
            let apply (args: WindowsVirtualMachinePlanArgs) =
                args.Product <- io product
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publisher")>]
        member _.Publisher((n, args), publisher) =
            let apply (args: WindowsVirtualMachinePlanArgs) =
                args.Publisher <- input publisher
                args

            ()
            n, List.Cons(apply, args)

        member _.Publisher((n, args), publisher) =
            let apply (args: WindowsVirtualMachinePlanArgs) =
                args.Publisher <- io publisher
                args

            ()
            n, List.Cons(apply, args)

    let windowsVirtualMachinePlan = WindowsVirtualMachinePlanBuilder()

    type WindowsVirtualMachineScaleSetAdditionalCapabilitiesBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (WindowsVirtualMachineScaleSetAdditionalCapabilitiesArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("ultraSsdEnabled")>]
        member _.UltraSsdEnabled((n, args), ultraSsdEnabled) =
            let apply (args: WindowsVirtualMachineScaleSetAdditionalCapabilitiesArgs) =
                args.UltraSsdEnabled <- input ultraSsdEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.UltraSsdEnabled((n, args), ultraSsdEnabled) =
            let apply (args: WindowsVirtualMachineScaleSetAdditionalCapabilitiesArgs) =
                args.UltraSsdEnabled <- io ultraSsdEnabled
                args

            ()
            n, List.Cons(apply, args)

    let windowsVirtualMachineScaleSetAdditionalCapabilities =
        WindowsVirtualMachineScaleSetAdditionalCapabilitiesBuilder()

    type WindowsVirtualMachineScaleSetAdditionalUnattendContentBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (WindowsVirtualMachineScaleSetAdditionalUnattendContentArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("content")>]
        member _.Content((n, args), content) =
            let apply (args: WindowsVirtualMachineScaleSetAdditionalUnattendContentArgs) =
                args.Content <- input content
                args

            ()
            n, List.Cons(apply, args)

        member _.Content((n, args), content) =
            let apply (args: WindowsVirtualMachineScaleSetAdditionalUnattendContentArgs) =
                args.Content <- io content
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("setting")>]
        member _.Setting((n, args), setting) =
            let apply (args: WindowsVirtualMachineScaleSetAdditionalUnattendContentArgs) =
                args.Setting <- input setting
                args

            ()
            n, List.Cons(apply, args)

        member _.Setting((n, args), setting) =
            let apply (args: WindowsVirtualMachineScaleSetAdditionalUnattendContentArgs) =
                args.Setting <- io setting
                args

            ()
            n, List.Cons(apply, args)

    let windowsVirtualMachineScaleSetAdditionalUnattendContent =
        WindowsVirtualMachineScaleSetAdditionalUnattendContentBuilder()

    type WindowsVirtualMachineScaleSetAutomaticInstanceRepairBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (WindowsVirtualMachineScaleSetAutomaticInstanceRepairArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: WindowsVirtualMachineScaleSetAutomaticInstanceRepairArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: WindowsVirtualMachineScaleSetAutomaticInstanceRepairArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("gracePeriod")>]
        member _.GracePeriod((n, args), gracePeriod) =
            let apply (args: WindowsVirtualMachineScaleSetAutomaticInstanceRepairArgs) =
                args.GracePeriod <- input gracePeriod
                args

            ()
            n, List.Cons(apply, args)

        member _.GracePeriod((n, args), gracePeriod) =
            let apply (args: WindowsVirtualMachineScaleSetAutomaticInstanceRepairArgs) =
                args.GracePeriod <- io gracePeriod
                args

            ()
            n, List.Cons(apply, args)

    let windowsVirtualMachineScaleSetAutomaticInstanceRepair =
        WindowsVirtualMachineScaleSetAutomaticInstanceRepairBuilder()

    type WindowsVirtualMachineScaleSetAutomaticOsUpgradePolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (WindowsVirtualMachineScaleSetAutomaticOsUpgradePolicyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("disableAutomaticRollback")>]
        member _.DisableAutomaticRollback((n, args), disableAutomaticRollback) =
            let apply (args: WindowsVirtualMachineScaleSetAutomaticOsUpgradePolicyArgs) =
                args.DisableAutomaticRollback <- input disableAutomaticRollback
                args

            ()
            n, List.Cons(apply, args)

        member _.DisableAutomaticRollback((n, args), disableAutomaticRollback) =
            let apply (args: WindowsVirtualMachineScaleSetAutomaticOsUpgradePolicyArgs) =
                args.DisableAutomaticRollback <- io disableAutomaticRollback
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enableAutomaticOsUpgrade")>]
        member _.EnableAutomaticOsUpgrade((n, args), enableAutomaticOsUpgrade) =
            let apply (args: WindowsVirtualMachineScaleSetAutomaticOsUpgradePolicyArgs) =
                args.EnableAutomaticOsUpgrade <- input enableAutomaticOsUpgrade
                args

            ()
            n, List.Cons(apply, args)

        member _.EnableAutomaticOsUpgrade((n, args), enableAutomaticOsUpgrade) =
            let apply (args: WindowsVirtualMachineScaleSetAutomaticOsUpgradePolicyArgs) =
                args.EnableAutomaticOsUpgrade <- io enableAutomaticOsUpgrade
                args

            ()
            n, List.Cons(apply, args)

    let windowsVirtualMachineScaleSetAutomaticOsUpgradePolicy =
        WindowsVirtualMachineScaleSetAutomaticOsUpgradePolicyBuilder()

    type WindowsVirtualMachineScaleSetBootDiagnosticsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (WindowsVirtualMachineScaleSetBootDiagnosticsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("storageAccountUri")>]
        member _.StorageAccountUri((n, args), storageAccountUri) =
            let apply (args: WindowsVirtualMachineScaleSetBootDiagnosticsArgs) =
                args.StorageAccountUri <- input storageAccountUri
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountUri((n, args), storageAccountUri) =
            let apply (args: WindowsVirtualMachineScaleSetBootDiagnosticsArgs) =
                args.StorageAccountUri <- io storageAccountUri
                args

            ()
            n, List.Cons(apply, args)

    let windowsVirtualMachineScaleSetBootDiagnostics =
        WindowsVirtualMachineScaleSetBootDiagnosticsBuilder()

    type WindowsVirtualMachineScaleSetDataDiskBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (WindowsVirtualMachineScaleSetDataDiskArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("caching")>]
        member _.Caching((n, args), caching) =
            let apply (args: WindowsVirtualMachineScaleSetDataDiskArgs) =
                args.Caching <- input caching
                args

            ()
            n, List.Cons(apply, args)

        member _.Caching((n, args), caching) =
            let apply (args: WindowsVirtualMachineScaleSetDataDiskArgs) =
                args.Caching <- io caching
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("createOption")>]
        member _.CreateOption((n, args), createOption) =
            let apply (args: WindowsVirtualMachineScaleSetDataDiskArgs) =
                args.CreateOption <- input createOption
                args

            ()
            n, List.Cons(apply, args)

        member _.CreateOption((n, args), createOption) =
            let apply (args: WindowsVirtualMachineScaleSetDataDiskArgs) =
                args.CreateOption <- io createOption
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("diskEncryptionSetId")>]
        member _.DiskEncryptionSetId((n, args), diskEncryptionSetId) =
            let apply (args: WindowsVirtualMachineScaleSetDataDiskArgs) =
                args.DiskEncryptionSetId <- input diskEncryptionSetId
                args

            ()
            n, List.Cons(apply, args)

        member _.DiskEncryptionSetId((n, args), diskEncryptionSetId) =
            let apply (args: WindowsVirtualMachineScaleSetDataDiskArgs) =
                args.DiskEncryptionSetId <- io diskEncryptionSetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("diskSizeGb")>]
        member _.DiskSizeGb((n, args), diskSizeGb) =
            let apply (args: WindowsVirtualMachineScaleSetDataDiskArgs) =
                args.DiskSizeGb <- input diskSizeGb
                args

            ()
            n, List.Cons(apply, args)

        member _.DiskSizeGb((n, args), diskSizeGb) =
            let apply (args: WindowsVirtualMachineScaleSetDataDiskArgs) =
                args.DiskSizeGb <- io diskSizeGb
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("lun")>]
        member _.Lun((n, args), lun) =
            let apply (args: WindowsVirtualMachineScaleSetDataDiskArgs) =
                args.Lun <- input lun
                args

            ()
            n, List.Cons(apply, args)

        member _.Lun((n, args), lun) =
            let apply (args: WindowsVirtualMachineScaleSetDataDiskArgs) =
                args.Lun <- io lun
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageAccountType")>]
        member _.StorageAccountType((n, args), storageAccountType) =
            let apply (args: WindowsVirtualMachineScaleSetDataDiskArgs) =
                args.StorageAccountType <- input storageAccountType
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountType((n, args), storageAccountType) =
            let apply (args: WindowsVirtualMachineScaleSetDataDiskArgs) =
                args.StorageAccountType <- io storageAccountType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("writeAcceleratorEnabled")>]
        member _.WriteAcceleratorEnabled((n, args), writeAcceleratorEnabled) =
            let apply (args: WindowsVirtualMachineScaleSetDataDiskArgs) =
                args.WriteAcceleratorEnabled <- input writeAcceleratorEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.WriteAcceleratorEnabled((n, args), writeAcceleratorEnabled) =
            let apply (args: WindowsVirtualMachineScaleSetDataDiskArgs) =
                args.WriteAcceleratorEnabled <- io writeAcceleratorEnabled
                args

            ()
            n, List.Cons(apply, args)

    let windowsVirtualMachineScaleSetDataDisk =
        WindowsVirtualMachineScaleSetDataDiskBuilder()

    type WindowsVirtualMachineScaleSetIdentityBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (WindowsVirtualMachineScaleSetIdentityArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("identityIds")>]
        member _.IdentityIds((n, args), identityIds) =
            let apply (args: WindowsVirtualMachineScaleSetIdentityArgs) =
                args.IdentityIds <- inputList identityIds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("principalId")>]
        member _.PrincipalId((n, args), principalId) =
            let apply (args: WindowsVirtualMachineScaleSetIdentityArgs) =
                args.PrincipalId <- input principalId
                args

            ()
            n, List.Cons(apply, args)

        member _.PrincipalId((n, args), principalId) =
            let apply (args: WindowsVirtualMachineScaleSetIdentityArgs) =
                args.PrincipalId <- io principalId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: WindowsVirtualMachineScaleSetIdentityArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: WindowsVirtualMachineScaleSetIdentityArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let windowsVirtualMachineScaleSetIdentity =
        WindowsVirtualMachineScaleSetIdentityBuilder()

    type WindowsVirtualMachineScaleSetNetworkInterfaceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (WindowsVirtualMachineScaleSetNetworkInterfaceArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("dnsServers")>]
        member _.DnsServers((n, args), dnsServers) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceArgs) =
                args.DnsServers <- inputList dnsServers
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enableAcceleratedNetworking")>]
        member _.EnableAcceleratedNetworking((n, args), enableAcceleratedNetworking) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceArgs) =
                args.EnableAcceleratedNetworking <- input enableAcceleratedNetworking
                args

            ()
            n, List.Cons(apply, args)

        member _.EnableAcceleratedNetworking((n, args), enableAcceleratedNetworking) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceArgs) =
                args.EnableAcceleratedNetworking <- io enableAcceleratedNetworking
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enableIpForwarding")>]
        member _.EnableIpForwarding((n, args), enableIpForwarding) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceArgs) =
                args.EnableIpForwarding <- input enableIpForwarding
                args

            ()
            n, List.Cons(apply, args)

        member _.EnableIpForwarding((n, args), enableIpForwarding) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceArgs) =
                args.EnableIpForwarding <- io enableIpForwarding
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ipConfigurations")>]
        member _.IpConfigurations((n, args), ipConfigurations) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceArgs) =
                args.IpConfigurations <- inputList ipConfigurations
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("networkSecurityGroupId")>]
        member _.NetworkSecurityGroupId((n, args), networkSecurityGroupId) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceArgs) =
                args.NetworkSecurityGroupId <- input networkSecurityGroupId
                args

            ()
            n, List.Cons(apply, args)

        member _.NetworkSecurityGroupId((n, args), networkSecurityGroupId) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceArgs) =
                args.NetworkSecurityGroupId <- io networkSecurityGroupId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("primary")>]
        member _.Primary((n, args), primary) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceArgs) =
                args.Primary <- input primary
                args

            ()
            n, List.Cons(apply, args)

        member _.Primary((n, args), primary) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceArgs) =
                args.Primary <- io primary
                args

            ()
            n, List.Cons(apply, args)

    let windowsVirtualMachineScaleSetNetworkInterface =
        WindowsVirtualMachineScaleSetNetworkInterfaceBuilder()

    type WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("applicationGatewayBackendAddressPoolIds")>]
        member _.ApplicationGatewayBackendAddressPoolIds((n, args), applicationGatewayBackendAddressPoolIds) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs) =
                args.ApplicationGatewayBackendAddressPoolIds <- inputList applicationGatewayBackendAddressPoolIds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("applicationSecurityGroupIds")>]
        member _.ApplicationSecurityGroupIds((n, args), applicationSecurityGroupIds) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs) =
                args.ApplicationSecurityGroupIds <- inputList applicationSecurityGroupIds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("loadBalancerBackendAddressPoolIds")>]
        member _.LoadBalancerBackendAddressPoolIds((n, args), loadBalancerBackendAddressPoolIds) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs) =
                args.LoadBalancerBackendAddressPoolIds <- inputList loadBalancerBackendAddressPoolIds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("loadBalancerInboundNatRulesIds")>]
        member _.LoadBalancerInboundNatRulesIds((n, args), loadBalancerInboundNatRulesIds) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs) =
                args.LoadBalancerInboundNatRulesIds <- inputList loadBalancerInboundNatRulesIds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("primary")>]
        member _.Primary((n, args), primary) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs) =
                args.Primary <- input primary
                args

            ()
            n, List.Cons(apply, args)

        member _.Primary((n, args), primary) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs) =
                args.Primary <- io primary
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publicIpAddresses")>]
        member _.PublicIpAddresses((n, args), publicIpAddresses) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs) =
                args.PublicIpAddresses <- inputList publicIpAddresses
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("version")>]
        member _.Version((n, args), version) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs) =
                args.Version <- input version
                args

            ()
            n, List.Cons(apply, args)

        member _.Version((n, args), version) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs) =
                args.Version <- io version
                args

            ()
            n, List.Cons(apply, args)

    let windowsVirtualMachineScaleSetNetworkInterfaceIpConfiguration =
        WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationBuilder()

    type WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("domainNameLabel")>]
        member _.DomainNameLabel((n, args), domainNameLabel) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs) =
                args.DomainNameLabel <- input domainNameLabel
                args

            ()
            n, List.Cons(apply, args)

        member _.DomainNameLabel((n, args), domainNameLabel) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs) =
                args.DomainNameLabel <- io domainNameLabel
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("idleTimeoutInMinutes")>]
        member _.IdleTimeoutInMinutes((n, args), idleTimeoutInMinutes) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs) =
                args.IdleTimeoutInMinutes <- input idleTimeoutInMinutes
                args

            ()
            n, List.Cons(apply, args)

        member _.IdleTimeoutInMinutes((n, args), idleTimeoutInMinutes) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs) =
                args.IdleTimeoutInMinutes <- io idleTimeoutInMinutes
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ipTags")>]
        member _.IpTags((n, args), ipTags) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs) =
                args.IpTags <- inputList ipTags
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publicIpPrefixId")>]
        member _.PublicIpPrefixId((n, args), publicIpPrefixId) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs) =
                args.PublicIpPrefixId <- input publicIpPrefixId
                args

            ()
            n, List.Cons(apply, args)

        member _.PublicIpPrefixId((n, args), publicIpPrefixId) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs) =
                args.PublicIpPrefixId <- io publicIpPrefixId
                args

            ()
            n, List.Cons(apply, args)

    let windowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress =
        WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressBuilder()

    type WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("tag")>]
        member _.Tag((n, args), tag) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagArgs) =
                args.Tag <- input tag
                args

            ()
            n, List.Cons(apply, args)

        member _.Tag((n, args), tag) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagArgs) =
                args.Tag <- io tag
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let windowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag =
        WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagBuilder()

    type WindowsVirtualMachineScaleSetOsDiskBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (WindowsVirtualMachineScaleSetOsDiskArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("caching")>]
        member _.Caching((n, args), caching) =
            let apply (args: WindowsVirtualMachineScaleSetOsDiskArgs) =
                args.Caching <- input caching
                args

            ()
            n, List.Cons(apply, args)

        member _.Caching((n, args), caching) =
            let apply (args: WindowsVirtualMachineScaleSetOsDiskArgs) =
                args.Caching <- io caching
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: WindowsVirtualMachineScaleSetOsDiskArgs) =
                   args.DiffDiskSettings <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("diskEncryptionSetId")>]
        member _.DiskEncryptionSetId((n, args), diskEncryptionSetId) =
            let apply (args: WindowsVirtualMachineScaleSetOsDiskArgs) =
                args.DiskEncryptionSetId <- input diskEncryptionSetId
                args

            ()
            n, List.Cons(apply, args)

        member _.DiskEncryptionSetId((n, args), diskEncryptionSetId) =
            let apply (args: WindowsVirtualMachineScaleSetOsDiskArgs) =
                args.DiskEncryptionSetId <- io diskEncryptionSetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("diskSizeGb")>]
        member _.DiskSizeGb((n, args), diskSizeGb) =
            let apply (args: WindowsVirtualMachineScaleSetOsDiskArgs) =
                args.DiskSizeGb <- input diskSizeGb
                args

            ()
            n, List.Cons(apply, args)

        member _.DiskSizeGb((n, args), diskSizeGb) =
            let apply (args: WindowsVirtualMachineScaleSetOsDiskArgs) =
                args.DiskSizeGb <- io diskSizeGb
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageAccountType")>]
        member _.StorageAccountType((n, args), storageAccountType) =
            let apply (args: WindowsVirtualMachineScaleSetOsDiskArgs) =
                args.StorageAccountType <- input storageAccountType
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountType((n, args), storageAccountType) =
            let apply (args: WindowsVirtualMachineScaleSetOsDiskArgs) =
                args.StorageAccountType <- io storageAccountType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("writeAcceleratorEnabled")>]
        member _.WriteAcceleratorEnabled((n, args), writeAcceleratorEnabled) =
            let apply (args: WindowsVirtualMachineScaleSetOsDiskArgs) =
                args.WriteAcceleratorEnabled <- input writeAcceleratorEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.WriteAcceleratorEnabled((n, args), writeAcceleratorEnabled) =
            let apply (args: WindowsVirtualMachineScaleSetOsDiskArgs) =
                args.WriteAcceleratorEnabled <- io writeAcceleratorEnabled
                args

            ()
            n, List.Cons(apply, args)

    let windowsVirtualMachineScaleSetOsDisk =
        WindowsVirtualMachineScaleSetOsDiskBuilder()

    type WindowsVirtualMachineScaleSetOsDiskDiffDiskSettingsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (WindowsVirtualMachineScaleSetOsDiskDiffDiskSettingsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("option")>]
        member _.Option((n, args), option) =
            let apply (args: WindowsVirtualMachineScaleSetOsDiskDiffDiskSettingsArgs) =
                args.Option <- input option
                args

            ()
            n, List.Cons(apply, args)

        member _.Option((n, args), option) =
            let apply (args: WindowsVirtualMachineScaleSetOsDiskDiffDiskSettingsArgs) =
                args.Option <- io option
                args

            ()
            n, List.Cons(apply, args)

    let windowsVirtualMachineScaleSetOsDiskDiffDiskSettings =
        WindowsVirtualMachineScaleSetOsDiskDiffDiskSettingsBuilder()

    type WindowsVirtualMachineScaleSetPlanBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (WindowsVirtualMachineScaleSetPlanArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: WindowsVirtualMachineScaleSetPlanArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: WindowsVirtualMachineScaleSetPlanArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("product")>]
        member _.Product((n, args), product) =
            let apply (args: WindowsVirtualMachineScaleSetPlanArgs) =
                args.Product <- input product
                args

            ()
            n, List.Cons(apply, args)

        member _.Product((n, args), product) =
            let apply (args: WindowsVirtualMachineScaleSetPlanArgs) =
                args.Product <- io product
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publisher")>]
        member _.Publisher((n, args), publisher) =
            let apply (args: WindowsVirtualMachineScaleSetPlanArgs) =
                args.Publisher <- input publisher
                args

            ()
            n, List.Cons(apply, args)

        member _.Publisher((n, args), publisher) =
            let apply (args: WindowsVirtualMachineScaleSetPlanArgs) =
                args.Publisher <- io publisher
                args

            ()
            n, List.Cons(apply, args)

    let windowsVirtualMachineScaleSetPlan =
        WindowsVirtualMachineScaleSetPlanBuilder()

    type WindowsVirtualMachineScaleSetRollingUpgradePolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (WindowsVirtualMachineScaleSetRollingUpgradePolicyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("maxBatchInstancePercent")>]
        member _.MaxBatchInstancePercent((n, args), maxBatchInstancePercent) =
            let apply (args: WindowsVirtualMachineScaleSetRollingUpgradePolicyArgs) =
                args.MaxBatchInstancePercent <- input maxBatchInstancePercent
                args

            ()
            n, List.Cons(apply, args)

        member _.MaxBatchInstancePercent((n, args), maxBatchInstancePercent) =
            let apply (args: WindowsVirtualMachineScaleSetRollingUpgradePolicyArgs) =
                args.MaxBatchInstancePercent <- io maxBatchInstancePercent
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("maxUnhealthyInstancePercent")>]
        member _.MaxUnhealthyInstancePercent((n, args), maxUnhealthyInstancePercent) =
            let apply (args: WindowsVirtualMachineScaleSetRollingUpgradePolicyArgs) =
                args.MaxUnhealthyInstancePercent <- input maxUnhealthyInstancePercent
                args

            ()
            n, List.Cons(apply, args)

        member _.MaxUnhealthyInstancePercent((n, args), maxUnhealthyInstancePercent) =
            let apply (args: WindowsVirtualMachineScaleSetRollingUpgradePolicyArgs) =
                args.MaxUnhealthyInstancePercent <- io maxUnhealthyInstancePercent
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("maxUnhealthyUpgradedInstancePercent")>]
        member _.MaxUnhealthyUpgradedInstancePercent((n, args), maxUnhealthyUpgradedInstancePercent) =
            let apply (args: WindowsVirtualMachineScaleSetRollingUpgradePolicyArgs) =
                args.MaxUnhealthyUpgradedInstancePercent <- input maxUnhealthyUpgradedInstancePercent
                args

            ()
            n, List.Cons(apply, args)

        member _.MaxUnhealthyUpgradedInstancePercent((n, args), maxUnhealthyUpgradedInstancePercent) =
            let apply (args: WindowsVirtualMachineScaleSetRollingUpgradePolicyArgs) =
                args.MaxUnhealthyUpgradedInstancePercent <- io maxUnhealthyUpgradedInstancePercent
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("pauseTimeBetweenBatches")>]
        member _.PauseTimeBetweenBatches((n, args), pauseTimeBetweenBatches) =
            let apply (args: WindowsVirtualMachineScaleSetRollingUpgradePolicyArgs) =
                args.PauseTimeBetweenBatches <- input pauseTimeBetweenBatches
                args

            ()
            n, List.Cons(apply, args)

        member _.PauseTimeBetweenBatches((n, args), pauseTimeBetweenBatches) =
            let apply (args: WindowsVirtualMachineScaleSetRollingUpgradePolicyArgs) =
                args.PauseTimeBetweenBatches <- io pauseTimeBetweenBatches
                args

            ()
            n, List.Cons(apply, args)

    let windowsVirtualMachineScaleSetRollingUpgradePolicy =
        WindowsVirtualMachineScaleSetRollingUpgradePolicyBuilder()

    type WindowsVirtualMachineScaleSetSecretBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (WindowsVirtualMachineScaleSetSecretArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("certificates")>]
        member _.Certificates((n, args), certificates) =
            let apply (args: WindowsVirtualMachineScaleSetSecretArgs) =
                args.Certificates <- inputList certificates
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("keyVaultId")>]
        member _.KeyVaultId((n, args), keyVaultId) =
            let apply (args: WindowsVirtualMachineScaleSetSecretArgs) =
                args.KeyVaultId <- input keyVaultId
                args

            ()
            n, List.Cons(apply, args)

        member _.KeyVaultId((n, args), keyVaultId) =
            let apply (args: WindowsVirtualMachineScaleSetSecretArgs) =
                args.KeyVaultId <- io keyVaultId
                args

            ()
            n, List.Cons(apply, args)

    let windowsVirtualMachineScaleSetSecret =
        WindowsVirtualMachineScaleSetSecretBuilder()

    type WindowsVirtualMachineScaleSetSecretCertificateBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (WindowsVirtualMachineScaleSetSecretCertificateArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("store")>]
        member _.Store((n, args), store) =
            let apply (args: WindowsVirtualMachineScaleSetSecretCertificateArgs) =
                args.Store <- input store
                args

            ()
            n, List.Cons(apply, args)

        member _.Store((n, args), store) =
            let apply (args: WindowsVirtualMachineScaleSetSecretCertificateArgs) =
                args.Store <- io store
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("url")>]
        member _.Url((n, args), url) =
            let apply (args: WindowsVirtualMachineScaleSetSecretCertificateArgs) =
                args.Url <- input url
                args

            ()
            n, List.Cons(apply, args)

        member _.Url((n, args), url) =
            let apply (args: WindowsVirtualMachineScaleSetSecretCertificateArgs) =
                args.Url <- io url
                args

            ()
            n, List.Cons(apply, args)

    let windowsVirtualMachineScaleSetSecretCertificate =
        WindowsVirtualMachineScaleSetSecretCertificateBuilder()

    type WindowsVirtualMachineScaleSetSourceImageReferenceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (WindowsVirtualMachineScaleSetSourceImageReferenceArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("offer")>]
        member _.Offer((n, args), offer) =
            let apply (args: WindowsVirtualMachineScaleSetSourceImageReferenceArgs) =
                args.Offer <- input offer
                args

            ()
            n, List.Cons(apply, args)

        member _.Offer((n, args), offer) =
            let apply (args: WindowsVirtualMachineScaleSetSourceImageReferenceArgs) =
                args.Offer <- io offer
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publisher")>]
        member _.Publisher((n, args), publisher) =
            let apply (args: WindowsVirtualMachineScaleSetSourceImageReferenceArgs) =
                args.Publisher <- input publisher
                args

            ()
            n, List.Cons(apply, args)

        member _.Publisher((n, args), publisher) =
            let apply (args: WindowsVirtualMachineScaleSetSourceImageReferenceArgs) =
                args.Publisher <- io publisher
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sku")>]
        member _.Sku((n, args), sku) =
            let apply (args: WindowsVirtualMachineScaleSetSourceImageReferenceArgs) =
                args.Sku <- input sku
                args

            ()
            n, List.Cons(apply, args)

        member _.Sku((n, args), sku) =
            let apply (args: WindowsVirtualMachineScaleSetSourceImageReferenceArgs) =
                args.Sku <- io sku
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("version")>]
        member _.Version((n, args), version) =
            let apply (args: WindowsVirtualMachineScaleSetSourceImageReferenceArgs) =
                args.Version <- input version
                args

            ()
            n, List.Cons(apply, args)

        member _.Version((n, args), version) =
            let apply (args: WindowsVirtualMachineScaleSetSourceImageReferenceArgs) =
                args.Version <- io version
                args

            ()
            n, List.Cons(apply, args)

    let windowsVirtualMachineScaleSetSourceImageReference =
        WindowsVirtualMachineScaleSetSourceImageReferenceBuilder()

    type WindowsVirtualMachineScaleSetTerminateNotificationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (WindowsVirtualMachineScaleSetTerminateNotificationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: WindowsVirtualMachineScaleSetTerminateNotificationArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: WindowsVirtualMachineScaleSetTerminateNotificationArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("timeout")>]
        member _.Timeout((n, args), timeout) =
            let apply (args: WindowsVirtualMachineScaleSetTerminateNotificationArgs) =
                args.Timeout <- input timeout
                args

            ()
            n, List.Cons(apply, args)

        member _.Timeout((n, args), timeout) =
            let apply (args: WindowsVirtualMachineScaleSetTerminateNotificationArgs) =
                args.Timeout <- io timeout
                args

            ()
            n, List.Cons(apply, args)

    let windowsVirtualMachineScaleSetTerminateNotification =
        WindowsVirtualMachineScaleSetTerminateNotificationBuilder()

    type WindowsVirtualMachineScaleSetWinrmListenerBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (WindowsVirtualMachineScaleSetWinrmListenerArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("certificateUrl")>]
        member _.CertificateUrl((n, args), certificateUrl) =
            let apply (args: WindowsVirtualMachineScaleSetWinrmListenerArgs) =
                args.CertificateUrl <- input certificateUrl
                args

            ()
            n, List.Cons(apply, args)

        member _.CertificateUrl((n, args), certificateUrl) =
            let apply (args: WindowsVirtualMachineScaleSetWinrmListenerArgs) =
                args.CertificateUrl <- io certificateUrl
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("protocol")>]
        member _.Protocol((n, args), protocol) =
            let apply (args: WindowsVirtualMachineScaleSetWinrmListenerArgs) =
                args.Protocol <- input protocol
                args

            ()
            n, List.Cons(apply, args)

        member _.Protocol((n, args), protocol) =
            let apply (args: WindowsVirtualMachineScaleSetWinrmListenerArgs) =
                args.Protocol <- io protocol
                args

            ()
            n, List.Cons(apply, args)

    let windowsVirtualMachineScaleSetWinrmListener =
        WindowsVirtualMachineScaleSetWinrmListenerBuilder()

    type WindowsVirtualMachineSecretBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (WindowsVirtualMachineSecretArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("certificates")>]
        member _.Certificates((n, args), certificates) =
            let apply (args: WindowsVirtualMachineSecretArgs) =
                args.Certificates <- inputList certificates
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("keyVaultId")>]
        member _.KeyVaultId((n, args), keyVaultId) =
            let apply (args: WindowsVirtualMachineSecretArgs) =
                args.KeyVaultId <- input keyVaultId
                args

            ()
            n, List.Cons(apply, args)

        member _.KeyVaultId((n, args), keyVaultId) =
            let apply (args: WindowsVirtualMachineSecretArgs) =
                args.KeyVaultId <- io keyVaultId
                args

            ()
            n, List.Cons(apply, args)

    let windowsVirtualMachineSecret = WindowsVirtualMachineSecretBuilder()

    type WindowsVirtualMachineSecretCertificateBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (WindowsVirtualMachineSecretCertificateArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("store")>]
        member _.Store((n, args), store) =
            let apply (args: WindowsVirtualMachineSecretCertificateArgs) =
                args.Store <- input store
                args

            ()
            n, List.Cons(apply, args)

        member _.Store((n, args), store) =
            let apply (args: WindowsVirtualMachineSecretCertificateArgs) =
                args.Store <- io store
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("url")>]
        member _.Url((n, args), url) =
            let apply (args: WindowsVirtualMachineSecretCertificateArgs) =
                args.Url <- input url
                args

            ()
            n, List.Cons(apply, args)

        member _.Url((n, args), url) =
            let apply (args: WindowsVirtualMachineSecretCertificateArgs) =
                args.Url <- io url
                args

            ()
            n, List.Cons(apply, args)

    let windowsVirtualMachineSecretCertificate =
        WindowsVirtualMachineSecretCertificateBuilder()

    type WindowsVirtualMachineSourceImageReferenceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (WindowsVirtualMachineSourceImageReferenceArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("offer")>]
        member _.Offer((n, args), offer) =
            let apply (args: WindowsVirtualMachineSourceImageReferenceArgs) =
                args.Offer <- input offer
                args

            ()
            n, List.Cons(apply, args)

        member _.Offer((n, args), offer) =
            let apply (args: WindowsVirtualMachineSourceImageReferenceArgs) =
                args.Offer <- io offer
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publisher")>]
        member _.Publisher((n, args), publisher) =
            let apply (args: WindowsVirtualMachineSourceImageReferenceArgs) =
                args.Publisher <- input publisher
                args

            ()
            n, List.Cons(apply, args)

        member _.Publisher((n, args), publisher) =
            let apply (args: WindowsVirtualMachineSourceImageReferenceArgs) =
                args.Publisher <- io publisher
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sku")>]
        member _.Sku((n, args), sku) =
            let apply (args: WindowsVirtualMachineSourceImageReferenceArgs) =
                args.Sku <- input sku
                args

            ()
            n, List.Cons(apply, args)

        member _.Sku((n, args), sku) =
            let apply (args: WindowsVirtualMachineSourceImageReferenceArgs) =
                args.Sku <- io sku
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("version")>]
        member _.Version((n, args), version) =
            let apply (args: WindowsVirtualMachineSourceImageReferenceArgs) =
                args.Version <- input version
                args

            ()
            n, List.Cons(apply, args)

        member _.Version((n, args), version) =
            let apply (args: WindowsVirtualMachineSourceImageReferenceArgs) =
                args.Version <- io version
                args

            ()
            n, List.Cons(apply, args)

    let windowsVirtualMachineSourceImageReference =
        WindowsVirtualMachineSourceImageReferenceBuilder()

    type WindowsVirtualMachineWinrmListenerBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (WindowsVirtualMachineWinrmListenerArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("certificateUrl")>]
        member _.CertificateUrl((n, args), certificateUrl) =
            let apply (args: WindowsVirtualMachineWinrmListenerArgs) =
                args.CertificateUrl <- input certificateUrl
                args

            ()
            n, List.Cons(apply, args)

        member _.CertificateUrl((n, args), certificateUrl) =
            let apply (args: WindowsVirtualMachineWinrmListenerArgs) =
                args.CertificateUrl <- io certificateUrl
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("protocol")>]
        member _.Protocol((n, args), protocol) =
            let apply (args: WindowsVirtualMachineWinrmListenerArgs) =
                args.Protocol <- input protocol
                args

            ()
            n, List.Cons(apply, args)

        member _.Protocol((n, args), protocol) =
            let apply (args: WindowsVirtualMachineWinrmListenerArgs) =
                args.Protocol <- io protocol
                args

            ()
            n, List.Cons(apply, args)

    let windowsVirtualMachineWinrmListener =
        WindowsVirtualMachineWinrmListenerBuilder()

    type AvailabilitySetBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            AvailabilitySet(name, (List.fold func (AvailabilitySetArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: AvailabilitySetArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: AvailabilitySetArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("managed")>]
        member _.Managed((name, args), managed) =
            let apply (args: AvailabilitySetArgs) =
                args.Managed <- input managed
                args

            ()
            name, List.Cons(apply, args)

        member _.Managed((name, args), managed) =
            let apply (args: AvailabilitySetArgs) =
                args.Managed <- io managed
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: AvailabilitySetArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: AvailabilitySetArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("platformFaultDomainCount")>]
        member _.PlatformFaultDomainCount((name, args), platformFaultDomainCount) =
            let apply (args: AvailabilitySetArgs) =
                args.PlatformFaultDomainCount <- input platformFaultDomainCount
                args

            ()
            name, List.Cons(apply, args)

        member _.PlatformFaultDomainCount((name, args), platformFaultDomainCount) =
            let apply (args: AvailabilitySetArgs) =
                args.PlatformFaultDomainCount <- io platformFaultDomainCount
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("platformUpdateDomainCount")>]
        member _.PlatformUpdateDomainCount((name, args), platformUpdateDomainCount) =
            let apply (args: AvailabilitySetArgs) =
                args.PlatformUpdateDomainCount <- input platformUpdateDomainCount
                args

            ()
            name, List.Cons(apply, args)

        member _.PlatformUpdateDomainCount((name, args), platformUpdateDomainCount) =
            let apply (args: AvailabilitySetArgs) =
                args.PlatformUpdateDomainCount <- io platformUpdateDomainCount
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("proximityPlacementGroupId")>]
        member _.ProximityPlacementGroupId((name, args), proximityPlacementGroupId) =
            let apply (args: AvailabilitySetArgs) =
                args.ProximityPlacementGroupId <- input proximityPlacementGroupId
                args

            ()
            name, List.Cons(apply, args)

        member _.ProximityPlacementGroupId((name, args), proximityPlacementGroupId) =
            let apply (args: AvailabilitySetArgs) =
                args.ProximityPlacementGroupId <- io proximityPlacementGroupId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AvailabilitySetArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AvailabilitySetArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: AvailabilitySetArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let availabilitySet = AvailabilitySetBuilder()

    type BastionHostBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            BastionHost(name, (List.fold func (BastionHostArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: BastionHostArgs) =
                   args.IpConfiguration <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: BastionHostArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: BastionHostArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: BastionHostArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: BastionHostArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: BastionHostArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: BastionHostArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: BastionHostArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let bastionHost = BastionHostBuilder()

    type DataDiskAttachmentBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            DataDiskAttachment(name, (List.fold func (DataDiskAttachmentArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("caching")>]
        member _.Caching((name, args), caching) =
            let apply (args: DataDiskAttachmentArgs) =
                args.Caching <- input caching
                args

            ()
            name, List.Cons(apply, args)

        member _.Caching((name, args), caching) =
            let apply (args: DataDiskAttachmentArgs) =
                args.Caching <- io caching
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("createOption")>]
        member _.CreateOption((name, args), createOption) =
            let apply (args: DataDiskAttachmentArgs) =
                args.CreateOption <- input createOption
                args

            ()
            name, List.Cons(apply, args)

        member _.CreateOption((name, args), createOption) =
            let apply (args: DataDiskAttachmentArgs) =
                args.CreateOption <- io createOption
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("lun")>]
        member _.Lun((name, args), lun) =
            let apply (args: DataDiskAttachmentArgs) =
                args.Lun <- input lun
                args

            ()
            name, List.Cons(apply, args)

        member _.Lun((name, args), lun) =
            let apply (args: DataDiskAttachmentArgs) =
                args.Lun <- io lun
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("managedDiskId")>]
        member _.ManagedDiskId((name, args), managedDiskId) =
            let apply (args: DataDiskAttachmentArgs) =
                args.ManagedDiskId <- input managedDiskId
                args

            ()
            name, List.Cons(apply, args)

        member _.ManagedDiskId((name, args), managedDiskId) =
            let apply (args: DataDiskAttachmentArgs) =
                args.ManagedDiskId <- io managedDiskId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("virtualMachineId")>]
        member _.VirtualMachineId((name, args), virtualMachineId) =
            let apply (args: DataDiskAttachmentArgs) =
                args.VirtualMachineId <- input virtualMachineId
                args

            ()
            name, List.Cons(apply, args)

        member _.VirtualMachineId((name, args), virtualMachineId) =
            let apply (args: DataDiskAttachmentArgs) =
                args.VirtualMachineId <- io virtualMachineId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("writeAcceleratorEnabled")>]
        member _.WriteAcceleratorEnabled((name, args), writeAcceleratorEnabled) =
            let apply (args: DataDiskAttachmentArgs) =
                args.WriteAcceleratorEnabled <- input writeAcceleratorEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.WriteAcceleratorEnabled((name, args), writeAcceleratorEnabled) =
            let apply (args: DataDiskAttachmentArgs) =
                args.WriteAcceleratorEnabled <- io writeAcceleratorEnabled
                args

            ()
            name, List.Cons(apply, args)

    let dataDiskAttachment = DataDiskAttachmentBuilder()

    type DedicatedHostBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            DedicatedHost(name, (List.fold func (DedicatedHostArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("autoReplaceOnFailure")>]
        member _.AutoReplaceOnFailure((name, args), autoReplaceOnFailure) =
            let apply (args: DedicatedHostArgs) =
                args.AutoReplaceOnFailure <- input autoReplaceOnFailure
                args

            ()
            name, List.Cons(apply, args)

        member _.AutoReplaceOnFailure((name, args), autoReplaceOnFailure) =
            let apply (args: DedicatedHostArgs) =
                args.AutoReplaceOnFailure <- io autoReplaceOnFailure
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("dedicatedHostGroupId")>]
        member _.DedicatedHostGroupId((name, args), dedicatedHostGroupId) =
            let apply (args: DedicatedHostArgs) =
                args.DedicatedHostGroupId <- input dedicatedHostGroupId
                args

            ()
            name, List.Cons(apply, args)

        member _.DedicatedHostGroupId((name, args), dedicatedHostGroupId) =
            let apply (args: DedicatedHostArgs) =
                args.DedicatedHostGroupId <- io dedicatedHostGroupId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("licenseType")>]
        member _.LicenseType((name, args), licenseType) =
            let apply (args: DedicatedHostArgs) =
                args.LicenseType <- input licenseType
                args

            ()
            name, List.Cons(apply, args)

        member _.LicenseType((name, args), licenseType) =
            let apply (args: DedicatedHostArgs) =
                args.LicenseType <- io licenseType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: DedicatedHostArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: DedicatedHostArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: DedicatedHostArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: DedicatedHostArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("platformFaultDomain")>]
        member _.PlatformFaultDomain((name, args), platformFaultDomain) =
            let apply (args: DedicatedHostArgs) =
                args.PlatformFaultDomain <- input platformFaultDomain
                args

            ()
            name, List.Cons(apply, args)

        member _.PlatformFaultDomain((name, args), platformFaultDomain) =
            let apply (args: DedicatedHostArgs) =
                args.PlatformFaultDomain <- io platformFaultDomain
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("skuName")>]
        member _.SkuName((name, args), skuName) =
            let apply (args: DedicatedHostArgs) =
                args.SkuName <- input skuName
                args

            ()
            name, List.Cons(apply, args)

        member _.SkuName((name, args), skuName) =
            let apply (args: DedicatedHostArgs) =
                args.SkuName <- io skuName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: DedicatedHostArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let dedicatedHost = DedicatedHostBuilder()

    type DedicatedHostGroupBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            DedicatedHostGroup(name, (List.fold func (DedicatedHostGroupArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: DedicatedHostGroupArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: DedicatedHostGroupArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: DedicatedHostGroupArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: DedicatedHostGroupArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("platformFaultDomainCount")>]
        member _.PlatformFaultDomainCount((name, args), platformFaultDomainCount) =
            let apply (args: DedicatedHostGroupArgs) =
                args.PlatformFaultDomainCount <- input platformFaultDomainCount
                args

            ()
            name, List.Cons(apply, args)

        member _.PlatformFaultDomainCount((name, args), platformFaultDomainCount) =
            let apply (args: DedicatedHostGroupArgs) =
                args.PlatformFaultDomainCount <- io platformFaultDomainCount
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DedicatedHostGroupArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DedicatedHostGroupArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: DedicatedHostGroupArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zones")>]
        member _.Zones((name, args), zones) =
            let apply (args: DedicatedHostGroupArgs) =
                args.Zones <- input zones
                args

            ()
            name, List.Cons(apply, args)

        member _.Zones((name, args), zones) =
            let apply (args: DedicatedHostGroupArgs) =
                args.Zones <- io zones
                args

            ()
            name, List.Cons(apply, args)

    let dedicatedHostGroup = DedicatedHostGroupBuilder()

    type DiskEncryptionSetBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            DiskEncryptionSet(name, (List.fold func (DiskEncryptionSetArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: DiskEncryptionSetArgs) =
                   args.Identity <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("keyVaultKeyId")>]
        member _.KeyVaultKeyId((name, args), keyVaultKeyId) =
            let apply (args: DiskEncryptionSetArgs) =
                args.KeyVaultKeyId <- input keyVaultKeyId
                args

            ()
            name, List.Cons(apply, args)

        member _.KeyVaultKeyId((name, args), keyVaultKeyId) =
            let apply (args: DiskEncryptionSetArgs) =
                args.KeyVaultKeyId <- io keyVaultKeyId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: DiskEncryptionSetArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: DiskEncryptionSetArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: DiskEncryptionSetArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: DiskEncryptionSetArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DiskEncryptionSetArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DiskEncryptionSetArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: DiskEncryptionSetArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let diskEncryptionSet = DiskEncryptionSetBuilder()

    type ExtensionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Extension(name, (List.fold func (ExtensionArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("autoUpgradeMinorVersion")>]
        member _.AutoUpgradeMinorVersion((name, args), autoUpgradeMinorVersion) =
            let apply (args: ExtensionArgs) =
                args.AutoUpgradeMinorVersion <- input autoUpgradeMinorVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.AutoUpgradeMinorVersion((name, args), autoUpgradeMinorVersion) =
            let apply (args: ExtensionArgs) =
                args.AutoUpgradeMinorVersion <- io autoUpgradeMinorVersion
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ExtensionArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ExtensionArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("protectedSettings")>]
        member _.ProtectedSettings((name, args), protectedSettings) =
            let apply (args: ExtensionArgs) =
                args.ProtectedSettings <- input protectedSettings
                args

            ()
            name, List.Cons(apply, args)

        member _.ProtectedSettings((name, args), protectedSettings) =
            let apply (args: ExtensionArgs) =
                args.ProtectedSettings <- io protectedSettings
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("publisher")>]
        member _.Publisher((name, args), publisher) =
            let apply (args: ExtensionArgs) =
                args.Publisher <- input publisher
                args

            ()
            name, List.Cons(apply, args)

        member _.Publisher((name, args), publisher) =
            let apply (args: ExtensionArgs) =
                args.Publisher <- io publisher
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("settings")>]
        member _.Settings((name, args), settings) =
            let apply (args: ExtensionArgs) =
                args.Settings <- input settings
                args

            ()
            name, List.Cons(apply, args)

        member _.Settings((name, args), settings) =
            let apply (args: ExtensionArgs) =
                args.Settings <- io settings
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ExtensionArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((name, args), ``type``) =
            let apply (args: ExtensionArgs) =
                args.Type <- input ``type``
                args

            ()
            name, List.Cons(apply, args)

        member _.Type((name, args), ``type``) =
            let apply (args: ExtensionArgs) =
                args.Type <- io ``type``
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("typeHandlerVersion")>]
        member _.TypeHandlerVersion((name, args), typeHandlerVersion) =
            let apply (args: ExtensionArgs) =
                args.TypeHandlerVersion <- input typeHandlerVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.TypeHandlerVersion((name, args), typeHandlerVersion) =
            let apply (args: ExtensionArgs) =
                args.TypeHandlerVersion <- io typeHandlerVersion
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("virtualMachineId")>]
        member _.VirtualMachineId((name, args), virtualMachineId) =
            let apply (args: ExtensionArgs) =
                args.VirtualMachineId <- input virtualMachineId
                args

            ()
            name, List.Cons(apply, args)

        member _.VirtualMachineId((name, args), virtualMachineId) =
            let apply (args: ExtensionArgs) =
                args.VirtualMachineId <- io virtualMachineId
                args

            ()
            name, List.Cons(apply, args)

    let extension = ExtensionBuilder()

    type ImageBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Image(name, (List.fold func (ImageArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("dataDisks")>]
        member _.DataDisks((name, args), dataDisks) =
            let apply (args: ImageArgs) =
                args.DataDisks <- inputList dataDisks
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("hyperVGeneration")>]
        member _.HyperVGeneration((name, args), hyperVGeneration) =
            let apply (args: ImageArgs) =
                args.HyperVGeneration <- input hyperVGeneration
                args

            ()
            name, List.Cons(apply, args)

        member _.HyperVGeneration((name, args), hyperVGeneration) =
            let apply (args: ImageArgs) =
                args.HyperVGeneration <- io hyperVGeneration
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ImageArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ImageArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ImageArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ImageArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ImageArgs) =
                   args.OsDisk <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ImageArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ImageArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sourceVirtualMachineId")>]
        member _.SourceVirtualMachineId((name, args), sourceVirtualMachineId) =
            let apply (args: ImageArgs) =
                args.SourceVirtualMachineId <- input sourceVirtualMachineId
                args

            ()
            name, List.Cons(apply, args)

        member _.SourceVirtualMachineId((name, args), sourceVirtualMachineId) =
            let apply (args: ImageArgs) =
                args.SourceVirtualMachineId <- io sourceVirtualMachineId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ImageArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zoneResilient")>]
        member _.ZoneResilient((name, args), zoneResilient) =
            let apply (args: ImageArgs) =
                args.ZoneResilient <- input zoneResilient
                args

            ()
            name, List.Cons(apply, args)

        member _.ZoneResilient((name, args), zoneResilient) =
            let apply (args: ImageArgs) =
                args.ZoneResilient <- io zoneResilient
                args

            ()
            name, List.Cons(apply, args)

    let image = ImageBuilder()

    type LinuxVirtualMachineBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            LinuxVirtualMachine(name, (List.fold func (LinuxVirtualMachineArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: LinuxVirtualMachineArgs) =
                   args.AdditionalCapabilities <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("adminPassword")>]
        member _.AdminPassword((name, args), adminPassword) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.AdminPassword <- input adminPassword
                args

            ()
            name, List.Cons(apply, args)

        member _.AdminPassword((name, args), adminPassword) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.AdminPassword <- io adminPassword
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("adminSshKeys")>]
        member _.AdminSshKeys((name, args), adminSshKeys) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.AdminSshKeys <- inputList adminSshKeys
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("adminUsername")>]
        member _.AdminUsername((name, args), adminUsername) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.AdminUsername <- input adminUsername
                args

            ()
            name, List.Cons(apply, args)

        member _.AdminUsername((name, args), adminUsername) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.AdminUsername <- io adminUsername
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("allowExtensionOperations")>]
        member _.AllowExtensionOperations((name, args), allowExtensionOperations) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.AllowExtensionOperations <- input allowExtensionOperations
                args

            ()
            name, List.Cons(apply, args)

        member _.AllowExtensionOperations((name, args), allowExtensionOperations) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.AllowExtensionOperations <- io allowExtensionOperations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("availabilitySetId")>]
        member _.AvailabilitySetId((name, args), availabilitySetId) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.AvailabilitySetId <- input availabilitySetId
                args

            ()
            name, List.Cons(apply, args)

        member _.AvailabilitySetId((name, args), availabilitySetId) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.AvailabilitySetId <- io availabilitySetId
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: LinuxVirtualMachineArgs) =
                   args.BootDiagnostics <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("computerName")>]
        member _.ComputerName((name, args), computerName) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.ComputerName <- input computerName
                args

            ()
            name, List.Cons(apply, args)

        member _.ComputerName((name, args), computerName) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.ComputerName <- io computerName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("customData")>]
        member _.CustomData((name, args), customData) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.CustomData <- input customData
                args

            ()
            name, List.Cons(apply, args)

        member _.CustomData((name, args), customData) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.CustomData <- io customData
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("dedicatedHostId")>]
        member _.DedicatedHostId((name, args), dedicatedHostId) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.DedicatedHostId <- input dedicatedHostId
                args

            ()
            name, List.Cons(apply, args)

        member _.DedicatedHostId((name, args), dedicatedHostId) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.DedicatedHostId <- io dedicatedHostId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("disablePasswordAuthentication")>]
        member _.DisablePasswordAuthentication((name, args), disablePasswordAuthentication) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.DisablePasswordAuthentication <- input disablePasswordAuthentication
                args

            ()
            name, List.Cons(apply, args)

        member _.DisablePasswordAuthentication((name, args), disablePasswordAuthentication) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.DisablePasswordAuthentication <- io disablePasswordAuthentication
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("evictionPolicy")>]
        member _.EvictionPolicy((name, args), evictionPolicy) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.EvictionPolicy <- input evictionPolicy
                args

            ()
            name, List.Cons(apply, args)

        member _.EvictionPolicy((name, args), evictionPolicy) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.EvictionPolicy <- io evictionPolicy
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: LinuxVirtualMachineArgs) =
                   args.Identity <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("maxBidPrice")>]
        member _.MaxBidPrice((name, args), maxBidPrice) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.MaxBidPrice <- input maxBidPrice
                args

            ()
            name, List.Cons(apply, args)

        member _.MaxBidPrice((name, args), maxBidPrice) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.MaxBidPrice <- io maxBidPrice
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("networkInterfaceIds")>]
        member _.NetworkInterfaceIds((name, args), networkInterfaceIds) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.NetworkInterfaceIds <- inputList networkInterfaceIds
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: LinuxVirtualMachineArgs) =
                   args.OsDisk <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: LinuxVirtualMachineArgs) =
                   args.Plan <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("priority")>]
        member _.Priority((name, args), priority) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.Priority <- input priority
                args

            ()
            name, List.Cons(apply, args)

        member _.Priority((name, args), priority) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.Priority <- io priority
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("provisionVmAgent")>]
        member _.ProvisionVmAgent((name, args), provisionVmAgent) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.ProvisionVmAgent <- input provisionVmAgent
                args

            ()
            name, List.Cons(apply, args)

        member _.ProvisionVmAgent((name, args), provisionVmAgent) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.ProvisionVmAgent <- io provisionVmAgent
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("proximityPlacementGroupId")>]
        member _.ProximityPlacementGroupId((name, args), proximityPlacementGroupId) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.ProximityPlacementGroupId <- input proximityPlacementGroupId
                args

            ()
            name, List.Cons(apply, args)

        member _.ProximityPlacementGroupId((name, args), proximityPlacementGroupId) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.ProximityPlacementGroupId <- io proximityPlacementGroupId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("secrets")>]
        member _.Secrets((name, args), secrets) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.Secrets <- inputList secrets
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("size")>]
        member _.Size((name, args), size) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.Size <- input size
                args

            ()
            name, List.Cons(apply, args)

        member _.Size((name, args), size) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.Size <- io size
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sourceImageId")>]
        member _.SourceImageId((name, args), sourceImageId) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.SourceImageId <- input sourceImageId
                args

            ()
            name, List.Cons(apply, args)

        member _.SourceImageId((name, args), sourceImageId) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.SourceImageId <- io sourceImageId
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: LinuxVirtualMachineArgs) =
                   args.SourceImageReference <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("virtualMachineScaleSetId")>]
        member _.VirtualMachineScaleSetId((name, args), virtualMachineScaleSetId) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.VirtualMachineScaleSetId <- input virtualMachineScaleSetId
                args

            ()
            name, List.Cons(apply, args)

        member _.VirtualMachineScaleSetId((name, args), virtualMachineScaleSetId) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.VirtualMachineScaleSetId <- io virtualMachineScaleSetId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zone")>]
        member _.Zone((name, args), zone) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.Zone <- input zone
                args

            ()
            name, List.Cons(apply, args)

        member _.Zone((name, args), zone) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.Zone <- io zone
                args

            ()
            name, List.Cons(apply, args)

    let linuxVirtualMachine = LinuxVirtualMachineBuilder()

    type LinuxVirtualMachineScaleSetBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            LinuxVirtualMachineScaleSet(name, (List.fold func (LinuxVirtualMachineScaleSetArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: LinuxVirtualMachineScaleSetArgs) =
                   args.AdditionalCapabilities <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("adminPassword")>]
        member _.AdminPassword((name, args), adminPassword) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.AdminPassword <- input adminPassword
                args

            ()
            name, List.Cons(apply, args)

        member _.AdminPassword((name, args), adminPassword) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.AdminPassword <- io adminPassword
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("adminSshKeys")>]
        member _.AdminSshKeys((name, args), adminSshKeys) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.AdminSshKeys <- inputList adminSshKeys
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("adminUsername")>]
        member _.AdminUsername((name, args), adminUsername) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.AdminUsername <- input adminUsername
                args

            ()
            name, List.Cons(apply, args)

        member _.AdminUsername((name, args), adminUsername) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.AdminUsername <- io adminUsername
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: LinuxVirtualMachineScaleSetArgs) =
                   args.AutomaticInstanceRepair <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: LinuxVirtualMachineScaleSetArgs) =
                   args.AutomaticOsUpgradePolicy <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: LinuxVirtualMachineScaleSetArgs) =
                   args.BootDiagnostics <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("computerNamePrefix")>]
        member _.ComputerNamePrefix((name, args), computerNamePrefix) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.ComputerNamePrefix <- input computerNamePrefix
                args

            ()
            name, List.Cons(apply, args)

        member _.ComputerNamePrefix((name, args), computerNamePrefix) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.ComputerNamePrefix <- io computerNamePrefix
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("customData")>]
        member _.CustomData((name, args), customData) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.CustomData <- input customData
                args

            ()
            name, List.Cons(apply, args)

        member _.CustomData((name, args), customData) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.CustomData <- io customData
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("dataDisks")>]
        member _.DataDisks((name, args), dataDisks) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.DataDisks <- inputList dataDisks
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("disablePasswordAuthentication")>]
        member _.DisablePasswordAuthentication((name, args), disablePasswordAuthentication) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.DisablePasswordAuthentication <- input disablePasswordAuthentication
                args

            ()
            name, List.Cons(apply, args)

        member _.DisablePasswordAuthentication((name, args), disablePasswordAuthentication) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.DisablePasswordAuthentication <- io disablePasswordAuthentication
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("doNotRunExtensionsOnOverprovisionedMachines")>]
        member _.DoNotRunExtensionsOnOverprovisionedMachines((name, args), doNotRunExtensionsOnOverprovisionedMachines) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.DoNotRunExtensionsOnOverprovisionedMachines <- input doNotRunExtensionsOnOverprovisionedMachines
                args

            ()
            name, List.Cons(apply, args)

        member _.DoNotRunExtensionsOnOverprovisionedMachines((name, args), doNotRunExtensionsOnOverprovisionedMachines) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.DoNotRunExtensionsOnOverprovisionedMachines <- io doNotRunExtensionsOnOverprovisionedMachines
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("evictionPolicy")>]
        member _.EvictionPolicy((name, args), evictionPolicy) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.EvictionPolicy <- input evictionPolicy
                args

            ()
            name, List.Cons(apply, args)

        member _.EvictionPolicy((name, args), evictionPolicy) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.EvictionPolicy <- io evictionPolicy
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("healthProbeId")>]
        member _.HealthProbeId((name, args), healthProbeId) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.HealthProbeId <- input healthProbeId
                args

            ()
            name, List.Cons(apply, args)

        member _.HealthProbeId((name, args), healthProbeId) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.HealthProbeId <- io healthProbeId
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: LinuxVirtualMachineScaleSetArgs) =
                   args.Identity <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("instances")>]
        member _.Instances((name, args), instances) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.Instances <- input instances
                args

            ()
            name, List.Cons(apply, args)

        member _.Instances((name, args), instances) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.Instances <- io instances
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("maxBidPrice")>]
        member _.MaxBidPrice((name, args), maxBidPrice) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.MaxBidPrice <- input maxBidPrice
                args

            ()
            name, List.Cons(apply, args)

        member _.MaxBidPrice((name, args), maxBidPrice) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.MaxBidPrice <- io maxBidPrice
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("networkInterfaces")>]
        member _.NetworkInterfaces((name, args), networkInterfaces) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.NetworkInterfaces <- inputList networkInterfaces
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: LinuxVirtualMachineScaleSetArgs) =
                   args.OsDisk <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("overprovision")>]
        member _.Overprovision((name, args), overprovision) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.Overprovision <- input overprovision
                args

            ()
            name, List.Cons(apply, args)

        member _.Overprovision((name, args), overprovision) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.Overprovision <- io overprovision
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: LinuxVirtualMachineScaleSetArgs) =
                   args.Plan <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("priority")>]
        member _.Priority((name, args), priority) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.Priority <- input priority
                args

            ()
            name, List.Cons(apply, args)

        member _.Priority((name, args), priority) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.Priority <- io priority
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("provisionVmAgent")>]
        member _.ProvisionVmAgent((name, args), provisionVmAgent) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.ProvisionVmAgent <- input provisionVmAgent
                args

            ()
            name, List.Cons(apply, args)

        member _.ProvisionVmAgent((name, args), provisionVmAgent) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.ProvisionVmAgent <- io provisionVmAgent
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("proximityPlacementGroupId")>]
        member _.ProximityPlacementGroupId((name, args), proximityPlacementGroupId) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.ProximityPlacementGroupId <- input proximityPlacementGroupId
                args

            ()
            name, List.Cons(apply, args)

        member _.ProximityPlacementGroupId((name, args), proximityPlacementGroupId) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.ProximityPlacementGroupId <- io proximityPlacementGroupId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: LinuxVirtualMachineScaleSetArgs) =
                   args.RollingUpgradePolicy <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("scaleInPolicy")>]
        member _.ScaleInPolicy((name, args), scaleInPolicy) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.ScaleInPolicy <- input scaleInPolicy
                args

            ()
            name, List.Cons(apply, args)

        member _.ScaleInPolicy((name, args), scaleInPolicy) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.ScaleInPolicy <- io scaleInPolicy
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("secrets")>]
        member _.Secrets((name, args), secrets) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.Secrets <- inputList secrets
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("singlePlacementGroup")>]
        member _.SinglePlacementGroup((name, args), singlePlacementGroup) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.SinglePlacementGroup <- input singlePlacementGroup
                args

            ()
            name, List.Cons(apply, args)

        member _.SinglePlacementGroup((name, args), singlePlacementGroup) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.SinglePlacementGroup <- io singlePlacementGroup
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sku")>]
        member _.Sku((name, args), sku) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.Sku <- input sku
                args

            ()
            name, List.Cons(apply, args)

        member _.Sku((name, args), sku) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.Sku <- io sku
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sourceImageId")>]
        member _.SourceImageId((name, args), sourceImageId) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.SourceImageId <- input sourceImageId
                args

            ()
            name, List.Cons(apply, args)

        member _.SourceImageId((name, args), sourceImageId) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.SourceImageId <- io sourceImageId
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: LinuxVirtualMachineScaleSetArgs) =
                   args.SourceImageReference <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: LinuxVirtualMachineScaleSetArgs) =
                   args.TerminateNotification <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("upgradeMode")>]
        member _.UpgradeMode((name, args), upgradeMode) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.UpgradeMode <- input upgradeMode
                args

            ()
            name, List.Cons(apply, args)

        member _.UpgradeMode((name, args), upgradeMode) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.UpgradeMode <- io upgradeMode
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zoneBalance")>]
        member _.ZoneBalance((name, args), zoneBalance) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.ZoneBalance <- input zoneBalance
                args

            ()
            name, List.Cons(apply, args)

        member _.ZoneBalance((name, args), zoneBalance) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.ZoneBalance <- io zoneBalance
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zones")>]
        member _.Zones((name, args), zones) =
            let apply (args: LinuxVirtualMachineScaleSetArgs) =
                args.Zones <- inputList zones
                args

            ()
            name, List.Cons(apply, args)

    let linuxVirtualMachineScaleSet = LinuxVirtualMachineScaleSetBuilder()

    type ManagedDiskBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ManagedDisk(name, (List.fold func (ManagedDiskArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("createOption")>]
        member _.CreateOption((name, args), createOption) =
            let apply (args: ManagedDiskArgs) =
                args.CreateOption <- input createOption
                args

            ()
            name, List.Cons(apply, args)

        member _.CreateOption((name, args), createOption) =
            let apply (args: ManagedDiskArgs) =
                args.CreateOption <- io createOption
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("diskEncryptionSetId")>]
        member _.DiskEncryptionSetId((name, args), diskEncryptionSetId) =
            let apply (args: ManagedDiskArgs) =
                args.DiskEncryptionSetId <- input diskEncryptionSetId
                args

            ()
            name, List.Cons(apply, args)

        member _.DiskEncryptionSetId((name, args), diskEncryptionSetId) =
            let apply (args: ManagedDiskArgs) =
                args.DiskEncryptionSetId <- io diskEncryptionSetId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("diskIopsReadWrite")>]
        member _.DiskIopsReadWrite((name, args), diskIopsReadWrite) =
            let apply (args: ManagedDiskArgs) =
                args.DiskIopsReadWrite <- input diskIopsReadWrite
                args

            ()
            name, List.Cons(apply, args)

        member _.DiskIopsReadWrite((name, args), diskIopsReadWrite) =
            let apply (args: ManagedDiskArgs) =
                args.DiskIopsReadWrite <- io diskIopsReadWrite
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("diskMbpsReadWrite")>]
        member _.DiskMbpsReadWrite((name, args), diskMbpsReadWrite) =
            let apply (args: ManagedDiskArgs) =
                args.DiskMbpsReadWrite <- input diskMbpsReadWrite
                args

            ()
            name, List.Cons(apply, args)

        member _.DiskMbpsReadWrite((name, args), diskMbpsReadWrite) =
            let apply (args: ManagedDiskArgs) =
                args.DiskMbpsReadWrite <- io diskMbpsReadWrite
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("diskSizeGb")>]
        member _.DiskSizeGb((name, args), diskSizeGb) =
            let apply (args: ManagedDiskArgs) =
                args.DiskSizeGb <- input diskSizeGb
                args

            ()
            name, List.Cons(apply, args)

        member _.DiskSizeGb((name, args), diskSizeGb) =
            let apply (args: ManagedDiskArgs) =
                args.DiskSizeGb <- io diskSizeGb
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ManagedDiskArgs) =
                   args.EncryptionSettings <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("imageReferenceId")>]
        member _.ImageReferenceId((name, args), imageReferenceId) =
            let apply (args: ManagedDiskArgs) =
                args.ImageReferenceId <- input imageReferenceId
                args

            ()
            name, List.Cons(apply, args)

        member _.ImageReferenceId((name, args), imageReferenceId) =
            let apply (args: ManagedDiskArgs) =
                args.ImageReferenceId <- io imageReferenceId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ManagedDiskArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ManagedDiskArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ManagedDiskArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ManagedDiskArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("osType")>]
        member _.OsType((name, args), osType) =
            let apply (args: ManagedDiskArgs) =
                args.OsType <- input osType
                args

            ()
            name, List.Cons(apply, args)

        member _.OsType((name, args), osType) =
            let apply (args: ManagedDiskArgs) =
                args.OsType <- io osType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ManagedDiskArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ManagedDiskArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sourceResourceId")>]
        member _.SourceResourceId((name, args), sourceResourceId) =
            let apply (args: ManagedDiskArgs) =
                args.SourceResourceId <- input sourceResourceId
                args

            ()
            name, List.Cons(apply, args)

        member _.SourceResourceId((name, args), sourceResourceId) =
            let apply (args: ManagedDiskArgs) =
                args.SourceResourceId <- io sourceResourceId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sourceUri")>]
        member _.SourceUri((name, args), sourceUri) =
            let apply (args: ManagedDiskArgs) =
                args.SourceUri <- input sourceUri
                args

            ()
            name, List.Cons(apply, args)

        member _.SourceUri((name, args), sourceUri) =
            let apply (args: ManagedDiskArgs) =
                args.SourceUri <- io sourceUri
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageAccountId")>]
        member _.StorageAccountId((name, args), storageAccountId) =
            let apply (args: ManagedDiskArgs) =
                args.StorageAccountId <- input storageAccountId
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageAccountId((name, args), storageAccountId) =
            let apply (args: ManagedDiskArgs) =
                args.StorageAccountId <- io storageAccountId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageAccountType")>]
        member _.StorageAccountType((name, args), storageAccountType) =
            let apply (args: ManagedDiskArgs) =
                args.StorageAccountType <- input storageAccountType
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageAccountType((name, args), storageAccountType) =
            let apply (args: ManagedDiskArgs) =
                args.StorageAccountType <- io storageAccountType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ManagedDiskArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zones")>]
        member _.Zones((name, args), zones) =
            let apply (args: ManagedDiskArgs) =
                args.Zones <- input zones
                args

            ()
            name, List.Cons(apply, args)

        member _.Zones((name, args), zones) =
            let apply (args: ManagedDiskArgs) =
                args.Zones <- io zones
                args

            ()
            name, List.Cons(apply, args)

    let managedDisk = ManagedDiskBuilder()

    type OrchestratedVirtualMachineScaleSetBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            OrchestratedVirtualMachineScaleSet(name, (List.fold func (OrchestratedVirtualMachineScaleSetArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: OrchestratedVirtualMachineScaleSetArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: OrchestratedVirtualMachineScaleSetArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: OrchestratedVirtualMachineScaleSetArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: OrchestratedVirtualMachineScaleSetArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("platformFaultDomainCount")>]
        member _.PlatformFaultDomainCount((name, args), platformFaultDomainCount) =
            let apply (args: OrchestratedVirtualMachineScaleSetArgs) =
                args.PlatformFaultDomainCount <- input platformFaultDomainCount
                args

            ()
            name, List.Cons(apply, args)

        member _.PlatformFaultDomainCount((name, args), platformFaultDomainCount) =
            let apply (args: OrchestratedVirtualMachineScaleSetArgs) =
                args.PlatformFaultDomainCount <- io platformFaultDomainCount
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: OrchestratedVirtualMachineScaleSetArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: OrchestratedVirtualMachineScaleSetArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("singlePlacementGroup")>]
        member _.SinglePlacementGroup((name, args), singlePlacementGroup) =
            let apply (args: OrchestratedVirtualMachineScaleSetArgs) =
                args.SinglePlacementGroup <- input singlePlacementGroup
                args

            ()
            name, List.Cons(apply, args)

        member _.SinglePlacementGroup((name, args), singlePlacementGroup) =
            let apply (args: OrchestratedVirtualMachineScaleSetArgs) =
                args.SinglePlacementGroup <- io singlePlacementGroup
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: OrchestratedVirtualMachineScaleSetArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zones")>]
        member _.Zones((name, args), zones) =
            let apply (args: OrchestratedVirtualMachineScaleSetArgs) =
                args.Zones <- input zones
                args

            ()
            name, List.Cons(apply, args)

        member _.Zones((name, args), zones) =
            let apply (args: OrchestratedVirtualMachineScaleSetArgs) =
                args.Zones <- io zones
                args

            ()
            name, List.Cons(apply, args)

    let orchestratedVirtualMachineScaleSet =
        OrchestratedVirtualMachineScaleSetBuilder()

    type ScaleSetBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ScaleSet(name, (List.fold func (ScaleSetArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("automaticOsUpgrade")>]
        member _.AutomaticOsUpgrade((name, args), automaticOsUpgrade) =
            let apply (args: ScaleSetArgs) =
                args.AutomaticOsUpgrade <- input automaticOsUpgrade
                args

            ()
            name, List.Cons(apply, args)

        member _.AutomaticOsUpgrade((name, args), automaticOsUpgrade) =
            let apply (args: ScaleSetArgs) =
                args.AutomaticOsUpgrade <- io automaticOsUpgrade
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ScaleSetArgs) =
                   args.BootDiagnostics <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("evictionPolicy")>]
        member _.EvictionPolicy((name, args), evictionPolicy) =
            let apply (args: ScaleSetArgs) =
                args.EvictionPolicy <- input evictionPolicy
                args

            ()
            name, List.Cons(apply, args)

        member _.EvictionPolicy((name, args), evictionPolicy) =
            let apply (args: ScaleSetArgs) =
                args.EvictionPolicy <- io evictionPolicy
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("extensions")>]
        member _.Extensions((name, args), extensions) =
            let apply (args: ScaleSetArgs) =
                args.Extensions <- inputList extensions
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("healthProbeId")>]
        member _.HealthProbeId((name, args), healthProbeId) =
            let apply (args: ScaleSetArgs) =
                args.HealthProbeId <- input healthProbeId
                args

            ()
            name, List.Cons(apply, args)

        member _.HealthProbeId((name, args), healthProbeId) =
            let apply (args: ScaleSetArgs) =
                args.HealthProbeId <- io healthProbeId
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ScaleSetArgs) =
                   args.Identity <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("licenseType")>]
        member _.LicenseType((name, args), licenseType) =
            let apply (args: ScaleSetArgs) =
                args.LicenseType <- input licenseType
                args

            ()
            name, List.Cons(apply, args)

        member _.LicenseType((name, args), licenseType) =
            let apply (args: ScaleSetArgs) =
                args.LicenseType <- io licenseType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ScaleSetArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ScaleSetArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ScaleSetArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ScaleSetArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("networkProfiles")>]
        member _.NetworkProfiles((name, args), networkProfiles) =
            let apply (args: ScaleSetArgs) =
                args.NetworkProfiles <- inputList networkProfiles
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ScaleSetArgs) =
                   args.OsProfile <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: ScaleSetArgs) =
                   args.OsProfileLinuxConfig <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("osProfileSecrets")>]
        member _.OsProfileSecrets((name, args), osProfileSecrets) =
            let apply (args: ScaleSetArgs) =
                args.OsProfileSecrets <- inputList osProfileSecrets
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ScaleSetArgs) =
                   args.OsProfileWindowsConfig <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("overprovision")>]
        member _.Overprovision((name, args), overprovision) =
            let apply (args: ScaleSetArgs) =
                args.Overprovision <- input overprovision
                args

            ()
            name, List.Cons(apply, args)

        member _.Overprovision((name, args), overprovision) =
            let apply (args: ScaleSetArgs) =
                args.Overprovision <- io overprovision
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ScaleSetArgs) =
                   args.Plan <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("priority")>]
        member _.Priority((name, args), priority) =
            let apply (args: ScaleSetArgs) =
                args.Priority <- input priority
                args

            ()
            name, List.Cons(apply, args)

        member _.Priority((name, args), priority) =
            let apply (args: ScaleSetArgs) =
                args.Priority <- io priority
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("proximityPlacementGroupId")>]
        member _.ProximityPlacementGroupId((name, args), proximityPlacementGroupId) =
            let apply (args: ScaleSetArgs) =
                args.ProximityPlacementGroupId <- input proximityPlacementGroupId
                args

            ()
            name, List.Cons(apply, args)

        member _.ProximityPlacementGroupId((name, args), proximityPlacementGroupId) =
            let apply (args: ScaleSetArgs) =
                args.ProximityPlacementGroupId <- io proximityPlacementGroupId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ScaleSetArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ScaleSetArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ScaleSetArgs) =
                   args.RollingUpgradePolicy <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("singlePlacementGroup")>]
        member _.SinglePlacementGroup((name, args), singlePlacementGroup) =
            let apply (args: ScaleSetArgs) =
                args.SinglePlacementGroup <- input singlePlacementGroup
                args

            ()
            name, List.Cons(apply, args)

        member _.SinglePlacementGroup((name, args), singlePlacementGroup) =
            let apply (args: ScaleSetArgs) =
                args.SinglePlacementGroup <- io singlePlacementGroup
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ScaleSetArgs) =
                   args.Sku <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("storageProfileDataDisks")>]
        member _.StorageProfileDataDisks((name, args), storageProfileDataDisks) =
            let apply (args: ScaleSetArgs) =
                args.StorageProfileDataDisks <- inputList storageProfileDataDisks
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ScaleSetArgs) =
                   args.StorageProfileImageReference <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: ScaleSetArgs) =
                   args.StorageProfileOsDisk <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ScaleSetArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("upgradePolicyMode")>]
        member _.UpgradePolicyMode((name, args), upgradePolicyMode) =
            let apply (args: ScaleSetArgs) =
                args.UpgradePolicyMode <- input upgradePolicyMode
                args

            ()
            name, List.Cons(apply, args)

        member _.UpgradePolicyMode((name, args), upgradePolicyMode) =
            let apply (args: ScaleSetArgs) =
                args.UpgradePolicyMode <- io upgradePolicyMode
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zones")>]
        member _.Zones((name, args), zones) =
            let apply (args: ScaleSetArgs) =
                args.Zones <- inputList zones
                args

            ()
            name, List.Cons(apply, args)

    let scaleSet = ScaleSetBuilder()

    type SharedImageBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            SharedImage(name, (List.fold func (SharedImageArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: SharedImageArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: SharedImageArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("eula")>]
        member _.Eula((name, args), eula) =
            let apply (args: SharedImageArgs) =
                args.Eula <- input eula
                args

            ()
            name, List.Cons(apply, args)

        member _.Eula((name, args), eula) =
            let apply (args: SharedImageArgs) =
                args.Eula <- io eula
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("galleryName")>]
        member _.GalleryName((name, args), galleryName) =
            let apply (args: SharedImageArgs) =
                args.GalleryName <- input galleryName
                args

            ()
            name, List.Cons(apply, args)

        member _.GalleryName((name, args), galleryName) =
            let apply (args: SharedImageArgs) =
                args.GalleryName <- io galleryName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("hyperVGeneration")>]
        member _.HyperVGeneration((name, args), hyperVGeneration) =
            let apply (args: SharedImageArgs) =
                args.HyperVGeneration <- input hyperVGeneration
                args

            ()
            name, List.Cons(apply, args)

        member _.HyperVGeneration((name, args), hyperVGeneration) =
            let apply (args: SharedImageArgs) =
                args.HyperVGeneration <- io hyperVGeneration
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: SharedImageArgs) =
                   args.Identifier <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: SharedImageArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: SharedImageArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: SharedImageArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: SharedImageArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("osType")>]
        member _.OsType((name, args), osType) =
            let apply (args: SharedImageArgs) =
                args.OsType <- input osType
                args

            ()
            name, List.Cons(apply, args)

        member _.OsType((name, args), osType) =
            let apply (args: SharedImageArgs) =
                args.OsType <- io osType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("privacyStatementUri")>]
        member _.PrivacyStatementUri((name, args), privacyStatementUri) =
            let apply (args: SharedImageArgs) =
                args.PrivacyStatementUri <- input privacyStatementUri
                args

            ()
            name, List.Cons(apply, args)

        member _.PrivacyStatementUri((name, args), privacyStatementUri) =
            let apply (args: SharedImageArgs) =
                args.PrivacyStatementUri <- io privacyStatementUri
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("releaseNoteUri")>]
        member _.ReleaseNoteUri((name, args), releaseNoteUri) =
            let apply (args: SharedImageArgs) =
                args.ReleaseNoteUri <- input releaseNoteUri
                args

            ()
            name, List.Cons(apply, args)

        member _.ReleaseNoteUri((name, args), releaseNoteUri) =
            let apply (args: SharedImageArgs) =
                args.ReleaseNoteUri <- io releaseNoteUri
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SharedImageArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SharedImageArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: SharedImageArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let sharedImage = SharedImageBuilder()

    type SharedImageGalleryBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            SharedImageGallery(name, (List.fold func (SharedImageGalleryArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: SharedImageGalleryArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: SharedImageGalleryArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: SharedImageGalleryArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: SharedImageGalleryArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: SharedImageGalleryArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: SharedImageGalleryArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SharedImageGalleryArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SharedImageGalleryArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: SharedImageGalleryArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let sharedImageGallery = SharedImageGalleryBuilder()

    type SharedImageVersionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            SharedImageVersion(name, (List.fold func (SharedImageVersionArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("excludeFromLatest")>]
        member _.ExcludeFromLatest((name, args), excludeFromLatest) =
            let apply (args: SharedImageVersionArgs) =
                args.ExcludeFromLatest <- input excludeFromLatest
                args

            ()
            name, List.Cons(apply, args)

        member _.ExcludeFromLatest((name, args), excludeFromLatest) =
            let apply (args: SharedImageVersionArgs) =
                args.ExcludeFromLatest <- io excludeFromLatest
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("galleryName")>]
        member _.GalleryName((name, args), galleryName) =
            let apply (args: SharedImageVersionArgs) =
                args.GalleryName <- input galleryName
                args

            ()
            name, List.Cons(apply, args)

        member _.GalleryName((name, args), galleryName) =
            let apply (args: SharedImageVersionArgs) =
                args.GalleryName <- io galleryName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("imageName")>]
        member _.ImageName((name, args), imageName) =
            let apply (args: SharedImageVersionArgs) =
                args.ImageName <- input imageName
                args

            ()
            name, List.Cons(apply, args)

        member _.ImageName((name, args), imageName) =
            let apply (args: SharedImageVersionArgs) =
                args.ImageName <- io imageName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: SharedImageVersionArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: SharedImageVersionArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("managedImageId")>]
        member _.ManagedImageId((name, args), managedImageId) =
            let apply (args: SharedImageVersionArgs) =
                args.ManagedImageId <- input managedImageId
                args

            ()
            name, List.Cons(apply, args)

        member _.ManagedImageId((name, args), managedImageId) =
            let apply (args: SharedImageVersionArgs) =
                args.ManagedImageId <- io managedImageId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: SharedImageVersionArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: SharedImageVersionArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SharedImageVersionArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SharedImageVersionArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: SharedImageVersionArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("targetRegions")>]
        member _.TargetRegions((name, args), targetRegions) =
            let apply (args: SharedImageVersionArgs) =
                args.TargetRegions <- inputList targetRegions
                args

            ()
            name, List.Cons(apply, args)

    let sharedImageVersion = SharedImageVersionBuilder()

    type SnapshotBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Snapshot(name, (List.fold func (SnapshotArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("createOption")>]
        member _.CreateOption((name, args), createOption) =
            let apply (args: SnapshotArgs) =
                args.CreateOption <- input createOption
                args

            ()
            name, List.Cons(apply, args)

        member _.CreateOption((name, args), createOption) =
            let apply (args: SnapshotArgs) =
                args.CreateOption <- io createOption
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("diskSizeGb")>]
        member _.DiskSizeGb((name, args), diskSizeGb) =
            let apply (args: SnapshotArgs) =
                args.DiskSizeGb <- input diskSizeGb
                args

            ()
            name, List.Cons(apply, args)

        member _.DiskSizeGb((name, args), diskSizeGb) =
            let apply (args: SnapshotArgs) =
                args.DiskSizeGb <- io diskSizeGb
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: SnapshotArgs) =
                   args.EncryptionSettings <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: SnapshotArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: SnapshotArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: SnapshotArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: SnapshotArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SnapshotArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SnapshotArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sourceResourceId")>]
        member _.SourceResourceId((name, args), sourceResourceId) =
            let apply (args: SnapshotArgs) =
                args.SourceResourceId <- input sourceResourceId
                args

            ()
            name, List.Cons(apply, args)

        member _.SourceResourceId((name, args), sourceResourceId) =
            let apply (args: SnapshotArgs) =
                args.SourceResourceId <- io sourceResourceId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sourceUri")>]
        member _.SourceUri((name, args), sourceUri) =
            let apply (args: SnapshotArgs) =
                args.SourceUri <- input sourceUri
                args

            ()
            name, List.Cons(apply, args)

        member _.SourceUri((name, args), sourceUri) =
            let apply (args: SnapshotArgs) =
                args.SourceUri <- io sourceUri
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageAccountId")>]
        member _.StorageAccountId((name, args), storageAccountId) =
            let apply (args: SnapshotArgs) =
                args.StorageAccountId <- input storageAccountId
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageAccountId((name, args), storageAccountId) =
            let apply (args: SnapshotArgs) =
                args.StorageAccountId <- io storageAccountId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: SnapshotArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let snapshot = SnapshotBuilder()

    type VirtualMachineBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            VirtualMachine(name, (List.fold func (VirtualMachineArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: VirtualMachineArgs) =
                   args.AdditionalCapabilities <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("availabilitySetId")>]
        member _.AvailabilitySetId((name, args), availabilitySetId) =
            let apply (args: VirtualMachineArgs) =
                args.AvailabilitySetId <- input availabilitySetId
                args

            ()
            name, List.Cons(apply, args)

        member _.AvailabilitySetId((name, args), availabilitySetId) =
            let apply (args: VirtualMachineArgs) =
                args.AvailabilitySetId <- io availabilitySetId
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: VirtualMachineArgs) =
                   args.BootDiagnostics <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("deleteDataDisksOnTermination")>]
        member _.DeleteDataDisksOnTermination((name, args), deleteDataDisksOnTermination) =
            let apply (args: VirtualMachineArgs) =
                args.DeleteDataDisksOnTermination <- input deleteDataDisksOnTermination
                args

            ()
            name, List.Cons(apply, args)

        member _.DeleteDataDisksOnTermination((name, args), deleteDataDisksOnTermination) =
            let apply (args: VirtualMachineArgs) =
                args.DeleteDataDisksOnTermination <- io deleteDataDisksOnTermination
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("deleteOsDiskOnTermination")>]
        member _.DeleteOsDiskOnTermination((name, args), deleteOsDiskOnTermination) =
            let apply (args: VirtualMachineArgs) =
                args.DeleteOsDiskOnTermination <- input deleteOsDiskOnTermination
                args

            ()
            name, List.Cons(apply, args)

        member _.DeleteOsDiskOnTermination((name, args), deleteOsDiskOnTermination) =
            let apply (args: VirtualMachineArgs) =
                args.DeleteOsDiskOnTermination <- io deleteOsDiskOnTermination
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: VirtualMachineArgs) =
                   args.Identity <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("licenseType")>]
        member _.LicenseType((name, args), licenseType) =
            let apply (args: VirtualMachineArgs) =
                args.LicenseType <- input licenseType
                args

            ()
            name, List.Cons(apply, args)

        member _.LicenseType((name, args), licenseType) =
            let apply (args: VirtualMachineArgs) =
                args.LicenseType <- io licenseType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: VirtualMachineArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: VirtualMachineArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: VirtualMachineArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: VirtualMachineArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("networkInterfaceIds")>]
        member _.NetworkInterfaceIds((name, args), networkInterfaceIds) =
            let apply (args: VirtualMachineArgs) =
                args.NetworkInterfaceIds <- inputList networkInterfaceIds
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: VirtualMachineArgs) =
                   args.OsProfile <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: VirtualMachineArgs) =
                   args.OsProfileLinuxConfig <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("osProfileSecrets")>]
        member _.OsProfileSecrets((name, args), osProfileSecrets) =
            let apply (args: VirtualMachineArgs) =
                args.OsProfileSecrets <- inputList osProfileSecrets
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: VirtualMachineArgs) =
                   args.OsProfileWindowsConfig <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: VirtualMachineArgs) =
                   args.Plan <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("primaryNetworkInterfaceId")>]
        member _.PrimaryNetworkInterfaceId((name, args), primaryNetworkInterfaceId) =
            let apply (args: VirtualMachineArgs) =
                args.PrimaryNetworkInterfaceId <- input primaryNetworkInterfaceId
                args

            ()
            name, List.Cons(apply, args)

        member _.PrimaryNetworkInterfaceId((name, args), primaryNetworkInterfaceId) =
            let apply (args: VirtualMachineArgs) =
                args.PrimaryNetworkInterfaceId <- io primaryNetworkInterfaceId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("proximityPlacementGroupId")>]
        member _.ProximityPlacementGroupId((name, args), proximityPlacementGroupId) =
            let apply (args: VirtualMachineArgs) =
                args.ProximityPlacementGroupId <- input proximityPlacementGroupId
                args

            ()
            name, List.Cons(apply, args)

        member _.ProximityPlacementGroupId((name, args), proximityPlacementGroupId) =
            let apply (args: VirtualMachineArgs) =
                args.ProximityPlacementGroupId <- io proximityPlacementGroupId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: VirtualMachineArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: VirtualMachineArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageDataDisks")>]
        member _.StorageDataDisks((name, args), storageDataDisks) =
            let apply (args: VirtualMachineArgs) =
                args.StorageDataDisks <- inputList storageDataDisks
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: VirtualMachineArgs) =
                   args.StorageImageReference <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: VirtualMachineArgs) =
                   args.StorageOsDisk <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: VirtualMachineArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("vmSize")>]
        member _.VmSize((name, args), vmSize) =
            let apply (args: VirtualMachineArgs) =
                args.VmSize <- input vmSize
                args

            ()
            name, List.Cons(apply, args)

        member _.VmSize((name, args), vmSize) =
            let apply (args: VirtualMachineArgs) =
                args.VmSize <- io vmSize
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zones")>]
        member _.Zones((name, args), zones) =
            let apply (args: VirtualMachineArgs) =
                args.Zones <- input zones
                args

            ()
            name, List.Cons(apply, args)

        member _.Zones((name, args), zones) =
            let apply (args: VirtualMachineArgs) =
                args.Zones <- io zones
                args

            ()
            name, List.Cons(apply, args)

    let virtualMachine = VirtualMachineBuilder()

    type VirtualMachineScaleSetExtensionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            VirtualMachineScaleSetExtension(name, (List.fold func (VirtualMachineScaleSetExtensionArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("autoUpgradeMinorVersion")>]
        member _.AutoUpgradeMinorVersion((name, args), autoUpgradeMinorVersion) =
            let apply (args: VirtualMachineScaleSetExtensionArgs) =
                args.AutoUpgradeMinorVersion <- input autoUpgradeMinorVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.AutoUpgradeMinorVersion((name, args), autoUpgradeMinorVersion) =
            let apply (args: VirtualMachineScaleSetExtensionArgs) =
                args.AutoUpgradeMinorVersion <- io autoUpgradeMinorVersion
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("forceUpdateTag")>]
        member _.ForceUpdateTag((name, args), forceUpdateTag) =
            let apply (args: VirtualMachineScaleSetExtensionArgs) =
                args.ForceUpdateTag <- input forceUpdateTag
                args

            ()
            name, List.Cons(apply, args)

        member _.ForceUpdateTag((name, args), forceUpdateTag) =
            let apply (args: VirtualMachineScaleSetExtensionArgs) =
                args.ForceUpdateTag <- io forceUpdateTag
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: VirtualMachineScaleSetExtensionArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: VirtualMachineScaleSetExtensionArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("protectedSettings")>]
        member _.ProtectedSettings((name, args), protectedSettings) =
            let apply (args: VirtualMachineScaleSetExtensionArgs) =
                args.ProtectedSettings <- input protectedSettings
                args

            ()
            name, List.Cons(apply, args)

        member _.ProtectedSettings((name, args), protectedSettings) =
            let apply (args: VirtualMachineScaleSetExtensionArgs) =
                args.ProtectedSettings <- io protectedSettings
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("provisionAfterExtensions")>]
        member _.ProvisionAfterExtensions((name, args), provisionAfterExtensions) =
            let apply (args: VirtualMachineScaleSetExtensionArgs) =
                args.ProvisionAfterExtensions <- inputList provisionAfterExtensions
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("publisher")>]
        member _.Publisher((name, args), publisher) =
            let apply (args: VirtualMachineScaleSetExtensionArgs) =
                args.Publisher <- input publisher
                args

            ()
            name, List.Cons(apply, args)

        member _.Publisher((name, args), publisher) =
            let apply (args: VirtualMachineScaleSetExtensionArgs) =
                args.Publisher <- io publisher
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("settings")>]
        member _.Settings((name, args), settings) =
            let apply (args: VirtualMachineScaleSetExtensionArgs) =
                args.Settings <- input settings
                args

            ()
            name, List.Cons(apply, args)

        member _.Settings((name, args), settings) =
            let apply (args: VirtualMachineScaleSetExtensionArgs) =
                args.Settings <- io settings
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((name, args), ``type``) =
            let apply (args: VirtualMachineScaleSetExtensionArgs) =
                args.Type <- input ``type``
                args

            ()
            name, List.Cons(apply, args)

        member _.Type((name, args), ``type``) =
            let apply (args: VirtualMachineScaleSetExtensionArgs) =
                args.Type <- io ``type``
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("typeHandlerVersion")>]
        member _.TypeHandlerVersion((name, args), typeHandlerVersion) =
            let apply (args: VirtualMachineScaleSetExtensionArgs) =
                args.TypeHandlerVersion <- input typeHandlerVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.TypeHandlerVersion((name, args), typeHandlerVersion) =
            let apply (args: VirtualMachineScaleSetExtensionArgs) =
                args.TypeHandlerVersion <- io typeHandlerVersion
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("virtualMachineScaleSetId")>]
        member _.VirtualMachineScaleSetId((name, args), virtualMachineScaleSetId) =
            let apply (args: VirtualMachineScaleSetExtensionArgs) =
                args.VirtualMachineScaleSetId <- input virtualMachineScaleSetId
                args

            ()
            name, List.Cons(apply, args)

        member _.VirtualMachineScaleSetId((name, args), virtualMachineScaleSetId) =
            let apply (args: VirtualMachineScaleSetExtensionArgs) =
                args.VirtualMachineScaleSetId <- io virtualMachineScaleSetId
                args

            ()
            name, List.Cons(apply, args)

    let virtualMachineScaleSetExtension = VirtualMachineScaleSetExtensionBuilder()

    type WindowsVirtualMachineBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            WindowsVirtualMachine(name, (List.fold func (WindowsVirtualMachineArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: WindowsVirtualMachineArgs) =
                   args.AdditionalCapabilities <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("additionalUnattendContents")>]
        member _.AdditionalUnattendContents((name, args), additionalUnattendContents) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.AdditionalUnattendContents <- inputList additionalUnattendContents
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("adminPassword")>]
        member _.AdminPassword((name, args), adminPassword) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.AdminPassword <- input adminPassword
                args

            ()
            name, List.Cons(apply, args)

        member _.AdminPassword((name, args), adminPassword) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.AdminPassword <- io adminPassword
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("adminUsername")>]
        member _.AdminUsername((name, args), adminUsername) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.AdminUsername <- input adminUsername
                args

            ()
            name, List.Cons(apply, args)

        member _.AdminUsername((name, args), adminUsername) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.AdminUsername <- io adminUsername
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("allowExtensionOperations")>]
        member _.AllowExtensionOperations((name, args), allowExtensionOperations) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.AllowExtensionOperations <- input allowExtensionOperations
                args

            ()
            name, List.Cons(apply, args)

        member _.AllowExtensionOperations((name, args), allowExtensionOperations) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.AllowExtensionOperations <- io allowExtensionOperations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("availabilitySetId")>]
        member _.AvailabilitySetId((name, args), availabilitySetId) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.AvailabilitySetId <- input availabilitySetId
                args

            ()
            name, List.Cons(apply, args)

        member _.AvailabilitySetId((name, args), availabilitySetId) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.AvailabilitySetId <- io availabilitySetId
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: WindowsVirtualMachineArgs) =
                   args.BootDiagnostics <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("computerName")>]
        member _.ComputerName((name, args), computerName) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.ComputerName <- input computerName
                args

            ()
            name, List.Cons(apply, args)

        member _.ComputerName((name, args), computerName) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.ComputerName <- io computerName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("customData")>]
        member _.CustomData((name, args), customData) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.CustomData <- input customData
                args

            ()
            name, List.Cons(apply, args)

        member _.CustomData((name, args), customData) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.CustomData <- io customData
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("dedicatedHostId")>]
        member _.DedicatedHostId((name, args), dedicatedHostId) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.DedicatedHostId <- input dedicatedHostId
                args

            ()
            name, List.Cons(apply, args)

        member _.DedicatedHostId((name, args), dedicatedHostId) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.DedicatedHostId <- io dedicatedHostId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enableAutomaticUpdates")>]
        member _.EnableAutomaticUpdates((name, args), enableAutomaticUpdates) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.EnableAutomaticUpdates <- input enableAutomaticUpdates
                args

            ()
            name, List.Cons(apply, args)

        member _.EnableAutomaticUpdates((name, args), enableAutomaticUpdates) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.EnableAutomaticUpdates <- io enableAutomaticUpdates
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("evictionPolicy")>]
        member _.EvictionPolicy((name, args), evictionPolicy) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.EvictionPolicy <- input evictionPolicy
                args

            ()
            name, List.Cons(apply, args)

        member _.EvictionPolicy((name, args), evictionPolicy) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.EvictionPolicy <- io evictionPolicy
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: WindowsVirtualMachineArgs) =
                   args.Identity <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("licenseType")>]
        member _.LicenseType((name, args), licenseType) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.LicenseType <- input licenseType
                args

            ()
            name, List.Cons(apply, args)

        member _.LicenseType((name, args), licenseType) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.LicenseType <- io licenseType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("maxBidPrice")>]
        member _.MaxBidPrice((name, args), maxBidPrice) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.MaxBidPrice <- input maxBidPrice
                args

            ()
            name, List.Cons(apply, args)

        member _.MaxBidPrice((name, args), maxBidPrice) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.MaxBidPrice <- io maxBidPrice
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("networkInterfaceIds")>]
        member _.NetworkInterfaceIds((name, args), networkInterfaceIds) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.NetworkInterfaceIds <- inputList networkInterfaceIds
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: WindowsVirtualMachineArgs) =
                   args.OsDisk <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: WindowsVirtualMachineArgs) =
                   args.Plan <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("priority")>]
        member _.Priority((name, args), priority) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.Priority <- input priority
                args

            ()
            name, List.Cons(apply, args)

        member _.Priority((name, args), priority) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.Priority <- io priority
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("provisionVmAgent")>]
        member _.ProvisionVmAgent((name, args), provisionVmAgent) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.ProvisionVmAgent <- input provisionVmAgent
                args

            ()
            name, List.Cons(apply, args)

        member _.ProvisionVmAgent((name, args), provisionVmAgent) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.ProvisionVmAgent <- io provisionVmAgent
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("proximityPlacementGroupId")>]
        member _.ProximityPlacementGroupId((name, args), proximityPlacementGroupId) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.ProximityPlacementGroupId <- input proximityPlacementGroupId
                args

            ()
            name, List.Cons(apply, args)

        member _.ProximityPlacementGroupId((name, args), proximityPlacementGroupId) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.ProximityPlacementGroupId <- io proximityPlacementGroupId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("secrets")>]
        member _.Secrets((name, args), secrets) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.Secrets <- inputList secrets
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("size")>]
        member _.Size((name, args), size) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.Size <- input size
                args

            ()
            name, List.Cons(apply, args)

        member _.Size((name, args), size) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.Size <- io size
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sourceImageId")>]
        member _.SourceImageId((name, args), sourceImageId) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.SourceImageId <- input sourceImageId
                args

            ()
            name, List.Cons(apply, args)

        member _.SourceImageId((name, args), sourceImageId) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.SourceImageId <- io sourceImageId
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: WindowsVirtualMachineArgs) =
                   args.SourceImageReference <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("timezone")>]
        member _.Timezone((name, args), timezone) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.Timezone <- input timezone
                args

            ()
            name, List.Cons(apply, args)

        member _.Timezone((name, args), timezone) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.Timezone <- io timezone
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("virtualMachineScaleSetId")>]
        member _.VirtualMachineScaleSetId((name, args), virtualMachineScaleSetId) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.VirtualMachineScaleSetId <- input virtualMachineScaleSetId
                args

            ()
            name, List.Cons(apply, args)

        member _.VirtualMachineScaleSetId((name, args), virtualMachineScaleSetId) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.VirtualMachineScaleSetId <- io virtualMachineScaleSetId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("winrmListeners")>]
        member _.WinrmListeners((name, args), winrmListeners) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.WinrmListeners <- inputList winrmListeners
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zone")>]
        member _.Zone((name, args), zone) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.Zone <- input zone
                args

            ()
            name, List.Cons(apply, args)

        member _.Zone((name, args), zone) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.Zone <- io zone
                args

            ()
            name, List.Cons(apply, args)

    let windowsVirtualMachine = WindowsVirtualMachineBuilder()

    type WindowsVirtualMachineScaleSetBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            WindowsVirtualMachineScaleSet(name, (List.fold func (WindowsVirtualMachineScaleSetArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: WindowsVirtualMachineScaleSetArgs) =
                   args.AdditionalCapabilities <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("additionalUnattendContents")>]
        member _.AdditionalUnattendContents((name, args), additionalUnattendContents) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.AdditionalUnattendContents <- inputList additionalUnattendContents
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("adminPassword")>]
        member _.AdminPassword((name, args), adminPassword) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.AdminPassword <- input adminPassword
                args

            ()
            name, List.Cons(apply, args)

        member _.AdminPassword((name, args), adminPassword) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.AdminPassword <- io adminPassword
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("adminUsername")>]
        member _.AdminUsername((name, args), adminUsername) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.AdminUsername <- input adminUsername
                args

            ()
            name, List.Cons(apply, args)

        member _.AdminUsername((name, args), adminUsername) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.AdminUsername <- io adminUsername
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: WindowsVirtualMachineScaleSetArgs) =
                   args.AutomaticInstanceRepair <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: WindowsVirtualMachineScaleSetArgs) =
                   args.AutomaticOsUpgradePolicy <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: WindowsVirtualMachineScaleSetArgs) =
                   args.BootDiagnostics <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("computerNamePrefix")>]
        member _.ComputerNamePrefix((name, args), computerNamePrefix) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.ComputerNamePrefix <- input computerNamePrefix
                args

            ()
            name, List.Cons(apply, args)

        member _.ComputerNamePrefix((name, args), computerNamePrefix) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.ComputerNamePrefix <- io computerNamePrefix
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("customData")>]
        member _.CustomData((name, args), customData) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.CustomData <- input customData
                args

            ()
            name, List.Cons(apply, args)

        member _.CustomData((name, args), customData) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.CustomData <- io customData
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("dataDisks")>]
        member _.DataDisks((name, args), dataDisks) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.DataDisks <- inputList dataDisks
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("doNotRunExtensionsOnOverprovisionedMachines")>]
        member _.DoNotRunExtensionsOnOverprovisionedMachines((name, args), doNotRunExtensionsOnOverprovisionedMachines) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.DoNotRunExtensionsOnOverprovisionedMachines <- input doNotRunExtensionsOnOverprovisionedMachines
                args

            ()
            name, List.Cons(apply, args)

        member _.DoNotRunExtensionsOnOverprovisionedMachines((name, args), doNotRunExtensionsOnOverprovisionedMachines) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.DoNotRunExtensionsOnOverprovisionedMachines <- io doNotRunExtensionsOnOverprovisionedMachines
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enableAutomaticUpdates")>]
        member _.EnableAutomaticUpdates((name, args), enableAutomaticUpdates) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.EnableAutomaticUpdates <- input enableAutomaticUpdates
                args

            ()
            name, List.Cons(apply, args)

        member _.EnableAutomaticUpdates((name, args), enableAutomaticUpdates) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.EnableAutomaticUpdates <- io enableAutomaticUpdates
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("evictionPolicy")>]
        member _.EvictionPolicy((name, args), evictionPolicy) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.EvictionPolicy <- input evictionPolicy
                args

            ()
            name, List.Cons(apply, args)

        member _.EvictionPolicy((name, args), evictionPolicy) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.EvictionPolicy <- io evictionPolicy
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("healthProbeId")>]
        member _.HealthProbeId((name, args), healthProbeId) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.HealthProbeId <- input healthProbeId
                args

            ()
            name, List.Cons(apply, args)

        member _.HealthProbeId((name, args), healthProbeId) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.HealthProbeId <- io healthProbeId
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: WindowsVirtualMachineScaleSetArgs) =
                   args.Identity <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("instances")>]
        member _.Instances((name, args), instances) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.Instances <- input instances
                args

            ()
            name, List.Cons(apply, args)

        member _.Instances((name, args), instances) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.Instances <- io instances
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("licenseType")>]
        member _.LicenseType((name, args), licenseType) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.LicenseType <- input licenseType
                args

            ()
            name, List.Cons(apply, args)

        member _.LicenseType((name, args), licenseType) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.LicenseType <- io licenseType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("maxBidPrice")>]
        member _.MaxBidPrice((name, args), maxBidPrice) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.MaxBidPrice <- input maxBidPrice
                args

            ()
            name, List.Cons(apply, args)

        member _.MaxBidPrice((name, args), maxBidPrice) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.MaxBidPrice <- io maxBidPrice
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("networkInterfaces")>]
        member _.NetworkInterfaces((name, args), networkInterfaces) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.NetworkInterfaces <- inputList networkInterfaces
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: WindowsVirtualMachineScaleSetArgs) =
                   args.OsDisk <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("overprovision")>]
        member _.Overprovision((name, args), overprovision) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.Overprovision <- input overprovision
                args

            ()
            name, List.Cons(apply, args)

        member _.Overprovision((name, args), overprovision) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.Overprovision <- io overprovision
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: WindowsVirtualMachineScaleSetArgs) =
                   args.Plan <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("priority")>]
        member _.Priority((name, args), priority) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.Priority <- input priority
                args

            ()
            name, List.Cons(apply, args)

        member _.Priority((name, args), priority) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.Priority <- io priority
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("provisionVmAgent")>]
        member _.ProvisionVmAgent((name, args), provisionVmAgent) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.ProvisionVmAgent <- input provisionVmAgent
                args

            ()
            name, List.Cons(apply, args)

        member _.ProvisionVmAgent((name, args), provisionVmAgent) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.ProvisionVmAgent <- io provisionVmAgent
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("proximityPlacementGroupId")>]
        member _.ProximityPlacementGroupId((name, args), proximityPlacementGroupId) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.ProximityPlacementGroupId <- input proximityPlacementGroupId
                args

            ()
            name, List.Cons(apply, args)

        member _.ProximityPlacementGroupId((name, args), proximityPlacementGroupId) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.ProximityPlacementGroupId <- io proximityPlacementGroupId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: WindowsVirtualMachineScaleSetArgs) =
                   args.RollingUpgradePolicy <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("scaleInPolicy")>]
        member _.ScaleInPolicy((name, args), scaleInPolicy) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.ScaleInPolicy <- input scaleInPolicy
                args

            ()
            name, List.Cons(apply, args)

        member _.ScaleInPolicy((name, args), scaleInPolicy) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.ScaleInPolicy <- io scaleInPolicy
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("secrets")>]
        member _.Secrets((name, args), secrets) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.Secrets <- inputList secrets
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("singlePlacementGroup")>]
        member _.SinglePlacementGroup((name, args), singlePlacementGroup) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.SinglePlacementGroup <- input singlePlacementGroup
                args

            ()
            name, List.Cons(apply, args)

        member _.SinglePlacementGroup((name, args), singlePlacementGroup) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.SinglePlacementGroup <- io singlePlacementGroup
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sku")>]
        member _.Sku((name, args), sku) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.Sku <- input sku
                args

            ()
            name, List.Cons(apply, args)

        member _.Sku((name, args), sku) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.Sku <- io sku
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sourceImageId")>]
        member _.SourceImageId((name, args), sourceImageId) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.SourceImageId <- input sourceImageId
                args

            ()
            name, List.Cons(apply, args)

        member _.SourceImageId((name, args), sourceImageId) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.SourceImageId <- io sourceImageId
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: WindowsVirtualMachineScaleSetArgs) =
                   args.SourceImageReference <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: WindowsVirtualMachineScaleSetArgs) =
                   args.TerminateNotification <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("timezone")>]
        member _.Timezone((name, args), timezone) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.Timezone <- input timezone
                args

            ()
            name, List.Cons(apply, args)

        member _.Timezone((name, args), timezone) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.Timezone <- io timezone
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("upgradeMode")>]
        member _.UpgradeMode((name, args), upgradeMode) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.UpgradeMode <- input upgradeMode
                args

            ()
            name, List.Cons(apply, args)

        member _.UpgradeMode((name, args), upgradeMode) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.UpgradeMode <- io upgradeMode
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("winrmListeners")>]
        member _.WinrmListeners((name, args), winrmListeners) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.WinrmListeners <- inputList winrmListeners
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zoneBalance")>]
        member _.ZoneBalance((name, args), zoneBalance) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.ZoneBalance <- input zoneBalance
                args

            ()
            name, List.Cons(apply, args)

        member _.ZoneBalance((name, args), zoneBalance) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.ZoneBalance <- io zoneBalance
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zones")>]
        member _.Zones((name, args), zones) =
            let apply (args: WindowsVirtualMachineScaleSetArgs) =
                args.Zones <- inputList zones
                args

            ()
            name, List.Cons(apply, args)

    let windowsVirtualMachineScaleSet = WindowsVirtualMachineScaleSetBuilder()

module ContainerService =
    open Pulumi.Azure.ContainerService
    open Pulumi.Azure.ContainerService.Inputs

    type GroupContainerBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (GroupContainerArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("commands")>]
        member _.Commands((n, args), commands) =
            let apply (args: GroupContainerArgs) =
                args.Commands <- inputList commands
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("cpu")>]
        member _.Cpu((n, args), cpu) =
            let apply (args: GroupContainerArgs) =
                args.Cpu <- input cpu
                args

            ()
            n, List.Cons(apply, args)

        member _.Cpu((n, args), cpu) =
            let apply (args: GroupContainerArgs) =
                args.Cpu <- io cpu
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("environmentVariables")>]
        member _.EnvironmentVariables((n, args), environmentVariables) =
            let apply (args: GroupContainerArgs) =
                args.EnvironmentVariables <- inputMap environmentVariables
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: GroupContainerArgs) =
                   args.Gpu <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("image")>]
        member _.Image((n, args), image) =
            let apply (args: GroupContainerArgs) =
                args.Image <- input image
                args

            ()
            n, List.Cons(apply, args)

        member _.Image((n, args), image) =
            let apply (args: GroupContainerArgs) =
                args.Image <- io image
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: GroupContainerArgs) =
                   args.LivenessProbe <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("memory")>]
        member _.Memory((n, args), memory) =
            let apply (args: GroupContainerArgs) =
                args.Memory <- input memory
                args

            ()
            n, List.Cons(apply, args)

        member _.Memory((n, args), memory) =
            let apply (args: GroupContainerArgs) =
                args.Memory <- io memory
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: GroupContainerArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: GroupContainerArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ports")>]
        member _.Ports((n, args), ports) =
            let apply (args: GroupContainerArgs) =
                args.Ports <- inputList ports
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: GroupContainerArgs) =
                   args.ReadinessProbe <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("secureEnvironmentVariables")>]
        member _.SecureEnvironmentVariables((n, args), secureEnvironmentVariables) =
            let apply (args: GroupContainerArgs) =
                args.SecureEnvironmentVariables <- inputMap secureEnvironmentVariables
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("volumes")>]
        member _.Volumes((n, args), volumes) =
            let apply (args: GroupContainerArgs) =
                args.Volumes <- inputList volumes
                args

            ()
            n, List.Cons(apply, args)

    let groupContainer = GroupContainerBuilder()

    type GroupContainerGpuBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (GroupContainerGpuArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("count")>]
        member _.Count((n, args), count) =
            let apply (args: GroupContainerGpuArgs) =
                args.Count <- input count
                args

            ()
            n, List.Cons(apply, args)

        member _.Count((n, args), count) =
            let apply (args: GroupContainerGpuArgs) =
                args.Count <- io count
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sku")>]
        member _.Sku((n, args), sku) =
            let apply (args: GroupContainerGpuArgs) =
                args.Sku <- input sku
                args

            ()
            n, List.Cons(apply, args)

        member _.Sku((n, args), sku) =
            let apply (args: GroupContainerGpuArgs) =
                args.Sku <- io sku
                args

            ()
            n, List.Cons(apply, args)

    let groupContainerGpu = GroupContainerGpuBuilder()

    type GroupContainerLivenessProbeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (GroupContainerLivenessProbeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("execs")>]
        member _.Execs((n, args), execs) =
            let apply (args: GroupContainerLivenessProbeArgs) =
                args.Execs <- inputList execs
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("failureThreshold")>]
        member _.FailureThreshold((n, args), failureThreshold) =
            let apply (args: GroupContainerLivenessProbeArgs) =
                args.FailureThreshold <- input failureThreshold
                args

            ()
            n, List.Cons(apply, args)

        member _.FailureThreshold((n, args), failureThreshold) =
            let apply (args: GroupContainerLivenessProbeArgs) =
                args.FailureThreshold <- io failureThreshold
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("httpGets")>]
        member _.HttpGets((n, args), httpGets) =
            let apply (args: GroupContainerLivenessProbeArgs) =
                args.HttpGets <- inputList httpGets
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("initialDelaySeconds")>]
        member _.InitialDelaySeconds((n, args), initialDelaySeconds) =
            let apply (args: GroupContainerLivenessProbeArgs) =
                args.InitialDelaySeconds <- input initialDelaySeconds
                args

            ()
            n, List.Cons(apply, args)

        member _.InitialDelaySeconds((n, args), initialDelaySeconds) =
            let apply (args: GroupContainerLivenessProbeArgs) =
                args.InitialDelaySeconds <- io initialDelaySeconds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("periodSeconds")>]
        member _.PeriodSeconds((n, args), periodSeconds) =
            let apply (args: GroupContainerLivenessProbeArgs) =
                args.PeriodSeconds <- input periodSeconds
                args

            ()
            n, List.Cons(apply, args)

        member _.PeriodSeconds((n, args), periodSeconds) =
            let apply (args: GroupContainerLivenessProbeArgs) =
                args.PeriodSeconds <- io periodSeconds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("successThreshold")>]
        member _.SuccessThreshold((n, args), successThreshold) =
            let apply (args: GroupContainerLivenessProbeArgs) =
                args.SuccessThreshold <- input successThreshold
                args

            ()
            n, List.Cons(apply, args)

        member _.SuccessThreshold((n, args), successThreshold) =
            let apply (args: GroupContainerLivenessProbeArgs) =
                args.SuccessThreshold <- io successThreshold
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("timeoutSeconds")>]
        member _.TimeoutSeconds((n, args), timeoutSeconds) =
            let apply (args: GroupContainerLivenessProbeArgs) =
                args.TimeoutSeconds <- input timeoutSeconds
                args

            ()
            n, List.Cons(apply, args)

        member _.TimeoutSeconds((n, args), timeoutSeconds) =
            let apply (args: GroupContainerLivenessProbeArgs) =
                args.TimeoutSeconds <- io timeoutSeconds
                args

            ()
            n, List.Cons(apply, args)

    let groupContainerLivenessProbe = GroupContainerLivenessProbeBuilder()

    type GroupContainerLivenessProbeHttpGetBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (GroupContainerLivenessProbeHttpGetArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("path")>]
        member _.Path((n, args), path) =
            let apply (args: GroupContainerLivenessProbeHttpGetArgs) =
                args.Path <- input path
                args

            ()
            n, List.Cons(apply, args)

        member _.Path((n, args), path) =
            let apply (args: GroupContainerLivenessProbeHttpGetArgs) =
                args.Path <- io path
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("port")>]
        member _.Port((n, args), port) =
            let apply (args: GroupContainerLivenessProbeHttpGetArgs) =
                args.Port <- input port
                args

            ()
            n, List.Cons(apply, args)

        member _.Port((n, args), port) =
            let apply (args: GroupContainerLivenessProbeHttpGetArgs) =
                args.Port <- io port
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("scheme")>]
        member _.Scheme((n, args), scheme) =
            let apply (args: GroupContainerLivenessProbeHttpGetArgs) =
                args.Scheme <- input scheme
                args

            ()
            n, List.Cons(apply, args)

        member _.Scheme((n, args), scheme) =
            let apply (args: GroupContainerLivenessProbeHttpGetArgs) =
                args.Scheme <- io scheme
                args

            ()
            n, List.Cons(apply, args)

    let groupContainerLivenessProbeHttpGet =
        GroupContainerLivenessProbeHttpGetBuilder()

    type GroupContainerPortBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (GroupContainerPortArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("port")>]
        member _.Port((n, args), port) =
            let apply (args: GroupContainerPortArgs) =
                args.Port <- input port
                args

            ()
            n, List.Cons(apply, args)

        member _.Port((n, args), port) =
            let apply (args: GroupContainerPortArgs) =
                args.Port <- io port
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("protocol")>]
        member _.Protocol((n, args), protocol) =
            let apply (args: GroupContainerPortArgs) =
                args.Protocol <- input protocol
                args

            ()
            n, List.Cons(apply, args)

        member _.Protocol((n, args), protocol) =
            let apply (args: GroupContainerPortArgs) =
                args.Protocol <- io protocol
                args

            ()
            n, List.Cons(apply, args)

    let groupContainerPort = GroupContainerPortBuilder()

    type GroupContainerReadinessProbeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (GroupContainerReadinessProbeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("execs")>]
        member _.Execs((n, args), execs) =
            let apply (args: GroupContainerReadinessProbeArgs) =
                args.Execs <- inputList execs
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("failureThreshold")>]
        member _.FailureThreshold((n, args), failureThreshold) =
            let apply (args: GroupContainerReadinessProbeArgs) =
                args.FailureThreshold <- input failureThreshold
                args

            ()
            n, List.Cons(apply, args)

        member _.FailureThreshold((n, args), failureThreshold) =
            let apply (args: GroupContainerReadinessProbeArgs) =
                args.FailureThreshold <- io failureThreshold
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("httpGets")>]
        member _.HttpGets((n, args), httpGets) =
            let apply (args: GroupContainerReadinessProbeArgs) =
                args.HttpGets <- inputList httpGets
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("initialDelaySeconds")>]
        member _.InitialDelaySeconds((n, args), initialDelaySeconds) =
            let apply (args: GroupContainerReadinessProbeArgs) =
                args.InitialDelaySeconds <- input initialDelaySeconds
                args

            ()
            n, List.Cons(apply, args)

        member _.InitialDelaySeconds((n, args), initialDelaySeconds) =
            let apply (args: GroupContainerReadinessProbeArgs) =
                args.InitialDelaySeconds <- io initialDelaySeconds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("periodSeconds")>]
        member _.PeriodSeconds((n, args), periodSeconds) =
            let apply (args: GroupContainerReadinessProbeArgs) =
                args.PeriodSeconds <- input periodSeconds
                args

            ()
            n, List.Cons(apply, args)

        member _.PeriodSeconds((n, args), periodSeconds) =
            let apply (args: GroupContainerReadinessProbeArgs) =
                args.PeriodSeconds <- io periodSeconds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("successThreshold")>]
        member _.SuccessThreshold((n, args), successThreshold) =
            let apply (args: GroupContainerReadinessProbeArgs) =
                args.SuccessThreshold <- input successThreshold
                args

            ()
            n, List.Cons(apply, args)

        member _.SuccessThreshold((n, args), successThreshold) =
            let apply (args: GroupContainerReadinessProbeArgs) =
                args.SuccessThreshold <- io successThreshold
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("timeoutSeconds")>]
        member _.TimeoutSeconds((n, args), timeoutSeconds) =
            let apply (args: GroupContainerReadinessProbeArgs) =
                args.TimeoutSeconds <- input timeoutSeconds
                args

            ()
            n, List.Cons(apply, args)

        member _.TimeoutSeconds((n, args), timeoutSeconds) =
            let apply (args: GroupContainerReadinessProbeArgs) =
                args.TimeoutSeconds <- io timeoutSeconds
                args

            ()
            n, List.Cons(apply, args)

    let groupContainerReadinessProbe = GroupContainerReadinessProbeBuilder()

    type GroupContainerReadinessProbeHttpGetBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (GroupContainerReadinessProbeHttpGetArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("path")>]
        member _.Path((n, args), path) =
            let apply (args: GroupContainerReadinessProbeHttpGetArgs) =
                args.Path <- input path
                args

            ()
            n, List.Cons(apply, args)

        member _.Path((n, args), path) =
            let apply (args: GroupContainerReadinessProbeHttpGetArgs) =
                args.Path <- io path
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("port")>]
        member _.Port((n, args), port) =
            let apply (args: GroupContainerReadinessProbeHttpGetArgs) =
                args.Port <- input port
                args

            ()
            n, List.Cons(apply, args)

        member _.Port((n, args), port) =
            let apply (args: GroupContainerReadinessProbeHttpGetArgs) =
                args.Port <- io port
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("scheme")>]
        member _.Scheme((n, args), scheme) =
            let apply (args: GroupContainerReadinessProbeHttpGetArgs) =
                args.Scheme <- input scheme
                args

            ()
            n, List.Cons(apply, args)

        member _.Scheme((n, args), scheme) =
            let apply (args: GroupContainerReadinessProbeHttpGetArgs) =
                args.Scheme <- io scheme
                args

            ()
            n, List.Cons(apply, args)

    let groupContainerReadinessProbeHttpGet =
        GroupContainerReadinessProbeHttpGetBuilder()

    type GroupContainerVolumeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (GroupContainerVolumeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("mountPath")>]
        member _.MountPath((n, args), mountPath) =
            let apply (args: GroupContainerVolumeArgs) =
                args.MountPath <- input mountPath
                args

            ()
            n, List.Cons(apply, args)

        member _.MountPath((n, args), mountPath) =
            let apply (args: GroupContainerVolumeArgs) =
                args.MountPath <- io mountPath
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: GroupContainerVolumeArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: GroupContainerVolumeArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("readOnly")>]
        member _.ReadOnly((n, args), readOnly) =
            let apply (args: GroupContainerVolumeArgs) =
                args.ReadOnly <- input readOnly
                args

            ()
            n, List.Cons(apply, args)

        member _.ReadOnly((n, args), readOnly) =
            let apply (args: GroupContainerVolumeArgs) =
                args.ReadOnly <- io readOnly
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("shareName")>]
        member _.ShareName((n, args), shareName) =
            let apply (args: GroupContainerVolumeArgs) =
                args.ShareName <- input shareName
                args

            ()
            n, List.Cons(apply, args)

        member _.ShareName((n, args), shareName) =
            let apply (args: GroupContainerVolumeArgs) =
                args.ShareName <- io shareName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageAccountKey")>]
        member _.StorageAccountKey((n, args), storageAccountKey) =
            let apply (args: GroupContainerVolumeArgs) =
                args.StorageAccountKey <- input storageAccountKey
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountKey((n, args), storageAccountKey) =
            let apply (args: GroupContainerVolumeArgs) =
                args.StorageAccountKey <- io storageAccountKey
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageAccountName")>]
        member _.StorageAccountName((n, args), storageAccountName) =
            let apply (args: GroupContainerVolumeArgs) =
                args.StorageAccountName <- input storageAccountName
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountName((n, args), storageAccountName) =
            let apply (args: GroupContainerVolumeArgs) =
                args.StorageAccountName <- io storageAccountName
                args

            ()
            n, List.Cons(apply, args)

    let groupContainerVolume = GroupContainerVolumeBuilder()

    type GroupDiagnosticsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (GroupDiagnosticsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: GroupDiagnosticsArgs) =
                   args.LogAnalytics <- input arg
                   args

               ()
               func) ]

    let groupDiagnostics = GroupDiagnosticsBuilder()

    type GroupDiagnosticsLogAnalyticsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (GroupDiagnosticsLogAnalyticsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("logType")>]
        member _.LogType((n, args), logType) =
            let apply (args: GroupDiagnosticsLogAnalyticsArgs) =
                args.LogType <- input logType
                args

            ()
            n, List.Cons(apply, args)

        member _.LogType((n, args), logType) =
            let apply (args: GroupDiagnosticsLogAnalyticsArgs) =
                args.LogType <- io logType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("metadata")>]
        member _.Metadata((n, args), metadata) =
            let apply (args: GroupDiagnosticsLogAnalyticsArgs) =
                args.Metadata <- inputMap metadata
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("workspaceId")>]
        member _.WorkspaceId((n, args), workspaceId) =
            let apply (args: GroupDiagnosticsLogAnalyticsArgs) =
                args.WorkspaceId <- input workspaceId
                args

            ()
            n, List.Cons(apply, args)

        member _.WorkspaceId((n, args), workspaceId) =
            let apply (args: GroupDiagnosticsLogAnalyticsArgs) =
                args.WorkspaceId <- io workspaceId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("workspaceKey")>]
        member _.WorkspaceKey((n, args), workspaceKey) =
            let apply (args: GroupDiagnosticsLogAnalyticsArgs) =
                args.WorkspaceKey <- input workspaceKey
                args

            ()
            n, List.Cons(apply, args)

        member _.WorkspaceKey((n, args), workspaceKey) =
            let apply (args: GroupDiagnosticsLogAnalyticsArgs) =
                args.WorkspaceKey <- io workspaceKey
                args

            ()
            n, List.Cons(apply, args)

    let groupDiagnosticsLogAnalytics = GroupDiagnosticsLogAnalyticsBuilder()

    type GroupIdentityBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (GroupIdentityArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("identityIds")>]
        member _.IdentityIds((n, args), identityIds) =
            let apply (args: GroupIdentityArgs) =
                args.IdentityIds <- inputList identityIds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("principalId")>]
        member _.PrincipalId((n, args), principalId) =
            let apply (args: GroupIdentityArgs) =
                args.PrincipalId <- input principalId
                args

            ()
            n, List.Cons(apply, args)

        member _.PrincipalId((n, args), principalId) =
            let apply (args: GroupIdentityArgs) =
                args.PrincipalId <- io principalId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: GroupIdentityArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: GroupIdentityArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let groupIdentity = GroupIdentityBuilder()

    type GroupImageRegistryCredentialBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (GroupImageRegistryCredentialArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: GroupImageRegistryCredentialArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: GroupImageRegistryCredentialArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("server")>]
        member _.Server((n, args), server) =
            let apply (args: GroupImageRegistryCredentialArgs) =
                args.Server <- input server
                args

            ()
            n, List.Cons(apply, args)

        member _.Server((n, args), server) =
            let apply (args: GroupImageRegistryCredentialArgs) =
                args.Server <- io server
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: GroupImageRegistryCredentialArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: GroupImageRegistryCredentialArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

    let groupImageRegistryCredential = GroupImageRegistryCredentialBuilder()

    type KubernetesClusterAddonProfileBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (KubernetesClusterAddonProfileArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: KubernetesClusterAddonProfileArgs) =
                   args.AciConnectorLinux <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: KubernetesClusterAddonProfileArgs) =
                   args.AzurePolicy <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: KubernetesClusterAddonProfileArgs) =
                   args.HttpApplicationRouting <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: KubernetesClusterAddonProfileArgs) =
                   args.KubeDashboard <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: KubernetesClusterAddonProfileArgs) =
                   args.OmsAgent <- input arg
                   args

               ()
               func) ]

    let kubernetesClusterAddonProfile = KubernetesClusterAddonProfileBuilder()

    type KubernetesClusterAddonProfileAciConnectorLinuxBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (KubernetesClusterAddonProfileAciConnectorLinuxArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: KubernetesClusterAddonProfileAciConnectorLinuxArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: KubernetesClusterAddonProfileAciConnectorLinuxArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetName")>]
        member _.SubnetName((n, args), subnetName) =
            let apply (args: KubernetesClusterAddonProfileAciConnectorLinuxArgs) =
                args.SubnetName <- input subnetName
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetName((n, args), subnetName) =
            let apply (args: KubernetesClusterAddonProfileAciConnectorLinuxArgs) =
                args.SubnetName <- io subnetName
                args

            ()
            n, List.Cons(apply, args)

    let kubernetesClusterAddonProfileAciConnectorLinux =
        KubernetesClusterAddonProfileAciConnectorLinuxBuilder()

    type KubernetesClusterAddonProfileAzurePolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (KubernetesClusterAddonProfileAzurePolicyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: KubernetesClusterAddonProfileAzurePolicyArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: KubernetesClusterAddonProfileAzurePolicyArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

    let kubernetesClusterAddonProfileAzurePolicy =
        KubernetesClusterAddonProfileAzurePolicyBuilder()

    type KubernetesClusterAddonProfileHttpApplicationRoutingBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (KubernetesClusterAddonProfileHttpApplicationRoutingArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: KubernetesClusterAddonProfileHttpApplicationRoutingArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: KubernetesClusterAddonProfileHttpApplicationRoutingArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("httpApplicationRoutingZoneName")>]
        member _.HttpApplicationRoutingZoneName((n, args), httpApplicationRoutingZoneName) =
            let apply (args: KubernetesClusterAddonProfileHttpApplicationRoutingArgs) =
                args.HttpApplicationRoutingZoneName <- input httpApplicationRoutingZoneName
                args

            ()
            n, List.Cons(apply, args)

        member _.HttpApplicationRoutingZoneName((n, args), httpApplicationRoutingZoneName) =
            let apply (args: KubernetesClusterAddonProfileHttpApplicationRoutingArgs) =
                args.HttpApplicationRoutingZoneName <- io httpApplicationRoutingZoneName
                args

            ()
            n, List.Cons(apply, args)

    let kubernetesClusterAddonProfileHttpApplicationRouting =
        KubernetesClusterAddonProfileHttpApplicationRoutingBuilder()

    type KubernetesClusterAddonProfileKubeDashboardBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (KubernetesClusterAddonProfileKubeDashboardArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: KubernetesClusterAddonProfileKubeDashboardArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: KubernetesClusterAddonProfileKubeDashboardArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

    let kubernetesClusterAddonProfileKubeDashboard =
        KubernetesClusterAddonProfileKubeDashboardBuilder()

    type KubernetesClusterAddonProfileOmsAgentBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (KubernetesClusterAddonProfileOmsAgentArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: KubernetesClusterAddonProfileOmsAgentArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: KubernetesClusterAddonProfileOmsAgentArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("logAnalyticsWorkspaceId")>]
        member _.LogAnalyticsWorkspaceId((n, args), logAnalyticsWorkspaceId) =
            let apply (args: KubernetesClusterAddonProfileOmsAgentArgs) =
                args.LogAnalyticsWorkspaceId <- input logAnalyticsWorkspaceId
                args

            ()
            n, List.Cons(apply, args)

        member _.LogAnalyticsWorkspaceId((n, args), logAnalyticsWorkspaceId) =
            let apply (args: KubernetesClusterAddonProfileOmsAgentArgs) =
                args.LogAnalyticsWorkspaceId <- io logAnalyticsWorkspaceId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("omsAgentIdentities")>]
        member _.OmsAgentIdentities((n, args), omsAgentIdentities) =
            let apply (args: KubernetesClusterAddonProfileOmsAgentArgs) =
                args.OmsAgentIdentities <- inputList omsAgentIdentities
                args

            ()
            n, List.Cons(apply, args)

    let kubernetesClusterAddonProfileOmsAgent =
        KubernetesClusterAddonProfileOmsAgentBuilder()

    type KubernetesClusterAddonProfileOmsAgentOmsAgentIdentityBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (KubernetesClusterAddonProfileOmsAgentOmsAgentIdentityArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("clientId")>]
        member _.ClientId((n, args), clientId) =
            let apply (args: KubernetesClusterAddonProfileOmsAgentOmsAgentIdentityArgs) =
                args.ClientId <- input clientId
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientId((n, args), clientId) =
            let apply (args: KubernetesClusterAddonProfileOmsAgentOmsAgentIdentityArgs) =
                args.ClientId <- io clientId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("objectId")>]
        member _.ObjectId((n, args), objectId) =
            let apply (args: KubernetesClusterAddonProfileOmsAgentOmsAgentIdentityArgs) =
                args.ObjectId <- input objectId
                args

            ()
            n, List.Cons(apply, args)

        member _.ObjectId((n, args), objectId) =
            let apply (args: KubernetesClusterAddonProfileOmsAgentOmsAgentIdentityArgs) =
                args.ObjectId <- io objectId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("userAssignedIdentityId")>]
        member _.UserAssignedIdentityId((n, args), userAssignedIdentityId) =
            let apply (args: KubernetesClusterAddonProfileOmsAgentOmsAgentIdentityArgs) =
                args.UserAssignedIdentityId <- input userAssignedIdentityId
                args

            ()
            n, List.Cons(apply, args)

        member _.UserAssignedIdentityId((n, args), userAssignedIdentityId) =
            let apply (args: KubernetesClusterAddonProfileOmsAgentOmsAgentIdentityArgs) =
                args.UserAssignedIdentityId <- io userAssignedIdentityId
                args

            ()
            n, List.Cons(apply, args)

    let kubernetesClusterAddonProfileOmsAgentOmsAgentIdentity =
        KubernetesClusterAddonProfileOmsAgentOmsAgentIdentityBuilder()

    type KubernetesClusterAutoScalerProfileBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (KubernetesClusterAutoScalerProfileArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("balanceSimilarNodeGroups")>]
        member _.BalanceSimilarNodeGroups((n, args), balanceSimilarNodeGroups) =
            let apply (args: KubernetesClusterAutoScalerProfileArgs) =
                args.BalanceSimilarNodeGroups <- input balanceSimilarNodeGroups
                args

            ()
            n, List.Cons(apply, args)

        member _.BalanceSimilarNodeGroups((n, args), balanceSimilarNodeGroups) =
            let apply (args: KubernetesClusterAutoScalerProfileArgs) =
                args.BalanceSimilarNodeGroups <- io balanceSimilarNodeGroups
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("maxGracefulTerminationSec")>]
        member _.MaxGracefulTerminationSec((n, args), maxGracefulTerminationSec) =
            let apply (args: KubernetesClusterAutoScalerProfileArgs) =
                args.MaxGracefulTerminationSec <- input maxGracefulTerminationSec
                args

            ()
            n, List.Cons(apply, args)

        member _.MaxGracefulTerminationSec((n, args), maxGracefulTerminationSec) =
            let apply (args: KubernetesClusterAutoScalerProfileArgs) =
                args.MaxGracefulTerminationSec <- io maxGracefulTerminationSec
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("scaleDownDelayAfterAdd")>]
        member _.ScaleDownDelayAfterAdd((n, args), scaleDownDelayAfterAdd) =
            let apply (args: KubernetesClusterAutoScalerProfileArgs) =
                args.ScaleDownDelayAfterAdd <- input scaleDownDelayAfterAdd
                args

            ()
            n, List.Cons(apply, args)

        member _.ScaleDownDelayAfterAdd((n, args), scaleDownDelayAfterAdd) =
            let apply (args: KubernetesClusterAutoScalerProfileArgs) =
                args.ScaleDownDelayAfterAdd <- io scaleDownDelayAfterAdd
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("scaleDownDelayAfterDelete")>]
        member _.ScaleDownDelayAfterDelete((n, args), scaleDownDelayAfterDelete) =
            let apply (args: KubernetesClusterAutoScalerProfileArgs) =
                args.ScaleDownDelayAfterDelete <- input scaleDownDelayAfterDelete
                args

            ()
            n, List.Cons(apply, args)

        member _.ScaleDownDelayAfterDelete((n, args), scaleDownDelayAfterDelete) =
            let apply (args: KubernetesClusterAutoScalerProfileArgs) =
                args.ScaleDownDelayAfterDelete <- io scaleDownDelayAfterDelete
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("scaleDownDelayAfterFailure")>]
        member _.ScaleDownDelayAfterFailure((n, args), scaleDownDelayAfterFailure) =
            let apply (args: KubernetesClusterAutoScalerProfileArgs) =
                args.ScaleDownDelayAfterFailure <- input scaleDownDelayAfterFailure
                args

            ()
            n, List.Cons(apply, args)

        member _.ScaleDownDelayAfterFailure((n, args), scaleDownDelayAfterFailure) =
            let apply (args: KubernetesClusterAutoScalerProfileArgs) =
                args.ScaleDownDelayAfterFailure <- io scaleDownDelayAfterFailure
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("scaleDownUnneeded")>]
        member _.ScaleDownUnneeded((n, args), scaleDownUnneeded) =
            let apply (args: KubernetesClusterAutoScalerProfileArgs) =
                args.ScaleDownUnneeded <- input scaleDownUnneeded
                args

            ()
            n, List.Cons(apply, args)

        member _.ScaleDownUnneeded((n, args), scaleDownUnneeded) =
            let apply (args: KubernetesClusterAutoScalerProfileArgs) =
                args.ScaleDownUnneeded <- io scaleDownUnneeded
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("scaleDownUnready")>]
        member _.ScaleDownUnready((n, args), scaleDownUnready) =
            let apply (args: KubernetesClusterAutoScalerProfileArgs) =
                args.ScaleDownUnready <- input scaleDownUnready
                args

            ()
            n, List.Cons(apply, args)

        member _.ScaleDownUnready((n, args), scaleDownUnready) =
            let apply (args: KubernetesClusterAutoScalerProfileArgs) =
                args.ScaleDownUnready <- io scaleDownUnready
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("scaleDownUtilizationThreshold")>]
        member _.ScaleDownUtilizationThreshold((n, args), scaleDownUtilizationThreshold) =
            let apply (args: KubernetesClusterAutoScalerProfileArgs) =
                args.ScaleDownUtilizationThreshold <- input scaleDownUtilizationThreshold
                args

            ()
            n, List.Cons(apply, args)

        member _.ScaleDownUtilizationThreshold((n, args), scaleDownUtilizationThreshold) =
            let apply (args: KubernetesClusterAutoScalerProfileArgs) =
                args.ScaleDownUtilizationThreshold <- io scaleDownUtilizationThreshold
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("scanInterval")>]
        member _.ScanInterval((n, args), scanInterval) =
            let apply (args: KubernetesClusterAutoScalerProfileArgs) =
                args.ScanInterval <- input scanInterval
                args

            ()
            n, List.Cons(apply, args)

        member _.ScanInterval((n, args), scanInterval) =
            let apply (args: KubernetesClusterAutoScalerProfileArgs) =
                args.ScanInterval <- io scanInterval
                args

            ()
            n, List.Cons(apply, args)

    let kubernetesClusterAutoScalerProfile =
        KubernetesClusterAutoScalerProfileBuilder()

    type KubernetesClusterDefaultNodePoolBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (KubernetesClusterDefaultNodePoolArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("availabilityZones")>]
        member _.AvailabilityZones((n, args), availabilityZones) =
            let apply (args: KubernetesClusterDefaultNodePoolArgs) =
                args.AvailabilityZones <- inputList availabilityZones
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enableAutoScaling")>]
        member _.EnableAutoScaling((n, args), enableAutoScaling) =
            let apply (args: KubernetesClusterDefaultNodePoolArgs) =
                args.EnableAutoScaling <- input enableAutoScaling
                args

            ()
            n, List.Cons(apply, args)

        member _.EnableAutoScaling((n, args), enableAutoScaling) =
            let apply (args: KubernetesClusterDefaultNodePoolArgs) =
                args.EnableAutoScaling <- io enableAutoScaling
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enableNodePublicIp")>]
        member _.EnableNodePublicIp((n, args), enableNodePublicIp) =
            let apply (args: KubernetesClusterDefaultNodePoolArgs) =
                args.EnableNodePublicIp <- input enableNodePublicIp
                args

            ()
            n, List.Cons(apply, args)

        member _.EnableNodePublicIp((n, args), enableNodePublicIp) =
            let apply (args: KubernetesClusterDefaultNodePoolArgs) =
                args.EnableNodePublicIp <- io enableNodePublicIp
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("maxCount")>]
        member _.MaxCount((n, args), maxCount) =
            let apply (args: KubernetesClusterDefaultNodePoolArgs) =
                args.MaxCount <- input maxCount
                args

            ()
            n, List.Cons(apply, args)

        member _.MaxCount((n, args), maxCount) =
            let apply (args: KubernetesClusterDefaultNodePoolArgs) =
                args.MaxCount <- io maxCount
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("maxPods")>]
        member _.MaxPods((n, args), maxPods) =
            let apply (args: KubernetesClusterDefaultNodePoolArgs) =
                args.MaxPods <- input maxPods
                args

            ()
            n, List.Cons(apply, args)

        member _.MaxPods((n, args), maxPods) =
            let apply (args: KubernetesClusterDefaultNodePoolArgs) =
                args.MaxPods <- io maxPods
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("minCount")>]
        member _.MinCount((n, args), minCount) =
            let apply (args: KubernetesClusterDefaultNodePoolArgs) =
                args.MinCount <- input minCount
                args

            ()
            n, List.Cons(apply, args)

        member _.MinCount((n, args), minCount) =
            let apply (args: KubernetesClusterDefaultNodePoolArgs) =
                args.MinCount <- io minCount
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: KubernetesClusterDefaultNodePoolArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: KubernetesClusterDefaultNodePoolArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("nodeCount")>]
        member _.NodeCount((n, args), nodeCount) =
            let apply (args: KubernetesClusterDefaultNodePoolArgs) =
                args.NodeCount <- input nodeCount
                args

            ()
            n, List.Cons(apply, args)

        member _.NodeCount((n, args), nodeCount) =
            let apply (args: KubernetesClusterDefaultNodePoolArgs) =
                args.NodeCount <- io nodeCount
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("nodeLabels")>]
        member _.NodeLabels((n, args), nodeLabels) =
            let apply (args: KubernetesClusterDefaultNodePoolArgs) =
                args.NodeLabels <- inputMap nodeLabels
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("nodeTaints")>]
        member _.NodeTaints((n, args), nodeTaints) =
            let apply (args: KubernetesClusterDefaultNodePoolArgs) =
                args.NodeTaints <- inputList nodeTaints
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("orchestratorVersion")>]
        member _.OrchestratorVersion((n, args), orchestratorVersion) =
            let apply (args: KubernetesClusterDefaultNodePoolArgs) =
                args.OrchestratorVersion <- input orchestratorVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.OrchestratorVersion((n, args), orchestratorVersion) =
            let apply (args: KubernetesClusterDefaultNodePoolArgs) =
                args.OrchestratorVersion <- io orchestratorVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("osDiskSizeGb")>]
        member _.OsDiskSizeGb((n, args), osDiskSizeGb) =
            let apply (args: KubernetesClusterDefaultNodePoolArgs) =
                args.OsDiskSizeGb <- input osDiskSizeGb
                args

            ()
            n, List.Cons(apply, args)

        member _.OsDiskSizeGb((n, args), osDiskSizeGb) =
            let apply (args: KubernetesClusterDefaultNodePoolArgs) =
                args.OsDiskSizeGb <- io osDiskSizeGb
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((n, args), tags) =
            let apply (args: KubernetesClusterDefaultNodePoolArgs) =
                args.Tags <- inputMap tags
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: KubernetesClusterDefaultNodePoolArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: KubernetesClusterDefaultNodePoolArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vmSize")>]
        member _.VmSize((n, args), vmSize) =
            let apply (args: KubernetesClusterDefaultNodePoolArgs) =
                args.VmSize <- input vmSize
                args

            ()
            n, List.Cons(apply, args)

        member _.VmSize((n, args), vmSize) =
            let apply (args: KubernetesClusterDefaultNodePoolArgs) =
                args.VmSize <- io vmSize
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vnetSubnetId")>]
        member _.VnetSubnetId((n, args), vnetSubnetId) =
            let apply (args: KubernetesClusterDefaultNodePoolArgs) =
                args.VnetSubnetId <- input vnetSubnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.VnetSubnetId((n, args), vnetSubnetId) =
            let apply (args: KubernetesClusterDefaultNodePoolArgs) =
                args.VnetSubnetId <- io vnetSubnetId
                args

            ()
            n, List.Cons(apply, args)

    let kubernetesClusterDefaultNodePool =
        KubernetesClusterDefaultNodePoolBuilder()

    type KubernetesClusterIdentityBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (KubernetesClusterIdentityArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("principalId")>]
        member _.PrincipalId((n, args), principalId) =
            let apply (args: KubernetesClusterIdentityArgs) =
                args.PrincipalId <- input principalId
                args

            ()
            n, List.Cons(apply, args)

        member _.PrincipalId((n, args), principalId) =
            let apply (args: KubernetesClusterIdentityArgs) =
                args.PrincipalId <- io principalId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tenantId")>]
        member _.TenantId((n, args), tenantId) =
            let apply (args: KubernetesClusterIdentityArgs) =
                args.TenantId <- input tenantId
                args

            ()
            n, List.Cons(apply, args)

        member _.TenantId((n, args), tenantId) =
            let apply (args: KubernetesClusterIdentityArgs) =
                args.TenantId <- io tenantId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: KubernetesClusterIdentityArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: KubernetesClusterIdentityArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let kubernetesClusterIdentity = KubernetesClusterIdentityBuilder()

    type KubernetesClusterKubeAdminConfigBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (KubernetesClusterKubeAdminConfigArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("clientCertificate")>]
        member _.ClientCertificate((n, args), clientCertificate) =
            let apply (args: KubernetesClusterKubeAdminConfigArgs) =
                args.ClientCertificate <- input clientCertificate
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientCertificate((n, args), clientCertificate) =
            let apply (args: KubernetesClusterKubeAdminConfigArgs) =
                args.ClientCertificate <- io clientCertificate
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("clientKey")>]
        member _.ClientKey((n, args), clientKey) =
            let apply (args: KubernetesClusterKubeAdminConfigArgs) =
                args.ClientKey <- input clientKey
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientKey((n, args), clientKey) =
            let apply (args: KubernetesClusterKubeAdminConfigArgs) =
                args.ClientKey <- io clientKey
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("clusterCaCertificate")>]
        member _.ClusterCaCertificate((n, args), clusterCaCertificate) =
            let apply (args: KubernetesClusterKubeAdminConfigArgs) =
                args.ClusterCaCertificate <- input clusterCaCertificate
                args

            ()
            n, List.Cons(apply, args)

        member _.ClusterCaCertificate((n, args), clusterCaCertificate) =
            let apply (args: KubernetesClusterKubeAdminConfigArgs) =
                args.ClusterCaCertificate <- io clusterCaCertificate
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("host")>]
        member _.Host((n, args), host) =
            let apply (args: KubernetesClusterKubeAdminConfigArgs) =
                args.Host <- input host
                args

            ()
            n, List.Cons(apply, args)

        member _.Host((n, args), host) =
            let apply (args: KubernetesClusterKubeAdminConfigArgs) =
                args.Host <- io host
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: KubernetesClusterKubeAdminConfigArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: KubernetesClusterKubeAdminConfigArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: KubernetesClusterKubeAdminConfigArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: KubernetesClusterKubeAdminConfigArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

    let kubernetesClusterKubeAdminConfig =
        KubernetesClusterKubeAdminConfigBuilder()

    type KubernetesClusterKubeConfigBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (KubernetesClusterKubeConfigArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("clientCertificate")>]
        member _.ClientCertificate((n, args), clientCertificate) =
            let apply (args: KubernetesClusterKubeConfigArgs) =
                args.ClientCertificate <- input clientCertificate
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientCertificate((n, args), clientCertificate) =
            let apply (args: KubernetesClusterKubeConfigArgs) =
                args.ClientCertificate <- io clientCertificate
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("clientKey")>]
        member _.ClientKey((n, args), clientKey) =
            let apply (args: KubernetesClusterKubeConfigArgs) =
                args.ClientKey <- input clientKey
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientKey((n, args), clientKey) =
            let apply (args: KubernetesClusterKubeConfigArgs) =
                args.ClientKey <- io clientKey
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("clusterCaCertificate")>]
        member _.ClusterCaCertificate((n, args), clusterCaCertificate) =
            let apply (args: KubernetesClusterKubeConfigArgs) =
                args.ClusterCaCertificate <- input clusterCaCertificate
                args

            ()
            n, List.Cons(apply, args)

        member _.ClusterCaCertificate((n, args), clusterCaCertificate) =
            let apply (args: KubernetesClusterKubeConfigArgs) =
                args.ClusterCaCertificate <- io clusterCaCertificate
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("host")>]
        member _.Host((n, args), host) =
            let apply (args: KubernetesClusterKubeConfigArgs) =
                args.Host <- input host
                args

            ()
            n, List.Cons(apply, args)

        member _.Host((n, args), host) =
            let apply (args: KubernetesClusterKubeConfigArgs) =
                args.Host <- io host
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: KubernetesClusterKubeConfigArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: KubernetesClusterKubeConfigArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: KubernetesClusterKubeConfigArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: KubernetesClusterKubeConfigArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

    let kubernetesClusterKubeConfig = KubernetesClusterKubeConfigBuilder()

    type KubernetesClusterKubeletIdentityBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (KubernetesClusterKubeletIdentityArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("clientId")>]
        member _.ClientId((n, args), clientId) =
            let apply (args: KubernetesClusterKubeletIdentityArgs) =
                args.ClientId <- input clientId
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientId((n, args), clientId) =
            let apply (args: KubernetesClusterKubeletIdentityArgs) =
                args.ClientId <- io clientId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("objectId")>]
        member _.ObjectId((n, args), objectId) =
            let apply (args: KubernetesClusterKubeletIdentityArgs) =
                args.ObjectId <- input objectId
                args

            ()
            n, List.Cons(apply, args)

        member _.ObjectId((n, args), objectId) =
            let apply (args: KubernetesClusterKubeletIdentityArgs) =
                args.ObjectId <- io objectId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("userAssignedIdentityId")>]
        member _.UserAssignedIdentityId((n, args), userAssignedIdentityId) =
            let apply (args: KubernetesClusterKubeletIdentityArgs) =
                args.UserAssignedIdentityId <- input userAssignedIdentityId
                args

            ()
            n, List.Cons(apply, args)

        member _.UserAssignedIdentityId((n, args), userAssignedIdentityId) =
            let apply (args: KubernetesClusterKubeletIdentityArgs) =
                args.UserAssignedIdentityId <- io userAssignedIdentityId
                args

            ()
            n, List.Cons(apply, args)

    let kubernetesClusterKubeletIdentity =
        KubernetesClusterKubeletIdentityBuilder()

    type KubernetesClusterLinuxProfileBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (KubernetesClusterLinuxProfileArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("adminUsername")>]
        member _.AdminUsername((n, args), adminUsername) =
            let apply (args: KubernetesClusterLinuxProfileArgs) =
                args.AdminUsername <- input adminUsername
                args

            ()
            n, List.Cons(apply, args)

        member _.AdminUsername((n, args), adminUsername) =
            let apply (args: KubernetesClusterLinuxProfileArgs) =
                args.AdminUsername <- io adminUsername
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: KubernetesClusterLinuxProfileArgs) =
                   args.SshKey <- input arg
                   args

               ()
               func) ]

    let kubernetesClusterLinuxProfile = KubernetesClusterLinuxProfileBuilder()

    type KubernetesClusterLinuxProfileSshKeyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (KubernetesClusterLinuxProfileSshKeyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("keyData")>]
        member _.KeyData((n, args), keyData) =
            let apply (args: KubernetesClusterLinuxProfileSshKeyArgs) =
                args.KeyData <- input keyData
                args

            ()
            n, List.Cons(apply, args)

        member _.KeyData((n, args), keyData) =
            let apply (args: KubernetesClusterLinuxProfileSshKeyArgs) =
                args.KeyData <- io keyData
                args

            ()
            n, List.Cons(apply, args)

    let kubernetesClusterLinuxProfileSshKey =
        KubernetesClusterLinuxProfileSshKeyBuilder()

    type KubernetesClusterNetworkProfileBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (KubernetesClusterNetworkProfileArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("dnsServiceIp")>]
        member _.DnsServiceIp((n, args), dnsServiceIp) =
            let apply (args: KubernetesClusterNetworkProfileArgs) =
                args.DnsServiceIp <- input dnsServiceIp
                args

            ()
            n, List.Cons(apply, args)

        member _.DnsServiceIp((n, args), dnsServiceIp) =
            let apply (args: KubernetesClusterNetworkProfileArgs) =
                args.DnsServiceIp <- io dnsServiceIp
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("dockerBridgeCidr")>]
        member _.DockerBridgeCidr((n, args), dockerBridgeCidr) =
            let apply (args: KubernetesClusterNetworkProfileArgs) =
                args.DockerBridgeCidr <- input dockerBridgeCidr
                args

            ()
            n, List.Cons(apply, args)

        member _.DockerBridgeCidr((n, args), dockerBridgeCidr) =
            let apply (args: KubernetesClusterNetworkProfileArgs) =
                args.DockerBridgeCidr <- io dockerBridgeCidr
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: KubernetesClusterNetworkProfileArgs) =
                   args.LoadBalancerProfile <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("loadBalancerSku")>]
        member _.LoadBalancerSku((n, args), loadBalancerSku) =
            let apply (args: KubernetesClusterNetworkProfileArgs) =
                args.LoadBalancerSku <- input loadBalancerSku
                args

            ()
            n, List.Cons(apply, args)

        member _.LoadBalancerSku((n, args), loadBalancerSku) =
            let apply (args: KubernetesClusterNetworkProfileArgs) =
                args.LoadBalancerSku <- io loadBalancerSku
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("networkPlugin")>]
        member _.NetworkPlugin((n, args), networkPlugin) =
            let apply (args: KubernetesClusterNetworkProfileArgs) =
                args.NetworkPlugin <- input networkPlugin
                args

            ()
            n, List.Cons(apply, args)

        member _.NetworkPlugin((n, args), networkPlugin) =
            let apply (args: KubernetesClusterNetworkProfileArgs) =
                args.NetworkPlugin <- io networkPlugin
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("networkPolicy")>]
        member _.NetworkPolicy((n, args), networkPolicy) =
            let apply (args: KubernetesClusterNetworkProfileArgs) =
                args.NetworkPolicy <- input networkPolicy
                args

            ()
            n, List.Cons(apply, args)

        member _.NetworkPolicy((n, args), networkPolicy) =
            let apply (args: KubernetesClusterNetworkProfileArgs) =
                args.NetworkPolicy <- io networkPolicy
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("outboundType")>]
        member _.OutboundType((n, args), outboundType) =
            let apply (args: KubernetesClusterNetworkProfileArgs) =
                args.OutboundType <- input outboundType
                args

            ()
            n, List.Cons(apply, args)

        member _.OutboundType((n, args), outboundType) =
            let apply (args: KubernetesClusterNetworkProfileArgs) =
                args.OutboundType <- io outboundType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("podCidr")>]
        member _.PodCidr((n, args), podCidr) =
            let apply (args: KubernetesClusterNetworkProfileArgs) =
                args.PodCidr <- input podCidr
                args

            ()
            n, List.Cons(apply, args)

        member _.PodCidr((n, args), podCidr) =
            let apply (args: KubernetesClusterNetworkProfileArgs) =
                args.PodCidr <- io podCidr
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("serviceCidr")>]
        member _.ServiceCidr((n, args), serviceCidr) =
            let apply (args: KubernetesClusterNetworkProfileArgs) =
                args.ServiceCidr <- input serviceCidr
                args

            ()
            n, List.Cons(apply, args)

        member _.ServiceCidr((n, args), serviceCidr) =
            let apply (args: KubernetesClusterNetworkProfileArgs) =
                args.ServiceCidr <- io serviceCidr
                args

            ()
            n, List.Cons(apply, args)

    let kubernetesClusterNetworkProfile = KubernetesClusterNetworkProfileBuilder()

    type KubernetesClusterNetworkProfileLoadBalancerProfileBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (KubernetesClusterNetworkProfileLoadBalancerProfileArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("effectiveOutboundIps")>]
        member _.EffectiveOutboundIps((n, args), effectiveOutboundIps) =
            let apply (args: KubernetesClusterNetworkProfileLoadBalancerProfileArgs) =
                args.EffectiveOutboundIps <- inputList effectiveOutboundIps
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("idleTimeoutInMinutes")>]
        member _.IdleTimeoutInMinutes((n, args), idleTimeoutInMinutes) =
            let apply (args: KubernetesClusterNetworkProfileLoadBalancerProfileArgs) =
                args.IdleTimeoutInMinutes <- input idleTimeoutInMinutes
                args

            ()
            n, List.Cons(apply, args)

        member _.IdleTimeoutInMinutes((n, args), idleTimeoutInMinutes) =
            let apply (args: KubernetesClusterNetworkProfileLoadBalancerProfileArgs) =
                args.IdleTimeoutInMinutes <- io idleTimeoutInMinutes
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("managedOutboundIpCount")>]
        member _.ManagedOutboundIpCount((n, args), managedOutboundIpCount) =
            let apply (args: KubernetesClusterNetworkProfileLoadBalancerProfileArgs) =
                args.ManagedOutboundIpCount <- input managedOutboundIpCount
                args

            ()
            n, List.Cons(apply, args)

        member _.ManagedOutboundIpCount((n, args), managedOutboundIpCount) =
            let apply (args: KubernetesClusterNetworkProfileLoadBalancerProfileArgs) =
                args.ManagedOutboundIpCount <- io managedOutboundIpCount
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("outboundIpAddressIds")>]
        member _.OutboundIpAddressIds((n, args), outboundIpAddressIds) =
            let apply (args: KubernetesClusterNetworkProfileLoadBalancerProfileArgs) =
                args.OutboundIpAddressIds <- inputList outboundIpAddressIds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("outboundIpPrefixIds")>]
        member _.OutboundIpPrefixIds((n, args), outboundIpPrefixIds) =
            let apply (args: KubernetesClusterNetworkProfileLoadBalancerProfileArgs) =
                args.OutboundIpPrefixIds <- inputList outboundIpPrefixIds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("outboundPortsAllocated")>]
        member _.OutboundPortsAllocated((n, args), outboundPortsAllocated) =
            let apply (args: KubernetesClusterNetworkProfileLoadBalancerProfileArgs) =
                args.OutboundPortsAllocated <- input outboundPortsAllocated
                args

            ()
            n, List.Cons(apply, args)

        member _.OutboundPortsAllocated((n, args), outboundPortsAllocated) =
            let apply (args: KubernetesClusterNetworkProfileLoadBalancerProfileArgs) =
                args.OutboundPortsAllocated <- io outboundPortsAllocated
                args

            ()
            n, List.Cons(apply, args)

    let kubernetesClusterNetworkProfileLoadBalancerProfile =
        KubernetesClusterNetworkProfileLoadBalancerProfileBuilder()

    type KubernetesClusterRoleBasedAccessControlBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (KubernetesClusterRoleBasedAccessControlArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: KubernetesClusterRoleBasedAccessControlArgs) =
                   args.AzureActiveDirectory <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: KubernetesClusterRoleBasedAccessControlArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: KubernetesClusterRoleBasedAccessControlArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

    let kubernetesClusterRoleBasedAccessControl =
        KubernetesClusterRoleBasedAccessControlBuilder()

    type KubernetesClusterRoleBasedAccessControlAzureActiveDirectoryBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (KubernetesClusterRoleBasedAccessControlAzureActiveDirectoryArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("adminGroupObjectIds")>]
        member _.AdminGroupObjectIds((n, args), adminGroupObjectIds) =
            let apply (args: KubernetesClusterRoleBasedAccessControlAzureActiveDirectoryArgs) =
                args.AdminGroupObjectIds <- inputList adminGroupObjectIds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("clientAppId")>]
        member _.ClientAppId((n, args), clientAppId) =
            let apply (args: KubernetesClusterRoleBasedAccessControlAzureActiveDirectoryArgs) =
                args.ClientAppId <- input clientAppId
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientAppId((n, args), clientAppId) =
            let apply (args: KubernetesClusterRoleBasedAccessControlAzureActiveDirectoryArgs) =
                args.ClientAppId <- io clientAppId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("managed")>]
        member _.Managed((n, args), managed) =
            let apply (args: KubernetesClusterRoleBasedAccessControlAzureActiveDirectoryArgs) =
                args.Managed <- input managed
                args

            ()
            n, List.Cons(apply, args)

        member _.Managed((n, args), managed) =
            let apply (args: KubernetesClusterRoleBasedAccessControlAzureActiveDirectoryArgs) =
                args.Managed <- io managed
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("serverAppId")>]
        member _.ServerAppId((n, args), serverAppId) =
            let apply (args: KubernetesClusterRoleBasedAccessControlAzureActiveDirectoryArgs) =
                args.ServerAppId <- input serverAppId
                args

            ()
            n, List.Cons(apply, args)

        member _.ServerAppId((n, args), serverAppId) =
            let apply (args: KubernetesClusterRoleBasedAccessControlAzureActiveDirectoryArgs) =
                args.ServerAppId <- io serverAppId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("serverAppSecret")>]
        member _.ServerAppSecret((n, args), serverAppSecret) =
            let apply (args: KubernetesClusterRoleBasedAccessControlAzureActiveDirectoryArgs) =
                args.ServerAppSecret <- input serverAppSecret
                args

            ()
            n, List.Cons(apply, args)

        member _.ServerAppSecret((n, args), serverAppSecret) =
            let apply (args: KubernetesClusterRoleBasedAccessControlAzureActiveDirectoryArgs) =
                args.ServerAppSecret <- io serverAppSecret
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tenantId")>]
        member _.TenantId((n, args), tenantId) =
            let apply (args: KubernetesClusterRoleBasedAccessControlAzureActiveDirectoryArgs) =
                args.TenantId <- input tenantId
                args

            ()
            n, List.Cons(apply, args)

        member _.TenantId((n, args), tenantId) =
            let apply (args: KubernetesClusterRoleBasedAccessControlAzureActiveDirectoryArgs) =
                args.TenantId <- io tenantId
                args

            ()
            n, List.Cons(apply, args)

    let kubernetesClusterRoleBasedAccessControlAzureActiveDirectory =
        KubernetesClusterRoleBasedAccessControlAzureActiveDirectoryBuilder()

    type KubernetesClusterServicePrincipalBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (KubernetesClusterServicePrincipalArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("clientId")>]
        member _.ClientId((n, args), clientId) =
            let apply (args: KubernetesClusterServicePrincipalArgs) =
                args.ClientId <- input clientId
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientId((n, args), clientId) =
            let apply (args: KubernetesClusterServicePrincipalArgs) =
                args.ClientId <- io clientId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("clientSecret")>]
        member _.ClientSecret((n, args), clientSecret) =
            let apply (args: KubernetesClusterServicePrincipalArgs) =
                args.ClientSecret <- input clientSecret
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientSecret((n, args), clientSecret) =
            let apply (args: KubernetesClusterServicePrincipalArgs) =
                args.ClientSecret <- io clientSecret
                args

            ()
            n, List.Cons(apply, args)

    let kubernetesClusterServicePrincipal =
        KubernetesClusterServicePrincipalBuilder()

    type KubernetesClusterWindowsProfileBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (KubernetesClusterWindowsProfileArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("adminPassword")>]
        member _.AdminPassword((n, args), adminPassword) =
            let apply (args: KubernetesClusterWindowsProfileArgs) =
                args.AdminPassword <- input adminPassword
                args

            ()
            n, List.Cons(apply, args)

        member _.AdminPassword((n, args), adminPassword) =
            let apply (args: KubernetesClusterWindowsProfileArgs) =
                args.AdminPassword <- io adminPassword
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("adminUsername")>]
        member _.AdminUsername((n, args), adminUsername) =
            let apply (args: KubernetesClusterWindowsProfileArgs) =
                args.AdminUsername <- input adminUsername
                args

            ()
            n, List.Cons(apply, args)

        member _.AdminUsername((n, args), adminUsername) =
            let apply (args: KubernetesClusterWindowsProfileArgs) =
                args.AdminUsername <- io adminUsername
                args

            ()
            n, List.Cons(apply, args)

    let kubernetesClusterWindowsProfile = KubernetesClusterWindowsProfileBuilder()

    type RegistryNetworkRuleSetBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (RegistryNetworkRuleSetArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("defaultAction")>]
        member _.DefaultAction((n, args), defaultAction) =
            let apply (args: RegistryNetworkRuleSetArgs) =
                args.DefaultAction <- input defaultAction
                args

            ()
            n, List.Cons(apply, args)

        member _.DefaultAction((n, args), defaultAction) =
            let apply (args: RegistryNetworkRuleSetArgs) =
                args.DefaultAction <- io defaultAction
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ipRules")>]
        member _.IpRules((n, args), ipRules) =
            let apply (args: RegistryNetworkRuleSetArgs) =
                args.IpRules <- inputList ipRules
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualNetworks")>]
        member _.VirtualNetworks((n, args), virtualNetworks) =
            let apply (args: RegistryNetworkRuleSetArgs) =
                args.VirtualNetworks <- inputList virtualNetworks
                args

            ()
            n, List.Cons(apply, args)

    let registryNetworkRuleSet = RegistryNetworkRuleSetBuilder()

    type RegistryNetworkRuleSetIpRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (RegistryNetworkRuleSetIpRuleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("action")>]
        member _.Action((n, args), action) =
            let apply (args: RegistryNetworkRuleSetIpRuleArgs) =
                args.Action <- input action
                args

            ()
            n, List.Cons(apply, args)

        member _.Action((n, args), action) =
            let apply (args: RegistryNetworkRuleSetIpRuleArgs) =
                args.Action <- io action
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ipRange")>]
        member _.IpRange((n, args), ipRange) =
            let apply (args: RegistryNetworkRuleSetIpRuleArgs) =
                args.IpRange <- input ipRange
                args

            ()
            n, List.Cons(apply, args)

        member _.IpRange((n, args), ipRange) =
            let apply (args: RegistryNetworkRuleSetIpRuleArgs) =
                args.IpRange <- io ipRange
                args

            ()
            n, List.Cons(apply, args)

    let registryNetworkRuleSetIpRule = RegistryNetworkRuleSetIpRuleBuilder()

    type RegistryNetworkRuleSetVirtualNetworkBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (RegistryNetworkRuleSetVirtualNetworkArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("action")>]
        member _.Action((n, args), action) =
            let apply (args: RegistryNetworkRuleSetVirtualNetworkArgs) =
                args.Action <- input action
                args

            ()
            n, List.Cons(apply, args)

        member _.Action((n, args), action) =
            let apply (args: RegistryNetworkRuleSetVirtualNetworkArgs) =
                args.Action <- io action
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: RegistryNetworkRuleSetVirtualNetworkArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: RegistryNetworkRuleSetVirtualNetworkArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

    let registryNetworkRuleSetVirtualNetwork =
        RegistryNetworkRuleSetVirtualNetworkBuilder()

    type GroupBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Group(name, (List.fold func (GroupArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("containers")>]
        member _.Containers((name, args), containers) =
            let apply (args: GroupArgs) =
                args.Containers <- inputList containers
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: GroupArgs) =
                   args.Diagnostics <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("dnsNameLabel")>]
        member _.DnsNameLabel((name, args), dnsNameLabel) =
            let apply (args: GroupArgs) =
                args.DnsNameLabel <- input dnsNameLabel
                args

            ()
            name, List.Cons(apply, args)

        member _.DnsNameLabel((name, args), dnsNameLabel) =
            let apply (args: GroupArgs) =
                args.DnsNameLabel <- io dnsNameLabel
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: GroupArgs) =
                   args.Identity <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("imageRegistryCredentials")>]
        member _.ImageRegistryCredentials((name, args), imageRegistryCredentials) =
            let apply (args: GroupArgs) =
                args.ImageRegistryCredentials <- inputList imageRegistryCredentials
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("ipAddressType")>]
        member _.IpAddressType((name, args), ipAddressType) =
            let apply (args: GroupArgs) =
                args.IpAddressType <- input ipAddressType
                args

            ()
            name, List.Cons(apply, args)

        member _.IpAddressType((name, args), ipAddressType) =
            let apply (args: GroupArgs) =
                args.IpAddressType <- io ipAddressType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: GroupArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: GroupArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: GroupArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: GroupArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("networkProfileId")>]
        member _.NetworkProfileId((name, args), networkProfileId) =
            let apply (args: GroupArgs) =
                args.NetworkProfileId <- input networkProfileId
                args

            ()
            name, List.Cons(apply, args)

        member _.NetworkProfileId((name, args), networkProfileId) =
            let apply (args: GroupArgs) =
                args.NetworkProfileId <- io networkProfileId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("osType")>]
        member _.OsType((name, args), osType) =
            let apply (args: GroupArgs) =
                args.OsType <- input osType
                args

            ()
            name, List.Cons(apply, args)

        member _.OsType((name, args), osType) =
            let apply (args: GroupArgs) =
                args.OsType <- io osType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: GroupArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: GroupArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("restartPolicy")>]
        member _.RestartPolicy((name, args), restartPolicy) =
            let apply (args: GroupArgs) =
                args.RestartPolicy <- input restartPolicy
                args

            ()
            name, List.Cons(apply, args)

        member _.RestartPolicy((name, args), restartPolicy) =
            let apply (args: GroupArgs) =
                args.RestartPolicy <- io restartPolicy
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: GroupArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let group = GroupBuilder()

    type KubernetesClusterBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            KubernetesCluster(name, (List.fold func (KubernetesClusterArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: KubernetesClusterArgs) =
                   args.AddonProfile <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("apiServerAuthorizedIpRanges")>]
        member _.ApiServerAuthorizedIpRanges((name, args), apiServerAuthorizedIpRanges) =
            let apply (args: KubernetesClusterArgs) =
                args.ApiServerAuthorizedIpRanges <- inputList apiServerAuthorizedIpRanges
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: KubernetesClusterArgs) =
                   args.AutoScalerProfile <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: KubernetesClusterArgs) =
                   args.DefaultNodePool <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("diskEncryptionSetId")>]
        member _.DiskEncryptionSetId((name, args), diskEncryptionSetId) =
            let apply (args: KubernetesClusterArgs) =
                args.DiskEncryptionSetId <- input diskEncryptionSetId
                args

            ()
            name, List.Cons(apply, args)

        member _.DiskEncryptionSetId((name, args), diskEncryptionSetId) =
            let apply (args: KubernetesClusterArgs) =
                args.DiskEncryptionSetId <- io diskEncryptionSetId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("dnsPrefix")>]
        member _.DnsPrefix((name, args), dnsPrefix) =
            let apply (args: KubernetesClusterArgs) =
                args.DnsPrefix <- input dnsPrefix
                args

            ()
            name, List.Cons(apply, args)

        member _.DnsPrefix((name, args), dnsPrefix) =
            let apply (args: KubernetesClusterArgs) =
                args.DnsPrefix <- io dnsPrefix
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enablePodSecurityPolicy")>]
        member _.EnablePodSecurityPolicy((name, args), enablePodSecurityPolicy) =
            let apply (args: KubernetesClusterArgs) =
                args.EnablePodSecurityPolicy <- input enablePodSecurityPolicy
                args

            ()
            name, List.Cons(apply, args)

        member _.EnablePodSecurityPolicy((name, args), enablePodSecurityPolicy) =
            let apply (args: KubernetesClusterArgs) =
                args.EnablePodSecurityPolicy <- io enablePodSecurityPolicy
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: KubernetesClusterArgs) =
                   args.Identity <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("kubernetesVersion")>]
        member _.KubernetesVersion((name, args), kubernetesVersion) =
            let apply (args: KubernetesClusterArgs) =
                args.KubernetesVersion <- input kubernetesVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.KubernetesVersion((name, args), kubernetesVersion) =
            let apply (args: KubernetesClusterArgs) =
                args.KubernetesVersion <- io kubernetesVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: KubernetesClusterArgs) =
                   args.LinuxProfile <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: KubernetesClusterArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: KubernetesClusterArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: KubernetesClusterArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: KubernetesClusterArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: KubernetesClusterArgs) =
                   args.NetworkProfile <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("nodeResourceGroup")>]
        member _.NodeResourceGroup((name, args), nodeResourceGroup) =
            let apply (args: KubernetesClusterArgs) =
                args.NodeResourceGroup <- input nodeResourceGroup
                args

            ()
            name, List.Cons(apply, args)

        member _.NodeResourceGroup((name, args), nodeResourceGroup) =
            let apply (args: KubernetesClusterArgs) =
                args.NodeResourceGroup <- io nodeResourceGroup
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("privateClusterEnabled")>]
        member _.PrivateClusterEnabled((name, args), privateClusterEnabled) =
            let apply (args: KubernetesClusterArgs) =
                args.PrivateClusterEnabled <- input privateClusterEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.PrivateClusterEnabled((name, args), privateClusterEnabled) =
            let apply (args: KubernetesClusterArgs) =
                args.PrivateClusterEnabled <- io privateClusterEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("privateLinkEnabled")>]
        member _.PrivateLinkEnabled((name, args), privateLinkEnabled) =
            let apply (args: KubernetesClusterArgs) =
                args.PrivateLinkEnabled <- input privateLinkEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.PrivateLinkEnabled((name, args), privateLinkEnabled) =
            let apply (args: KubernetesClusterArgs) =
                args.PrivateLinkEnabled <- io privateLinkEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: KubernetesClusterArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: KubernetesClusterArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: KubernetesClusterArgs) =
                   args.RoleBasedAccessControl <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: KubernetesClusterArgs) =
                   args.ServicePrincipal <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("skuTier")>]
        member _.SkuTier((name, args), skuTier) =
            let apply (args: KubernetesClusterArgs) =
                args.SkuTier <- input skuTier
                args

            ()
            name, List.Cons(apply, args)

        member _.SkuTier((name, args), skuTier) =
            let apply (args: KubernetesClusterArgs) =
                args.SkuTier <- io skuTier
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: KubernetesClusterArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: KubernetesClusterArgs) =
                   args.WindowsProfile <- input arg
                   args

               ()
               func) ]

    let kubernetesCluster = KubernetesClusterBuilder()

    type KubernetesClusterNodePoolBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            KubernetesClusterNodePool(name, (List.fold func (KubernetesClusterNodePoolArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("availabilityZones")>]
        member _.AvailabilityZones((name, args), availabilityZones) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.AvailabilityZones <- inputList availabilityZones
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enableAutoScaling")>]
        member _.EnableAutoScaling((name, args), enableAutoScaling) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.EnableAutoScaling <- input enableAutoScaling
                args

            ()
            name, List.Cons(apply, args)

        member _.EnableAutoScaling((name, args), enableAutoScaling) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.EnableAutoScaling <- io enableAutoScaling
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enableNodePublicIp")>]
        member _.EnableNodePublicIp((name, args), enableNodePublicIp) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.EnableNodePublicIp <- input enableNodePublicIp
                args

            ()
            name, List.Cons(apply, args)

        member _.EnableNodePublicIp((name, args), enableNodePublicIp) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.EnableNodePublicIp <- io enableNodePublicIp
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("evictionPolicy")>]
        member _.EvictionPolicy((name, args), evictionPolicy) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.EvictionPolicy <- input evictionPolicy
                args

            ()
            name, List.Cons(apply, args)

        member _.EvictionPolicy((name, args), evictionPolicy) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.EvictionPolicy <- io evictionPolicy
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("kubernetesClusterId")>]
        member _.KubernetesClusterId((name, args), kubernetesClusterId) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.KubernetesClusterId <- input kubernetesClusterId
                args

            ()
            name, List.Cons(apply, args)

        member _.KubernetesClusterId((name, args), kubernetesClusterId) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.KubernetesClusterId <- io kubernetesClusterId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("maxCount")>]
        member _.MaxCount((name, args), maxCount) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.MaxCount <- input maxCount
                args

            ()
            name, List.Cons(apply, args)

        member _.MaxCount((name, args), maxCount) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.MaxCount <- io maxCount
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("maxPods")>]
        member _.MaxPods((name, args), maxPods) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.MaxPods <- input maxPods
                args

            ()
            name, List.Cons(apply, args)

        member _.MaxPods((name, args), maxPods) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.MaxPods <- io maxPods
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("minCount")>]
        member _.MinCount((name, args), minCount) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.MinCount <- input minCount
                args

            ()
            name, List.Cons(apply, args)

        member _.MinCount((name, args), minCount) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.MinCount <- io minCount
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("mode")>]
        member _.Mode((name, args), mode) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.Mode <- input mode
                args

            ()
            name, List.Cons(apply, args)

        member _.Mode((name, args), mode) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.Mode <- io mode
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("nodeCount")>]
        member _.NodeCount((name, args), nodeCount) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.NodeCount <- input nodeCount
                args

            ()
            name, List.Cons(apply, args)

        member _.NodeCount((name, args), nodeCount) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.NodeCount <- io nodeCount
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("nodeLabels")>]
        member _.NodeLabels((name, args), nodeLabels) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.NodeLabels <- inputMap nodeLabels
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("nodeTaints")>]
        member _.NodeTaints((name, args), nodeTaints) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.NodeTaints <- inputList nodeTaints
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("orchestratorVersion")>]
        member _.OrchestratorVersion((name, args), orchestratorVersion) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.OrchestratorVersion <- input orchestratorVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.OrchestratorVersion((name, args), orchestratorVersion) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.OrchestratorVersion <- io orchestratorVersion
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("osDiskSizeGb")>]
        member _.OsDiskSizeGb((name, args), osDiskSizeGb) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.OsDiskSizeGb <- input osDiskSizeGb
                args

            ()
            name, List.Cons(apply, args)

        member _.OsDiskSizeGb((name, args), osDiskSizeGb) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.OsDiskSizeGb <- io osDiskSizeGb
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("osType")>]
        member _.OsType((name, args), osType) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.OsType <- input osType
                args

            ()
            name, List.Cons(apply, args)

        member _.OsType((name, args), osType) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.OsType <- io osType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("priority")>]
        member _.Priority((name, args), priority) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.Priority <- input priority
                args

            ()
            name, List.Cons(apply, args)

        member _.Priority((name, args), priority) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.Priority <- io priority
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("spotMaxPrice")>]
        member _.SpotMaxPrice((name, args), spotMaxPrice) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.SpotMaxPrice <- input spotMaxPrice
                args

            ()
            name, List.Cons(apply, args)

        member _.SpotMaxPrice((name, args), spotMaxPrice) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.SpotMaxPrice <- io spotMaxPrice
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("vmSize")>]
        member _.VmSize((name, args), vmSize) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.VmSize <- input vmSize
                args

            ()
            name, List.Cons(apply, args)

        member _.VmSize((name, args), vmSize) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.VmSize <- io vmSize
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("vnetSubnetId")>]
        member _.VnetSubnetId((name, args), vnetSubnetId) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.VnetSubnetId <- input vnetSubnetId
                args

            ()
            name, List.Cons(apply, args)

        member _.VnetSubnetId((name, args), vnetSubnetId) =
            let apply (args: KubernetesClusterNodePoolArgs) =
                args.VnetSubnetId <- io vnetSubnetId
                args

            ()
            name, List.Cons(apply, args)

    let kubernetesClusterNodePool = KubernetesClusterNodePoolBuilder()

    type RegistryBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Registry(name, (List.fold func (RegistryArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("adminEnabled")>]
        member _.AdminEnabled((name, args), adminEnabled) =
            let apply (args: RegistryArgs) =
                args.AdminEnabled <- input adminEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.AdminEnabled((name, args), adminEnabled) =
            let apply (args: RegistryArgs) =
                args.AdminEnabled <- io adminEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("georeplicationLocations")>]
        member _.GeoreplicationLocations((name, args), georeplicationLocations) =
            let apply (args: RegistryArgs) =
                args.GeoreplicationLocations <- inputList georeplicationLocations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: RegistryArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: RegistryArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: RegistryArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: RegistryArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: RegistryArgs) =
                   args.NetworkRuleSet <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: RegistryArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: RegistryArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sku")>]
        member _.Sku((name, args), sku) =
            let apply (args: RegistryArgs) =
                args.Sku <- input sku
                args

            ()
            name, List.Cons(apply, args)

        member _.Sku((name, args), sku) =
            let apply (args: RegistryArgs) =
                args.Sku <- io sku
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageAccountId")>]
        member _.StorageAccountId((name, args), storageAccountId) =
            let apply (args: RegistryArgs) =
                args.StorageAccountId <- input storageAccountId
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageAccountId((name, args), storageAccountId) =
            let apply (args: RegistryArgs) =
                args.StorageAccountId <- io storageAccountId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: RegistryArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let registry = RegistryBuilder()

    type RegistryWebhookBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            RegistryWebhook(name, (List.fold func (RegistryWebhookArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("actions")>]
        member _.Actions((name, args), actions) =
            let apply (args: RegistryWebhookArgs) =
                args.Actions <- inputList actions
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("customHeaders")>]
        member _.CustomHeaders((name, args), customHeaders) =
            let apply (args: RegistryWebhookArgs) =
                args.CustomHeaders <- inputMap customHeaders
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: RegistryWebhookArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: RegistryWebhookArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: RegistryWebhookArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: RegistryWebhookArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("registryName")>]
        member _.RegistryName((name, args), registryName) =
            let apply (args: RegistryWebhookArgs) =
                args.RegistryName <- input registryName
                args

            ()
            name, List.Cons(apply, args)

        member _.RegistryName((name, args), registryName) =
            let apply (args: RegistryWebhookArgs) =
                args.RegistryName <- io registryName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: RegistryWebhookArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: RegistryWebhookArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("scope")>]
        member _.Scope((name, args), scope) =
            let apply (args: RegistryWebhookArgs) =
                args.Scope <- input scope
                args

            ()
            name, List.Cons(apply, args)

        member _.Scope((name, args), scope) =
            let apply (args: RegistryWebhookArgs) =
                args.Scope <- io scope
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serviceUri")>]
        member _.ServiceUri((name, args), serviceUri) =
            let apply (args: RegistryWebhookArgs) =
                args.ServiceUri <- input serviceUri
                args

            ()
            name, List.Cons(apply, args)

        member _.ServiceUri((name, args), serviceUri) =
            let apply (args: RegistryWebhookArgs) =
                args.ServiceUri <- io serviceUri
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("status")>]
        member _.Status((name, args), status) =
            let apply (args: RegistryWebhookArgs) =
                args.Status <- input status
                args

            ()
            name, List.Cons(apply, args)

        member _.Status((name, args), status) =
            let apply (args: RegistryWebhookArgs) =
                args.Status <- io status
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: RegistryWebhookArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let registryWebhook = RegistryWebhookBuilder()

    type RegistryWebookBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            RegistryWebook(name, (List.fold func (RegistryWebookArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("actions")>]
        member _.Actions((name, args), actions) =
            let apply (args: RegistryWebookArgs) =
                args.Actions <- inputList actions
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("customHeaders")>]
        member _.CustomHeaders((name, args), customHeaders) =
            let apply (args: RegistryWebookArgs) =
                args.CustomHeaders <- inputMap customHeaders
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: RegistryWebookArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: RegistryWebookArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: RegistryWebookArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: RegistryWebookArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("registryName")>]
        member _.RegistryName((name, args), registryName) =
            let apply (args: RegistryWebookArgs) =
                args.RegistryName <- input registryName
                args

            ()
            name, List.Cons(apply, args)

        member _.RegistryName((name, args), registryName) =
            let apply (args: RegistryWebookArgs) =
                args.RegistryName <- io registryName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: RegistryWebookArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: RegistryWebookArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("scope")>]
        member _.Scope((name, args), scope) =
            let apply (args: RegistryWebookArgs) =
                args.Scope <- input scope
                args

            ()
            name, List.Cons(apply, args)

        member _.Scope((name, args), scope) =
            let apply (args: RegistryWebookArgs) =
                args.Scope <- io scope
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serviceUri")>]
        member _.ServiceUri((name, args), serviceUri) =
            let apply (args: RegistryWebookArgs) =
                args.ServiceUri <- input serviceUri
                args

            ()
            name, List.Cons(apply, args)

        member _.ServiceUri((name, args), serviceUri) =
            let apply (args: RegistryWebookArgs) =
                args.ServiceUri <- io serviceUri
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("status")>]
        member _.Status((name, args), status) =
            let apply (args: RegistryWebookArgs) =
                args.Status <- input status
                args

            ()
            name, List.Cons(apply, args)

        member _.Status((name, args), status) =
            let apply (args: RegistryWebookArgs) =
                args.Status <- io status
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: RegistryWebookArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let registryWebook = RegistryWebookBuilder()

module Core =
    open Pulumi.Azure.Core
    open Pulumi.Azure.Core.Inputs

    type CustomProviderActionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (CustomProviderActionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("endpoint")>]
        member _.Endpoint((n, args), endpoint) =
            let apply (args: CustomProviderActionArgs) =
                args.Endpoint <- input endpoint
                args

            ()
            n, List.Cons(apply, args)

        member _.Endpoint((n, args), endpoint) =
            let apply (args: CustomProviderActionArgs) =
                args.Endpoint <- io endpoint
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: CustomProviderActionArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: CustomProviderActionArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

    let customProviderAction = CustomProviderActionBuilder()

    type CustomProviderResourceTypeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (CustomProviderResourceTypeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("endpoint")>]
        member _.Endpoint((n, args), endpoint) =
            let apply (args: CustomProviderResourceTypeArgs) =
                args.Endpoint <- input endpoint
                args

            ()
            n, List.Cons(apply, args)

        member _.Endpoint((n, args), endpoint) =
            let apply (args: CustomProviderResourceTypeArgs) =
                args.Endpoint <- io endpoint
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: CustomProviderResourceTypeArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: CustomProviderResourceTypeArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("routingType")>]
        member _.RoutingType((n, args), routingType) =
            let apply (args: CustomProviderResourceTypeArgs) =
                args.RoutingType <- input routingType
                args

            ()
            n, List.Cons(apply, args)

        member _.RoutingType((n, args), routingType) =
            let apply (args: CustomProviderResourceTypeArgs) =
                args.RoutingType <- io routingType
                args

            ()
            n, List.Cons(apply, args)

    let customProviderResourceType = CustomProviderResourceTypeBuilder()

    type CustomProviderValidationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (CustomProviderValidationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("specification")>]
        member _.Specification((n, args), specification) =
            let apply (args: CustomProviderValidationArgs) =
                args.Specification <- input specification
                args

            ()
            n, List.Cons(apply, args)

        member _.Specification((n, args), specification) =
            let apply (args: CustomProviderValidationArgs) =
                args.Specification <- io specification
                args

            ()
            n, List.Cons(apply, args)

    let customProviderValidation = CustomProviderValidationBuilder()

    type CustomProviderBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            CustomProvider(name, (List.fold func (CustomProviderArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("actions")>]
        member _.Actions((name, args), actions) =
            let apply (args: CustomProviderArgs) =
                args.Actions <- inputList actions
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: CustomProviderArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: CustomProviderArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: CustomProviderArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: CustomProviderArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: CustomProviderArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: CustomProviderArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceTypes")>]
        member _.ResourceTypes((name, args), resourceTypes) =
            let apply (args: CustomProviderArgs) =
                args.ResourceTypes <- inputList resourceTypes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: CustomProviderArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("validations")>]
        member _.Validations((name, args), validations) =
            let apply (args: CustomProviderArgs) =
                args.Validations <- inputList validations
                args

            ()
            name, List.Cons(apply, args)

    let customProvider = CustomProviderBuilder()

    type ResourceGroupBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ResourceGroup(name, (List.fold func (ResourceGroupArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ResourceGroupArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ResourceGroupArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ResourceGroupArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ResourceGroupArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ResourceGroupArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let resourceGroup = ResourceGroupBuilder()

    type TemplateDeploymentBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            TemplateDeployment(name, (List.fold func (TemplateDeploymentArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("deploymentMode")>]
        member _.DeploymentMode((name, args), deploymentMode) =
            let apply (args: TemplateDeploymentArgs) =
                args.DeploymentMode <- input deploymentMode
                args

            ()
            name, List.Cons(apply, args)

        member _.DeploymentMode((name, args), deploymentMode) =
            let apply (args: TemplateDeploymentArgs) =
                args.DeploymentMode <- io deploymentMode
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: TemplateDeploymentArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: TemplateDeploymentArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("parameters")>]
        member _.Parameters((name, args), parameters) =
            let apply (args: TemplateDeploymentArgs) =
                args.Parameters <- inputMap parameters
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("parametersBody")>]
        member _.ParametersBody((name, args), parametersBody) =
            let apply (args: TemplateDeploymentArgs) =
                args.ParametersBody <- input parametersBody
                args

            ()
            name, List.Cons(apply, args)

        member _.ParametersBody((name, args), parametersBody) =
            let apply (args: TemplateDeploymentArgs) =
                args.ParametersBody <- io parametersBody
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: TemplateDeploymentArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: TemplateDeploymentArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("templateBody")>]
        member _.TemplateBody((name, args), templateBody) =
            let apply (args: TemplateDeploymentArgs) =
                args.TemplateBody <- input templateBody
                args

            ()
            name, List.Cons(apply, args)

        member _.TemplateBody((name, args), templateBody) =
            let apply (args: TemplateDeploymentArgs) =
                args.TemplateBody <- io templateBody
                args

            ()
            name, List.Cons(apply, args)

    let templateDeployment = TemplateDeploymentBuilder()

module CosmosDB =
    open Pulumi.Azure.CosmosDB
    open Pulumi.Azure.CosmosDB.Inputs

    type AccountCapabilityBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AccountCapabilityArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: AccountCapabilityArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: AccountCapabilityArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

    let accountCapability = AccountCapabilityBuilder()

    type AccountConsistencyPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AccountConsistencyPolicyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("consistencyLevel")>]
        member _.ConsistencyLevel((n, args), consistencyLevel) =
            let apply (args: AccountConsistencyPolicyArgs) =
                args.ConsistencyLevel <- input consistencyLevel
                args

            ()
            n, List.Cons(apply, args)

        member _.ConsistencyLevel((n, args), consistencyLevel) =
            let apply (args: AccountConsistencyPolicyArgs) =
                args.ConsistencyLevel <- io consistencyLevel
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("maxIntervalInSeconds")>]
        member _.MaxIntervalInSeconds((n, args), maxIntervalInSeconds) =
            let apply (args: AccountConsistencyPolicyArgs) =
                args.MaxIntervalInSeconds <- input maxIntervalInSeconds
                args

            ()
            n, List.Cons(apply, args)

        member _.MaxIntervalInSeconds((n, args), maxIntervalInSeconds) =
            let apply (args: AccountConsistencyPolicyArgs) =
                args.MaxIntervalInSeconds <- io maxIntervalInSeconds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("maxStalenessPrefix")>]
        member _.MaxStalenessPrefix((n, args), maxStalenessPrefix) =
            let apply (args: AccountConsistencyPolicyArgs) =
                args.MaxStalenessPrefix <- input maxStalenessPrefix
                args

            ()
            n, List.Cons(apply, args)

        member _.MaxStalenessPrefix((n, args), maxStalenessPrefix) =
            let apply (args: AccountConsistencyPolicyArgs) =
                args.MaxStalenessPrefix <- io maxStalenessPrefix
                args

            ()
            n, List.Cons(apply, args)

    let accountConsistencyPolicy = AccountConsistencyPolicyBuilder()

    type AccountGeoLocationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AccountGeoLocationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("failoverPriority")>]
        member _.FailoverPriority((n, args), failoverPriority) =
            let apply (args: AccountGeoLocationArgs) =
                args.FailoverPriority <- input failoverPriority
                args

            ()
            n, List.Cons(apply, args)

        member _.FailoverPriority((n, args), failoverPriority) =
            let apply (args: AccountGeoLocationArgs) =
                args.FailoverPriority <- io failoverPriority
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: AccountGeoLocationArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: AccountGeoLocationArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((n, args), location) =
            let apply (args: AccountGeoLocationArgs) =
                args.Location <- input location
                args

            ()
            n, List.Cons(apply, args)

        member _.Location((n, args), location) =
            let apply (args: AccountGeoLocationArgs) =
                args.Location <- io location
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("prefix")>]
        member _.Prefix((n, args), prefix) =
            let apply (args: AccountGeoLocationArgs) =
                args.Prefix <- input prefix
                args

            ()
            n, List.Cons(apply, args)

        member _.Prefix((n, args), prefix) =
            let apply (args: AccountGeoLocationArgs) =
                args.Prefix <- io prefix
                args

            ()
            n, List.Cons(apply, args)

    let accountGeoLocation = AccountGeoLocationBuilder()

    type AccountVirtualNetworkRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AccountVirtualNetworkRuleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: AccountVirtualNetworkRuleArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: AccountVirtualNetworkRuleArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

    let accountVirtualNetworkRule = AccountVirtualNetworkRuleBuilder()

    type GremlinGraphConflictResolutionPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (GremlinGraphConflictResolutionPolicyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("conflictResolutionPath")>]
        member _.ConflictResolutionPath((n, args), conflictResolutionPath) =
            let apply (args: GremlinGraphConflictResolutionPolicyArgs) =
                args.ConflictResolutionPath <- input conflictResolutionPath
                args

            ()
            n, List.Cons(apply, args)

        member _.ConflictResolutionPath((n, args), conflictResolutionPath) =
            let apply (args: GremlinGraphConflictResolutionPolicyArgs) =
                args.ConflictResolutionPath <- io conflictResolutionPath
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("conflictResolutionProcedure")>]
        member _.ConflictResolutionProcedure((n, args), conflictResolutionProcedure) =
            let apply (args: GremlinGraphConflictResolutionPolicyArgs) =
                args.ConflictResolutionProcedure <- input conflictResolutionProcedure
                args

            ()
            n, List.Cons(apply, args)

        member _.ConflictResolutionProcedure((n, args), conflictResolutionProcedure) =
            let apply (args: GremlinGraphConflictResolutionPolicyArgs) =
                args.ConflictResolutionProcedure <- io conflictResolutionProcedure
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("mode")>]
        member _.Mode((n, args), mode) =
            let apply (args: GremlinGraphConflictResolutionPolicyArgs) =
                args.Mode <- input mode
                args

            ()
            n, List.Cons(apply, args)

        member _.Mode((n, args), mode) =
            let apply (args: GremlinGraphConflictResolutionPolicyArgs) =
                args.Mode <- io mode
                args

            ()
            n, List.Cons(apply, args)

    let gremlinGraphConflictResolutionPolicy =
        GremlinGraphConflictResolutionPolicyBuilder()

    type GremlinGraphIndexPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (GremlinGraphIndexPolicyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("automatic")>]
        member _.Automatic((n, args), automatic) =
            let apply (args: GremlinGraphIndexPolicyArgs) =
                args.Automatic <- input automatic
                args

            ()
            n, List.Cons(apply, args)

        member _.Automatic((n, args), automatic) =
            let apply (args: GremlinGraphIndexPolicyArgs) =
                args.Automatic <- io automatic
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("excludedPaths")>]
        member _.ExcludedPaths((n, args), excludedPaths) =
            let apply (args: GremlinGraphIndexPolicyArgs) =
                args.ExcludedPaths <- inputList excludedPaths
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("includedPaths")>]
        member _.IncludedPaths((n, args), includedPaths) =
            let apply (args: GremlinGraphIndexPolicyArgs) =
                args.IncludedPaths <- inputList includedPaths
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("indexingMode")>]
        member _.IndexingMode((n, args), indexingMode) =
            let apply (args: GremlinGraphIndexPolicyArgs) =
                args.IndexingMode <- input indexingMode
                args

            ()
            n, List.Cons(apply, args)

        member _.IndexingMode((n, args), indexingMode) =
            let apply (args: GremlinGraphIndexPolicyArgs) =
                args.IndexingMode <- io indexingMode
                args

            ()
            n, List.Cons(apply, args)

    let gremlinGraphIndexPolicy = GremlinGraphIndexPolicyBuilder()

    type GremlinGraphUniqueKeyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (GremlinGraphUniqueKeyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("paths")>]
        member _.Paths((n, args), paths) =
            let apply (args: GremlinGraphUniqueKeyArgs) =
                args.Paths <- inputList paths
                args

            ()
            n, List.Cons(apply, args)

    let gremlinGraphUniqueKey = GremlinGraphUniqueKeyBuilder()

    type MongoCollectionIndexBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (MongoCollectionIndexArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("keys")>]
        member _.Keys((n, args), keys) =
            let apply (args: MongoCollectionIndexArgs) =
                args.Keys <- inputList keys
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("unique")>]
        member _.Unique((n, args), unique) =
            let apply (args: MongoCollectionIndexArgs) =
                args.Unique <- input unique
                args

            ()
            n, List.Cons(apply, args)

        member _.Unique((n, args), unique) =
            let apply (args: MongoCollectionIndexArgs) =
                args.Unique <- io unique
                args

            ()
            n, List.Cons(apply, args)

    let mongoCollectionIndex = MongoCollectionIndexBuilder()

    type MongoCollectionSystemIndexBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (MongoCollectionSystemIndexArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("keys")>]
        member _.Keys((n, args), keys) =
            let apply (args: MongoCollectionSystemIndexArgs) =
                args.Keys <- inputList keys
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("unique")>]
        member _.Unique((n, args), unique) =
            let apply (args: MongoCollectionSystemIndexArgs) =
                args.Unique <- input unique
                args

            ()
            n, List.Cons(apply, args)

        member _.Unique((n, args), unique) =
            let apply (args: MongoCollectionSystemIndexArgs) =
                args.Unique <- io unique
                args

            ()
            n, List.Cons(apply, args)

    let mongoCollectionSystemIndex = MongoCollectionSystemIndexBuilder()

    type SqlContainerUniqueKeyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SqlContainerUniqueKeyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("paths")>]
        member _.Paths((n, args), paths) =
            let apply (args: SqlContainerUniqueKeyArgs) =
                args.Paths <- inputList paths
                args

            ()
            n, List.Cons(apply, args)

    let sqlContainerUniqueKey = SqlContainerUniqueKeyBuilder()

    type AccountBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Account(name, (List.fold func (AccountArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("capabilities")>]
        member _.Capabilities((name, args), capabilities) =
            let apply (args: AccountArgs) =
                args.Capabilities <- inputList capabilities
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: AccountArgs) =
                   args.ConsistencyPolicy <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("enableAutomaticFailover")>]
        member _.EnableAutomaticFailover((name, args), enableAutomaticFailover) =
            let apply (args: AccountArgs) =
                args.EnableAutomaticFailover <- input enableAutomaticFailover
                args

            ()
            name, List.Cons(apply, args)

        member _.EnableAutomaticFailover((name, args), enableAutomaticFailover) =
            let apply (args: AccountArgs) =
                args.EnableAutomaticFailover <- io enableAutomaticFailover
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enableMultipleWriteLocations")>]
        member _.EnableMultipleWriteLocations((name, args), enableMultipleWriteLocations) =
            let apply (args: AccountArgs) =
                args.EnableMultipleWriteLocations <- input enableMultipleWriteLocations
                args

            ()
            name, List.Cons(apply, args)

        member _.EnableMultipleWriteLocations((name, args), enableMultipleWriteLocations) =
            let apply (args: AccountArgs) =
                args.EnableMultipleWriteLocations <- io enableMultipleWriteLocations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("geoLocations")>]
        member _.GeoLocations((name, args), geoLocations) =
            let apply (args: AccountArgs) =
                args.GeoLocations <- inputList geoLocations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("ipRangeFilter")>]
        member _.IpRangeFilter((name, args), ipRangeFilter) =
            let apply (args: AccountArgs) =
                args.IpRangeFilter <- input ipRangeFilter
                args

            ()
            name, List.Cons(apply, args)

        member _.IpRangeFilter((name, args), ipRangeFilter) =
            let apply (args: AccountArgs) =
                args.IpRangeFilter <- io ipRangeFilter
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("isVirtualNetworkFilterEnabled")>]
        member _.IsVirtualNetworkFilterEnabled((name, args), isVirtualNetworkFilterEnabled) =
            let apply (args: AccountArgs) =
                args.IsVirtualNetworkFilterEnabled <- input isVirtualNetworkFilterEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.IsVirtualNetworkFilterEnabled((name, args), isVirtualNetworkFilterEnabled) =
            let apply (args: AccountArgs) =
                args.IsVirtualNetworkFilterEnabled <- io isVirtualNetworkFilterEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("kind")>]
        member _.Kind((name, args), kind) =
            let apply (args: AccountArgs) =
                args.Kind <- input kind
                args

            ()
            name, List.Cons(apply, args)

        member _.Kind((name, args), kind) =
            let apply (args: AccountArgs) =
                args.Kind <- io kind
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: AccountArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: AccountArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: AccountArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: AccountArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("offerType")>]
        member _.OfferType((name, args), offerType) =
            let apply (args: AccountArgs) =
                args.OfferType <- input offerType
                args

            ()
            name, List.Cons(apply, args)

        member _.OfferType((name, args), offerType) =
            let apply (args: AccountArgs) =
                args.OfferType <- io offerType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AccountArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AccountArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: AccountArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkRules")>]
        member _.VirtualNetworkRules((name, args), virtualNetworkRules) =
            let apply (args: AccountArgs) =
                args.VirtualNetworkRules <- inputList virtualNetworkRules
                args

            ()
            name, List.Cons(apply, args)

    let account = AccountBuilder()

    type CassandraKeyspaceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            CassandraKeyspace(name, (List.fold func (CassandraKeyspaceArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("accountName")>]
        member _.AccountName((name, args), accountName) =
            let apply (args: CassandraKeyspaceArgs) =
                args.AccountName <- input accountName
                args

            ()
            name, List.Cons(apply, args)

        member _.AccountName((name, args), accountName) =
            let apply (args: CassandraKeyspaceArgs) =
                args.AccountName <- io accountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: CassandraKeyspaceArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: CassandraKeyspaceArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: CassandraKeyspaceArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: CassandraKeyspaceArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("throughput")>]
        member _.Throughput((name, args), throughput) =
            let apply (args: CassandraKeyspaceArgs) =
                args.Throughput <- input throughput
                args

            ()
            name, List.Cons(apply, args)

        member _.Throughput((name, args), throughput) =
            let apply (args: CassandraKeyspaceArgs) =
                args.Throughput <- io throughput
                args

            ()
            name, List.Cons(apply, args)

    let cassandraKeyspace = CassandraKeyspaceBuilder()

    type GremlinDatabaseBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            GremlinDatabase(name, (List.fold func (GremlinDatabaseArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("accountName")>]
        member _.AccountName((name, args), accountName) =
            let apply (args: GremlinDatabaseArgs) =
                args.AccountName <- input accountName
                args

            ()
            name, List.Cons(apply, args)

        member _.AccountName((name, args), accountName) =
            let apply (args: GremlinDatabaseArgs) =
                args.AccountName <- io accountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: GremlinDatabaseArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: GremlinDatabaseArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: GremlinDatabaseArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: GremlinDatabaseArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("throughput")>]
        member _.Throughput((name, args), throughput) =
            let apply (args: GremlinDatabaseArgs) =
                args.Throughput <- input throughput
                args

            ()
            name, List.Cons(apply, args)

        member _.Throughput((name, args), throughput) =
            let apply (args: GremlinDatabaseArgs) =
                args.Throughput <- io throughput
                args

            ()
            name, List.Cons(apply, args)

    let gremlinDatabase = GremlinDatabaseBuilder()

    type GremlinGraphBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            GremlinGraph(name, (List.fold func (GremlinGraphArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("accountName")>]
        member _.AccountName((name, args), accountName) =
            let apply (args: GremlinGraphArgs) =
                args.AccountName <- input accountName
                args

            ()
            name, List.Cons(apply, args)

        member _.AccountName((name, args), accountName) =
            let apply (args: GremlinGraphArgs) =
                args.AccountName <- io accountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("conflictResolutionPolicies")>]
        member _.ConflictResolutionPolicies((name, args), conflictResolutionPolicies) =
            let apply (args: GremlinGraphArgs) =
                args.ConflictResolutionPolicies <- inputList conflictResolutionPolicies
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("databaseName")>]
        member _.DatabaseName((name, args), databaseName) =
            let apply (args: GremlinGraphArgs) =
                args.DatabaseName <- input databaseName
                args

            ()
            name, List.Cons(apply, args)

        member _.DatabaseName((name, args), databaseName) =
            let apply (args: GremlinGraphArgs) =
                args.DatabaseName <- io databaseName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("indexPolicies")>]
        member _.IndexPolicies((name, args), indexPolicies) =
            let apply (args: GremlinGraphArgs) =
                args.IndexPolicies <- inputList indexPolicies
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: GremlinGraphArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: GremlinGraphArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("partitionKeyPath")>]
        member _.PartitionKeyPath((name, args), partitionKeyPath) =
            let apply (args: GremlinGraphArgs) =
                args.PartitionKeyPath <- input partitionKeyPath
                args

            ()
            name, List.Cons(apply, args)

        member _.PartitionKeyPath((name, args), partitionKeyPath) =
            let apply (args: GremlinGraphArgs) =
                args.PartitionKeyPath <- io partitionKeyPath
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: GremlinGraphArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: GremlinGraphArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("throughput")>]
        member _.Throughput((name, args), throughput) =
            let apply (args: GremlinGraphArgs) =
                args.Throughput <- input throughput
                args

            ()
            name, List.Cons(apply, args)

        member _.Throughput((name, args), throughput) =
            let apply (args: GremlinGraphArgs) =
                args.Throughput <- io throughput
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("uniqueKeys")>]
        member _.UniqueKeys((name, args), uniqueKeys) =
            let apply (args: GremlinGraphArgs) =
                args.UniqueKeys <- inputList uniqueKeys
                args

            ()
            name, List.Cons(apply, args)

    let gremlinGraph = GremlinGraphBuilder()

    type MongoCollectionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            MongoCollection(name, (List.fold func (MongoCollectionArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("accountName")>]
        member _.AccountName((name, args), accountName) =
            let apply (args: MongoCollectionArgs) =
                args.AccountName <- input accountName
                args

            ()
            name, List.Cons(apply, args)

        member _.AccountName((name, args), accountName) =
            let apply (args: MongoCollectionArgs) =
                args.AccountName <- io accountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("databaseName")>]
        member _.DatabaseName((name, args), databaseName) =
            let apply (args: MongoCollectionArgs) =
                args.DatabaseName <- input databaseName
                args

            ()
            name, List.Cons(apply, args)

        member _.DatabaseName((name, args), databaseName) =
            let apply (args: MongoCollectionArgs) =
                args.DatabaseName <- io databaseName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("defaultTtlSeconds")>]
        member _.DefaultTtlSeconds((name, args), defaultTtlSeconds) =
            let apply (args: MongoCollectionArgs) =
                args.DefaultTtlSeconds <- input defaultTtlSeconds
                args

            ()
            name, List.Cons(apply, args)

        member _.DefaultTtlSeconds((name, args), defaultTtlSeconds) =
            let apply (args: MongoCollectionArgs) =
                args.DefaultTtlSeconds <- io defaultTtlSeconds
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("indices")>]
        member _.Indices((name, args), indices) =
            let apply (args: MongoCollectionArgs) =
                args.Indices <- inputList indices
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: MongoCollectionArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: MongoCollectionArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: MongoCollectionArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: MongoCollectionArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("shardKey")>]
        member _.ShardKey((name, args), shardKey) =
            let apply (args: MongoCollectionArgs) =
                args.ShardKey <- input shardKey
                args

            ()
            name, List.Cons(apply, args)

        member _.ShardKey((name, args), shardKey) =
            let apply (args: MongoCollectionArgs) =
                args.ShardKey <- io shardKey
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("throughput")>]
        member _.Throughput((name, args), throughput) =
            let apply (args: MongoCollectionArgs) =
                args.Throughput <- input throughput
                args

            ()
            name, List.Cons(apply, args)

        member _.Throughput((name, args), throughput) =
            let apply (args: MongoCollectionArgs) =
                args.Throughput <- io throughput
                args

            ()
            name, List.Cons(apply, args)

    let mongoCollection = MongoCollectionBuilder()

    type MongoDatabaseBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            MongoDatabase(name, (List.fold func (MongoDatabaseArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("accountName")>]
        member _.AccountName((name, args), accountName) =
            let apply (args: MongoDatabaseArgs) =
                args.AccountName <- input accountName
                args

            ()
            name, List.Cons(apply, args)

        member _.AccountName((name, args), accountName) =
            let apply (args: MongoDatabaseArgs) =
                args.AccountName <- io accountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: MongoDatabaseArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: MongoDatabaseArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: MongoDatabaseArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: MongoDatabaseArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("throughput")>]
        member _.Throughput((name, args), throughput) =
            let apply (args: MongoDatabaseArgs) =
                args.Throughput <- input throughput
                args

            ()
            name, List.Cons(apply, args)

        member _.Throughput((name, args), throughput) =
            let apply (args: MongoDatabaseArgs) =
                args.Throughput <- io throughput
                args

            ()
            name, List.Cons(apply, args)

    let mongoDatabase = MongoDatabaseBuilder()

    type SqlContainerBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            SqlContainer(name, (List.fold func (SqlContainerArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("accountName")>]
        member _.AccountName((name, args), accountName) =
            let apply (args: SqlContainerArgs) =
                args.AccountName <- input accountName
                args

            ()
            name, List.Cons(apply, args)

        member _.AccountName((name, args), accountName) =
            let apply (args: SqlContainerArgs) =
                args.AccountName <- io accountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("databaseName")>]
        member _.DatabaseName((name, args), databaseName) =
            let apply (args: SqlContainerArgs) =
                args.DatabaseName <- input databaseName
                args

            ()
            name, List.Cons(apply, args)

        member _.DatabaseName((name, args), databaseName) =
            let apply (args: SqlContainerArgs) =
                args.DatabaseName <- io databaseName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("defaultTtl")>]
        member _.DefaultTtl((name, args), defaultTtl) =
            let apply (args: SqlContainerArgs) =
                args.DefaultTtl <- input defaultTtl
                args

            ()
            name, List.Cons(apply, args)

        member _.DefaultTtl((name, args), defaultTtl) =
            let apply (args: SqlContainerArgs) =
                args.DefaultTtl <- io defaultTtl
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: SqlContainerArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: SqlContainerArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("partitionKeyPath")>]
        member _.PartitionKeyPath((name, args), partitionKeyPath) =
            let apply (args: SqlContainerArgs) =
                args.PartitionKeyPath <- input partitionKeyPath
                args

            ()
            name, List.Cons(apply, args)

        member _.PartitionKeyPath((name, args), partitionKeyPath) =
            let apply (args: SqlContainerArgs) =
                args.PartitionKeyPath <- io partitionKeyPath
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SqlContainerArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SqlContainerArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("throughput")>]
        member _.Throughput((name, args), throughput) =
            let apply (args: SqlContainerArgs) =
                args.Throughput <- input throughput
                args

            ()
            name, List.Cons(apply, args)

        member _.Throughput((name, args), throughput) =
            let apply (args: SqlContainerArgs) =
                args.Throughput <- io throughput
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("uniqueKeys")>]
        member _.UniqueKeys((name, args), uniqueKeys) =
            let apply (args: SqlContainerArgs) =
                args.UniqueKeys <- inputList uniqueKeys
                args

            ()
            name, List.Cons(apply, args)

    let sqlContainer = SqlContainerBuilder()

    type SqlDatabaseBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            SqlDatabase(name, (List.fold func (SqlDatabaseArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("accountName")>]
        member _.AccountName((name, args), accountName) =
            let apply (args: SqlDatabaseArgs) =
                args.AccountName <- input accountName
                args

            ()
            name, List.Cons(apply, args)

        member _.AccountName((name, args), accountName) =
            let apply (args: SqlDatabaseArgs) =
                args.AccountName <- io accountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: SqlDatabaseArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: SqlDatabaseArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SqlDatabaseArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SqlDatabaseArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("throughput")>]
        member _.Throughput((name, args), throughput) =
            let apply (args: SqlDatabaseArgs) =
                args.Throughput <- input throughput
                args

            ()
            name, List.Cons(apply, args)

        member _.Throughput((name, args), throughput) =
            let apply (args: SqlDatabaseArgs) =
                args.Throughput <- io throughput
                args

            ()
            name, List.Cons(apply, args)

    let sqlDatabase = SqlDatabaseBuilder()

    type TableBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Table(name, (List.fold func (TableArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("accountName")>]
        member _.AccountName((name, args), accountName) =
            let apply (args: TableArgs) =
                args.AccountName <- input accountName
                args

            ()
            name, List.Cons(apply, args)

        member _.AccountName((name, args), accountName) =
            let apply (args: TableArgs) =
                args.AccountName <- io accountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: TableArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: TableArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: TableArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: TableArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("throughput")>]
        member _.Throughput((name, args), throughput) =
            let apply (args: TableArgs) =
                args.Throughput <- input throughput
                args

            ()
            name, List.Cons(apply, args)

        member _.Throughput((name, args), throughput) =
            let apply (args: TableArgs) =
                args.Throughput <- io throughput
                args

            ()
            name, List.Cons(apply, args)

    let table = TableBuilder()

module CostManagement =
    open Pulumi.Azure.CostManagement
    open Pulumi.Azure.CostManagement.Inputs

    type ResourceGroupExportDeliveryInfoBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ResourceGroupExportDeliveryInfoArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("containerName")>]
        member _.ContainerName((n, args), containerName) =
            let apply (args: ResourceGroupExportDeliveryInfoArgs) =
                args.ContainerName <- input containerName
                args

            ()
            n, List.Cons(apply, args)

        member _.ContainerName((n, args), containerName) =
            let apply (args: ResourceGroupExportDeliveryInfoArgs) =
                args.ContainerName <- io containerName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("rootFolderPath")>]
        member _.RootFolderPath((n, args), rootFolderPath) =
            let apply (args: ResourceGroupExportDeliveryInfoArgs) =
                args.RootFolderPath <- input rootFolderPath
                args

            ()
            n, List.Cons(apply, args)

        member _.RootFolderPath((n, args), rootFolderPath) =
            let apply (args: ResourceGroupExportDeliveryInfoArgs) =
                args.RootFolderPath <- io rootFolderPath
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageAccountId")>]
        member _.StorageAccountId((n, args), storageAccountId) =
            let apply (args: ResourceGroupExportDeliveryInfoArgs) =
                args.StorageAccountId <- input storageAccountId
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountId((n, args), storageAccountId) =
            let apply (args: ResourceGroupExportDeliveryInfoArgs) =
                args.StorageAccountId <- io storageAccountId
                args

            ()
            n, List.Cons(apply, args)

    let resourceGroupExportDeliveryInfo = ResourceGroupExportDeliveryInfoBuilder()

    type ResourceGroupExportQueryBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ResourceGroupExportQueryArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("timeFrame")>]
        member _.TimeFrame((n, args), timeFrame) =
            let apply (args: ResourceGroupExportQueryArgs) =
                args.TimeFrame <- input timeFrame
                args

            ()
            n, List.Cons(apply, args)

        member _.TimeFrame((n, args), timeFrame) =
            let apply (args: ResourceGroupExportQueryArgs) =
                args.TimeFrame <- io timeFrame
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: ResourceGroupExportQueryArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: ResourceGroupExportQueryArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let resourceGroupExportQuery = ResourceGroupExportQueryBuilder()

    type ResourceGroupExportBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ResourceGroupExport(name, (List.fold func (ResourceGroupExportArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("active")>]
        member _.Active((name, args), active) =
            let apply (args: ResourceGroupExportArgs) =
                args.Active <- input active
                args

            ()
            name, List.Cons(apply, args)

        member _.Active((name, args), active) =
            let apply (args: ResourceGroupExportArgs) =
                args.Active <- io active
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ResourceGroupExportArgs) =
                   args.DeliveryInfo <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ResourceGroupExportArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ResourceGroupExportArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ResourceGroupExportArgs) =
                   args.Query <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("recurrencePeriodEnd")>]
        member _.RecurrencePeriodEnd((name, args), recurrencePeriodEnd) =
            let apply (args: ResourceGroupExportArgs) =
                args.RecurrencePeriodEnd <- input recurrencePeriodEnd
                args

            ()
            name, List.Cons(apply, args)

        member _.RecurrencePeriodEnd((name, args), recurrencePeriodEnd) =
            let apply (args: ResourceGroupExportArgs) =
                args.RecurrencePeriodEnd <- io recurrencePeriodEnd
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("recurrencePeriodStart")>]
        member _.RecurrencePeriodStart((name, args), recurrencePeriodStart) =
            let apply (args: ResourceGroupExportArgs) =
                args.RecurrencePeriodStart <- input recurrencePeriodStart
                args

            ()
            name, List.Cons(apply, args)

        member _.RecurrencePeriodStart((name, args), recurrencePeriodStart) =
            let apply (args: ResourceGroupExportArgs) =
                args.RecurrencePeriodStart <- io recurrencePeriodStart
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("recurrenceType")>]
        member _.RecurrenceType((name, args), recurrenceType) =
            let apply (args: ResourceGroupExportArgs) =
                args.RecurrenceType <- input recurrenceType
                args

            ()
            name, List.Cons(apply, args)

        member _.RecurrenceType((name, args), recurrenceType) =
            let apply (args: ResourceGroupExportArgs) =
                args.RecurrenceType <- io recurrenceType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroupId")>]
        member _.ResourceGroupId((name, args), resourceGroupId) =
            let apply (args: ResourceGroupExportArgs) =
                args.ResourceGroupId <- input resourceGroupId
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroupId((name, args), resourceGroupId) =
            let apply (args: ResourceGroupExportArgs) =
                args.ResourceGroupId <- io resourceGroupId
                args

            ()
            name, List.Cons(apply, args)

    let resourceGroupExport = ResourceGroupExportBuilder()

module DataBricks =
    open Pulumi.Azure.DataBricks
    open Pulumi.Azure.DataBricks.Inputs

    type WorkspaceCustomParametersBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (WorkspaceCustomParametersArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("noPublicIp")>]
        member _.NoPublicIp((n, args), noPublicIp) =
            let apply (args: WorkspaceCustomParametersArgs) =
                args.NoPublicIp <- input noPublicIp
                args

            ()
            n, List.Cons(apply, args)

        member _.NoPublicIp((n, args), noPublicIp) =
            let apply (args: WorkspaceCustomParametersArgs) =
                args.NoPublicIp <- io noPublicIp
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("privateSubnetName")>]
        member _.PrivateSubnetName((n, args), privateSubnetName) =
            let apply (args: WorkspaceCustomParametersArgs) =
                args.PrivateSubnetName <- input privateSubnetName
                args

            ()
            n, List.Cons(apply, args)

        member _.PrivateSubnetName((n, args), privateSubnetName) =
            let apply (args: WorkspaceCustomParametersArgs) =
                args.PrivateSubnetName <- io privateSubnetName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publicSubnetName")>]
        member _.PublicSubnetName((n, args), publicSubnetName) =
            let apply (args: WorkspaceCustomParametersArgs) =
                args.PublicSubnetName <- input publicSubnetName
                args

            ()
            n, List.Cons(apply, args)

        member _.PublicSubnetName((n, args), publicSubnetName) =
            let apply (args: WorkspaceCustomParametersArgs) =
                args.PublicSubnetName <- io publicSubnetName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkId")>]
        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: WorkspaceCustomParametersArgs) =
                args.VirtualNetworkId <- input virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: WorkspaceCustomParametersArgs) =
                args.VirtualNetworkId <- io virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

    let workspaceCustomParameters = WorkspaceCustomParametersBuilder()

    type WorkspaceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Workspace(name, (List.fold func (WorkspaceArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: WorkspaceArgs) =
                   args.CustomParameters <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: WorkspaceArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: WorkspaceArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("managedResourceGroupName")>]
        member _.ManagedResourceGroupName((name, args), managedResourceGroupName) =
            let apply (args: WorkspaceArgs) =
                args.ManagedResourceGroupName <- input managedResourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ManagedResourceGroupName((name, args), managedResourceGroupName) =
            let apply (args: WorkspaceArgs) =
                args.ManagedResourceGroupName <- io managedResourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: WorkspaceArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: WorkspaceArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: WorkspaceArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: WorkspaceArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sku")>]
        member _.Sku((name, args), sku) =
            let apply (args: WorkspaceArgs) =
                args.Sku <- input sku
                args

            ()
            name, List.Cons(apply, args)

        member _.Sku((name, args), sku) =
            let apply (args: WorkspaceArgs) =
                args.Sku <- io sku
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: WorkspaceArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let workspace = WorkspaceBuilder()

module DataFactory =
    open Pulumi.Azure.DataFactory
    open Pulumi.Azure.DataFactory.Inputs

    type DatasetMysqlSchemaColumnBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (DatasetMysqlSchemaColumnArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("description")>]
        member _.Description((n, args), description) =
            let apply (args: DatasetMysqlSchemaColumnArgs) =
                args.Description <- input description
                args

            ()
            n, List.Cons(apply, args)

        member _.Description((n, args), description) =
            let apply (args: DatasetMysqlSchemaColumnArgs) =
                args.Description <- io description
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: DatasetMysqlSchemaColumnArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: DatasetMysqlSchemaColumnArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: DatasetMysqlSchemaColumnArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: DatasetMysqlSchemaColumnArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let datasetMysqlSchemaColumn = DatasetMysqlSchemaColumnBuilder()

    type DatasetPostgresqlSchemaColumnBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (DatasetPostgresqlSchemaColumnArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("description")>]
        member _.Description((n, args), description) =
            let apply (args: DatasetPostgresqlSchemaColumnArgs) =
                args.Description <- input description
                args

            ()
            n, List.Cons(apply, args)

        member _.Description((n, args), description) =
            let apply (args: DatasetPostgresqlSchemaColumnArgs) =
                args.Description <- io description
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: DatasetPostgresqlSchemaColumnArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: DatasetPostgresqlSchemaColumnArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: DatasetPostgresqlSchemaColumnArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: DatasetPostgresqlSchemaColumnArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let datasetPostgresqlSchemaColumn = DatasetPostgresqlSchemaColumnBuilder()

    type DatasetSqlServerTableSchemaColumnBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (DatasetSqlServerTableSchemaColumnArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("description")>]
        member _.Description((n, args), description) =
            let apply (args: DatasetSqlServerTableSchemaColumnArgs) =
                args.Description <- input description
                args

            ()
            n, List.Cons(apply, args)

        member _.Description((n, args), description) =
            let apply (args: DatasetSqlServerTableSchemaColumnArgs) =
                args.Description <- io description
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: DatasetSqlServerTableSchemaColumnArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: DatasetSqlServerTableSchemaColumnArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: DatasetSqlServerTableSchemaColumnArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: DatasetSqlServerTableSchemaColumnArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let datasetSqlServerTableSchemaColumn =
        DatasetSqlServerTableSchemaColumnBuilder()

    type FactoryGithubConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FactoryGithubConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("accountName")>]
        member _.AccountName((n, args), accountName) =
            let apply (args: FactoryGithubConfigurationArgs) =
                args.AccountName <- input accountName
                args

            ()
            n, List.Cons(apply, args)

        member _.AccountName((n, args), accountName) =
            let apply (args: FactoryGithubConfigurationArgs) =
                args.AccountName <- io accountName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("branchName")>]
        member _.BranchName((n, args), branchName) =
            let apply (args: FactoryGithubConfigurationArgs) =
                args.BranchName <- input branchName
                args

            ()
            n, List.Cons(apply, args)

        member _.BranchName((n, args), branchName) =
            let apply (args: FactoryGithubConfigurationArgs) =
                args.BranchName <- io branchName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("gitUrl")>]
        member _.GitUrl((n, args), gitUrl) =
            let apply (args: FactoryGithubConfigurationArgs) =
                args.GitUrl <- input gitUrl
                args

            ()
            n, List.Cons(apply, args)

        member _.GitUrl((n, args), gitUrl) =
            let apply (args: FactoryGithubConfigurationArgs) =
                args.GitUrl <- io gitUrl
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("repositoryName")>]
        member _.RepositoryName((n, args), repositoryName) =
            let apply (args: FactoryGithubConfigurationArgs) =
                args.RepositoryName <- input repositoryName
                args

            ()
            n, List.Cons(apply, args)

        member _.RepositoryName((n, args), repositoryName) =
            let apply (args: FactoryGithubConfigurationArgs) =
                args.RepositoryName <- io repositoryName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("rootFolder")>]
        member _.RootFolder((n, args), rootFolder) =
            let apply (args: FactoryGithubConfigurationArgs) =
                args.RootFolder <- input rootFolder
                args

            ()
            n, List.Cons(apply, args)

        member _.RootFolder((n, args), rootFolder) =
            let apply (args: FactoryGithubConfigurationArgs) =
                args.RootFolder <- io rootFolder
                args

            ()
            n, List.Cons(apply, args)

    let factoryGithubConfiguration = FactoryGithubConfigurationBuilder()

    type FactoryIdentityBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FactoryIdentityArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("principalId")>]
        member _.PrincipalId((n, args), principalId) =
            let apply (args: FactoryIdentityArgs) =
                args.PrincipalId <- input principalId
                args

            ()
            n, List.Cons(apply, args)

        member _.PrincipalId((n, args), principalId) =
            let apply (args: FactoryIdentityArgs) =
                args.PrincipalId <- io principalId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tenantId")>]
        member _.TenantId((n, args), tenantId) =
            let apply (args: FactoryIdentityArgs) =
                args.TenantId <- input tenantId
                args

            ()
            n, List.Cons(apply, args)

        member _.TenantId((n, args), tenantId) =
            let apply (args: FactoryIdentityArgs) =
                args.TenantId <- io tenantId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: FactoryIdentityArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: FactoryIdentityArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let factoryIdentity = FactoryIdentityBuilder()

    type FactoryVstsConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FactoryVstsConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("accountName")>]
        member _.AccountName((n, args), accountName) =
            let apply (args: FactoryVstsConfigurationArgs) =
                args.AccountName <- input accountName
                args

            ()
            n, List.Cons(apply, args)

        member _.AccountName((n, args), accountName) =
            let apply (args: FactoryVstsConfigurationArgs) =
                args.AccountName <- io accountName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("branchName")>]
        member _.BranchName((n, args), branchName) =
            let apply (args: FactoryVstsConfigurationArgs) =
                args.BranchName <- input branchName
                args

            ()
            n, List.Cons(apply, args)

        member _.BranchName((n, args), branchName) =
            let apply (args: FactoryVstsConfigurationArgs) =
                args.BranchName <- io branchName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("projectName")>]
        member _.ProjectName((n, args), projectName) =
            let apply (args: FactoryVstsConfigurationArgs) =
                args.ProjectName <- input projectName
                args

            ()
            n, List.Cons(apply, args)

        member _.ProjectName((n, args), projectName) =
            let apply (args: FactoryVstsConfigurationArgs) =
                args.ProjectName <- io projectName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("repositoryName")>]
        member _.RepositoryName((n, args), repositoryName) =
            let apply (args: FactoryVstsConfigurationArgs) =
                args.RepositoryName <- input repositoryName
                args

            ()
            n, List.Cons(apply, args)

        member _.RepositoryName((n, args), repositoryName) =
            let apply (args: FactoryVstsConfigurationArgs) =
                args.RepositoryName <- io repositoryName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("rootFolder")>]
        member _.RootFolder((n, args), rootFolder) =
            let apply (args: FactoryVstsConfigurationArgs) =
                args.RootFolder <- input rootFolder
                args

            ()
            n, List.Cons(apply, args)

        member _.RootFolder((n, args), rootFolder) =
            let apply (args: FactoryVstsConfigurationArgs) =
                args.RootFolder <- io rootFolder
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tenantId")>]
        member _.TenantId((n, args), tenantId) =
            let apply (args: FactoryVstsConfigurationArgs) =
                args.TenantId <- input tenantId
                args

            ()
            n, List.Cons(apply, args)

        member _.TenantId((n, args), tenantId) =
            let apply (args: FactoryVstsConfigurationArgs) =
                args.TenantId <- io tenantId
                args

            ()
            n, List.Cons(apply, args)

    let factoryVstsConfiguration = FactoryVstsConfigurationBuilder()

    type IntegrationRuntimeManagedCatalogInfoBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (IntegrationRuntimeManagedCatalogInfoArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("administratorLogin")>]
        member _.AdministratorLogin((n, args), administratorLogin) =
            let apply (args: IntegrationRuntimeManagedCatalogInfoArgs) =
                args.AdministratorLogin <- input administratorLogin
                args

            ()
            n, List.Cons(apply, args)

        member _.AdministratorLogin((n, args), administratorLogin) =
            let apply (args: IntegrationRuntimeManagedCatalogInfoArgs) =
                args.AdministratorLogin <- io administratorLogin
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("administratorPassword")>]
        member _.AdministratorPassword((n, args), administratorPassword) =
            let apply (args: IntegrationRuntimeManagedCatalogInfoArgs) =
                args.AdministratorPassword <- input administratorPassword
                args

            ()
            n, List.Cons(apply, args)

        member _.AdministratorPassword((n, args), administratorPassword) =
            let apply (args: IntegrationRuntimeManagedCatalogInfoArgs) =
                args.AdministratorPassword <- io administratorPassword
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("pricingTier")>]
        member _.PricingTier((n, args), pricingTier) =
            let apply (args: IntegrationRuntimeManagedCatalogInfoArgs) =
                args.PricingTier <- input pricingTier
                args

            ()
            n, List.Cons(apply, args)

        member _.PricingTier((n, args), pricingTier) =
            let apply (args: IntegrationRuntimeManagedCatalogInfoArgs) =
                args.PricingTier <- io pricingTier
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("serverEndpoint")>]
        member _.ServerEndpoint((n, args), serverEndpoint) =
            let apply (args: IntegrationRuntimeManagedCatalogInfoArgs) =
                args.ServerEndpoint <- input serverEndpoint
                args

            ()
            n, List.Cons(apply, args)

        member _.ServerEndpoint((n, args), serverEndpoint) =
            let apply (args: IntegrationRuntimeManagedCatalogInfoArgs) =
                args.ServerEndpoint <- io serverEndpoint
                args

            ()
            n, List.Cons(apply, args)

    let integrationRuntimeManagedCatalogInfo =
        IntegrationRuntimeManagedCatalogInfoBuilder()

    type IntegrationRuntimeManagedCustomSetupScriptBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (IntegrationRuntimeManagedCustomSetupScriptArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("blobContainerUri")>]
        member _.BlobContainerUri((n, args), blobContainerUri) =
            let apply (args: IntegrationRuntimeManagedCustomSetupScriptArgs) =
                args.BlobContainerUri <- input blobContainerUri
                args

            ()
            n, List.Cons(apply, args)

        member _.BlobContainerUri((n, args), blobContainerUri) =
            let apply (args: IntegrationRuntimeManagedCustomSetupScriptArgs) =
                args.BlobContainerUri <- io blobContainerUri
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sasToken")>]
        member _.SasToken((n, args), sasToken) =
            let apply (args: IntegrationRuntimeManagedCustomSetupScriptArgs) =
                args.SasToken <- input sasToken
                args

            ()
            n, List.Cons(apply, args)

        member _.SasToken((n, args), sasToken) =
            let apply (args: IntegrationRuntimeManagedCustomSetupScriptArgs) =
                args.SasToken <- io sasToken
                args

            ()
            n, List.Cons(apply, args)

    let integrationRuntimeManagedCustomSetupScript =
        IntegrationRuntimeManagedCustomSetupScriptBuilder()

    type IntegrationRuntimeManagedVnetIntegrationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (IntegrationRuntimeManagedVnetIntegrationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("subnetName")>]
        member _.SubnetName((n, args), subnetName) =
            let apply (args: IntegrationRuntimeManagedVnetIntegrationArgs) =
                args.SubnetName <- input subnetName
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetName((n, args), subnetName) =
            let apply (args: IntegrationRuntimeManagedVnetIntegrationArgs) =
                args.SubnetName <- io subnetName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vnetId")>]
        member _.VnetId((n, args), vnetId) =
            let apply (args: IntegrationRuntimeManagedVnetIntegrationArgs) =
                args.VnetId <- input vnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.VnetId((n, args), vnetId) =
            let apply (args: IntegrationRuntimeManagedVnetIntegrationArgs) =
                args.VnetId <- io vnetId
                args

            ()
            n, List.Cons(apply, args)

    let integrationRuntimeManagedVnetIntegration =
        IntegrationRuntimeManagedVnetIntegrationBuilder()

    type IntegrationRuntimeSelfHostedRbacAuthorizationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (IntegrationRuntimeSelfHostedRbacAuthorizationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("resourceId")>]
        member _.ResourceId((n, args), resourceId) =
            let apply (args: IntegrationRuntimeSelfHostedRbacAuthorizationArgs) =
                args.ResourceId <- input resourceId
                args

            ()
            n, List.Cons(apply, args)

        member _.ResourceId((n, args), resourceId) =
            let apply (args: IntegrationRuntimeSelfHostedRbacAuthorizationArgs) =
                args.ResourceId <- io resourceId
                args

            ()
            n, List.Cons(apply, args)

    let integrationRuntimeSelfHostedRbacAuthorization =
        IntegrationRuntimeSelfHostedRbacAuthorizationBuilder()

    type DatasetMysqlBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            DatasetMysql(name, (List.fold func (DatasetMysqlArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("additionalProperties")>]
        member _.AdditionalProperties((name, args), additionalProperties) =
            let apply (args: DatasetMysqlArgs) =
                args.AdditionalProperties <- inputMap additionalProperties
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("annotations")>]
        member _.Annotations((name, args), annotations) =
            let apply (args: DatasetMysqlArgs) =
                args.Annotations <- inputList annotations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("dataFactoryName")>]
        member _.DataFactoryName((name, args), dataFactoryName) =
            let apply (args: DatasetMysqlArgs) =
                args.DataFactoryName <- input dataFactoryName
                args

            ()
            name, List.Cons(apply, args)

        member _.DataFactoryName((name, args), dataFactoryName) =
            let apply (args: DatasetMysqlArgs) =
                args.DataFactoryName <- io dataFactoryName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: DatasetMysqlArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: DatasetMysqlArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("folder")>]
        member _.Folder((name, args), folder) =
            let apply (args: DatasetMysqlArgs) =
                args.Folder <- input folder
                args

            ()
            name, List.Cons(apply, args)

        member _.Folder((name, args), folder) =
            let apply (args: DatasetMysqlArgs) =
                args.Folder <- io folder
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("linkedServiceName")>]
        member _.LinkedServiceName((name, args), linkedServiceName) =
            let apply (args: DatasetMysqlArgs) =
                args.LinkedServiceName <- input linkedServiceName
                args

            ()
            name, List.Cons(apply, args)

        member _.LinkedServiceName((name, args), linkedServiceName) =
            let apply (args: DatasetMysqlArgs) =
                args.LinkedServiceName <- io linkedServiceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: DatasetMysqlArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: DatasetMysqlArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("parameters")>]
        member _.Parameters((name, args), parameters) =
            let apply (args: DatasetMysqlArgs) =
                args.Parameters <- inputMap parameters
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DatasetMysqlArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DatasetMysqlArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("schemaColumns")>]
        member _.SchemaColumns((name, args), schemaColumns) =
            let apply (args: DatasetMysqlArgs) =
                args.SchemaColumns <- inputList schemaColumns
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tableName")>]
        member _.TableName((name, args), tableName) =
            let apply (args: DatasetMysqlArgs) =
                args.TableName <- input tableName
                args

            ()
            name, List.Cons(apply, args)

        member _.TableName((name, args), tableName) =
            let apply (args: DatasetMysqlArgs) =
                args.TableName <- io tableName
                args

            ()
            name, List.Cons(apply, args)

    let datasetMysql = DatasetMysqlBuilder()

    type DatasetPostgresqlBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            DatasetPostgresql(name, (List.fold func (DatasetPostgresqlArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("additionalProperties")>]
        member _.AdditionalProperties((name, args), additionalProperties) =
            let apply (args: DatasetPostgresqlArgs) =
                args.AdditionalProperties <- inputMap additionalProperties
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("annotations")>]
        member _.Annotations((name, args), annotations) =
            let apply (args: DatasetPostgresqlArgs) =
                args.Annotations <- inputList annotations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("dataFactoryName")>]
        member _.DataFactoryName((name, args), dataFactoryName) =
            let apply (args: DatasetPostgresqlArgs) =
                args.DataFactoryName <- input dataFactoryName
                args

            ()
            name, List.Cons(apply, args)

        member _.DataFactoryName((name, args), dataFactoryName) =
            let apply (args: DatasetPostgresqlArgs) =
                args.DataFactoryName <- io dataFactoryName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: DatasetPostgresqlArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: DatasetPostgresqlArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("folder")>]
        member _.Folder((name, args), folder) =
            let apply (args: DatasetPostgresqlArgs) =
                args.Folder <- input folder
                args

            ()
            name, List.Cons(apply, args)

        member _.Folder((name, args), folder) =
            let apply (args: DatasetPostgresqlArgs) =
                args.Folder <- io folder
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("linkedServiceName")>]
        member _.LinkedServiceName((name, args), linkedServiceName) =
            let apply (args: DatasetPostgresqlArgs) =
                args.LinkedServiceName <- input linkedServiceName
                args

            ()
            name, List.Cons(apply, args)

        member _.LinkedServiceName((name, args), linkedServiceName) =
            let apply (args: DatasetPostgresqlArgs) =
                args.LinkedServiceName <- io linkedServiceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: DatasetPostgresqlArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: DatasetPostgresqlArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("parameters")>]
        member _.Parameters((name, args), parameters) =
            let apply (args: DatasetPostgresqlArgs) =
                args.Parameters <- inputMap parameters
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DatasetPostgresqlArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DatasetPostgresqlArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("schemaColumns")>]
        member _.SchemaColumns((name, args), schemaColumns) =
            let apply (args: DatasetPostgresqlArgs) =
                args.SchemaColumns <- inputList schemaColumns
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tableName")>]
        member _.TableName((name, args), tableName) =
            let apply (args: DatasetPostgresqlArgs) =
                args.TableName <- input tableName
                args

            ()
            name, List.Cons(apply, args)

        member _.TableName((name, args), tableName) =
            let apply (args: DatasetPostgresqlArgs) =
                args.TableName <- io tableName
                args

            ()
            name, List.Cons(apply, args)

    let datasetPostgresql = DatasetPostgresqlBuilder()

    type DatasetSqlServerTableBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            DatasetSqlServerTable(name, (List.fold func (DatasetSqlServerTableArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("additionalProperties")>]
        member _.AdditionalProperties((name, args), additionalProperties) =
            let apply (args: DatasetSqlServerTableArgs) =
                args.AdditionalProperties <- inputMap additionalProperties
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("annotations")>]
        member _.Annotations((name, args), annotations) =
            let apply (args: DatasetSqlServerTableArgs) =
                args.Annotations <- inputList annotations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("dataFactoryName")>]
        member _.DataFactoryName((name, args), dataFactoryName) =
            let apply (args: DatasetSqlServerTableArgs) =
                args.DataFactoryName <- input dataFactoryName
                args

            ()
            name, List.Cons(apply, args)

        member _.DataFactoryName((name, args), dataFactoryName) =
            let apply (args: DatasetSqlServerTableArgs) =
                args.DataFactoryName <- io dataFactoryName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: DatasetSqlServerTableArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: DatasetSqlServerTableArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("folder")>]
        member _.Folder((name, args), folder) =
            let apply (args: DatasetSqlServerTableArgs) =
                args.Folder <- input folder
                args

            ()
            name, List.Cons(apply, args)

        member _.Folder((name, args), folder) =
            let apply (args: DatasetSqlServerTableArgs) =
                args.Folder <- io folder
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("linkedServiceName")>]
        member _.LinkedServiceName((name, args), linkedServiceName) =
            let apply (args: DatasetSqlServerTableArgs) =
                args.LinkedServiceName <- input linkedServiceName
                args

            ()
            name, List.Cons(apply, args)

        member _.LinkedServiceName((name, args), linkedServiceName) =
            let apply (args: DatasetSqlServerTableArgs) =
                args.LinkedServiceName <- io linkedServiceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: DatasetSqlServerTableArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: DatasetSqlServerTableArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("parameters")>]
        member _.Parameters((name, args), parameters) =
            let apply (args: DatasetSqlServerTableArgs) =
                args.Parameters <- inputMap parameters
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DatasetSqlServerTableArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DatasetSqlServerTableArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("schemaColumns")>]
        member _.SchemaColumns((name, args), schemaColumns) =
            let apply (args: DatasetSqlServerTableArgs) =
                args.SchemaColumns <- inputList schemaColumns
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tableName")>]
        member _.TableName((name, args), tableName) =
            let apply (args: DatasetSqlServerTableArgs) =
                args.TableName <- input tableName
                args

            ()
            name, List.Cons(apply, args)

        member _.TableName((name, args), tableName) =
            let apply (args: DatasetSqlServerTableArgs) =
                args.TableName <- io tableName
                args

            ()
            name, List.Cons(apply, args)

    let datasetSqlServerTable = DatasetSqlServerTableBuilder()

    type FactoryBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Factory(name, (List.fold func (FactoryArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: FactoryArgs) =
                   args.GithubConfiguration <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: FactoryArgs) =
                   args.Identity <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: FactoryArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: FactoryArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: FactoryArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: FactoryArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FactoryArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FactoryArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: FactoryArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: FactoryArgs) =
                   args.VstsConfiguration <- input arg
                   args

               ()
               func) ]

    let factory = FactoryBuilder()

    type IntegrationRuntimeManagedBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            IntegrationRuntimeManaged(name, (List.fold func (IntegrationRuntimeManagedArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: IntegrationRuntimeManagedArgs) =
                   args.CatalogInfo <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: IntegrationRuntimeManagedArgs) =
                   args.CustomSetupScript <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("dataFactoryName")>]
        member _.DataFactoryName((name, args), dataFactoryName) =
            let apply (args: IntegrationRuntimeManagedArgs) =
                args.DataFactoryName <- input dataFactoryName
                args

            ()
            name, List.Cons(apply, args)

        member _.DataFactoryName((name, args), dataFactoryName) =
            let apply (args: IntegrationRuntimeManagedArgs) =
                args.DataFactoryName <- io dataFactoryName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: IntegrationRuntimeManagedArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: IntegrationRuntimeManagedArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("edition")>]
        member _.Edition((name, args), edition) =
            let apply (args: IntegrationRuntimeManagedArgs) =
                args.Edition <- input edition
                args

            ()
            name, List.Cons(apply, args)

        member _.Edition((name, args), edition) =
            let apply (args: IntegrationRuntimeManagedArgs) =
                args.Edition <- io edition
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("licenseType")>]
        member _.LicenseType((name, args), licenseType) =
            let apply (args: IntegrationRuntimeManagedArgs) =
                args.LicenseType <- input licenseType
                args

            ()
            name, List.Cons(apply, args)

        member _.LicenseType((name, args), licenseType) =
            let apply (args: IntegrationRuntimeManagedArgs) =
                args.LicenseType <- io licenseType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: IntegrationRuntimeManagedArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: IntegrationRuntimeManagedArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("maxParallelExecutionsPerNode")>]
        member _.MaxParallelExecutionsPerNode((name, args), maxParallelExecutionsPerNode) =
            let apply (args: IntegrationRuntimeManagedArgs) =
                args.MaxParallelExecutionsPerNode <- input maxParallelExecutionsPerNode
                args

            ()
            name, List.Cons(apply, args)

        member _.MaxParallelExecutionsPerNode((name, args), maxParallelExecutionsPerNode) =
            let apply (args: IntegrationRuntimeManagedArgs) =
                args.MaxParallelExecutionsPerNode <- io maxParallelExecutionsPerNode
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: IntegrationRuntimeManagedArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: IntegrationRuntimeManagedArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("nodeSize")>]
        member _.NodeSize((name, args), nodeSize) =
            let apply (args: IntegrationRuntimeManagedArgs) =
                args.NodeSize <- input nodeSize
                args

            ()
            name, List.Cons(apply, args)

        member _.NodeSize((name, args), nodeSize) =
            let apply (args: IntegrationRuntimeManagedArgs) =
                args.NodeSize <- io nodeSize
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("numberOfNodes")>]
        member _.NumberOfNodes((name, args), numberOfNodes) =
            let apply (args: IntegrationRuntimeManagedArgs) =
                args.NumberOfNodes <- input numberOfNodes
                args

            ()
            name, List.Cons(apply, args)

        member _.NumberOfNodes((name, args), numberOfNodes) =
            let apply (args: IntegrationRuntimeManagedArgs) =
                args.NumberOfNodes <- io numberOfNodes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: IntegrationRuntimeManagedArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: IntegrationRuntimeManagedArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: IntegrationRuntimeManagedArgs) =
                   args.VnetIntegration <- input arg
                   args

               ()
               func) ]

    let integrationRuntimeManaged = IntegrationRuntimeManagedBuilder()

    type IntegrationRuntimeSelfHostedBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            IntegrationRuntimeSelfHosted(name, (List.fold func (IntegrationRuntimeSelfHostedArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("dataFactoryName")>]
        member _.DataFactoryName((name, args), dataFactoryName) =
            let apply (args: IntegrationRuntimeSelfHostedArgs) =
                args.DataFactoryName <- input dataFactoryName
                args

            ()
            name, List.Cons(apply, args)

        member _.DataFactoryName((name, args), dataFactoryName) =
            let apply (args: IntegrationRuntimeSelfHostedArgs) =
                args.DataFactoryName <- io dataFactoryName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: IntegrationRuntimeSelfHostedArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: IntegrationRuntimeSelfHostedArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: IntegrationRuntimeSelfHostedArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: IntegrationRuntimeSelfHostedArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("rbacAuthorizations")>]
        member _.RbacAuthorizations((name, args), rbacAuthorizations) =
            let apply (args: IntegrationRuntimeSelfHostedArgs) =
                args.RbacAuthorizations <- inputList rbacAuthorizations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: IntegrationRuntimeSelfHostedArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: IntegrationRuntimeSelfHostedArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let integrationRuntimeSelfHosted = IntegrationRuntimeSelfHostedBuilder()

    type LinkedServiceDataLakeStorageGen2Builder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            LinkedServiceDataLakeStorageGen2(name, (List.fold func (LinkedServiceDataLakeStorageGen2Args()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("additionalProperties")>]
        member _.AdditionalProperties((name, args), additionalProperties) =
            let apply (args: LinkedServiceDataLakeStorageGen2Args) =
                args.AdditionalProperties <- inputMap additionalProperties
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("annotations")>]
        member _.Annotations((name, args), annotations) =
            let apply (args: LinkedServiceDataLakeStorageGen2Args) =
                args.Annotations <- inputList annotations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("dataFactoryName")>]
        member _.DataFactoryName((name, args), dataFactoryName) =
            let apply (args: LinkedServiceDataLakeStorageGen2Args) =
                args.DataFactoryName <- input dataFactoryName
                args

            ()
            name, List.Cons(apply, args)

        member _.DataFactoryName((name, args), dataFactoryName) =
            let apply (args: LinkedServiceDataLakeStorageGen2Args) =
                args.DataFactoryName <- io dataFactoryName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: LinkedServiceDataLakeStorageGen2Args) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: LinkedServiceDataLakeStorageGen2Args) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("integrationRuntimeName")>]
        member _.IntegrationRuntimeName((name, args), integrationRuntimeName) =
            let apply (args: LinkedServiceDataLakeStorageGen2Args) =
                args.IntegrationRuntimeName <- input integrationRuntimeName
                args

            ()
            name, List.Cons(apply, args)

        member _.IntegrationRuntimeName((name, args), integrationRuntimeName) =
            let apply (args: LinkedServiceDataLakeStorageGen2Args) =
                args.IntegrationRuntimeName <- io integrationRuntimeName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: LinkedServiceDataLakeStorageGen2Args) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: LinkedServiceDataLakeStorageGen2Args) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("parameters")>]
        member _.Parameters((name, args), parameters) =
            let apply (args: LinkedServiceDataLakeStorageGen2Args) =
                args.Parameters <- inputMap parameters
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: LinkedServiceDataLakeStorageGen2Args) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: LinkedServiceDataLakeStorageGen2Args) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("servicePrincipalId")>]
        member _.ServicePrincipalId((name, args), servicePrincipalId) =
            let apply (args: LinkedServiceDataLakeStorageGen2Args) =
                args.ServicePrincipalId <- input servicePrincipalId
                args

            ()
            name, List.Cons(apply, args)

        member _.ServicePrincipalId((name, args), servicePrincipalId) =
            let apply (args: LinkedServiceDataLakeStorageGen2Args) =
                args.ServicePrincipalId <- io servicePrincipalId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("servicePrincipalKey")>]
        member _.ServicePrincipalKey((name, args), servicePrincipalKey) =
            let apply (args: LinkedServiceDataLakeStorageGen2Args) =
                args.ServicePrincipalKey <- input servicePrincipalKey
                args

            ()
            name, List.Cons(apply, args)

        member _.ServicePrincipalKey((name, args), servicePrincipalKey) =
            let apply (args: LinkedServiceDataLakeStorageGen2Args) =
                args.ServicePrincipalKey <- io servicePrincipalKey
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tenant")>]
        member _.Tenant((name, args), tenant) =
            let apply (args: LinkedServiceDataLakeStorageGen2Args) =
                args.Tenant <- input tenant
                args

            ()
            name, List.Cons(apply, args)

        member _.Tenant((name, args), tenant) =
            let apply (args: LinkedServiceDataLakeStorageGen2Args) =
                args.Tenant <- io tenant
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("url")>]
        member _.Url((name, args), url) =
            let apply (args: LinkedServiceDataLakeStorageGen2Args) =
                args.Url <- input url
                args

            ()
            name, List.Cons(apply, args)

        member _.Url((name, args), url) =
            let apply (args: LinkedServiceDataLakeStorageGen2Args) =
                args.Url <- io url
                args

            ()
            name, List.Cons(apply, args)

    let linkedServiceDataLakeStorageGen2 =
        LinkedServiceDataLakeStorageGen2Builder()

    type LinkedServiceKeyVaultBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            LinkedServiceKeyVault(name, (List.fold func (LinkedServiceKeyVaultArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("additionalProperties")>]
        member _.AdditionalProperties((name, args), additionalProperties) =
            let apply (args: LinkedServiceKeyVaultArgs) =
                args.AdditionalProperties <- inputMap additionalProperties
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("annotations")>]
        member _.Annotations((name, args), annotations) =
            let apply (args: LinkedServiceKeyVaultArgs) =
                args.Annotations <- inputList annotations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("dataFactoryName")>]
        member _.DataFactoryName((name, args), dataFactoryName) =
            let apply (args: LinkedServiceKeyVaultArgs) =
                args.DataFactoryName <- input dataFactoryName
                args

            ()
            name, List.Cons(apply, args)

        member _.DataFactoryName((name, args), dataFactoryName) =
            let apply (args: LinkedServiceKeyVaultArgs) =
                args.DataFactoryName <- io dataFactoryName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: LinkedServiceKeyVaultArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: LinkedServiceKeyVaultArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("integrationRuntimeName")>]
        member _.IntegrationRuntimeName((name, args), integrationRuntimeName) =
            let apply (args: LinkedServiceKeyVaultArgs) =
                args.IntegrationRuntimeName <- input integrationRuntimeName
                args

            ()
            name, List.Cons(apply, args)

        member _.IntegrationRuntimeName((name, args), integrationRuntimeName) =
            let apply (args: LinkedServiceKeyVaultArgs) =
                args.IntegrationRuntimeName <- io integrationRuntimeName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("keyVaultId")>]
        member _.KeyVaultId((name, args), keyVaultId) =
            let apply (args: LinkedServiceKeyVaultArgs) =
                args.KeyVaultId <- input keyVaultId
                args

            ()
            name, List.Cons(apply, args)

        member _.KeyVaultId((name, args), keyVaultId) =
            let apply (args: LinkedServiceKeyVaultArgs) =
                args.KeyVaultId <- io keyVaultId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: LinkedServiceKeyVaultArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: LinkedServiceKeyVaultArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("parameters")>]
        member _.Parameters((name, args), parameters) =
            let apply (args: LinkedServiceKeyVaultArgs) =
                args.Parameters <- inputMap parameters
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: LinkedServiceKeyVaultArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: LinkedServiceKeyVaultArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let linkedServiceKeyVault = LinkedServiceKeyVaultBuilder()

    type LinkedServiceMysqlBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            LinkedServiceMysql(name, (List.fold func (LinkedServiceMysqlArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("additionalProperties")>]
        member _.AdditionalProperties((name, args), additionalProperties) =
            let apply (args: LinkedServiceMysqlArgs) =
                args.AdditionalProperties <- inputMap additionalProperties
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("annotations")>]
        member _.Annotations((name, args), annotations) =
            let apply (args: LinkedServiceMysqlArgs) =
                args.Annotations <- inputList annotations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("connectionString")>]
        member _.ConnectionString((name, args), connectionString) =
            let apply (args: LinkedServiceMysqlArgs) =
                args.ConnectionString <- input connectionString
                args

            ()
            name, List.Cons(apply, args)

        member _.ConnectionString((name, args), connectionString) =
            let apply (args: LinkedServiceMysqlArgs) =
                args.ConnectionString <- io connectionString
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("dataFactoryName")>]
        member _.DataFactoryName((name, args), dataFactoryName) =
            let apply (args: LinkedServiceMysqlArgs) =
                args.DataFactoryName <- input dataFactoryName
                args

            ()
            name, List.Cons(apply, args)

        member _.DataFactoryName((name, args), dataFactoryName) =
            let apply (args: LinkedServiceMysqlArgs) =
                args.DataFactoryName <- io dataFactoryName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: LinkedServiceMysqlArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: LinkedServiceMysqlArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("integrationRuntimeName")>]
        member _.IntegrationRuntimeName((name, args), integrationRuntimeName) =
            let apply (args: LinkedServiceMysqlArgs) =
                args.IntegrationRuntimeName <- input integrationRuntimeName
                args

            ()
            name, List.Cons(apply, args)

        member _.IntegrationRuntimeName((name, args), integrationRuntimeName) =
            let apply (args: LinkedServiceMysqlArgs) =
                args.IntegrationRuntimeName <- io integrationRuntimeName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: LinkedServiceMysqlArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: LinkedServiceMysqlArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("parameters")>]
        member _.Parameters((name, args), parameters) =
            let apply (args: LinkedServiceMysqlArgs) =
                args.Parameters <- inputMap parameters
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: LinkedServiceMysqlArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: LinkedServiceMysqlArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let linkedServiceMysql = LinkedServiceMysqlBuilder()

    type LinkedServicePostgresqlBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            LinkedServicePostgresql(name, (List.fold func (LinkedServicePostgresqlArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("additionalProperties")>]
        member _.AdditionalProperties((name, args), additionalProperties) =
            let apply (args: LinkedServicePostgresqlArgs) =
                args.AdditionalProperties <- inputMap additionalProperties
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("annotations")>]
        member _.Annotations((name, args), annotations) =
            let apply (args: LinkedServicePostgresqlArgs) =
                args.Annotations <- inputList annotations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("connectionString")>]
        member _.ConnectionString((name, args), connectionString) =
            let apply (args: LinkedServicePostgresqlArgs) =
                args.ConnectionString <- input connectionString
                args

            ()
            name, List.Cons(apply, args)

        member _.ConnectionString((name, args), connectionString) =
            let apply (args: LinkedServicePostgresqlArgs) =
                args.ConnectionString <- io connectionString
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("dataFactoryName")>]
        member _.DataFactoryName((name, args), dataFactoryName) =
            let apply (args: LinkedServicePostgresqlArgs) =
                args.DataFactoryName <- input dataFactoryName
                args

            ()
            name, List.Cons(apply, args)

        member _.DataFactoryName((name, args), dataFactoryName) =
            let apply (args: LinkedServicePostgresqlArgs) =
                args.DataFactoryName <- io dataFactoryName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: LinkedServicePostgresqlArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: LinkedServicePostgresqlArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("integrationRuntimeName")>]
        member _.IntegrationRuntimeName((name, args), integrationRuntimeName) =
            let apply (args: LinkedServicePostgresqlArgs) =
                args.IntegrationRuntimeName <- input integrationRuntimeName
                args

            ()
            name, List.Cons(apply, args)

        member _.IntegrationRuntimeName((name, args), integrationRuntimeName) =
            let apply (args: LinkedServicePostgresqlArgs) =
                args.IntegrationRuntimeName <- io integrationRuntimeName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: LinkedServicePostgresqlArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: LinkedServicePostgresqlArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("parameters")>]
        member _.Parameters((name, args), parameters) =
            let apply (args: LinkedServicePostgresqlArgs) =
                args.Parameters <- inputMap parameters
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: LinkedServicePostgresqlArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: LinkedServicePostgresqlArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let linkedServicePostgresql = LinkedServicePostgresqlBuilder()

    type LinkedServiceSqlServerBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            LinkedServiceSqlServer(name, (List.fold func (LinkedServiceSqlServerArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("additionalProperties")>]
        member _.AdditionalProperties((name, args), additionalProperties) =
            let apply (args: LinkedServiceSqlServerArgs) =
                args.AdditionalProperties <- inputMap additionalProperties
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("annotations")>]
        member _.Annotations((name, args), annotations) =
            let apply (args: LinkedServiceSqlServerArgs) =
                args.Annotations <- inputList annotations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("connectionString")>]
        member _.ConnectionString((name, args), connectionString) =
            let apply (args: LinkedServiceSqlServerArgs) =
                args.ConnectionString <- input connectionString
                args

            ()
            name, List.Cons(apply, args)

        member _.ConnectionString((name, args), connectionString) =
            let apply (args: LinkedServiceSqlServerArgs) =
                args.ConnectionString <- io connectionString
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("dataFactoryName")>]
        member _.DataFactoryName((name, args), dataFactoryName) =
            let apply (args: LinkedServiceSqlServerArgs) =
                args.DataFactoryName <- input dataFactoryName
                args

            ()
            name, List.Cons(apply, args)

        member _.DataFactoryName((name, args), dataFactoryName) =
            let apply (args: LinkedServiceSqlServerArgs) =
                args.DataFactoryName <- io dataFactoryName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: LinkedServiceSqlServerArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: LinkedServiceSqlServerArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("integrationRuntimeName")>]
        member _.IntegrationRuntimeName((name, args), integrationRuntimeName) =
            let apply (args: LinkedServiceSqlServerArgs) =
                args.IntegrationRuntimeName <- input integrationRuntimeName
                args

            ()
            name, List.Cons(apply, args)

        member _.IntegrationRuntimeName((name, args), integrationRuntimeName) =
            let apply (args: LinkedServiceSqlServerArgs) =
                args.IntegrationRuntimeName <- io integrationRuntimeName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: LinkedServiceSqlServerArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: LinkedServiceSqlServerArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("parameters")>]
        member _.Parameters((name, args), parameters) =
            let apply (args: LinkedServiceSqlServerArgs) =
                args.Parameters <- inputMap parameters
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: LinkedServiceSqlServerArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: LinkedServiceSqlServerArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let linkedServiceSqlServer = LinkedServiceSqlServerBuilder()

    type PipelineBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Pipeline(name, (List.fold func (PipelineArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("activitiesJson")>]
        member _.ActivitiesJson((name, args), activitiesJson) =
            let apply (args: PipelineArgs) =
                args.ActivitiesJson <- input activitiesJson
                args

            ()
            name, List.Cons(apply, args)

        member _.ActivitiesJson((name, args), activitiesJson) =
            let apply (args: PipelineArgs) =
                args.ActivitiesJson <- io activitiesJson
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("annotations")>]
        member _.Annotations((name, args), annotations) =
            let apply (args: PipelineArgs) =
                args.Annotations <- inputList annotations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("dataFactoryName")>]
        member _.DataFactoryName((name, args), dataFactoryName) =
            let apply (args: PipelineArgs) =
                args.DataFactoryName <- input dataFactoryName
                args

            ()
            name, List.Cons(apply, args)

        member _.DataFactoryName((name, args), dataFactoryName) =
            let apply (args: PipelineArgs) =
                args.DataFactoryName <- io dataFactoryName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: PipelineArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: PipelineArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: PipelineArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: PipelineArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("parameters")>]
        member _.Parameters((name, args), parameters) =
            let apply (args: PipelineArgs) =
                args.Parameters <- inputMap parameters
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: PipelineArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: PipelineArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("variables")>]
        member _.Variables((name, args), variables) =
            let apply (args: PipelineArgs) =
                args.Variables <- inputMap variables
                args

            ()
            name, List.Cons(apply, args)

    let pipeline = PipelineBuilder()

    type TriggerScheduleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            TriggerSchedule(name, (List.fold func (TriggerScheduleArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("annotations")>]
        member _.Annotations((name, args), annotations) =
            let apply (args: TriggerScheduleArgs) =
                args.Annotations <- inputList annotations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("dataFactoryName")>]
        member _.DataFactoryName((name, args), dataFactoryName) =
            let apply (args: TriggerScheduleArgs) =
                args.DataFactoryName <- input dataFactoryName
                args

            ()
            name, List.Cons(apply, args)

        member _.DataFactoryName((name, args), dataFactoryName) =
            let apply (args: TriggerScheduleArgs) =
                args.DataFactoryName <- io dataFactoryName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("endTime")>]
        member _.EndTime((name, args), endTime) =
            let apply (args: TriggerScheduleArgs) =
                args.EndTime <- input endTime
                args

            ()
            name, List.Cons(apply, args)

        member _.EndTime((name, args), endTime) =
            let apply (args: TriggerScheduleArgs) =
                args.EndTime <- io endTime
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("frequency")>]
        member _.Frequency((name, args), frequency) =
            let apply (args: TriggerScheduleArgs) =
                args.Frequency <- input frequency
                args

            ()
            name, List.Cons(apply, args)

        member _.Frequency((name, args), frequency) =
            let apply (args: TriggerScheduleArgs) =
                args.Frequency <- io frequency
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("interval")>]
        member _.Interval((name, args), interval) =
            let apply (args: TriggerScheduleArgs) =
                args.Interval <- input interval
                args

            ()
            name, List.Cons(apply, args)

        member _.Interval((name, args), interval) =
            let apply (args: TriggerScheduleArgs) =
                args.Interval <- io interval
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: TriggerScheduleArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: TriggerScheduleArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("pipelineName")>]
        member _.PipelineName((name, args), pipelineName) =
            let apply (args: TriggerScheduleArgs) =
                args.PipelineName <- input pipelineName
                args

            ()
            name, List.Cons(apply, args)

        member _.PipelineName((name, args), pipelineName) =
            let apply (args: TriggerScheduleArgs) =
                args.PipelineName <- io pipelineName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("pipelineParameters")>]
        member _.PipelineParameters((name, args), pipelineParameters) =
            let apply (args: TriggerScheduleArgs) =
                args.PipelineParameters <- inputMap pipelineParameters
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: TriggerScheduleArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: TriggerScheduleArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("startTime")>]
        member _.StartTime((name, args), startTime) =
            let apply (args: TriggerScheduleArgs) =
                args.StartTime <- input startTime
                args

            ()
            name, List.Cons(apply, args)

        member _.StartTime((name, args), startTime) =
            let apply (args: TriggerScheduleArgs) =
                args.StartTime <- io startTime
                args

            ()
            name, List.Cons(apply, args)

    let triggerSchedule = TriggerScheduleBuilder()

module DataShare =
    open Pulumi.Azure.DataShare
    open Pulumi.Azure.DataShare.Inputs

    type AccountIdentityBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AccountIdentityArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("principalId")>]
        member _.PrincipalId((n, args), principalId) =
            let apply (args: AccountIdentityArgs) =
                args.PrincipalId <- input principalId
                args

            ()
            n, List.Cons(apply, args)

        member _.PrincipalId((n, args), principalId) =
            let apply (args: AccountIdentityArgs) =
                args.PrincipalId <- io principalId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tenantId")>]
        member _.TenantId((n, args), tenantId) =
            let apply (args: AccountIdentityArgs) =
                args.TenantId <- input tenantId
                args

            ()
            n, List.Cons(apply, args)

        member _.TenantId((n, args), tenantId) =
            let apply (args: AccountIdentityArgs) =
                args.TenantId <- io tenantId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: AccountIdentityArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: AccountIdentityArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let accountIdentity = AccountIdentityBuilder()

    type DatasetBlobStorageStorageAccountBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (DatasetBlobStorageStorageAccountArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: DatasetBlobStorageStorageAccountArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: DatasetBlobStorageStorageAccountArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((n, args), resourceGroupName) =
            let apply (args: DatasetBlobStorageStorageAccountArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            n, List.Cons(apply, args)

        member _.ResourceGroup((n, args), resourceGroupName) =
            let apply (args: DatasetBlobStorageStorageAccountArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subscriptionId")>]
        member _.SubscriptionId((n, args), subscriptionId) =
            let apply (args: DatasetBlobStorageStorageAccountArgs) =
                args.SubscriptionId <- input subscriptionId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubscriptionId((n, args), subscriptionId) =
            let apply (args: DatasetBlobStorageStorageAccountArgs) =
                args.SubscriptionId <- io subscriptionId
                args

            ()
            n, List.Cons(apply, args)

    let datasetBlobStorageStorageAccount =
        DatasetBlobStorageStorageAccountBuilder()

    type ShareSnapshotScheduleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ShareSnapshotScheduleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ShareSnapshotScheduleArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ShareSnapshotScheduleArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("recurrence")>]
        member _.Recurrence((n, args), recurrence) =
            let apply (args: ShareSnapshotScheduleArgs) =
                args.Recurrence <- input recurrence
                args

            ()
            n, List.Cons(apply, args)

        member _.Recurrence((n, args), recurrence) =
            let apply (args: ShareSnapshotScheduleArgs) =
                args.Recurrence <- io recurrence
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("startTime")>]
        member _.StartTime((n, args), startTime) =
            let apply (args: ShareSnapshotScheduleArgs) =
                args.StartTime <- input startTime
                args

            ()
            n, List.Cons(apply, args)

        member _.StartTime((n, args), startTime) =
            let apply (args: ShareSnapshotScheduleArgs) =
                args.StartTime <- io startTime
                args

            ()
            n, List.Cons(apply, args)

    let shareSnapshotSchedule = ShareSnapshotScheduleBuilder()

    type AccountBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Account(name, (List.fold func (AccountArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: AccountArgs) =
                   args.Identity <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: AccountArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: AccountArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: AccountArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: AccountArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AccountArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AccountArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: AccountArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let account = AccountBuilder()

    type DatasetBlobStorageBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            DatasetBlobStorage(name, (List.fold func (DatasetBlobStorageArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("containerName")>]
        member _.ContainerName((name, args), containerName) =
            let apply (args: DatasetBlobStorageArgs) =
                args.ContainerName <- input containerName
                args

            ()
            name, List.Cons(apply, args)

        member _.ContainerName((name, args), containerName) =
            let apply (args: DatasetBlobStorageArgs) =
                args.ContainerName <- io containerName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("dataShareId")>]
        member _.DataShareId((name, args), dataShareId) =
            let apply (args: DatasetBlobStorageArgs) =
                args.DataShareId <- input dataShareId
                args

            ()
            name, List.Cons(apply, args)

        member _.DataShareId((name, args), dataShareId) =
            let apply (args: DatasetBlobStorageArgs) =
                args.DataShareId <- io dataShareId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("filePath")>]
        member _.FilePath((name, args), filePath) =
            let apply (args: DatasetBlobStorageArgs) =
                args.FilePath <- input filePath
                args

            ()
            name, List.Cons(apply, args)

        member _.FilePath((name, args), filePath) =
            let apply (args: DatasetBlobStorageArgs) =
                args.FilePath <- io filePath
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("folderPath")>]
        member _.FolderPath((name, args), folderPath) =
            let apply (args: DatasetBlobStorageArgs) =
                args.FolderPath <- input folderPath
                args

            ()
            name, List.Cons(apply, args)

        member _.FolderPath((name, args), folderPath) =
            let apply (args: DatasetBlobStorageArgs) =
                args.FolderPath <- io folderPath
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: DatasetBlobStorageArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: DatasetBlobStorageArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: DatasetBlobStorageArgs) =
                   args.StorageAccount <- input arg
                   args

               ()
               func) ]

    let datasetBlobStorage = DatasetBlobStorageBuilder()

    type ShareBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Share(name, (List.fold func (ShareArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("accountId")>]
        member _.AccountId((name, args), accountId) =
            let apply (args: ShareArgs) =
                args.AccountId <- input accountId
                args

            ()
            name, List.Cons(apply, args)

        member _.AccountId((name, args), accountId) =
            let apply (args: ShareArgs) =
                args.AccountId <- io accountId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: ShareArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: ShareArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("kind")>]
        member _.Kind((name, args), kind) =
            let apply (args: ShareArgs) =
                args.Kind <- input kind
                args

            ()
            name, List.Cons(apply, args)

        member _.Kind((name, args), kind) =
            let apply (args: ShareArgs) =
                args.Kind <- io kind
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ShareArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ShareArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ShareArgs) =
                   args.SnapshotSchedule <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("terms")>]
        member _.Terms((name, args), terms) =
            let apply (args: ShareArgs) =
                args.Terms <- input terms
                args

            ()
            name, List.Cons(apply, args)

        member _.Terms((name, args), terms) =
            let apply (args: ShareArgs) =
                args.Terms <- io terms
                args

            ()
            name, List.Cons(apply, args)

    let share = ShareBuilder()

module DevTest =
    open Pulumi.Azure.DevTest
    open Pulumi.Azure.DevTest.Inputs

    type GlobalVMShutdownScheduleNotificationSettingsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (GlobalVMShutdownScheduleNotificationSettingsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: GlobalVMShutdownScheduleNotificationSettingsArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: GlobalVMShutdownScheduleNotificationSettingsArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("timeInMinutes")>]
        member _.TimeInMinutes((n, args), timeInMinutes) =
            let apply (args: GlobalVMShutdownScheduleNotificationSettingsArgs) =
                args.TimeInMinutes <- input timeInMinutes
                args

            ()
            n, List.Cons(apply, args)

        member _.TimeInMinutes((n, args), timeInMinutes) =
            let apply (args: GlobalVMShutdownScheduleNotificationSettingsArgs) =
                args.TimeInMinutes <- io timeInMinutes
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("webhookUrl")>]
        member _.WebhookUrl((n, args), webhookUrl) =
            let apply (args: GlobalVMShutdownScheduleNotificationSettingsArgs) =
                args.WebhookUrl <- input webhookUrl
                args

            ()
            n, List.Cons(apply, args)

        member _.WebhookUrl((n, args), webhookUrl) =
            let apply (args: GlobalVMShutdownScheduleNotificationSettingsArgs) =
                args.WebhookUrl <- io webhookUrl
                args

            ()
            n, List.Cons(apply, args)

    let globalVMShutdownScheduleNotificationSettings =
        GlobalVMShutdownScheduleNotificationSettingsBuilder()

    type LinuxVirtualMachineGalleryImageReferenceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LinuxVirtualMachineGalleryImageReferenceArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("offer")>]
        member _.Offer((n, args), offer) =
            let apply (args: LinuxVirtualMachineGalleryImageReferenceArgs) =
                args.Offer <- input offer
                args

            ()
            n, List.Cons(apply, args)

        member _.Offer((n, args), offer) =
            let apply (args: LinuxVirtualMachineGalleryImageReferenceArgs) =
                args.Offer <- io offer
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publisher")>]
        member _.Publisher((n, args), publisher) =
            let apply (args: LinuxVirtualMachineGalleryImageReferenceArgs) =
                args.Publisher <- input publisher
                args

            ()
            n, List.Cons(apply, args)

        member _.Publisher((n, args), publisher) =
            let apply (args: LinuxVirtualMachineGalleryImageReferenceArgs) =
                args.Publisher <- io publisher
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sku")>]
        member _.Sku((n, args), sku) =
            let apply (args: LinuxVirtualMachineGalleryImageReferenceArgs) =
                args.Sku <- input sku
                args

            ()
            n, List.Cons(apply, args)

        member _.Sku((n, args), sku) =
            let apply (args: LinuxVirtualMachineGalleryImageReferenceArgs) =
                args.Sku <- io sku
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("version")>]
        member _.Version((n, args), version) =
            let apply (args: LinuxVirtualMachineGalleryImageReferenceArgs) =
                args.Version <- input version
                args

            ()
            n, List.Cons(apply, args)

        member _.Version((n, args), version) =
            let apply (args: LinuxVirtualMachineGalleryImageReferenceArgs) =
                args.Version <- io version
                args

            ()
            n, List.Cons(apply, args)

    let linuxVirtualMachineGalleryImageReference =
        LinuxVirtualMachineGalleryImageReferenceBuilder()

    type LinuxVirtualMachineInboundNatRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LinuxVirtualMachineInboundNatRuleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("backendPort")>]
        member _.BackendPort((n, args), backendPort) =
            let apply (args: LinuxVirtualMachineInboundNatRuleArgs) =
                args.BackendPort <- input backendPort
                args

            ()
            n, List.Cons(apply, args)

        member _.BackendPort((n, args), backendPort) =
            let apply (args: LinuxVirtualMachineInboundNatRuleArgs) =
                args.BackendPort <- io backendPort
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("frontendPort")>]
        member _.FrontendPort((n, args), frontendPort) =
            let apply (args: LinuxVirtualMachineInboundNatRuleArgs) =
                args.FrontendPort <- input frontendPort
                args

            ()
            n, List.Cons(apply, args)

        member _.FrontendPort((n, args), frontendPort) =
            let apply (args: LinuxVirtualMachineInboundNatRuleArgs) =
                args.FrontendPort <- io frontendPort
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("protocol")>]
        member _.Protocol((n, args), protocol) =
            let apply (args: LinuxVirtualMachineInboundNatRuleArgs) =
                args.Protocol <- input protocol
                args

            ()
            n, List.Cons(apply, args)

        member _.Protocol((n, args), protocol) =
            let apply (args: LinuxVirtualMachineInboundNatRuleArgs) =
                args.Protocol <- io protocol
                args

            ()
            n, List.Cons(apply, args)

    let linuxVirtualMachineInboundNatRule =
        LinuxVirtualMachineInboundNatRuleBuilder()

    type ScheduleDailyRecurrenceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ScheduleDailyRecurrenceArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("time")>]
        member _.Time((n, args), time) =
            let apply (args: ScheduleDailyRecurrenceArgs) =
                args.Time <- input time
                args

            ()
            n, List.Cons(apply, args)

        member _.Time((n, args), time) =
            let apply (args: ScheduleDailyRecurrenceArgs) =
                args.Time <- io time
                args

            ()
            n, List.Cons(apply, args)

    let scheduleDailyRecurrence = ScheduleDailyRecurrenceBuilder()

    type ScheduleHourlyRecurrenceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ScheduleHourlyRecurrenceArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("minute")>]
        member _.Minute((n, args), minute) =
            let apply (args: ScheduleHourlyRecurrenceArgs) =
                args.Minute <- input minute
                args

            ()
            n, List.Cons(apply, args)

        member _.Minute((n, args), minute) =
            let apply (args: ScheduleHourlyRecurrenceArgs) =
                args.Minute <- io minute
                args

            ()
            n, List.Cons(apply, args)

    let scheduleHourlyRecurrence = ScheduleHourlyRecurrenceBuilder()

    type ScheduleNotificationSettingsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ScheduleNotificationSettingsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("status")>]
        member _.Status((n, args), status) =
            let apply (args: ScheduleNotificationSettingsArgs) =
                args.Status <- input status
                args

            ()
            n, List.Cons(apply, args)

        member _.Status((n, args), status) =
            let apply (args: ScheduleNotificationSettingsArgs) =
                args.Status <- io status
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("timeInMinutes")>]
        member _.TimeInMinutes((n, args), timeInMinutes) =
            let apply (args: ScheduleNotificationSettingsArgs) =
                args.TimeInMinutes <- input timeInMinutes
                args

            ()
            n, List.Cons(apply, args)

        member _.TimeInMinutes((n, args), timeInMinutes) =
            let apply (args: ScheduleNotificationSettingsArgs) =
                args.TimeInMinutes <- io timeInMinutes
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("webhookUrl")>]
        member _.WebhookUrl((n, args), webhookUrl) =
            let apply (args: ScheduleNotificationSettingsArgs) =
                args.WebhookUrl <- input webhookUrl
                args

            ()
            n, List.Cons(apply, args)

        member _.WebhookUrl((n, args), webhookUrl) =
            let apply (args: ScheduleNotificationSettingsArgs) =
                args.WebhookUrl <- io webhookUrl
                args

            ()
            n, List.Cons(apply, args)

    let scheduleNotificationSettings = ScheduleNotificationSettingsBuilder()

    type ScheduleWeeklyRecurrenceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ScheduleWeeklyRecurrenceArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("time")>]
        member _.Time((n, args), time) =
            let apply (args: ScheduleWeeklyRecurrenceArgs) =
                args.Time <- input time
                args

            ()
            n, List.Cons(apply, args)

        member _.Time((n, args), time) =
            let apply (args: ScheduleWeeklyRecurrenceArgs) =
                args.Time <- io time
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("weekDays")>]
        member _.WeekDays((n, args), weekDays) =
            let apply (args: ScheduleWeeklyRecurrenceArgs) =
                args.WeekDays <- inputList weekDays
                args

            ()
            n, List.Cons(apply, args)

    let scheduleWeeklyRecurrence = ScheduleWeeklyRecurrenceBuilder()

    type VirtualNetworkSubnetBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VirtualNetworkSubnetArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: VirtualNetworkSubnetArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: VirtualNetworkSubnetArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("useInVirtualMachineCreation")>]
        member _.UseInVirtualMachineCreation((n, args), useInVirtualMachineCreation) =
            let apply (args: VirtualNetworkSubnetArgs) =
                args.UseInVirtualMachineCreation <- input useInVirtualMachineCreation
                args

            ()
            n, List.Cons(apply, args)

        member _.UseInVirtualMachineCreation((n, args), useInVirtualMachineCreation) =
            let apply (args: VirtualNetworkSubnetArgs) =
                args.UseInVirtualMachineCreation <- io useInVirtualMachineCreation
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("usePublicIpAddress")>]
        member _.UsePublicIpAddress((n, args), usePublicIpAddress) =
            let apply (args: VirtualNetworkSubnetArgs) =
                args.UsePublicIpAddress <- input usePublicIpAddress
                args

            ()
            n, List.Cons(apply, args)

        member _.UsePublicIpAddress((n, args), usePublicIpAddress) =
            let apply (args: VirtualNetworkSubnetArgs) =
                args.UsePublicIpAddress <- io usePublicIpAddress
                args

            ()
            n, List.Cons(apply, args)

    let virtualNetworkSubnet = VirtualNetworkSubnetBuilder()

    type WindowsVirtualMachineGalleryImageReferenceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (WindowsVirtualMachineGalleryImageReferenceArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("offer")>]
        member _.Offer((n, args), offer) =
            let apply (args: WindowsVirtualMachineGalleryImageReferenceArgs) =
                args.Offer <- input offer
                args

            ()
            n, List.Cons(apply, args)

        member _.Offer((n, args), offer) =
            let apply (args: WindowsVirtualMachineGalleryImageReferenceArgs) =
                args.Offer <- io offer
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publisher")>]
        member _.Publisher((n, args), publisher) =
            let apply (args: WindowsVirtualMachineGalleryImageReferenceArgs) =
                args.Publisher <- input publisher
                args

            ()
            n, List.Cons(apply, args)

        member _.Publisher((n, args), publisher) =
            let apply (args: WindowsVirtualMachineGalleryImageReferenceArgs) =
                args.Publisher <- io publisher
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sku")>]
        member _.Sku((n, args), sku) =
            let apply (args: WindowsVirtualMachineGalleryImageReferenceArgs) =
                args.Sku <- input sku
                args

            ()
            n, List.Cons(apply, args)

        member _.Sku((n, args), sku) =
            let apply (args: WindowsVirtualMachineGalleryImageReferenceArgs) =
                args.Sku <- io sku
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("version")>]
        member _.Version((n, args), version) =
            let apply (args: WindowsVirtualMachineGalleryImageReferenceArgs) =
                args.Version <- input version
                args

            ()
            n, List.Cons(apply, args)

        member _.Version((n, args), version) =
            let apply (args: WindowsVirtualMachineGalleryImageReferenceArgs) =
                args.Version <- io version
                args

            ()
            n, List.Cons(apply, args)

    let windowsVirtualMachineGalleryImageReference =
        WindowsVirtualMachineGalleryImageReferenceBuilder()

    type WindowsVirtualMachineInboundNatRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (WindowsVirtualMachineInboundNatRuleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("backendPort")>]
        member _.BackendPort((n, args), backendPort) =
            let apply (args: WindowsVirtualMachineInboundNatRuleArgs) =
                args.BackendPort <- input backendPort
                args

            ()
            n, List.Cons(apply, args)

        member _.BackendPort((n, args), backendPort) =
            let apply (args: WindowsVirtualMachineInboundNatRuleArgs) =
                args.BackendPort <- io backendPort
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("frontendPort")>]
        member _.FrontendPort((n, args), frontendPort) =
            let apply (args: WindowsVirtualMachineInboundNatRuleArgs) =
                args.FrontendPort <- input frontendPort
                args

            ()
            n, List.Cons(apply, args)

        member _.FrontendPort((n, args), frontendPort) =
            let apply (args: WindowsVirtualMachineInboundNatRuleArgs) =
                args.FrontendPort <- io frontendPort
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("protocol")>]
        member _.Protocol((n, args), protocol) =
            let apply (args: WindowsVirtualMachineInboundNatRuleArgs) =
                args.Protocol <- input protocol
                args

            ()
            n, List.Cons(apply, args)

        member _.Protocol((n, args), protocol) =
            let apply (args: WindowsVirtualMachineInboundNatRuleArgs) =
                args.Protocol <- io protocol
                args

            ()
            n, List.Cons(apply, args)

    let windowsVirtualMachineInboundNatRule =
        WindowsVirtualMachineInboundNatRuleBuilder()

    type GlobalVMShutdownScheduleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            GlobalVMShutdownSchedule(name, (List.fold func (GlobalVMShutdownScheduleArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("dailyRecurrenceTime")>]
        member _.DailyRecurrenceTime((name, args), dailyRecurrenceTime) =
            let apply (args: GlobalVMShutdownScheduleArgs) =
                args.DailyRecurrenceTime <- input dailyRecurrenceTime
                args

            ()
            name, List.Cons(apply, args)

        member _.DailyRecurrenceTime((name, args), dailyRecurrenceTime) =
            let apply (args: GlobalVMShutdownScheduleArgs) =
                args.DailyRecurrenceTime <- io dailyRecurrenceTime
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((name, args), enabled) =
            let apply (args: GlobalVMShutdownScheduleArgs) =
                args.Enabled <- input enabled
                args

            ()
            name, List.Cons(apply, args)

        member _.Enabled((name, args), enabled) =
            let apply (args: GlobalVMShutdownScheduleArgs) =
                args.Enabled <- io enabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: GlobalVMShutdownScheduleArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: GlobalVMShutdownScheduleArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: GlobalVMShutdownScheduleArgs) =
                   args.NotificationSettings <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: GlobalVMShutdownScheduleArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("timezone")>]
        member _.Timezone((name, args), timezone) =
            let apply (args: GlobalVMShutdownScheduleArgs) =
                args.Timezone <- input timezone
                args

            ()
            name, List.Cons(apply, args)

        member _.Timezone((name, args), timezone) =
            let apply (args: GlobalVMShutdownScheduleArgs) =
                args.Timezone <- io timezone
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("virtualMachineId")>]
        member _.VirtualMachineId((name, args), virtualMachineId) =
            let apply (args: GlobalVMShutdownScheduleArgs) =
                args.VirtualMachineId <- input virtualMachineId
                args

            ()
            name, List.Cons(apply, args)

        member _.VirtualMachineId((name, args), virtualMachineId) =
            let apply (args: GlobalVMShutdownScheduleArgs) =
                args.VirtualMachineId <- io virtualMachineId
                args

            ()
            name, List.Cons(apply, args)

    let globalVMShutdownSchedule = GlobalVMShutdownScheduleBuilder()

    type LabBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Lab(name, (List.fold func (LabArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: LabArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: LabArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: LabArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: LabArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: LabArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: LabArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageType")>]
        member _.StorageType((name, args), storageType) =
            let apply (args: LabArgs) =
                args.StorageType <- input storageType
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageType((name, args), storageType) =
            let apply (args: LabArgs) =
                args.StorageType <- io storageType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: LabArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let lab = LabBuilder()

    type LinuxVirtualMachineBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            LinuxVirtualMachine(name, (List.fold func (LinuxVirtualMachineArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("allowClaim")>]
        member _.AllowClaim((name, args), allowClaim) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.AllowClaim <- input allowClaim
                args

            ()
            name, List.Cons(apply, args)

        member _.AllowClaim((name, args), allowClaim) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.AllowClaim <- io allowClaim
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("disallowPublicIpAddress")>]
        member _.DisallowPublicIpAddress((name, args), disallowPublicIpAddress) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.DisallowPublicIpAddress <- input disallowPublicIpAddress
                args

            ()
            name, List.Cons(apply, args)

        member _.DisallowPublicIpAddress((name, args), disallowPublicIpAddress) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.DisallowPublicIpAddress <- io disallowPublicIpAddress
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: LinuxVirtualMachineArgs) =
                   args.GalleryImageReference <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("inboundNatRules")>]
        member _.InboundNatRules((name, args), inboundNatRules) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.InboundNatRules <- inputList inboundNatRules
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("labName")>]
        member _.LabName((name, args), labName) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.LabName <- input labName
                args

            ()
            name, List.Cons(apply, args)

        member _.LabName((name, args), labName) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.LabName <- io labName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("labSubnetName")>]
        member _.LabSubnetName((name, args), labSubnetName) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.LabSubnetName <- input labSubnetName
                args

            ()
            name, List.Cons(apply, args)

        member _.LabSubnetName((name, args), labSubnetName) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.LabSubnetName <- io labSubnetName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("labVirtualNetworkId")>]
        member _.LabVirtualNetworkId((name, args), labVirtualNetworkId) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.LabVirtualNetworkId <- input labVirtualNetworkId
                args

            ()
            name, List.Cons(apply, args)

        member _.LabVirtualNetworkId((name, args), labVirtualNetworkId) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.LabVirtualNetworkId <- io labVirtualNetworkId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("notes")>]
        member _.Notes((name, args), notes) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.Notes <- input notes
                args

            ()
            name, List.Cons(apply, args)

        member _.Notes((name, args), notes) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.Notes <- io notes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("password")>]
        member _.Password((name, args), password) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.Password <- input password
                args

            ()
            name, List.Cons(apply, args)

        member _.Password((name, args), password) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.Password <- io password
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("size")>]
        member _.Size((name, args), size) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.Size <- input size
                args

            ()
            name, List.Cons(apply, args)

        member _.Size((name, args), size) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.Size <- io size
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sshKey")>]
        member _.SshKey((name, args), sshKey) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.SshKey <- input sshKey
                args

            ()
            name, List.Cons(apply, args)

        member _.SshKey((name, args), sshKey) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.SshKey <- io sshKey
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageType")>]
        member _.StorageType((name, args), storageType) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.StorageType <- input storageType
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageType((name, args), storageType) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.StorageType <- io storageType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((name, args), username) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.Username <- input username
                args

            ()
            name, List.Cons(apply, args)

        member _.Username((name, args), username) =
            let apply (args: LinuxVirtualMachineArgs) =
                args.Username <- io username
                args

            ()
            name, List.Cons(apply, args)

    let linuxVirtualMachine = LinuxVirtualMachineBuilder()

    type PolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Policy(name, (List.fold func (PolicyArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: PolicyArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: PolicyArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("evaluatorType")>]
        member _.EvaluatorType((name, args), evaluatorType) =
            let apply (args: PolicyArgs) =
                args.EvaluatorType <- input evaluatorType
                args

            ()
            name, List.Cons(apply, args)

        member _.EvaluatorType((name, args), evaluatorType) =
            let apply (args: PolicyArgs) =
                args.EvaluatorType <- io evaluatorType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("factData")>]
        member _.FactData((name, args), factData) =
            let apply (args: PolicyArgs) =
                args.FactData <- input factData
                args

            ()
            name, List.Cons(apply, args)

        member _.FactData((name, args), factData) =
            let apply (args: PolicyArgs) =
                args.FactData <- io factData
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("labName")>]
        member _.LabName((name, args), labName) =
            let apply (args: PolicyArgs) =
                args.LabName <- input labName
                args

            ()
            name, List.Cons(apply, args)

        member _.LabName((name, args), labName) =
            let apply (args: PolicyArgs) =
                args.LabName <- io labName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: PolicyArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: PolicyArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("policySetName")>]
        member _.PolicySetName((name, args), policySetName) =
            let apply (args: PolicyArgs) =
                args.PolicySetName <- input policySetName
                args

            ()
            name, List.Cons(apply, args)

        member _.PolicySetName((name, args), policySetName) =
            let apply (args: PolicyArgs) =
                args.PolicySetName <- io policySetName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: PolicyArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: PolicyArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: PolicyArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("threshold")>]
        member _.Threshold((name, args), threshold) =
            let apply (args: PolicyArgs) =
                args.Threshold <- input threshold
                args

            ()
            name, List.Cons(apply, args)

        member _.Threshold((name, args), threshold) =
            let apply (args: PolicyArgs) =
                args.Threshold <- io threshold
                args

            ()
            name, List.Cons(apply, args)

    let policy = PolicyBuilder()

    type ScheduleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Schedule(name, (List.fold func (ScheduleArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: ScheduleArgs) =
                   args.DailyRecurrence <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: ScheduleArgs) =
                   args.HourlyRecurrence <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("labName")>]
        member _.LabName((name, args), labName) =
            let apply (args: ScheduleArgs) =
                args.LabName <- input labName
                args

            ()
            name, List.Cons(apply, args)

        member _.LabName((name, args), labName) =
            let apply (args: ScheduleArgs) =
                args.LabName <- io labName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ScheduleArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ScheduleArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ScheduleArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ScheduleArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ScheduleArgs) =
                   args.NotificationSettings <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ScheduleArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ScheduleArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("status")>]
        member _.Status((name, args), status) =
            let apply (args: ScheduleArgs) =
                args.Status <- input status
                args

            ()
            name, List.Cons(apply, args)

        member _.Status((name, args), status) =
            let apply (args: ScheduleArgs) =
                args.Status <- io status
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ScheduleArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("taskType")>]
        member _.TaskType((name, args), taskType) =
            let apply (args: ScheduleArgs) =
                args.TaskType <- input taskType
                args

            ()
            name, List.Cons(apply, args)

        member _.TaskType((name, args), taskType) =
            let apply (args: ScheduleArgs) =
                args.TaskType <- io taskType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("timeZoneId")>]
        member _.TimeZoneId((name, args), timeZoneId) =
            let apply (args: ScheduleArgs) =
                args.TimeZoneId <- input timeZoneId
                args

            ()
            name, List.Cons(apply, args)

        member _.TimeZoneId((name, args), timeZoneId) =
            let apply (args: ScheduleArgs) =
                args.TimeZoneId <- io timeZoneId
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ScheduleArgs) =
                   args.WeeklyRecurrence <- input arg
                   args

               ()
               func) ]

    let schedule = ScheduleBuilder()

    type VirtualNetworkBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            VirtualNetwork(name, (List.fold func (VirtualNetworkArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: VirtualNetworkArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: VirtualNetworkArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("labName")>]
        member _.LabName((name, args), labName) =
            let apply (args: VirtualNetworkArgs) =
                args.LabName <- input labName
                args

            ()
            name, List.Cons(apply, args)

        member _.LabName((name, args), labName) =
            let apply (args: VirtualNetworkArgs) =
                args.LabName <- io labName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: VirtualNetworkArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: VirtualNetworkArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: VirtualNetworkArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: VirtualNetworkArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: VirtualNetworkArgs) =
                   args.Subnet <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: VirtualNetworkArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let virtualNetwork = VirtualNetworkBuilder()

    type WindowsVirtualMachineBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            WindowsVirtualMachine(name, (List.fold func (WindowsVirtualMachineArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("allowClaim")>]
        member _.AllowClaim((name, args), allowClaim) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.AllowClaim <- input allowClaim
                args

            ()
            name, List.Cons(apply, args)

        member _.AllowClaim((name, args), allowClaim) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.AllowClaim <- io allowClaim
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("disallowPublicIpAddress")>]
        member _.DisallowPublicIpAddress((name, args), disallowPublicIpAddress) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.DisallowPublicIpAddress <- input disallowPublicIpAddress
                args

            ()
            name, List.Cons(apply, args)

        member _.DisallowPublicIpAddress((name, args), disallowPublicIpAddress) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.DisallowPublicIpAddress <- io disallowPublicIpAddress
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: WindowsVirtualMachineArgs) =
                   args.GalleryImageReference <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("inboundNatRules")>]
        member _.InboundNatRules((name, args), inboundNatRules) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.InboundNatRules <- inputList inboundNatRules
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("labName")>]
        member _.LabName((name, args), labName) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.LabName <- input labName
                args

            ()
            name, List.Cons(apply, args)

        member _.LabName((name, args), labName) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.LabName <- io labName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("labSubnetName")>]
        member _.LabSubnetName((name, args), labSubnetName) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.LabSubnetName <- input labSubnetName
                args

            ()
            name, List.Cons(apply, args)

        member _.LabSubnetName((name, args), labSubnetName) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.LabSubnetName <- io labSubnetName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("labVirtualNetworkId")>]
        member _.LabVirtualNetworkId((name, args), labVirtualNetworkId) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.LabVirtualNetworkId <- input labVirtualNetworkId
                args

            ()
            name, List.Cons(apply, args)

        member _.LabVirtualNetworkId((name, args), labVirtualNetworkId) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.LabVirtualNetworkId <- io labVirtualNetworkId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("notes")>]
        member _.Notes((name, args), notes) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.Notes <- input notes
                args

            ()
            name, List.Cons(apply, args)

        member _.Notes((name, args), notes) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.Notes <- io notes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("password")>]
        member _.Password((name, args), password) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.Password <- input password
                args

            ()
            name, List.Cons(apply, args)

        member _.Password((name, args), password) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.Password <- io password
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("size")>]
        member _.Size((name, args), size) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.Size <- input size
                args

            ()
            name, List.Cons(apply, args)

        member _.Size((name, args), size) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.Size <- io size
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageType")>]
        member _.StorageType((name, args), storageType) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.StorageType <- input storageType
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageType((name, args), storageType) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.StorageType <- io storageType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((name, args), username) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.Username <- input username
                args

            ()
            name, List.Cons(apply, args)

        member _.Username((name, args), username) =
            let apply (args: WindowsVirtualMachineArgs) =
                args.Username <- io username
                args

            ()
            name, List.Cons(apply, args)

    let windowsVirtualMachine = WindowsVirtualMachineBuilder()

module Dns =
    open Pulumi.Azure.Dns
    open Pulumi.Azure.Dns.Inputs

    type CaaRecordRecordBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (CaaRecordRecordArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("flags")>]
        member _.Flags((n, args), flags) =
            let apply (args: CaaRecordRecordArgs) =
                args.Flags <- input flags
                args

            ()
            n, List.Cons(apply, args)

        member _.Flags((n, args), flags) =
            let apply (args: CaaRecordRecordArgs) =
                args.Flags <- io flags
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tag")>]
        member _.Tag((n, args), tag) =
            let apply (args: CaaRecordRecordArgs) =
                args.Tag <- input tag
                args

            ()
            n, List.Cons(apply, args)

        member _.Tag((n, args), tag) =
            let apply (args: CaaRecordRecordArgs) =
                args.Tag <- io tag
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((n, args), value) =
            let apply (args: CaaRecordRecordArgs) =
                args.Value <- input value
                args

            ()
            n, List.Cons(apply, args)

        member _.Value((n, args), value) =
            let apply (args: CaaRecordRecordArgs) =
                args.Value <- io value
                args

            ()
            n, List.Cons(apply, args)

    let caaRecordRecord = CaaRecordRecordBuilder()

    type MxRecordRecordBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (MxRecordRecordArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("exchange")>]
        member _.Exchange((n, args), exchange) =
            let apply (args: MxRecordRecordArgs) =
                args.Exchange <- input exchange
                args

            ()
            n, List.Cons(apply, args)

        member _.Exchange((n, args), exchange) =
            let apply (args: MxRecordRecordArgs) =
                args.Exchange <- io exchange
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("preference")>]
        member _.Preference((n, args), preference) =
            let apply (args: MxRecordRecordArgs) =
                args.Preference <- input preference
                args

            ()
            n, List.Cons(apply, args)

        member _.Preference((n, args), preference) =
            let apply (args: MxRecordRecordArgs) =
                args.Preference <- io preference
                args

            ()
            n, List.Cons(apply, args)

    let mxRecordRecord = MxRecordRecordBuilder()

    type SrvRecordRecordBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SrvRecordRecordArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("port")>]
        member _.Port((n, args), port) =
            let apply (args: SrvRecordRecordArgs) =
                args.Port <- input port
                args

            ()
            n, List.Cons(apply, args)

        member _.Port((n, args), port) =
            let apply (args: SrvRecordRecordArgs) =
                args.Port <- io port
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("priority")>]
        member _.Priority((n, args), priority) =
            let apply (args: SrvRecordRecordArgs) =
                args.Priority <- input priority
                args

            ()
            n, List.Cons(apply, args)

        member _.Priority((n, args), priority) =
            let apply (args: SrvRecordRecordArgs) =
                args.Priority <- io priority
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("target")>]
        member _.Target((n, args), target) =
            let apply (args: SrvRecordRecordArgs) =
                args.Target <- input target
                args

            ()
            n, List.Cons(apply, args)

        member _.Target((n, args), target) =
            let apply (args: SrvRecordRecordArgs) =
                args.Target <- io target
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("weight")>]
        member _.Weight((n, args), weight) =
            let apply (args: SrvRecordRecordArgs) =
                args.Weight <- input weight
                args

            ()
            n, List.Cons(apply, args)

        member _.Weight((n, args), weight) =
            let apply (args: SrvRecordRecordArgs) =
                args.Weight <- io weight
                args

            ()
            n, List.Cons(apply, args)

    let srvRecordRecord = SrvRecordRecordBuilder()

    type TxtRecordRecordBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (TxtRecordRecordArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("value")>]
        member _.Value((n, args), value) =
            let apply (args: TxtRecordRecordArgs) =
                args.Value <- input value
                args

            ()
            n, List.Cons(apply, args)

        member _.Value((n, args), value) =
            let apply (args: TxtRecordRecordArgs) =
                args.Value <- io value
                args

            ()
            n, List.Cons(apply, args)

    let txtRecordRecord = TxtRecordRecordBuilder()

    type ARecordBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ARecord(name, (List.fold func (ARecordArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ARecordArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ARecordArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("records")>]
        member _.Records((name, args), records) =
            let apply (args: ARecordArgs) =
                args.Records <- inputList records
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ARecordArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ARecordArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ARecordArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("targetResourceId")>]
        member _.TargetResourceId((name, args), targetResourceId) =
            let apply (args: ARecordArgs) =
                args.TargetResourceId <- input targetResourceId
                args

            ()
            name, List.Cons(apply, args)

        member _.TargetResourceId((name, args), targetResourceId) =
            let apply (args: ARecordArgs) =
                args.TargetResourceId <- io targetResourceId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("ttl")>]
        member _.Ttl((name, args), ttl) =
            let apply (args: ARecordArgs) =
                args.Ttl <- input ttl
                args

            ()
            name, List.Cons(apply, args)

        member _.Ttl((name, args), ttl) =
            let apply (args: ARecordArgs) =
                args.Ttl <- io ttl
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zoneName")>]
        member _.ZoneName((name, args), zoneName) =
            let apply (args: ARecordArgs) =
                args.ZoneName <- input zoneName
                args

            ()
            name, List.Cons(apply, args)

        member _.ZoneName((name, args), zoneName) =
            let apply (args: ARecordArgs) =
                args.ZoneName <- io zoneName
                args

            ()
            name, List.Cons(apply, args)

    let aRecord = ARecordBuilder()

    type AaaaRecordBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            AaaaRecord(name, (List.fold func (AaaaRecordArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: AaaaRecordArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: AaaaRecordArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("records")>]
        member _.Records((name, args), records) =
            let apply (args: AaaaRecordArgs) =
                args.Records <- inputList records
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AaaaRecordArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AaaaRecordArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: AaaaRecordArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("targetResourceId")>]
        member _.TargetResourceId((name, args), targetResourceId) =
            let apply (args: AaaaRecordArgs) =
                args.TargetResourceId <- input targetResourceId
                args

            ()
            name, List.Cons(apply, args)

        member _.TargetResourceId((name, args), targetResourceId) =
            let apply (args: AaaaRecordArgs) =
                args.TargetResourceId <- io targetResourceId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("ttl")>]
        member _.Ttl((name, args), ttl) =
            let apply (args: AaaaRecordArgs) =
                args.Ttl <- input ttl
                args

            ()
            name, List.Cons(apply, args)

        member _.Ttl((name, args), ttl) =
            let apply (args: AaaaRecordArgs) =
                args.Ttl <- io ttl
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zoneName")>]
        member _.ZoneName((name, args), zoneName) =
            let apply (args: AaaaRecordArgs) =
                args.ZoneName <- input zoneName
                args

            ()
            name, List.Cons(apply, args)

        member _.ZoneName((name, args), zoneName) =
            let apply (args: AaaaRecordArgs) =
                args.ZoneName <- io zoneName
                args

            ()
            name, List.Cons(apply, args)

    let aaaaRecord = AaaaRecordBuilder()

    type CNameRecordBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            CNameRecord(name, (List.fold func (CNameRecordArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: CNameRecordArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: CNameRecordArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("record")>]
        member _.Record((name, args), record) =
            let apply (args: CNameRecordArgs) =
                args.Record <- input record
                args

            ()
            name, List.Cons(apply, args)

        member _.Record((name, args), record) =
            let apply (args: CNameRecordArgs) =
                args.Record <- io record
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: CNameRecordArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: CNameRecordArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: CNameRecordArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("targetResourceId")>]
        member _.TargetResourceId((name, args), targetResourceId) =
            let apply (args: CNameRecordArgs) =
                args.TargetResourceId <- input targetResourceId
                args

            ()
            name, List.Cons(apply, args)

        member _.TargetResourceId((name, args), targetResourceId) =
            let apply (args: CNameRecordArgs) =
                args.TargetResourceId <- io targetResourceId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("ttl")>]
        member _.Ttl((name, args), ttl) =
            let apply (args: CNameRecordArgs) =
                args.Ttl <- input ttl
                args

            ()
            name, List.Cons(apply, args)

        member _.Ttl((name, args), ttl) =
            let apply (args: CNameRecordArgs) =
                args.Ttl <- io ttl
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zoneName")>]
        member _.ZoneName((name, args), zoneName) =
            let apply (args: CNameRecordArgs) =
                args.ZoneName <- input zoneName
                args

            ()
            name, List.Cons(apply, args)

        member _.ZoneName((name, args), zoneName) =
            let apply (args: CNameRecordArgs) =
                args.ZoneName <- io zoneName
                args

            ()
            name, List.Cons(apply, args)

    let cNameRecord = CNameRecordBuilder()

    type CaaRecordBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            CaaRecord(name, (List.fold func (CaaRecordArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: CaaRecordArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: CaaRecordArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("records")>]
        member _.Records((name, args), records) =
            let apply (args: CaaRecordArgs) =
                args.Records <- inputList records
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: CaaRecordArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: CaaRecordArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: CaaRecordArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("ttl")>]
        member _.Ttl((name, args), ttl) =
            let apply (args: CaaRecordArgs) =
                args.Ttl <- input ttl
                args

            ()
            name, List.Cons(apply, args)

        member _.Ttl((name, args), ttl) =
            let apply (args: CaaRecordArgs) =
                args.Ttl <- io ttl
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zoneName")>]
        member _.ZoneName((name, args), zoneName) =
            let apply (args: CaaRecordArgs) =
                args.ZoneName <- input zoneName
                args

            ()
            name, List.Cons(apply, args)

        member _.ZoneName((name, args), zoneName) =
            let apply (args: CaaRecordArgs) =
                args.ZoneName <- io zoneName
                args

            ()
            name, List.Cons(apply, args)

    let caaRecord = CaaRecordBuilder()

    type MxRecordBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            MxRecord(name, (List.fold func (MxRecordArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: MxRecordArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: MxRecordArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("records")>]
        member _.Records((name, args), records) =
            let apply (args: MxRecordArgs) =
                args.Records <- inputList records
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: MxRecordArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: MxRecordArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: MxRecordArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("ttl")>]
        member _.Ttl((name, args), ttl) =
            let apply (args: MxRecordArgs) =
                args.Ttl <- input ttl
                args

            ()
            name, List.Cons(apply, args)

        member _.Ttl((name, args), ttl) =
            let apply (args: MxRecordArgs) =
                args.Ttl <- io ttl
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zoneName")>]
        member _.ZoneName((name, args), zoneName) =
            let apply (args: MxRecordArgs) =
                args.ZoneName <- input zoneName
                args

            ()
            name, List.Cons(apply, args)

        member _.ZoneName((name, args), zoneName) =
            let apply (args: MxRecordArgs) =
                args.ZoneName <- io zoneName
                args

            ()
            name, List.Cons(apply, args)

    let mxRecord = MxRecordBuilder()

    type NsRecordBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            NsRecord(name, (List.fold func (NsRecordArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: NsRecordArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: NsRecordArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("records")>]
        member _.Records((name, args), records) =
            let apply (args: NsRecordArgs) =
                args.Records <- inputList records
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NsRecordArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NsRecordArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: NsRecordArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("ttl")>]
        member _.Ttl((name, args), ttl) =
            let apply (args: NsRecordArgs) =
                args.Ttl <- input ttl
                args

            ()
            name, List.Cons(apply, args)

        member _.Ttl((name, args), ttl) =
            let apply (args: NsRecordArgs) =
                args.Ttl <- io ttl
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zoneName")>]
        member _.ZoneName((name, args), zoneName) =
            let apply (args: NsRecordArgs) =
                args.ZoneName <- input zoneName
                args

            ()
            name, List.Cons(apply, args)

        member _.ZoneName((name, args), zoneName) =
            let apply (args: NsRecordArgs) =
                args.ZoneName <- io zoneName
                args

            ()
            name, List.Cons(apply, args)

    let nsRecord = NsRecordBuilder()

    type PtrRecordBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            PtrRecord(name, (List.fold func (PtrRecordArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: PtrRecordArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: PtrRecordArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("records")>]
        member _.Records((name, args), records) =
            let apply (args: PtrRecordArgs) =
                args.Records <- inputList records
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: PtrRecordArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: PtrRecordArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: PtrRecordArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("ttl")>]
        member _.Ttl((name, args), ttl) =
            let apply (args: PtrRecordArgs) =
                args.Ttl <- input ttl
                args

            ()
            name, List.Cons(apply, args)

        member _.Ttl((name, args), ttl) =
            let apply (args: PtrRecordArgs) =
                args.Ttl <- io ttl
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zoneName")>]
        member _.ZoneName((name, args), zoneName) =
            let apply (args: PtrRecordArgs) =
                args.ZoneName <- input zoneName
                args

            ()
            name, List.Cons(apply, args)

        member _.ZoneName((name, args), zoneName) =
            let apply (args: PtrRecordArgs) =
                args.ZoneName <- io zoneName
                args

            ()
            name, List.Cons(apply, args)

    let ptrRecord = PtrRecordBuilder()

    type SrvRecordBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            SrvRecord(name, (List.fold func (SrvRecordArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: SrvRecordArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: SrvRecordArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("records")>]
        member _.Records((name, args), records) =
            let apply (args: SrvRecordArgs) =
                args.Records <- inputList records
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SrvRecordArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SrvRecordArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: SrvRecordArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("ttl")>]
        member _.Ttl((name, args), ttl) =
            let apply (args: SrvRecordArgs) =
                args.Ttl <- input ttl
                args

            ()
            name, List.Cons(apply, args)

        member _.Ttl((name, args), ttl) =
            let apply (args: SrvRecordArgs) =
                args.Ttl <- io ttl
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zoneName")>]
        member _.ZoneName((name, args), zoneName) =
            let apply (args: SrvRecordArgs) =
                args.ZoneName <- input zoneName
                args

            ()
            name, List.Cons(apply, args)

        member _.ZoneName((name, args), zoneName) =
            let apply (args: SrvRecordArgs) =
                args.ZoneName <- io zoneName
                args

            ()
            name, List.Cons(apply, args)

    let srvRecord = SrvRecordBuilder()

    type TxtRecordBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            TxtRecord(name, (List.fold func (TxtRecordArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: TxtRecordArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: TxtRecordArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("records")>]
        member _.Records((name, args), records) =
            let apply (args: TxtRecordArgs) =
                args.Records <- inputList records
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: TxtRecordArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: TxtRecordArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: TxtRecordArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("ttl")>]
        member _.Ttl((name, args), ttl) =
            let apply (args: TxtRecordArgs) =
                args.Ttl <- input ttl
                args

            ()
            name, List.Cons(apply, args)

        member _.Ttl((name, args), ttl) =
            let apply (args: TxtRecordArgs) =
                args.Ttl <- io ttl
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zoneName")>]
        member _.ZoneName((name, args), zoneName) =
            let apply (args: TxtRecordArgs) =
                args.ZoneName <- input zoneName
                args

            ()
            name, List.Cons(apply, args)

        member _.ZoneName((name, args), zoneName) =
            let apply (args: TxtRecordArgs) =
                args.ZoneName <- io zoneName
                args

            ()
            name, List.Cons(apply, args)

    let txtRecord = TxtRecordBuilder()

    type ZoneBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Zone(name, (List.fold func (ZoneArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ZoneArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ZoneArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ZoneArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ZoneArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ZoneArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let zone = ZoneBuilder()

module EventGrid =
    open Pulumi.Azure.EventGrid
    open Pulumi.Azure.EventGrid.Inputs

    type DomainInputMappingDefaultValuesBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (DomainInputMappingDefaultValuesArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("dataVersion")>]
        member _.DataVersion((n, args), dataVersion) =
            let apply (args: DomainInputMappingDefaultValuesArgs) =
                args.DataVersion <- input dataVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.DataVersion((n, args), dataVersion) =
            let apply (args: DomainInputMappingDefaultValuesArgs) =
                args.DataVersion <- io dataVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("eventType")>]
        member _.EventType((n, args), eventType) =
            let apply (args: DomainInputMappingDefaultValuesArgs) =
                args.EventType <- input eventType
                args

            ()
            n, List.Cons(apply, args)

        member _.EventType((n, args), eventType) =
            let apply (args: DomainInputMappingDefaultValuesArgs) =
                args.EventType <- io eventType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subject")>]
        member _.Subject((n, args), subject) =
            let apply (args: DomainInputMappingDefaultValuesArgs) =
                args.Subject <- input subject
                args

            ()
            n, List.Cons(apply, args)

        member _.Subject((n, args), subject) =
            let apply (args: DomainInputMappingDefaultValuesArgs) =
                args.Subject <- io subject
                args

            ()
            n, List.Cons(apply, args)

    let domainInputMappingDefaultValues = DomainInputMappingDefaultValuesBuilder()

    type DomainInputMappingFieldsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (DomainInputMappingFieldsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("dataVersion")>]
        member _.DataVersion((n, args), dataVersion) =
            let apply (args: DomainInputMappingFieldsArgs) =
                args.DataVersion <- input dataVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.DataVersion((n, args), dataVersion) =
            let apply (args: DomainInputMappingFieldsArgs) =
                args.DataVersion <- io dataVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("eventTime")>]
        member _.EventTime((n, args), eventTime) =
            let apply (args: DomainInputMappingFieldsArgs) =
                args.EventTime <- input eventTime
                args

            ()
            n, List.Cons(apply, args)

        member _.EventTime((n, args), eventTime) =
            let apply (args: DomainInputMappingFieldsArgs) =
                args.EventTime <- io eventTime
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("eventType")>]
        member _.EventType((n, args), eventType) =
            let apply (args: DomainInputMappingFieldsArgs) =
                args.EventType <- input eventType
                args

            ()
            n, List.Cons(apply, args)

        member _.EventType((n, args), eventType) =
            let apply (args: DomainInputMappingFieldsArgs) =
                args.EventType <- io eventType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: DomainInputMappingFieldsArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: DomainInputMappingFieldsArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subject")>]
        member _.Subject((n, args), subject) =
            let apply (args: DomainInputMappingFieldsArgs) =
                args.Subject <- input subject
                args

            ()
            n, List.Cons(apply, args)

        member _.Subject((n, args), subject) =
            let apply (args: DomainInputMappingFieldsArgs) =
                args.Subject <- io subject
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("topic")>]
        member _.Topic((n, args), topic) =
            let apply (args: DomainInputMappingFieldsArgs) =
                args.Topic <- input topic
                args

            ()
            n, List.Cons(apply, args)

        member _.Topic((n, args), topic) =
            let apply (args: DomainInputMappingFieldsArgs) =
                args.Topic <- io topic
                args

            ()
            n, List.Cons(apply, args)

    let domainInputMappingFields = DomainInputMappingFieldsBuilder()

    type EventSubscriptionAdvancedFilterBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionAdvancedFilterArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("boolEquals")>]
        member _.BoolEquals((n, args), boolEquals) =
            let apply (args: EventSubscriptionAdvancedFilterArgs) =
                args.BoolEquals <- inputList boolEquals
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("numberGreaterThanOrEquals")>]
        member _.NumberGreaterThanOrEquals((n, args), numberGreaterThanOrEquals) =
            let apply (args: EventSubscriptionAdvancedFilterArgs) =
                args.NumberGreaterThanOrEquals <- inputList numberGreaterThanOrEquals
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("numberGreaterThans")>]
        member _.NumberGreaterThans((n, args), numberGreaterThans) =
            let apply (args: EventSubscriptionAdvancedFilterArgs) =
                args.NumberGreaterThans <- inputList numberGreaterThans
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("numberIns")>]
        member _.NumberIns((n, args), numberIns) =
            let apply (args: EventSubscriptionAdvancedFilterArgs) =
                args.NumberIns <- inputList numberIns
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("numberLessThanOrEquals")>]
        member _.NumberLessThanOrEquals((n, args), numberLessThanOrEquals) =
            let apply (args: EventSubscriptionAdvancedFilterArgs) =
                args.NumberLessThanOrEquals <- inputList numberLessThanOrEquals
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("numberLessThans")>]
        member _.NumberLessThans((n, args), numberLessThans) =
            let apply (args: EventSubscriptionAdvancedFilterArgs) =
                args.NumberLessThans <- inputList numberLessThans
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("numberNotIns")>]
        member _.NumberNotIns((n, args), numberNotIns) =
            let apply (args: EventSubscriptionAdvancedFilterArgs) =
                args.NumberNotIns <- inputList numberNotIns
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("stringBeginsWiths")>]
        member _.StringBeginsWiths((n, args), stringBeginsWiths) =
            let apply (args: EventSubscriptionAdvancedFilterArgs) =
                args.StringBeginsWiths <- inputList stringBeginsWiths
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("stringContains")>]
        member _.StringContains((n, args), stringContains) =
            let apply (args: EventSubscriptionAdvancedFilterArgs) =
                args.StringContains <- inputList stringContains
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("stringEndsWiths")>]
        member _.StringEndsWiths((n, args), stringEndsWiths) =
            let apply (args: EventSubscriptionAdvancedFilterArgs) =
                args.StringEndsWiths <- inputList stringEndsWiths
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("stringIns")>]
        member _.StringIns((n, args), stringIns) =
            let apply (args: EventSubscriptionAdvancedFilterArgs) =
                args.StringIns <- inputList stringIns
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("stringNotIns")>]
        member _.StringNotIns((n, args), stringNotIns) =
            let apply (args: EventSubscriptionAdvancedFilterArgs) =
                args.StringNotIns <- inputList stringNotIns
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionAdvancedFilter = EventSubscriptionAdvancedFilterBuilder()

    type EventSubscriptionAdvancedFilterBoolEqualBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionAdvancedFilterBoolEqualArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("key")>]
        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterBoolEqualArgs) =
                args.Key <- input key
                args

            ()
            n, List.Cons(apply, args)

        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterBoolEqualArgs) =
                args.Key <- io key
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((n, args), value) =
            let apply (args: EventSubscriptionAdvancedFilterBoolEqualArgs) =
                args.Value <- input value
                args

            ()
            n, List.Cons(apply, args)

        member _.Value((n, args), value) =
            let apply (args: EventSubscriptionAdvancedFilterBoolEqualArgs) =
                args.Value <- io value
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionAdvancedFilterBoolEqual =
        EventSubscriptionAdvancedFilterBoolEqualBuilder()

    type EventSubscriptionAdvancedFilterNumberGreaterThanBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionAdvancedFilterNumberGreaterThanArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("key")>]
        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterNumberGreaterThanArgs) =
                args.Key <- input key
                args

            ()
            n, List.Cons(apply, args)

        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterNumberGreaterThanArgs) =
                args.Key <- io key
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((n, args), value) =
            let apply (args: EventSubscriptionAdvancedFilterNumberGreaterThanArgs) =
                args.Value <- input value
                args

            ()
            n, List.Cons(apply, args)

        member _.Value((n, args), value) =
            let apply (args: EventSubscriptionAdvancedFilterNumberGreaterThanArgs) =
                args.Value <- io value
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionAdvancedFilterNumberGreaterThan =
        EventSubscriptionAdvancedFilterNumberGreaterThanBuilder()

    type EventSubscriptionAdvancedFilterNumberGreaterThanOrEqualBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("key")>]
        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgs) =
                args.Key <- input key
                args

            ()
            n, List.Cons(apply, args)

        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgs) =
                args.Key <- io key
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((n, args), value) =
            let apply (args: EventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgs) =
                args.Value <- input value
                args

            ()
            n, List.Cons(apply, args)

        member _.Value((n, args), value) =
            let apply (args: EventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgs) =
                args.Value <- io value
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionAdvancedFilterNumberGreaterThanOrEqual =
        EventSubscriptionAdvancedFilterNumberGreaterThanOrEqualBuilder()

    type EventSubscriptionAdvancedFilterNumberInBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionAdvancedFilterNumberInArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("key")>]
        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterNumberInArgs) =
                args.Key <- input key
                args

            ()
            n, List.Cons(apply, args)

        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterNumberInArgs) =
                args.Key <- io key
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: EventSubscriptionAdvancedFilterNumberInArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionAdvancedFilterNumberIn =
        EventSubscriptionAdvancedFilterNumberInBuilder()

    type EventSubscriptionAdvancedFilterNumberLessThanBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionAdvancedFilterNumberLessThanArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("key")>]
        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterNumberLessThanArgs) =
                args.Key <- input key
                args

            ()
            n, List.Cons(apply, args)

        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterNumberLessThanArgs) =
                args.Key <- io key
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((n, args), value) =
            let apply (args: EventSubscriptionAdvancedFilterNumberLessThanArgs) =
                args.Value <- input value
                args

            ()
            n, List.Cons(apply, args)

        member _.Value((n, args), value) =
            let apply (args: EventSubscriptionAdvancedFilterNumberLessThanArgs) =
                args.Value <- io value
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionAdvancedFilterNumberLessThan =
        EventSubscriptionAdvancedFilterNumberLessThanBuilder()

    type EventSubscriptionAdvancedFilterNumberLessThanOrEqualBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionAdvancedFilterNumberLessThanOrEqualArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("key")>]
        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterNumberLessThanOrEqualArgs) =
                args.Key <- input key
                args

            ()
            n, List.Cons(apply, args)

        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterNumberLessThanOrEqualArgs) =
                args.Key <- io key
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((n, args), value) =
            let apply (args: EventSubscriptionAdvancedFilterNumberLessThanOrEqualArgs) =
                args.Value <- input value
                args

            ()
            n, List.Cons(apply, args)

        member _.Value((n, args), value) =
            let apply (args: EventSubscriptionAdvancedFilterNumberLessThanOrEqualArgs) =
                args.Value <- io value
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionAdvancedFilterNumberLessThanOrEqual =
        EventSubscriptionAdvancedFilterNumberLessThanOrEqualBuilder()

    type EventSubscriptionAdvancedFilterNumberNotInBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionAdvancedFilterNumberNotInArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("key")>]
        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterNumberNotInArgs) =
                args.Key <- input key
                args

            ()
            n, List.Cons(apply, args)

        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterNumberNotInArgs) =
                args.Key <- io key
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: EventSubscriptionAdvancedFilterNumberNotInArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionAdvancedFilterNumberNotIn =
        EventSubscriptionAdvancedFilterNumberNotInBuilder()

    type EventSubscriptionAdvancedFilterStringBeginsWithBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionAdvancedFilterStringBeginsWithArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("key")>]
        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterStringBeginsWithArgs) =
                args.Key <- input key
                args

            ()
            n, List.Cons(apply, args)

        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterStringBeginsWithArgs) =
                args.Key <- io key
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: EventSubscriptionAdvancedFilterStringBeginsWithArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionAdvancedFilterStringBeginsWith =
        EventSubscriptionAdvancedFilterStringBeginsWithBuilder()

    type EventSubscriptionAdvancedFilterStringContainBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionAdvancedFilterStringContainArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("key")>]
        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterStringContainArgs) =
                args.Key <- input key
                args

            ()
            n, List.Cons(apply, args)

        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterStringContainArgs) =
                args.Key <- io key
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: EventSubscriptionAdvancedFilterStringContainArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionAdvancedFilterStringContain =
        EventSubscriptionAdvancedFilterStringContainBuilder()

    type EventSubscriptionAdvancedFilterStringEndsWithBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionAdvancedFilterStringEndsWithArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("key")>]
        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterStringEndsWithArgs) =
                args.Key <- input key
                args

            ()
            n, List.Cons(apply, args)

        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterStringEndsWithArgs) =
                args.Key <- io key
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: EventSubscriptionAdvancedFilterStringEndsWithArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionAdvancedFilterStringEndsWith =
        EventSubscriptionAdvancedFilterStringEndsWithBuilder()

    type EventSubscriptionAdvancedFilterStringInBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionAdvancedFilterStringInArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("key")>]
        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterStringInArgs) =
                args.Key <- input key
                args

            ()
            n, List.Cons(apply, args)

        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterStringInArgs) =
                args.Key <- io key
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: EventSubscriptionAdvancedFilterStringInArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionAdvancedFilterStringIn =
        EventSubscriptionAdvancedFilterStringInBuilder()

    type EventSubscriptionAdvancedFilterStringNotInBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionAdvancedFilterStringNotInArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("key")>]
        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterStringNotInArgs) =
                args.Key <- input key
                args

            ()
            n, List.Cons(apply, args)

        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterStringNotInArgs) =
                args.Key <- io key
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: EventSubscriptionAdvancedFilterStringNotInArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionAdvancedFilterStringNotIn =
        EventSubscriptionAdvancedFilterStringNotInBuilder()

    type EventSubscriptionAzureFunctionEndpointBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionAzureFunctionEndpointArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("functionId")>]
        member _.FunctionId((n, args), functionId) =
            let apply (args: EventSubscriptionAzureFunctionEndpointArgs) =
                args.FunctionId <- input functionId
                args

            ()
            n, List.Cons(apply, args)

        member _.FunctionId((n, args), functionId) =
            let apply (args: EventSubscriptionAzureFunctionEndpointArgs) =
                args.FunctionId <- io functionId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("maxEventsPerBatch")>]
        member _.MaxEventsPerBatch((n, args), maxEventsPerBatch) =
            let apply (args: EventSubscriptionAzureFunctionEndpointArgs) =
                args.MaxEventsPerBatch <- input maxEventsPerBatch
                args

            ()
            n, List.Cons(apply, args)

        member _.MaxEventsPerBatch((n, args), maxEventsPerBatch) =
            let apply (args: EventSubscriptionAzureFunctionEndpointArgs) =
                args.MaxEventsPerBatch <- io maxEventsPerBatch
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("preferredBatchSizeInKilobytes")>]
        member _.PreferredBatchSizeInKilobytes((n, args), preferredBatchSizeInKilobytes) =
            let apply (args: EventSubscriptionAzureFunctionEndpointArgs) =
                args.PreferredBatchSizeInKilobytes <- input preferredBatchSizeInKilobytes
                args

            ()
            n, List.Cons(apply, args)

        member _.PreferredBatchSizeInKilobytes((n, args), preferredBatchSizeInKilobytes) =
            let apply (args: EventSubscriptionAzureFunctionEndpointArgs) =
                args.PreferredBatchSizeInKilobytes <- io preferredBatchSizeInKilobytes
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionAzureFunctionEndpoint =
        EventSubscriptionAzureFunctionEndpointBuilder()

    type EventSubscriptionEventhubEndpointBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionEventhubEndpointArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("eventhubId")>]
        member _.EventhubId((n, args), eventhubId) =
            let apply (args: EventSubscriptionEventhubEndpointArgs) =
                args.EventhubId <- input eventhubId
                args

            ()
            n, List.Cons(apply, args)

        member _.EventhubId((n, args), eventhubId) =
            let apply (args: EventSubscriptionEventhubEndpointArgs) =
                args.EventhubId <- io eventhubId
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionEventhubEndpoint =
        EventSubscriptionEventhubEndpointBuilder()

    type EventSubscriptionHybridConnectionEndpointBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionHybridConnectionEndpointArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("hybridConnectionId")>]
        member _.HybridConnectionId((n, args), hybridConnectionId) =
            let apply (args: EventSubscriptionHybridConnectionEndpointArgs) =
                args.HybridConnectionId <- input hybridConnectionId
                args

            ()
            n, List.Cons(apply, args)

        member _.HybridConnectionId((n, args), hybridConnectionId) =
            let apply (args: EventSubscriptionHybridConnectionEndpointArgs) =
                args.HybridConnectionId <- io hybridConnectionId
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionHybridConnectionEndpoint =
        EventSubscriptionHybridConnectionEndpointBuilder()

    type EventSubscriptionRetryPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionRetryPolicyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("eventTimeToLive")>]
        member _.EventTimeToLive((n, args), eventTimeToLive) =
            let apply (args: EventSubscriptionRetryPolicyArgs) =
                args.EventTimeToLive <- input eventTimeToLive
                args

            ()
            n, List.Cons(apply, args)

        member _.EventTimeToLive((n, args), eventTimeToLive) =
            let apply (args: EventSubscriptionRetryPolicyArgs) =
                args.EventTimeToLive <- io eventTimeToLive
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("maxDeliveryAttempts")>]
        member _.MaxDeliveryAttempts((n, args), maxDeliveryAttempts) =
            let apply (args: EventSubscriptionRetryPolicyArgs) =
                args.MaxDeliveryAttempts <- input maxDeliveryAttempts
                args

            ()
            n, List.Cons(apply, args)

        member _.MaxDeliveryAttempts((n, args), maxDeliveryAttempts) =
            let apply (args: EventSubscriptionRetryPolicyArgs) =
                args.MaxDeliveryAttempts <- io maxDeliveryAttempts
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionRetryPolicy = EventSubscriptionRetryPolicyBuilder()

    type EventSubscriptionStorageBlobDeadLetterDestinationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionStorageBlobDeadLetterDestinationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("storageAccountId")>]
        member _.StorageAccountId((n, args), storageAccountId) =
            let apply (args: EventSubscriptionStorageBlobDeadLetterDestinationArgs) =
                args.StorageAccountId <- input storageAccountId
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountId((n, args), storageAccountId) =
            let apply (args: EventSubscriptionStorageBlobDeadLetterDestinationArgs) =
                args.StorageAccountId <- io storageAccountId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageBlobContainerName")>]
        member _.StorageBlobContainerName((n, args), storageBlobContainerName) =
            let apply (args: EventSubscriptionStorageBlobDeadLetterDestinationArgs) =
                args.StorageBlobContainerName <- input storageBlobContainerName
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageBlobContainerName((n, args), storageBlobContainerName) =
            let apply (args: EventSubscriptionStorageBlobDeadLetterDestinationArgs) =
                args.StorageBlobContainerName <- io storageBlobContainerName
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionStorageBlobDeadLetterDestination =
        EventSubscriptionStorageBlobDeadLetterDestinationBuilder()

    type EventSubscriptionStorageQueueEndpointBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionStorageQueueEndpointArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("queueName")>]
        member _.QueueName((n, args), queueName) =
            let apply (args: EventSubscriptionStorageQueueEndpointArgs) =
                args.QueueName <- input queueName
                args

            ()
            n, List.Cons(apply, args)

        member _.QueueName((n, args), queueName) =
            let apply (args: EventSubscriptionStorageQueueEndpointArgs) =
                args.QueueName <- io queueName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageAccountId")>]
        member _.StorageAccountId((n, args), storageAccountId) =
            let apply (args: EventSubscriptionStorageQueueEndpointArgs) =
                args.StorageAccountId <- input storageAccountId
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountId((n, args), storageAccountId) =
            let apply (args: EventSubscriptionStorageQueueEndpointArgs) =
                args.StorageAccountId <- io storageAccountId
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionStorageQueueEndpoint =
        EventSubscriptionStorageQueueEndpointBuilder()

    type EventSubscriptionSubjectFilterBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionSubjectFilterArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("caseSensitive")>]
        member _.CaseSensitive((n, args), caseSensitive) =
            let apply (args: EventSubscriptionSubjectFilterArgs) =
                args.CaseSensitive <- input caseSensitive
                args

            ()
            n, List.Cons(apply, args)

        member _.CaseSensitive((n, args), caseSensitive) =
            let apply (args: EventSubscriptionSubjectFilterArgs) =
                args.CaseSensitive <- io caseSensitive
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subjectBeginsWith")>]
        member _.SubjectBeginsWith((n, args), subjectBeginsWith) =
            let apply (args: EventSubscriptionSubjectFilterArgs) =
                args.SubjectBeginsWith <- input subjectBeginsWith
                args

            ()
            n, List.Cons(apply, args)

        member _.SubjectBeginsWith((n, args), subjectBeginsWith) =
            let apply (args: EventSubscriptionSubjectFilterArgs) =
                args.SubjectBeginsWith <- io subjectBeginsWith
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subjectEndsWith")>]
        member _.SubjectEndsWith((n, args), subjectEndsWith) =
            let apply (args: EventSubscriptionSubjectFilterArgs) =
                args.SubjectEndsWith <- input subjectEndsWith
                args

            ()
            n, List.Cons(apply, args)

        member _.SubjectEndsWith((n, args), subjectEndsWith) =
            let apply (args: EventSubscriptionSubjectFilterArgs) =
                args.SubjectEndsWith <- io subjectEndsWith
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionSubjectFilter = EventSubscriptionSubjectFilterBuilder()

    type EventSubscriptionWebhookEndpointBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionWebhookEndpointArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("activeDirectoryAppIdOrUri")>]
        member _.ActiveDirectoryAppIdOrUri((n, args), activeDirectoryAppIdOrUri) =
            let apply (args: EventSubscriptionWebhookEndpointArgs) =
                args.ActiveDirectoryAppIdOrUri <- input activeDirectoryAppIdOrUri
                args

            ()
            n, List.Cons(apply, args)

        member _.ActiveDirectoryAppIdOrUri((n, args), activeDirectoryAppIdOrUri) =
            let apply (args: EventSubscriptionWebhookEndpointArgs) =
                args.ActiveDirectoryAppIdOrUri <- io activeDirectoryAppIdOrUri
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("activeDirectoryTenantId")>]
        member _.ActiveDirectoryTenantId((n, args), activeDirectoryTenantId) =
            let apply (args: EventSubscriptionWebhookEndpointArgs) =
                args.ActiveDirectoryTenantId <- input activeDirectoryTenantId
                args

            ()
            n, List.Cons(apply, args)

        member _.ActiveDirectoryTenantId((n, args), activeDirectoryTenantId) =
            let apply (args: EventSubscriptionWebhookEndpointArgs) =
                args.ActiveDirectoryTenantId <- io activeDirectoryTenantId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("baseUrl")>]
        member _.BaseUrl((n, args), baseUrl) =
            let apply (args: EventSubscriptionWebhookEndpointArgs) =
                args.BaseUrl <- input baseUrl
                args

            ()
            n, List.Cons(apply, args)

        member _.BaseUrl((n, args), baseUrl) =
            let apply (args: EventSubscriptionWebhookEndpointArgs) =
                args.BaseUrl <- io baseUrl
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("maxEventsPerBatch")>]
        member _.MaxEventsPerBatch((n, args), maxEventsPerBatch) =
            let apply (args: EventSubscriptionWebhookEndpointArgs) =
                args.MaxEventsPerBatch <- input maxEventsPerBatch
                args

            ()
            n, List.Cons(apply, args)

        member _.MaxEventsPerBatch((n, args), maxEventsPerBatch) =
            let apply (args: EventSubscriptionWebhookEndpointArgs) =
                args.MaxEventsPerBatch <- io maxEventsPerBatch
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("preferredBatchSizeInKilobytes")>]
        member _.PreferredBatchSizeInKilobytes((n, args), preferredBatchSizeInKilobytes) =
            let apply (args: EventSubscriptionWebhookEndpointArgs) =
                args.PreferredBatchSizeInKilobytes <- input preferredBatchSizeInKilobytes
                args

            ()
            n, List.Cons(apply, args)

        member _.PreferredBatchSizeInKilobytes((n, args), preferredBatchSizeInKilobytes) =
            let apply (args: EventSubscriptionWebhookEndpointArgs) =
                args.PreferredBatchSizeInKilobytes <- io preferredBatchSizeInKilobytes
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("url")>]
        member _.Url((n, args), url) =
            let apply (args: EventSubscriptionWebhookEndpointArgs) =
                args.Url <- input url
                args

            ()
            n, List.Cons(apply, args)

        member _.Url((n, args), url) =
            let apply (args: EventSubscriptionWebhookEndpointArgs) =
                args.Url <- io url
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionWebhookEndpoint =
        EventSubscriptionWebhookEndpointBuilder()

    type TopicInputMappingDefaultValuesBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (TopicInputMappingDefaultValuesArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("dataVersion")>]
        member _.DataVersion((n, args), dataVersion) =
            let apply (args: TopicInputMappingDefaultValuesArgs) =
                args.DataVersion <- input dataVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.DataVersion((n, args), dataVersion) =
            let apply (args: TopicInputMappingDefaultValuesArgs) =
                args.DataVersion <- io dataVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("eventType")>]
        member _.EventType((n, args), eventType) =
            let apply (args: TopicInputMappingDefaultValuesArgs) =
                args.EventType <- input eventType
                args

            ()
            n, List.Cons(apply, args)

        member _.EventType((n, args), eventType) =
            let apply (args: TopicInputMappingDefaultValuesArgs) =
                args.EventType <- io eventType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subject")>]
        member _.Subject((n, args), subject) =
            let apply (args: TopicInputMappingDefaultValuesArgs) =
                args.Subject <- input subject
                args

            ()
            n, List.Cons(apply, args)

        member _.Subject((n, args), subject) =
            let apply (args: TopicInputMappingDefaultValuesArgs) =
                args.Subject <- io subject
                args

            ()
            n, List.Cons(apply, args)

    let topicInputMappingDefaultValues = TopicInputMappingDefaultValuesBuilder()

    type TopicInputMappingFieldsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (TopicInputMappingFieldsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("dataVersion")>]
        member _.DataVersion((n, args), dataVersion) =
            let apply (args: TopicInputMappingFieldsArgs) =
                args.DataVersion <- input dataVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.DataVersion((n, args), dataVersion) =
            let apply (args: TopicInputMappingFieldsArgs) =
                args.DataVersion <- io dataVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("eventTime")>]
        member _.EventTime((n, args), eventTime) =
            let apply (args: TopicInputMappingFieldsArgs) =
                args.EventTime <- input eventTime
                args

            ()
            n, List.Cons(apply, args)

        member _.EventTime((n, args), eventTime) =
            let apply (args: TopicInputMappingFieldsArgs) =
                args.EventTime <- io eventTime
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("eventType")>]
        member _.EventType((n, args), eventType) =
            let apply (args: TopicInputMappingFieldsArgs) =
                args.EventType <- input eventType
                args

            ()
            n, List.Cons(apply, args)

        member _.EventType((n, args), eventType) =
            let apply (args: TopicInputMappingFieldsArgs) =
                args.EventType <- io eventType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: TopicInputMappingFieldsArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: TopicInputMappingFieldsArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subject")>]
        member _.Subject((n, args), subject) =
            let apply (args: TopicInputMappingFieldsArgs) =
                args.Subject <- input subject
                args

            ()
            n, List.Cons(apply, args)

        member _.Subject((n, args), subject) =
            let apply (args: TopicInputMappingFieldsArgs) =
                args.Subject <- io subject
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("topic")>]
        member _.Topic((n, args), topic) =
            let apply (args: TopicInputMappingFieldsArgs) =
                args.Topic <- input topic
                args

            ()
            n, List.Cons(apply, args)

        member _.Topic((n, args), topic) =
            let apply (args: TopicInputMappingFieldsArgs) =
                args.Topic <- io topic
                args

            ()
            n, List.Cons(apply, args)

    let topicInputMappingFields = TopicInputMappingFieldsBuilder()

    type DomainBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Domain(name, (List.fold func (DomainArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: DomainArgs) =
                   args.InputMappingDefaultValues <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: DomainArgs) =
                   args.InputMappingFields <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("inputSchema")>]
        member _.InputSchema((name, args), inputSchema) =
            let apply (args: DomainArgs) =
                args.InputSchema <- input inputSchema
                args

            ()
            name, List.Cons(apply, args)

        member _.InputSchema((name, args), inputSchema) =
            let apply (args: DomainArgs) =
                args.InputSchema <- io inputSchema
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: DomainArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: DomainArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: DomainArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: DomainArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DomainArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DomainArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: DomainArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let domain = DomainBuilder()

    type DomainTopicBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            DomainTopic(name, (List.fold func (DomainTopicArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("domainName")>]
        member _.DomainName((name, args), domainName) =
            let apply (args: DomainTopicArgs) =
                args.DomainName <- input domainName
                args

            ()
            name, List.Cons(apply, args)

        member _.DomainName((name, args), domainName) =
            let apply (args: DomainTopicArgs) =
                args.DomainName <- io domainName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: DomainTopicArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: DomainTopicArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DomainTopicArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DomainTopicArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let domainTopic = DomainTopicBuilder()

    type EventSubscriptionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            EventSubscription(name, (List.fold func (EventSubscriptionArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: EventSubscriptionArgs) =
                   args.AdvancedFilter <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: EventSubscriptionArgs) =
                   args.AzureFunctionEndpoint <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("eventDeliverySchema")>]
        member _.EventDeliverySchema((name, args), eventDeliverySchema) =
            let apply (args: EventSubscriptionArgs) =
                args.EventDeliverySchema <- input eventDeliverySchema
                args

            ()
            name, List.Cons(apply, args)

        member _.EventDeliverySchema((name, args), eventDeliverySchema) =
            let apply (args: EventSubscriptionArgs) =
                args.EventDeliverySchema <- io eventDeliverySchema
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: EventSubscriptionArgs) =
                   args.EventhubEndpoint <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("eventhubEndpointId")>]
        member _.EventhubEndpointId((name, args), eventhubEndpointId) =
            let apply (args: EventSubscriptionArgs) =
                args.EventhubEndpointId <- input eventhubEndpointId
                args

            ()
            name, List.Cons(apply, args)

        member _.EventhubEndpointId((name, args), eventhubEndpointId) =
            let apply (args: EventSubscriptionArgs) =
                args.EventhubEndpointId <- io eventhubEndpointId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("expirationTimeUtc")>]
        member _.ExpirationTimeUtc((name, args), expirationTimeUtc) =
            let apply (args: EventSubscriptionArgs) =
                args.ExpirationTimeUtc <- input expirationTimeUtc
                args

            ()
            name, List.Cons(apply, args)

        member _.ExpirationTimeUtc((name, args), expirationTimeUtc) =
            let apply (args: EventSubscriptionArgs) =
                args.ExpirationTimeUtc <- io expirationTimeUtc
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: EventSubscriptionArgs) =
                   args.HybridConnectionEndpoint <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("hybridConnectionEndpointId")>]
        member _.HybridConnectionEndpointId((name, args), hybridConnectionEndpointId) =
            let apply (args: EventSubscriptionArgs) =
                args.HybridConnectionEndpointId <- input hybridConnectionEndpointId
                args

            ()
            name, List.Cons(apply, args)

        member _.HybridConnectionEndpointId((name, args), hybridConnectionEndpointId) =
            let apply (args: EventSubscriptionArgs) =
                args.HybridConnectionEndpointId <- io hybridConnectionEndpointId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("includedEventTypes")>]
        member _.IncludedEventTypes((name, args), includedEventTypes) =
            let apply (args: EventSubscriptionArgs) =
                args.IncludedEventTypes <- inputList includedEventTypes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("labels")>]
        member _.Labels((name, args), labels) =
            let apply (args: EventSubscriptionArgs) =
                args.Labels <- inputList labels
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: EventSubscriptionArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: EventSubscriptionArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: EventSubscriptionArgs) =
                   args.RetryPolicy <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("scope")>]
        member _.Scope((name, args), scope) =
            let apply (args: EventSubscriptionArgs) =
                args.Scope <- input scope
                args

            ()
            name, List.Cons(apply, args)

        member _.Scope((name, args), scope) =
            let apply (args: EventSubscriptionArgs) =
                args.Scope <- io scope
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serviceBusQueueEndpointId")>]
        member _.ServiceBusQueueEndpointId((name, args), serviceBusQueueEndpointId) =
            let apply (args: EventSubscriptionArgs) =
                args.ServiceBusQueueEndpointId <- input serviceBusQueueEndpointId
                args

            ()
            name, List.Cons(apply, args)

        member _.ServiceBusQueueEndpointId((name, args), serviceBusQueueEndpointId) =
            let apply (args: EventSubscriptionArgs) =
                args.ServiceBusQueueEndpointId <- io serviceBusQueueEndpointId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serviceBusTopicEndpointId")>]
        member _.ServiceBusTopicEndpointId((name, args), serviceBusTopicEndpointId) =
            let apply (args: EventSubscriptionArgs) =
                args.ServiceBusTopicEndpointId <- input serviceBusTopicEndpointId
                args

            ()
            name, List.Cons(apply, args)

        member _.ServiceBusTopicEndpointId((name, args), serviceBusTopicEndpointId) =
            let apply (args: EventSubscriptionArgs) =
                args.ServiceBusTopicEndpointId <- io serviceBusTopicEndpointId
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: EventSubscriptionArgs) =
                   args.StorageBlobDeadLetterDestination <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: EventSubscriptionArgs) =
                   args.StorageQueueEndpoint <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: EventSubscriptionArgs) =
                   args.SubjectFilter <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("topicName")>]
        member _.TopicName((name, args), topicName) =
            let apply (args: EventSubscriptionArgs) =
                args.TopicName <- input topicName
                args

            ()
            name, List.Cons(apply, args)

        member _.TopicName((name, args), topicName) =
            let apply (args: EventSubscriptionArgs) =
                args.TopicName <- io topicName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: EventSubscriptionArgs) =
                   args.WebhookEndpoint <- input arg
                   args

               ()
               func) ]

    let eventSubscription = EventSubscriptionBuilder()

    type TopicBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Topic(name, (List.fold func (TopicArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: TopicArgs) =
                   args.InputMappingDefaultValues <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: TopicArgs) =
                   args.InputMappingFields <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("inputSchema")>]
        member _.InputSchema((name, args), inputSchema) =
            let apply (args: TopicArgs) =
                args.InputSchema <- input inputSchema
                args

            ()
            name, List.Cons(apply, args)

        member _.InputSchema((name, args), inputSchema) =
            let apply (args: TopicArgs) =
                args.InputSchema <- io inputSchema
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: TopicArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: TopicArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: TopicArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: TopicArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: TopicArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: TopicArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: TopicArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let topic = TopicBuilder()

module EventHub =
    open Pulumi.Azure.EventHub
    open Pulumi.Azure.EventHub.Inputs

    type DomainInputMappingDefaultValuesBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (DomainInputMappingDefaultValuesArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("dataVersion")>]
        member _.DataVersion((n, args), dataVersion) =
            let apply (args: DomainInputMappingDefaultValuesArgs) =
                args.DataVersion <- input dataVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.DataVersion((n, args), dataVersion) =
            let apply (args: DomainInputMappingDefaultValuesArgs) =
                args.DataVersion <- io dataVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("eventType")>]
        member _.EventType((n, args), eventType) =
            let apply (args: DomainInputMappingDefaultValuesArgs) =
                args.EventType <- input eventType
                args

            ()
            n, List.Cons(apply, args)

        member _.EventType((n, args), eventType) =
            let apply (args: DomainInputMappingDefaultValuesArgs) =
                args.EventType <- io eventType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subject")>]
        member _.Subject((n, args), subject) =
            let apply (args: DomainInputMappingDefaultValuesArgs) =
                args.Subject <- input subject
                args

            ()
            n, List.Cons(apply, args)

        member _.Subject((n, args), subject) =
            let apply (args: DomainInputMappingDefaultValuesArgs) =
                args.Subject <- io subject
                args

            ()
            n, List.Cons(apply, args)

    let domainInputMappingDefaultValues = DomainInputMappingDefaultValuesBuilder()

    type DomainInputMappingFieldsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (DomainInputMappingFieldsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("dataVersion")>]
        member _.DataVersion((n, args), dataVersion) =
            let apply (args: DomainInputMappingFieldsArgs) =
                args.DataVersion <- input dataVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.DataVersion((n, args), dataVersion) =
            let apply (args: DomainInputMappingFieldsArgs) =
                args.DataVersion <- io dataVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("eventTime")>]
        member _.EventTime((n, args), eventTime) =
            let apply (args: DomainInputMappingFieldsArgs) =
                args.EventTime <- input eventTime
                args

            ()
            n, List.Cons(apply, args)

        member _.EventTime((n, args), eventTime) =
            let apply (args: DomainInputMappingFieldsArgs) =
                args.EventTime <- io eventTime
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("eventType")>]
        member _.EventType((n, args), eventType) =
            let apply (args: DomainInputMappingFieldsArgs) =
                args.EventType <- input eventType
                args

            ()
            n, List.Cons(apply, args)

        member _.EventType((n, args), eventType) =
            let apply (args: DomainInputMappingFieldsArgs) =
                args.EventType <- io eventType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: DomainInputMappingFieldsArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: DomainInputMappingFieldsArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subject")>]
        member _.Subject((n, args), subject) =
            let apply (args: DomainInputMappingFieldsArgs) =
                args.Subject <- input subject
                args

            ()
            n, List.Cons(apply, args)

        member _.Subject((n, args), subject) =
            let apply (args: DomainInputMappingFieldsArgs) =
                args.Subject <- io subject
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("topic")>]
        member _.Topic((n, args), topic) =
            let apply (args: DomainInputMappingFieldsArgs) =
                args.Topic <- input topic
                args

            ()
            n, List.Cons(apply, args)

        member _.Topic((n, args), topic) =
            let apply (args: DomainInputMappingFieldsArgs) =
                args.Topic <- io topic
                args

            ()
            n, List.Cons(apply, args)

    let domainInputMappingFields = DomainInputMappingFieldsBuilder()

    type EventGridTopicInputMappingDefaultValuesBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventGridTopicInputMappingDefaultValuesArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("dataVersion")>]
        member _.DataVersion((n, args), dataVersion) =
            let apply (args: EventGridTopicInputMappingDefaultValuesArgs) =
                args.DataVersion <- input dataVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.DataVersion((n, args), dataVersion) =
            let apply (args: EventGridTopicInputMappingDefaultValuesArgs) =
                args.DataVersion <- io dataVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("eventType")>]
        member _.EventType((n, args), eventType) =
            let apply (args: EventGridTopicInputMappingDefaultValuesArgs) =
                args.EventType <- input eventType
                args

            ()
            n, List.Cons(apply, args)

        member _.EventType((n, args), eventType) =
            let apply (args: EventGridTopicInputMappingDefaultValuesArgs) =
                args.EventType <- io eventType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subject")>]
        member _.Subject((n, args), subject) =
            let apply (args: EventGridTopicInputMappingDefaultValuesArgs) =
                args.Subject <- input subject
                args

            ()
            n, List.Cons(apply, args)

        member _.Subject((n, args), subject) =
            let apply (args: EventGridTopicInputMappingDefaultValuesArgs) =
                args.Subject <- io subject
                args

            ()
            n, List.Cons(apply, args)

    let eventGridTopicInputMappingDefaultValues =
        EventGridTopicInputMappingDefaultValuesBuilder()

    type EventGridTopicInputMappingFieldsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventGridTopicInputMappingFieldsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("dataVersion")>]
        member _.DataVersion((n, args), dataVersion) =
            let apply (args: EventGridTopicInputMappingFieldsArgs) =
                args.DataVersion <- input dataVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.DataVersion((n, args), dataVersion) =
            let apply (args: EventGridTopicInputMappingFieldsArgs) =
                args.DataVersion <- io dataVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("eventTime")>]
        member _.EventTime((n, args), eventTime) =
            let apply (args: EventGridTopicInputMappingFieldsArgs) =
                args.EventTime <- input eventTime
                args

            ()
            n, List.Cons(apply, args)

        member _.EventTime((n, args), eventTime) =
            let apply (args: EventGridTopicInputMappingFieldsArgs) =
                args.EventTime <- io eventTime
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("eventType")>]
        member _.EventType((n, args), eventType) =
            let apply (args: EventGridTopicInputMappingFieldsArgs) =
                args.EventType <- input eventType
                args

            ()
            n, List.Cons(apply, args)

        member _.EventType((n, args), eventType) =
            let apply (args: EventGridTopicInputMappingFieldsArgs) =
                args.EventType <- io eventType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: EventGridTopicInputMappingFieldsArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: EventGridTopicInputMappingFieldsArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subject")>]
        member _.Subject((n, args), subject) =
            let apply (args: EventGridTopicInputMappingFieldsArgs) =
                args.Subject <- input subject
                args

            ()
            n, List.Cons(apply, args)

        member _.Subject((n, args), subject) =
            let apply (args: EventGridTopicInputMappingFieldsArgs) =
                args.Subject <- io subject
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("topic")>]
        member _.Topic((n, args), topic) =
            let apply (args: EventGridTopicInputMappingFieldsArgs) =
                args.Topic <- input topic
                args

            ()
            n, List.Cons(apply, args)

        member _.Topic((n, args), topic) =
            let apply (args: EventGridTopicInputMappingFieldsArgs) =
                args.Topic <- io topic
                args

            ()
            n, List.Cons(apply, args)

    let eventGridTopicInputMappingFields =
        EventGridTopicInputMappingFieldsBuilder()

    type EventHubCaptureDescriptionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventHubCaptureDescriptionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: EventHubCaptureDescriptionArgs) =
                   args.Destination <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: EventHubCaptureDescriptionArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: EventHubCaptureDescriptionArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("encoding")>]
        member _.Encoding((n, args), encoding) =
            let apply (args: EventHubCaptureDescriptionArgs) =
                args.Encoding <- input encoding
                args

            ()
            n, List.Cons(apply, args)

        member _.Encoding((n, args), encoding) =
            let apply (args: EventHubCaptureDescriptionArgs) =
                args.Encoding <- io encoding
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("intervalInSeconds")>]
        member _.IntervalInSeconds((n, args), intervalInSeconds) =
            let apply (args: EventHubCaptureDescriptionArgs) =
                args.IntervalInSeconds <- input intervalInSeconds
                args

            ()
            n, List.Cons(apply, args)

        member _.IntervalInSeconds((n, args), intervalInSeconds) =
            let apply (args: EventHubCaptureDescriptionArgs) =
                args.IntervalInSeconds <- io intervalInSeconds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sizeLimitInBytes")>]
        member _.SizeLimitInBytes((n, args), sizeLimitInBytes) =
            let apply (args: EventHubCaptureDescriptionArgs) =
                args.SizeLimitInBytes <- input sizeLimitInBytes
                args

            ()
            n, List.Cons(apply, args)

        member _.SizeLimitInBytes((n, args), sizeLimitInBytes) =
            let apply (args: EventHubCaptureDescriptionArgs) =
                args.SizeLimitInBytes <- io sizeLimitInBytes
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("skipEmptyArchives")>]
        member _.SkipEmptyArchives((n, args), skipEmptyArchives) =
            let apply (args: EventHubCaptureDescriptionArgs) =
                args.SkipEmptyArchives <- input skipEmptyArchives
                args

            ()
            n, List.Cons(apply, args)

        member _.SkipEmptyArchives((n, args), skipEmptyArchives) =
            let apply (args: EventHubCaptureDescriptionArgs) =
                args.SkipEmptyArchives <- io skipEmptyArchives
                args

            ()
            n, List.Cons(apply, args)

    let eventHubCaptureDescription = EventHubCaptureDescriptionBuilder()

    type EventHubCaptureDescriptionDestinationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventHubCaptureDescriptionDestinationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("archiveNameFormat")>]
        member _.ArchiveNameFormat((n, args), archiveNameFormat) =
            let apply (args: EventHubCaptureDescriptionDestinationArgs) =
                args.ArchiveNameFormat <- input archiveNameFormat
                args

            ()
            n, List.Cons(apply, args)

        member _.ArchiveNameFormat((n, args), archiveNameFormat) =
            let apply (args: EventHubCaptureDescriptionDestinationArgs) =
                args.ArchiveNameFormat <- io archiveNameFormat
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("blobContainerName")>]
        member _.BlobContainerName((n, args), blobContainerName) =
            let apply (args: EventHubCaptureDescriptionDestinationArgs) =
                args.BlobContainerName <- input blobContainerName
                args

            ()
            n, List.Cons(apply, args)

        member _.BlobContainerName((n, args), blobContainerName) =
            let apply (args: EventHubCaptureDescriptionDestinationArgs) =
                args.BlobContainerName <- io blobContainerName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: EventHubCaptureDescriptionDestinationArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: EventHubCaptureDescriptionDestinationArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageAccountId")>]
        member _.StorageAccountId((n, args), storageAccountId) =
            let apply (args: EventHubCaptureDescriptionDestinationArgs) =
                args.StorageAccountId <- input storageAccountId
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountId((n, args), storageAccountId) =
            let apply (args: EventHubCaptureDescriptionDestinationArgs) =
                args.StorageAccountId <- io storageAccountId
                args

            ()
            n, List.Cons(apply, args)

    let eventHubCaptureDescriptionDestination =
        EventHubCaptureDescriptionDestinationBuilder()

    type EventHubNamespaceNetworkRulesetsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventHubNamespaceNetworkRulesetsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("defaultAction")>]
        member _.DefaultAction((n, args), defaultAction) =
            let apply (args: EventHubNamespaceNetworkRulesetsArgs) =
                args.DefaultAction <- input defaultAction
                args

            ()
            n, List.Cons(apply, args)

        member _.DefaultAction((n, args), defaultAction) =
            let apply (args: EventHubNamespaceNetworkRulesetsArgs) =
                args.DefaultAction <- io defaultAction
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ipRules")>]
        member _.IpRules((n, args), ipRules) =
            let apply (args: EventHubNamespaceNetworkRulesetsArgs) =
                args.IpRules <- inputList ipRules
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkRules")>]
        member _.VirtualNetworkRules((n, args), virtualNetworkRules) =
            let apply (args: EventHubNamespaceNetworkRulesetsArgs) =
                args.VirtualNetworkRules <- inputList virtualNetworkRules
                args

            ()
            n, List.Cons(apply, args)

    let eventHubNamespaceNetworkRulesets =
        EventHubNamespaceNetworkRulesetsBuilder()

    type EventHubNamespaceNetworkRulesetsIpRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventHubNamespaceNetworkRulesetsIpRuleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("action")>]
        member _.Action((n, args), action) =
            let apply (args: EventHubNamespaceNetworkRulesetsIpRuleArgs) =
                args.Action <- input action
                args

            ()
            n, List.Cons(apply, args)

        member _.Action((n, args), action) =
            let apply (args: EventHubNamespaceNetworkRulesetsIpRuleArgs) =
                args.Action <- io action
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ipMask")>]
        member _.IpMask((n, args), ipMask) =
            let apply (args: EventHubNamespaceNetworkRulesetsIpRuleArgs) =
                args.IpMask <- input ipMask
                args

            ()
            n, List.Cons(apply, args)

        member _.IpMask((n, args), ipMask) =
            let apply (args: EventHubNamespaceNetworkRulesetsIpRuleArgs) =
                args.IpMask <- io ipMask
                args

            ()
            n, List.Cons(apply, args)

    let eventHubNamespaceNetworkRulesetsIpRule =
        EventHubNamespaceNetworkRulesetsIpRuleBuilder()

    type EventHubNamespaceNetworkRulesetsVirtualNetworkRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventHubNamespaceNetworkRulesetsVirtualNetworkRuleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("ignoreMissingVirtualNetworkServiceEndpoint")>]
        member _.IgnoreMissingVirtualNetworkServiceEndpoint((n, args), ignoreMissingVirtualNetworkServiceEndpoint) =
            let apply (args: EventHubNamespaceNetworkRulesetsVirtualNetworkRuleArgs) =
                args.IgnoreMissingVirtualNetworkServiceEndpoint <- input ignoreMissingVirtualNetworkServiceEndpoint
                args

            ()
            n, List.Cons(apply, args)

        member _.IgnoreMissingVirtualNetworkServiceEndpoint((n, args), ignoreMissingVirtualNetworkServiceEndpoint) =
            let apply (args: EventHubNamespaceNetworkRulesetsVirtualNetworkRuleArgs) =
                args.IgnoreMissingVirtualNetworkServiceEndpoint <- io ignoreMissingVirtualNetworkServiceEndpoint
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: EventHubNamespaceNetworkRulesetsVirtualNetworkRuleArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: EventHubNamespaceNetworkRulesetsVirtualNetworkRuleArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

    let eventHubNamespaceNetworkRulesetsVirtualNetworkRule =
        EventHubNamespaceNetworkRulesetsVirtualNetworkRuleBuilder()

    type EventSubscriptionAdvancedFilterBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionAdvancedFilterArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("boolEquals")>]
        member _.BoolEquals((n, args), boolEquals) =
            let apply (args: EventSubscriptionAdvancedFilterArgs) =
                args.BoolEquals <- inputList boolEquals
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("numberGreaterThanOrEquals")>]
        member _.NumberGreaterThanOrEquals((n, args), numberGreaterThanOrEquals) =
            let apply (args: EventSubscriptionAdvancedFilterArgs) =
                args.NumberGreaterThanOrEquals <- inputList numberGreaterThanOrEquals
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("numberGreaterThans")>]
        member _.NumberGreaterThans((n, args), numberGreaterThans) =
            let apply (args: EventSubscriptionAdvancedFilterArgs) =
                args.NumberGreaterThans <- inputList numberGreaterThans
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("numberIns")>]
        member _.NumberIns((n, args), numberIns) =
            let apply (args: EventSubscriptionAdvancedFilterArgs) =
                args.NumberIns <- inputList numberIns
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("numberLessThanOrEquals")>]
        member _.NumberLessThanOrEquals((n, args), numberLessThanOrEquals) =
            let apply (args: EventSubscriptionAdvancedFilterArgs) =
                args.NumberLessThanOrEquals <- inputList numberLessThanOrEquals
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("numberLessThans")>]
        member _.NumberLessThans((n, args), numberLessThans) =
            let apply (args: EventSubscriptionAdvancedFilterArgs) =
                args.NumberLessThans <- inputList numberLessThans
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("numberNotIns")>]
        member _.NumberNotIns((n, args), numberNotIns) =
            let apply (args: EventSubscriptionAdvancedFilterArgs) =
                args.NumberNotIns <- inputList numberNotIns
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("stringBeginsWiths")>]
        member _.StringBeginsWiths((n, args), stringBeginsWiths) =
            let apply (args: EventSubscriptionAdvancedFilterArgs) =
                args.StringBeginsWiths <- inputList stringBeginsWiths
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("stringContains")>]
        member _.StringContains((n, args), stringContains) =
            let apply (args: EventSubscriptionAdvancedFilterArgs) =
                args.StringContains <- inputList stringContains
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("stringEndsWiths")>]
        member _.StringEndsWiths((n, args), stringEndsWiths) =
            let apply (args: EventSubscriptionAdvancedFilterArgs) =
                args.StringEndsWiths <- inputList stringEndsWiths
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("stringIns")>]
        member _.StringIns((n, args), stringIns) =
            let apply (args: EventSubscriptionAdvancedFilterArgs) =
                args.StringIns <- inputList stringIns
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("stringNotIns")>]
        member _.StringNotIns((n, args), stringNotIns) =
            let apply (args: EventSubscriptionAdvancedFilterArgs) =
                args.StringNotIns <- inputList stringNotIns
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionAdvancedFilter = EventSubscriptionAdvancedFilterBuilder()

    type EventSubscriptionAdvancedFilterBoolEqualBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionAdvancedFilterBoolEqualArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("key")>]
        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterBoolEqualArgs) =
                args.Key <- input key
                args

            ()
            n, List.Cons(apply, args)

        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterBoolEqualArgs) =
                args.Key <- io key
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((n, args), value) =
            let apply (args: EventSubscriptionAdvancedFilterBoolEqualArgs) =
                args.Value <- input value
                args

            ()
            n, List.Cons(apply, args)

        member _.Value((n, args), value) =
            let apply (args: EventSubscriptionAdvancedFilterBoolEqualArgs) =
                args.Value <- io value
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionAdvancedFilterBoolEqual =
        EventSubscriptionAdvancedFilterBoolEqualBuilder()

    type EventSubscriptionAdvancedFilterNumberGreaterThanBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionAdvancedFilterNumberGreaterThanArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("key")>]
        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterNumberGreaterThanArgs) =
                args.Key <- input key
                args

            ()
            n, List.Cons(apply, args)

        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterNumberGreaterThanArgs) =
                args.Key <- io key
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((n, args), value) =
            let apply (args: EventSubscriptionAdvancedFilterNumberGreaterThanArgs) =
                args.Value <- input value
                args

            ()
            n, List.Cons(apply, args)

        member _.Value((n, args), value) =
            let apply (args: EventSubscriptionAdvancedFilterNumberGreaterThanArgs) =
                args.Value <- io value
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionAdvancedFilterNumberGreaterThan =
        EventSubscriptionAdvancedFilterNumberGreaterThanBuilder()

    type EventSubscriptionAdvancedFilterNumberGreaterThanOrEqualBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("key")>]
        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgs) =
                args.Key <- input key
                args

            ()
            n, List.Cons(apply, args)

        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgs) =
                args.Key <- io key
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((n, args), value) =
            let apply (args: EventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgs) =
                args.Value <- input value
                args

            ()
            n, List.Cons(apply, args)

        member _.Value((n, args), value) =
            let apply (args: EventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgs) =
                args.Value <- io value
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionAdvancedFilterNumberGreaterThanOrEqual =
        EventSubscriptionAdvancedFilterNumberGreaterThanOrEqualBuilder()

    type EventSubscriptionAdvancedFilterNumberInBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionAdvancedFilterNumberInArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("key")>]
        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterNumberInArgs) =
                args.Key <- input key
                args

            ()
            n, List.Cons(apply, args)

        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterNumberInArgs) =
                args.Key <- io key
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: EventSubscriptionAdvancedFilterNumberInArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionAdvancedFilterNumberIn =
        EventSubscriptionAdvancedFilterNumberInBuilder()

    type EventSubscriptionAdvancedFilterNumberLessThanBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionAdvancedFilterNumberLessThanArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("key")>]
        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterNumberLessThanArgs) =
                args.Key <- input key
                args

            ()
            n, List.Cons(apply, args)

        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterNumberLessThanArgs) =
                args.Key <- io key
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((n, args), value) =
            let apply (args: EventSubscriptionAdvancedFilterNumberLessThanArgs) =
                args.Value <- input value
                args

            ()
            n, List.Cons(apply, args)

        member _.Value((n, args), value) =
            let apply (args: EventSubscriptionAdvancedFilterNumberLessThanArgs) =
                args.Value <- io value
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionAdvancedFilterNumberLessThan =
        EventSubscriptionAdvancedFilterNumberLessThanBuilder()

    type EventSubscriptionAdvancedFilterNumberLessThanOrEqualBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionAdvancedFilterNumberLessThanOrEqualArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("key")>]
        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterNumberLessThanOrEqualArgs) =
                args.Key <- input key
                args

            ()
            n, List.Cons(apply, args)

        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterNumberLessThanOrEqualArgs) =
                args.Key <- io key
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((n, args), value) =
            let apply (args: EventSubscriptionAdvancedFilterNumberLessThanOrEqualArgs) =
                args.Value <- input value
                args

            ()
            n, List.Cons(apply, args)

        member _.Value((n, args), value) =
            let apply (args: EventSubscriptionAdvancedFilterNumberLessThanOrEqualArgs) =
                args.Value <- io value
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionAdvancedFilterNumberLessThanOrEqual =
        EventSubscriptionAdvancedFilterNumberLessThanOrEqualBuilder()

    type EventSubscriptionAdvancedFilterNumberNotInBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionAdvancedFilterNumberNotInArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("key")>]
        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterNumberNotInArgs) =
                args.Key <- input key
                args

            ()
            n, List.Cons(apply, args)

        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterNumberNotInArgs) =
                args.Key <- io key
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: EventSubscriptionAdvancedFilterNumberNotInArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionAdvancedFilterNumberNotIn =
        EventSubscriptionAdvancedFilterNumberNotInBuilder()

    type EventSubscriptionAdvancedFilterStringBeginsWithBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionAdvancedFilterStringBeginsWithArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("key")>]
        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterStringBeginsWithArgs) =
                args.Key <- input key
                args

            ()
            n, List.Cons(apply, args)

        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterStringBeginsWithArgs) =
                args.Key <- io key
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: EventSubscriptionAdvancedFilterStringBeginsWithArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionAdvancedFilterStringBeginsWith =
        EventSubscriptionAdvancedFilterStringBeginsWithBuilder()

    type EventSubscriptionAdvancedFilterStringContainBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionAdvancedFilterStringContainArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("key")>]
        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterStringContainArgs) =
                args.Key <- input key
                args

            ()
            n, List.Cons(apply, args)

        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterStringContainArgs) =
                args.Key <- io key
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: EventSubscriptionAdvancedFilterStringContainArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionAdvancedFilterStringContain =
        EventSubscriptionAdvancedFilterStringContainBuilder()

    type EventSubscriptionAdvancedFilterStringEndsWithBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionAdvancedFilterStringEndsWithArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("key")>]
        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterStringEndsWithArgs) =
                args.Key <- input key
                args

            ()
            n, List.Cons(apply, args)

        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterStringEndsWithArgs) =
                args.Key <- io key
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: EventSubscriptionAdvancedFilterStringEndsWithArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionAdvancedFilterStringEndsWith =
        EventSubscriptionAdvancedFilterStringEndsWithBuilder()

    type EventSubscriptionAdvancedFilterStringInBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionAdvancedFilterStringInArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("key")>]
        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterStringInArgs) =
                args.Key <- input key
                args

            ()
            n, List.Cons(apply, args)

        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterStringInArgs) =
                args.Key <- io key
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: EventSubscriptionAdvancedFilterStringInArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionAdvancedFilterStringIn =
        EventSubscriptionAdvancedFilterStringInBuilder()

    type EventSubscriptionAdvancedFilterStringNotInBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionAdvancedFilterStringNotInArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("key")>]
        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterStringNotInArgs) =
                args.Key <- input key
                args

            ()
            n, List.Cons(apply, args)

        member _.Key((n, args), key) =
            let apply (args: EventSubscriptionAdvancedFilterStringNotInArgs) =
                args.Key <- io key
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: EventSubscriptionAdvancedFilterStringNotInArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionAdvancedFilterStringNotIn =
        EventSubscriptionAdvancedFilterStringNotInBuilder()

    type EventSubscriptionAzureFunctionEndpointBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionAzureFunctionEndpointArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("functionId")>]
        member _.FunctionId((n, args), functionId) =
            let apply (args: EventSubscriptionAzureFunctionEndpointArgs) =
                args.FunctionId <- input functionId
                args

            ()
            n, List.Cons(apply, args)

        member _.FunctionId((n, args), functionId) =
            let apply (args: EventSubscriptionAzureFunctionEndpointArgs) =
                args.FunctionId <- io functionId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("maxEventsPerBatch")>]
        member _.MaxEventsPerBatch((n, args), maxEventsPerBatch) =
            let apply (args: EventSubscriptionAzureFunctionEndpointArgs) =
                args.MaxEventsPerBatch <- input maxEventsPerBatch
                args

            ()
            n, List.Cons(apply, args)

        member _.MaxEventsPerBatch((n, args), maxEventsPerBatch) =
            let apply (args: EventSubscriptionAzureFunctionEndpointArgs) =
                args.MaxEventsPerBatch <- io maxEventsPerBatch
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("preferredBatchSizeInKilobytes")>]
        member _.PreferredBatchSizeInKilobytes((n, args), preferredBatchSizeInKilobytes) =
            let apply (args: EventSubscriptionAzureFunctionEndpointArgs) =
                args.PreferredBatchSizeInKilobytes <- input preferredBatchSizeInKilobytes
                args

            ()
            n, List.Cons(apply, args)

        member _.PreferredBatchSizeInKilobytes((n, args), preferredBatchSizeInKilobytes) =
            let apply (args: EventSubscriptionAzureFunctionEndpointArgs) =
                args.PreferredBatchSizeInKilobytes <- io preferredBatchSizeInKilobytes
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionAzureFunctionEndpoint =
        EventSubscriptionAzureFunctionEndpointBuilder()

    type EventSubscriptionEventhubEndpointBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionEventhubEndpointArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("eventhubId")>]
        member _.EventhubId((n, args), eventhubId) =
            let apply (args: EventSubscriptionEventhubEndpointArgs) =
                args.EventhubId <- input eventhubId
                args

            ()
            n, List.Cons(apply, args)

        member _.EventhubId((n, args), eventhubId) =
            let apply (args: EventSubscriptionEventhubEndpointArgs) =
                args.EventhubId <- io eventhubId
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionEventhubEndpoint =
        EventSubscriptionEventhubEndpointBuilder()

    type EventSubscriptionHybridConnectionEndpointBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionHybridConnectionEndpointArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("hybridConnectionId")>]
        member _.HybridConnectionId((n, args), hybridConnectionId) =
            let apply (args: EventSubscriptionHybridConnectionEndpointArgs) =
                args.HybridConnectionId <- input hybridConnectionId
                args

            ()
            n, List.Cons(apply, args)

        member _.HybridConnectionId((n, args), hybridConnectionId) =
            let apply (args: EventSubscriptionHybridConnectionEndpointArgs) =
                args.HybridConnectionId <- io hybridConnectionId
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionHybridConnectionEndpoint =
        EventSubscriptionHybridConnectionEndpointBuilder()

    type EventSubscriptionRetryPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionRetryPolicyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("eventTimeToLive")>]
        member _.EventTimeToLive((n, args), eventTimeToLive) =
            let apply (args: EventSubscriptionRetryPolicyArgs) =
                args.EventTimeToLive <- input eventTimeToLive
                args

            ()
            n, List.Cons(apply, args)

        member _.EventTimeToLive((n, args), eventTimeToLive) =
            let apply (args: EventSubscriptionRetryPolicyArgs) =
                args.EventTimeToLive <- io eventTimeToLive
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("maxDeliveryAttempts")>]
        member _.MaxDeliveryAttempts((n, args), maxDeliveryAttempts) =
            let apply (args: EventSubscriptionRetryPolicyArgs) =
                args.MaxDeliveryAttempts <- input maxDeliveryAttempts
                args

            ()
            n, List.Cons(apply, args)

        member _.MaxDeliveryAttempts((n, args), maxDeliveryAttempts) =
            let apply (args: EventSubscriptionRetryPolicyArgs) =
                args.MaxDeliveryAttempts <- io maxDeliveryAttempts
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionRetryPolicy = EventSubscriptionRetryPolicyBuilder()

    type EventSubscriptionStorageBlobDeadLetterDestinationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionStorageBlobDeadLetterDestinationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("storageAccountId")>]
        member _.StorageAccountId((n, args), storageAccountId) =
            let apply (args: EventSubscriptionStorageBlobDeadLetterDestinationArgs) =
                args.StorageAccountId <- input storageAccountId
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountId((n, args), storageAccountId) =
            let apply (args: EventSubscriptionStorageBlobDeadLetterDestinationArgs) =
                args.StorageAccountId <- io storageAccountId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageBlobContainerName")>]
        member _.StorageBlobContainerName((n, args), storageBlobContainerName) =
            let apply (args: EventSubscriptionStorageBlobDeadLetterDestinationArgs) =
                args.StorageBlobContainerName <- input storageBlobContainerName
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageBlobContainerName((n, args), storageBlobContainerName) =
            let apply (args: EventSubscriptionStorageBlobDeadLetterDestinationArgs) =
                args.StorageBlobContainerName <- io storageBlobContainerName
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionStorageBlobDeadLetterDestination =
        EventSubscriptionStorageBlobDeadLetterDestinationBuilder()

    type EventSubscriptionStorageQueueEndpointBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionStorageQueueEndpointArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("queueName")>]
        member _.QueueName((n, args), queueName) =
            let apply (args: EventSubscriptionStorageQueueEndpointArgs) =
                args.QueueName <- input queueName
                args

            ()
            n, List.Cons(apply, args)

        member _.QueueName((n, args), queueName) =
            let apply (args: EventSubscriptionStorageQueueEndpointArgs) =
                args.QueueName <- io queueName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageAccountId")>]
        member _.StorageAccountId((n, args), storageAccountId) =
            let apply (args: EventSubscriptionStorageQueueEndpointArgs) =
                args.StorageAccountId <- input storageAccountId
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountId((n, args), storageAccountId) =
            let apply (args: EventSubscriptionStorageQueueEndpointArgs) =
                args.StorageAccountId <- io storageAccountId
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionStorageQueueEndpoint =
        EventSubscriptionStorageQueueEndpointBuilder()

    type EventSubscriptionSubjectFilterBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionSubjectFilterArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("caseSensitive")>]
        member _.CaseSensitive((n, args), caseSensitive) =
            let apply (args: EventSubscriptionSubjectFilterArgs) =
                args.CaseSensitive <- input caseSensitive
                args

            ()
            n, List.Cons(apply, args)

        member _.CaseSensitive((n, args), caseSensitive) =
            let apply (args: EventSubscriptionSubjectFilterArgs) =
                args.CaseSensitive <- io caseSensitive
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subjectBeginsWith")>]
        member _.SubjectBeginsWith((n, args), subjectBeginsWith) =
            let apply (args: EventSubscriptionSubjectFilterArgs) =
                args.SubjectBeginsWith <- input subjectBeginsWith
                args

            ()
            n, List.Cons(apply, args)

        member _.SubjectBeginsWith((n, args), subjectBeginsWith) =
            let apply (args: EventSubscriptionSubjectFilterArgs) =
                args.SubjectBeginsWith <- io subjectBeginsWith
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subjectEndsWith")>]
        member _.SubjectEndsWith((n, args), subjectEndsWith) =
            let apply (args: EventSubscriptionSubjectFilterArgs) =
                args.SubjectEndsWith <- input subjectEndsWith
                args

            ()
            n, List.Cons(apply, args)

        member _.SubjectEndsWith((n, args), subjectEndsWith) =
            let apply (args: EventSubscriptionSubjectFilterArgs) =
                args.SubjectEndsWith <- io subjectEndsWith
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionSubjectFilter = EventSubscriptionSubjectFilterBuilder()

    type EventSubscriptionWebhookEndpointBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EventSubscriptionWebhookEndpointArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("activeDirectoryAppIdOrUri")>]
        member _.ActiveDirectoryAppIdOrUri((n, args), activeDirectoryAppIdOrUri) =
            let apply (args: EventSubscriptionWebhookEndpointArgs) =
                args.ActiveDirectoryAppIdOrUri <- input activeDirectoryAppIdOrUri
                args

            ()
            n, List.Cons(apply, args)

        member _.ActiveDirectoryAppIdOrUri((n, args), activeDirectoryAppIdOrUri) =
            let apply (args: EventSubscriptionWebhookEndpointArgs) =
                args.ActiveDirectoryAppIdOrUri <- io activeDirectoryAppIdOrUri
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("activeDirectoryTenantId")>]
        member _.ActiveDirectoryTenantId((n, args), activeDirectoryTenantId) =
            let apply (args: EventSubscriptionWebhookEndpointArgs) =
                args.ActiveDirectoryTenantId <- input activeDirectoryTenantId
                args

            ()
            n, List.Cons(apply, args)

        member _.ActiveDirectoryTenantId((n, args), activeDirectoryTenantId) =
            let apply (args: EventSubscriptionWebhookEndpointArgs) =
                args.ActiveDirectoryTenantId <- io activeDirectoryTenantId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("baseUrl")>]
        member _.BaseUrl((n, args), baseUrl) =
            let apply (args: EventSubscriptionWebhookEndpointArgs) =
                args.BaseUrl <- input baseUrl
                args

            ()
            n, List.Cons(apply, args)

        member _.BaseUrl((n, args), baseUrl) =
            let apply (args: EventSubscriptionWebhookEndpointArgs) =
                args.BaseUrl <- io baseUrl
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("maxEventsPerBatch")>]
        member _.MaxEventsPerBatch((n, args), maxEventsPerBatch) =
            let apply (args: EventSubscriptionWebhookEndpointArgs) =
                args.MaxEventsPerBatch <- input maxEventsPerBatch
                args

            ()
            n, List.Cons(apply, args)

        member _.MaxEventsPerBatch((n, args), maxEventsPerBatch) =
            let apply (args: EventSubscriptionWebhookEndpointArgs) =
                args.MaxEventsPerBatch <- io maxEventsPerBatch
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("preferredBatchSizeInKilobytes")>]
        member _.PreferredBatchSizeInKilobytes((n, args), preferredBatchSizeInKilobytes) =
            let apply (args: EventSubscriptionWebhookEndpointArgs) =
                args.PreferredBatchSizeInKilobytes <- input preferredBatchSizeInKilobytes
                args

            ()
            n, List.Cons(apply, args)

        member _.PreferredBatchSizeInKilobytes((n, args), preferredBatchSizeInKilobytes) =
            let apply (args: EventSubscriptionWebhookEndpointArgs) =
                args.PreferredBatchSizeInKilobytes <- io preferredBatchSizeInKilobytes
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("url")>]
        member _.Url((n, args), url) =
            let apply (args: EventSubscriptionWebhookEndpointArgs) =
                args.Url <- input url
                args

            ()
            n, List.Cons(apply, args)

        member _.Url((n, args), url) =
            let apply (args: EventSubscriptionWebhookEndpointArgs) =
                args.Url <- io url
                args

            ()
            n, List.Cons(apply, args)

    let eventSubscriptionWebhookEndpoint =
        EventSubscriptionWebhookEndpointBuilder()

    type SubscriptionRuleCorrelationFilterBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SubscriptionRuleCorrelationFilterArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("contentType")>]
        member _.ContentType((n, args), contentType) =
            let apply (args: SubscriptionRuleCorrelationFilterArgs) =
                args.ContentType <- input contentType
                args

            ()
            n, List.Cons(apply, args)

        member _.ContentType((n, args), contentType) =
            let apply (args: SubscriptionRuleCorrelationFilterArgs) =
                args.ContentType <- io contentType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("correlationId")>]
        member _.CorrelationId((n, args), correlationId) =
            let apply (args: SubscriptionRuleCorrelationFilterArgs) =
                args.CorrelationId <- input correlationId
                args

            ()
            n, List.Cons(apply, args)

        member _.CorrelationId((n, args), correlationId) =
            let apply (args: SubscriptionRuleCorrelationFilterArgs) =
                args.CorrelationId <- io correlationId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("label")>]
        member _.Label((n, args), label) =
            let apply (args: SubscriptionRuleCorrelationFilterArgs) =
                args.Label <- input label
                args

            ()
            n, List.Cons(apply, args)

        member _.Label((n, args), label) =
            let apply (args: SubscriptionRuleCorrelationFilterArgs) =
                args.Label <- io label
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("messageId")>]
        member _.MessageId((n, args), messageId) =
            let apply (args: SubscriptionRuleCorrelationFilterArgs) =
                args.MessageId <- input messageId
                args

            ()
            n, List.Cons(apply, args)

        member _.MessageId((n, args), messageId) =
            let apply (args: SubscriptionRuleCorrelationFilterArgs) =
                args.MessageId <- io messageId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("replyTo")>]
        member _.ReplyTo((n, args), replyTo) =
            let apply (args: SubscriptionRuleCorrelationFilterArgs) =
                args.ReplyTo <- input replyTo
                args

            ()
            n, List.Cons(apply, args)

        member _.ReplyTo((n, args), replyTo) =
            let apply (args: SubscriptionRuleCorrelationFilterArgs) =
                args.ReplyTo <- io replyTo
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("replyToSessionId")>]
        member _.ReplyToSessionId((n, args), replyToSessionId) =
            let apply (args: SubscriptionRuleCorrelationFilterArgs) =
                args.ReplyToSessionId <- input replyToSessionId
                args

            ()
            n, List.Cons(apply, args)

        member _.ReplyToSessionId((n, args), replyToSessionId) =
            let apply (args: SubscriptionRuleCorrelationFilterArgs) =
                args.ReplyToSessionId <- io replyToSessionId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sessionId")>]
        member _.SessionId((n, args), sessionId) =
            let apply (args: SubscriptionRuleCorrelationFilterArgs) =
                args.SessionId <- input sessionId
                args

            ()
            n, List.Cons(apply, args)

        member _.SessionId((n, args), sessionId) =
            let apply (args: SubscriptionRuleCorrelationFilterArgs) =
                args.SessionId <- io sessionId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("to")>]
        member _.To((n, args), ``to``) =
            let apply (args: SubscriptionRuleCorrelationFilterArgs) =
                args.To <- input ``to``
                args

            ()
            n, List.Cons(apply, args)

        member _.To((n, args), ``to``) =
            let apply (args: SubscriptionRuleCorrelationFilterArgs) =
                args.To <- io ``to``
                args

            ()
            n, List.Cons(apply, args)

    let subscriptionRuleCorrelationFilter =
        SubscriptionRuleCorrelationFilterBuilder()

    type AuthorizationRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            AuthorizationRule(name, (List.fold func (AuthorizationRuleArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("eventhubName")>]
        member _.EventhubName((name, args), eventhubName) =
            let apply (args: AuthorizationRuleArgs) =
                args.EventhubName <- input eventhubName
                args

            ()
            name, List.Cons(apply, args)

        member _.EventhubName((name, args), eventhubName) =
            let apply (args: AuthorizationRuleArgs) =
                args.EventhubName <- io eventhubName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("listen")>]
        member _.Listen((name, args), listen) =
            let apply (args: AuthorizationRuleArgs) =
                args.Listen <- input listen
                args

            ()
            name, List.Cons(apply, args)

        member _.Listen((name, args), listen) =
            let apply (args: AuthorizationRuleArgs) =
                args.Listen <- io listen
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("manage")>]
        member _.Manage((name, args), manage) =
            let apply (args: AuthorizationRuleArgs) =
                args.Manage <- input manage
                args

            ()
            name, List.Cons(apply, args)

        member _.Manage((name, args), manage) =
            let apply (args: AuthorizationRuleArgs) =
                args.Manage <- io manage
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: AuthorizationRuleArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: AuthorizationRuleArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("namespaceName")>]
        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: AuthorizationRuleArgs) =
                args.NamespaceName <- input namespaceName
                args

            ()
            name, List.Cons(apply, args)

        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: AuthorizationRuleArgs) =
                args.NamespaceName <- io namespaceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AuthorizationRuleArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AuthorizationRuleArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("send")>]
        member _.Send((name, args), send) =
            let apply (args: AuthorizationRuleArgs) =
                args.Send <- input send
                args

            ()
            name, List.Cons(apply, args)

        member _.Send((name, args), send) =
            let apply (args: AuthorizationRuleArgs) =
                args.Send <- io send
                args

            ()
            name, List.Cons(apply, args)

    let authorizationRule = AuthorizationRuleBuilder()

    type ClusterBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Cluster(name, (List.fold func (ClusterArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ClusterArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ClusterArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ClusterArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ClusterArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ClusterArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ClusterArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("skuName")>]
        member _.SkuName((name, args), skuName) =
            let apply (args: ClusterArgs) =
                args.SkuName <- input skuName
                args

            ()
            name, List.Cons(apply, args)

        member _.SkuName((name, args), skuName) =
            let apply (args: ClusterArgs) =
                args.SkuName <- io skuName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ClusterArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let cluster = ClusterBuilder()

    type ConsumerGroupBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ConsumerGroup(name, (List.fold func (ConsumerGroupArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("eventhubName")>]
        member _.EventhubName((name, args), eventhubName) =
            let apply (args: ConsumerGroupArgs) =
                args.EventhubName <- input eventhubName
                args

            ()
            name, List.Cons(apply, args)

        member _.EventhubName((name, args), eventhubName) =
            let apply (args: ConsumerGroupArgs) =
                args.EventhubName <- io eventhubName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ConsumerGroupArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ConsumerGroupArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("namespaceName")>]
        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: ConsumerGroupArgs) =
                args.NamespaceName <- input namespaceName
                args

            ()
            name, List.Cons(apply, args)

        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: ConsumerGroupArgs) =
                args.NamespaceName <- io namespaceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ConsumerGroupArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ConsumerGroupArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("userMetadata")>]
        member _.UserMetadata((name, args), userMetadata) =
            let apply (args: ConsumerGroupArgs) =
                args.UserMetadata <- input userMetadata
                args

            ()
            name, List.Cons(apply, args)

        member _.UserMetadata((name, args), userMetadata) =
            let apply (args: ConsumerGroupArgs) =
                args.UserMetadata <- io userMetadata
                args

            ()
            name, List.Cons(apply, args)

    let consumerGroup = ConsumerGroupBuilder()

    type DomainBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Domain(name, (List.fold func (DomainArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: DomainArgs) =
                   args.InputMappingDefaultValues <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: DomainArgs) =
                   args.InputMappingFields <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("inputSchema")>]
        member _.InputSchema((name, args), inputSchema) =
            let apply (args: DomainArgs) =
                args.InputSchema <- input inputSchema
                args

            ()
            name, List.Cons(apply, args)

        member _.InputSchema((name, args), inputSchema) =
            let apply (args: DomainArgs) =
                args.InputSchema <- io inputSchema
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: DomainArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: DomainArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: DomainArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: DomainArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DomainArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DomainArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: DomainArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let domain = DomainBuilder()

    type EventGridTopicBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            EventGridTopic(name, (List.fold func (EventGridTopicArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: EventGridTopicArgs) =
                   args.InputMappingDefaultValues <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: EventGridTopicArgs) =
                   args.InputMappingFields <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("inputSchema")>]
        member _.InputSchema((name, args), inputSchema) =
            let apply (args: EventGridTopicArgs) =
                args.InputSchema <- input inputSchema
                args

            ()
            name, List.Cons(apply, args)

        member _.InputSchema((name, args), inputSchema) =
            let apply (args: EventGridTopicArgs) =
                args.InputSchema <- io inputSchema
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: EventGridTopicArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: EventGridTopicArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: EventGridTopicArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: EventGridTopicArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: EventGridTopicArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: EventGridTopicArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: EventGridTopicArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let eventGridTopic = EventGridTopicBuilder()

    type EventHubBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            EventHub(name, (List.fold func (EventHubArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: EventHubArgs) =
                   args.CaptureDescription <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("messageRetention")>]
        member _.MessageRetention((name, args), messageRetention) =
            let apply (args: EventHubArgs) =
                args.MessageRetention <- input messageRetention
                args

            ()
            name, List.Cons(apply, args)

        member _.MessageRetention((name, args), messageRetention) =
            let apply (args: EventHubArgs) =
                args.MessageRetention <- io messageRetention
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: EventHubArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: EventHubArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("namespaceName")>]
        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: EventHubArgs) =
                args.NamespaceName <- input namespaceName
                args

            ()
            name, List.Cons(apply, args)

        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: EventHubArgs) =
                args.NamespaceName <- io namespaceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("partitionCount")>]
        member _.PartitionCount((name, args), partitionCount) =
            let apply (args: EventHubArgs) =
                args.PartitionCount <- input partitionCount
                args

            ()
            name, List.Cons(apply, args)

        member _.PartitionCount((name, args), partitionCount) =
            let apply (args: EventHubArgs) =
                args.PartitionCount <- io partitionCount
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: EventHubArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: EventHubArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let eventHub = EventHubBuilder()

    type EventHubAuthorizationRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            EventHubAuthorizationRule(name, (List.fold func (EventHubAuthorizationRuleArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("eventhubName")>]
        member _.EventhubName((name, args), eventhubName) =
            let apply (args: EventHubAuthorizationRuleArgs) =
                args.EventhubName <- input eventhubName
                args

            ()
            name, List.Cons(apply, args)

        member _.EventhubName((name, args), eventhubName) =
            let apply (args: EventHubAuthorizationRuleArgs) =
                args.EventhubName <- io eventhubName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("listen")>]
        member _.Listen((name, args), listen) =
            let apply (args: EventHubAuthorizationRuleArgs) =
                args.Listen <- input listen
                args

            ()
            name, List.Cons(apply, args)

        member _.Listen((name, args), listen) =
            let apply (args: EventHubAuthorizationRuleArgs) =
                args.Listen <- io listen
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("manage")>]
        member _.Manage((name, args), manage) =
            let apply (args: EventHubAuthorizationRuleArgs) =
                args.Manage <- input manage
                args

            ()
            name, List.Cons(apply, args)

        member _.Manage((name, args), manage) =
            let apply (args: EventHubAuthorizationRuleArgs) =
                args.Manage <- io manage
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: EventHubAuthorizationRuleArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: EventHubAuthorizationRuleArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("namespaceName")>]
        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: EventHubAuthorizationRuleArgs) =
                args.NamespaceName <- input namespaceName
                args

            ()
            name, List.Cons(apply, args)

        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: EventHubAuthorizationRuleArgs) =
                args.NamespaceName <- io namespaceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: EventHubAuthorizationRuleArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: EventHubAuthorizationRuleArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("send")>]
        member _.Send((name, args), send) =
            let apply (args: EventHubAuthorizationRuleArgs) =
                args.Send <- input send
                args

            ()
            name, List.Cons(apply, args)

        member _.Send((name, args), send) =
            let apply (args: EventHubAuthorizationRuleArgs) =
                args.Send <- io send
                args

            ()
            name, List.Cons(apply, args)

    let eventHubAuthorizationRule = EventHubAuthorizationRuleBuilder()

    type EventHubConsumerGroupBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            EventHubConsumerGroup(name, (List.fold func (EventHubConsumerGroupArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("eventhubName")>]
        member _.EventhubName((name, args), eventhubName) =
            let apply (args: EventHubConsumerGroupArgs) =
                args.EventhubName <- input eventhubName
                args

            ()
            name, List.Cons(apply, args)

        member _.EventhubName((name, args), eventhubName) =
            let apply (args: EventHubConsumerGroupArgs) =
                args.EventhubName <- io eventhubName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: EventHubConsumerGroupArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: EventHubConsumerGroupArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("namespaceName")>]
        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: EventHubConsumerGroupArgs) =
                args.NamespaceName <- input namespaceName
                args

            ()
            name, List.Cons(apply, args)

        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: EventHubConsumerGroupArgs) =
                args.NamespaceName <- io namespaceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: EventHubConsumerGroupArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: EventHubConsumerGroupArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("userMetadata")>]
        member _.UserMetadata((name, args), userMetadata) =
            let apply (args: EventHubConsumerGroupArgs) =
                args.UserMetadata <- input userMetadata
                args

            ()
            name, List.Cons(apply, args)

        member _.UserMetadata((name, args), userMetadata) =
            let apply (args: EventHubConsumerGroupArgs) =
                args.UserMetadata <- io userMetadata
                args

            ()
            name, List.Cons(apply, args)

    let eventHubConsumerGroup = EventHubConsumerGroupBuilder()

    type EventHubNamespaceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            EventHubNamespace(name, (List.fold func (EventHubNamespaceArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("autoInflateEnabled")>]
        member _.AutoInflateEnabled((name, args), autoInflateEnabled) =
            let apply (args: EventHubNamespaceArgs) =
                args.AutoInflateEnabled <- input autoInflateEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.AutoInflateEnabled((name, args), autoInflateEnabled) =
            let apply (args: EventHubNamespaceArgs) =
                args.AutoInflateEnabled <- io autoInflateEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("capacity")>]
        member _.Capacity((name, args), capacity) =
            let apply (args: EventHubNamespaceArgs) =
                args.Capacity <- input capacity
                args

            ()
            name, List.Cons(apply, args)

        member _.Capacity((name, args), capacity) =
            let apply (args: EventHubNamespaceArgs) =
                args.Capacity <- io capacity
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: EventHubNamespaceArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: EventHubNamespaceArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("maximumThroughputUnits")>]
        member _.MaximumThroughputUnits((name, args), maximumThroughputUnits) =
            let apply (args: EventHubNamespaceArgs) =
                args.MaximumThroughputUnits <- input maximumThroughputUnits
                args

            ()
            name, List.Cons(apply, args)

        member _.MaximumThroughputUnits((name, args), maximumThroughputUnits) =
            let apply (args: EventHubNamespaceArgs) =
                args.MaximumThroughputUnits <- io maximumThroughputUnits
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: EventHubNamespaceArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: EventHubNamespaceArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: EventHubNamespaceArgs) =
                   args.NetworkRulesets <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: EventHubNamespaceArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: EventHubNamespaceArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sku")>]
        member _.Sku((name, args), sku) =
            let apply (args: EventHubNamespaceArgs) =
                args.Sku <- input sku
                args

            ()
            name, List.Cons(apply, args)

        member _.Sku((name, args), sku) =
            let apply (args: EventHubNamespaceArgs) =
                args.Sku <- io sku
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: EventHubNamespaceArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let eventHubNamespace = EventHubNamespaceBuilder()

    type EventHubNamespaceAuthorizationRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            EventHubNamespaceAuthorizationRule(name, (List.fold func (EventHubNamespaceAuthorizationRuleArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("listen")>]
        member _.Listen((name, args), listen) =
            let apply (args: EventHubNamespaceAuthorizationRuleArgs) =
                args.Listen <- input listen
                args

            ()
            name, List.Cons(apply, args)

        member _.Listen((name, args), listen) =
            let apply (args: EventHubNamespaceAuthorizationRuleArgs) =
                args.Listen <- io listen
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("manage")>]
        member _.Manage((name, args), manage) =
            let apply (args: EventHubNamespaceAuthorizationRuleArgs) =
                args.Manage <- input manage
                args

            ()
            name, List.Cons(apply, args)

        member _.Manage((name, args), manage) =
            let apply (args: EventHubNamespaceAuthorizationRuleArgs) =
                args.Manage <- io manage
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: EventHubNamespaceAuthorizationRuleArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: EventHubNamespaceAuthorizationRuleArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("namespaceName")>]
        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: EventHubNamespaceAuthorizationRuleArgs) =
                args.NamespaceName <- input namespaceName
                args

            ()
            name, List.Cons(apply, args)

        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: EventHubNamespaceAuthorizationRuleArgs) =
                args.NamespaceName <- io namespaceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: EventHubNamespaceAuthorizationRuleArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: EventHubNamespaceAuthorizationRuleArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("send")>]
        member _.Send((name, args), send) =
            let apply (args: EventHubNamespaceAuthorizationRuleArgs) =
                args.Send <- input send
                args

            ()
            name, List.Cons(apply, args)

        member _.Send((name, args), send) =
            let apply (args: EventHubNamespaceAuthorizationRuleArgs) =
                args.Send <- io send
                args

            ()
            name, List.Cons(apply, args)

    let eventHubNamespaceAuthorizationRule =
        EventHubNamespaceAuthorizationRuleBuilder()

    type EventSubscriptionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            EventSubscription(name, (List.fold func (EventSubscriptionArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: EventSubscriptionArgs) =
                   args.AdvancedFilter <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: EventSubscriptionArgs) =
                   args.AzureFunctionEndpoint <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("eventDeliverySchema")>]
        member _.EventDeliverySchema((name, args), eventDeliverySchema) =
            let apply (args: EventSubscriptionArgs) =
                args.EventDeliverySchema <- input eventDeliverySchema
                args

            ()
            name, List.Cons(apply, args)

        member _.EventDeliverySchema((name, args), eventDeliverySchema) =
            let apply (args: EventSubscriptionArgs) =
                args.EventDeliverySchema <- io eventDeliverySchema
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: EventSubscriptionArgs) =
                   args.EventhubEndpoint <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("eventhubEndpointId")>]
        member _.EventhubEndpointId((name, args), eventhubEndpointId) =
            let apply (args: EventSubscriptionArgs) =
                args.EventhubEndpointId <- input eventhubEndpointId
                args

            ()
            name, List.Cons(apply, args)

        member _.EventhubEndpointId((name, args), eventhubEndpointId) =
            let apply (args: EventSubscriptionArgs) =
                args.EventhubEndpointId <- io eventhubEndpointId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("expirationTimeUtc")>]
        member _.ExpirationTimeUtc((name, args), expirationTimeUtc) =
            let apply (args: EventSubscriptionArgs) =
                args.ExpirationTimeUtc <- input expirationTimeUtc
                args

            ()
            name, List.Cons(apply, args)

        member _.ExpirationTimeUtc((name, args), expirationTimeUtc) =
            let apply (args: EventSubscriptionArgs) =
                args.ExpirationTimeUtc <- io expirationTimeUtc
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: EventSubscriptionArgs) =
                   args.HybridConnectionEndpoint <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("hybridConnectionEndpointId")>]
        member _.HybridConnectionEndpointId((name, args), hybridConnectionEndpointId) =
            let apply (args: EventSubscriptionArgs) =
                args.HybridConnectionEndpointId <- input hybridConnectionEndpointId
                args

            ()
            name, List.Cons(apply, args)

        member _.HybridConnectionEndpointId((name, args), hybridConnectionEndpointId) =
            let apply (args: EventSubscriptionArgs) =
                args.HybridConnectionEndpointId <- io hybridConnectionEndpointId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("includedEventTypes")>]
        member _.IncludedEventTypes((name, args), includedEventTypes) =
            let apply (args: EventSubscriptionArgs) =
                args.IncludedEventTypes <- inputList includedEventTypes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("labels")>]
        member _.Labels((name, args), labels) =
            let apply (args: EventSubscriptionArgs) =
                args.Labels <- inputList labels
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: EventSubscriptionArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: EventSubscriptionArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: EventSubscriptionArgs) =
                   args.RetryPolicy <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("scope")>]
        member _.Scope((name, args), scope) =
            let apply (args: EventSubscriptionArgs) =
                args.Scope <- input scope
                args

            ()
            name, List.Cons(apply, args)

        member _.Scope((name, args), scope) =
            let apply (args: EventSubscriptionArgs) =
                args.Scope <- io scope
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serviceBusQueueEndpointId")>]
        member _.ServiceBusQueueEndpointId((name, args), serviceBusQueueEndpointId) =
            let apply (args: EventSubscriptionArgs) =
                args.ServiceBusQueueEndpointId <- input serviceBusQueueEndpointId
                args

            ()
            name, List.Cons(apply, args)

        member _.ServiceBusQueueEndpointId((name, args), serviceBusQueueEndpointId) =
            let apply (args: EventSubscriptionArgs) =
                args.ServiceBusQueueEndpointId <- io serviceBusQueueEndpointId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serviceBusTopicEndpointId")>]
        member _.ServiceBusTopicEndpointId((name, args), serviceBusTopicEndpointId) =
            let apply (args: EventSubscriptionArgs) =
                args.ServiceBusTopicEndpointId <- input serviceBusTopicEndpointId
                args

            ()
            name, List.Cons(apply, args)

        member _.ServiceBusTopicEndpointId((name, args), serviceBusTopicEndpointId) =
            let apply (args: EventSubscriptionArgs) =
                args.ServiceBusTopicEndpointId <- io serviceBusTopicEndpointId
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: EventSubscriptionArgs) =
                   args.StorageBlobDeadLetterDestination <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: EventSubscriptionArgs) =
                   args.StorageQueueEndpoint <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: EventSubscriptionArgs) =
                   args.SubjectFilter <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("topicName")>]
        member _.TopicName((name, args), topicName) =
            let apply (args: EventSubscriptionArgs) =
                args.TopicName <- input topicName
                args

            ()
            name, List.Cons(apply, args)

        member _.TopicName((name, args), topicName) =
            let apply (args: EventSubscriptionArgs) =
                args.TopicName <- io topicName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: EventSubscriptionArgs) =
                   args.WebhookEndpoint <- input arg
                   args

               ()
               func) ]

    let eventSubscription = EventSubscriptionBuilder()

    type EventhubNamespaceDisasterRecoveryConfigBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            EventhubNamespaceDisasterRecoveryConfig
                (name, (List.fold func (EventhubNamespaceDisasterRecoveryConfigArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("alternateName")>]
        member _.AlternateName((name, args), alternateName) =
            let apply (args: EventhubNamespaceDisasterRecoveryConfigArgs) =
                args.AlternateName <- input alternateName
                args

            ()
            name, List.Cons(apply, args)

        member _.AlternateName((name, args), alternateName) =
            let apply (args: EventhubNamespaceDisasterRecoveryConfigArgs) =
                args.AlternateName <- io alternateName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: EventhubNamespaceDisasterRecoveryConfigArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: EventhubNamespaceDisasterRecoveryConfigArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("namespaceName")>]
        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: EventhubNamespaceDisasterRecoveryConfigArgs) =
                args.NamespaceName <- input namespaceName
                args

            ()
            name, List.Cons(apply, args)

        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: EventhubNamespaceDisasterRecoveryConfigArgs) =
                args.NamespaceName <- io namespaceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("partnerNamespaceId")>]
        member _.PartnerNamespaceId((name, args), partnerNamespaceId) =
            let apply (args: EventhubNamespaceDisasterRecoveryConfigArgs) =
                args.PartnerNamespaceId <- input partnerNamespaceId
                args

            ()
            name, List.Cons(apply, args)

        member _.PartnerNamespaceId((name, args), partnerNamespaceId) =
            let apply (args: EventhubNamespaceDisasterRecoveryConfigArgs) =
                args.PartnerNamespaceId <- io partnerNamespaceId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: EventhubNamespaceDisasterRecoveryConfigArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: EventhubNamespaceDisasterRecoveryConfigArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let eventhubNamespaceDisasterRecoveryConfig =
        EventhubNamespaceDisasterRecoveryConfigBuilder()

    type NamespaceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Namespace(name, (List.fold func (NamespaceArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("capacity")>]
        member _.Capacity((name, args), capacity) =
            let apply (args: NamespaceArgs) =
                args.Capacity <- input capacity
                args

            ()
            name, List.Cons(apply, args)

        member _.Capacity((name, args), capacity) =
            let apply (args: NamespaceArgs) =
                args.Capacity <- io capacity
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: NamespaceArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: NamespaceArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: NamespaceArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: NamespaceArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NamespaceArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NamespaceArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sku")>]
        member _.Sku((name, args), sku) =
            let apply (args: NamespaceArgs) =
                args.Sku <- input sku
                args

            ()
            name, List.Cons(apply, args)

        member _.Sku((name, args), sku) =
            let apply (args: NamespaceArgs) =
                args.Sku <- io sku
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: NamespaceArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zoneRedundant")>]
        member _.ZoneRedundant((name, args), zoneRedundant) =
            let apply (args: NamespaceArgs) =
                args.ZoneRedundant <- input zoneRedundant
                args

            ()
            name, List.Cons(apply, args)

        member _.ZoneRedundant((name, args), zoneRedundant) =
            let apply (args: NamespaceArgs) =
                args.ZoneRedundant <- io zoneRedundant
                args

            ()
            name, List.Cons(apply, args)

    let ``namespace`` = NamespaceBuilder()

    type NamespaceAuthorizationRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            NamespaceAuthorizationRule(name, (List.fold func (NamespaceAuthorizationRuleArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("listen")>]
        member _.Listen((name, args), listen) =
            let apply (args: NamespaceAuthorizationRuleArgs) =
                args.Listen <- input listen
                args

            ()
            name, List.Cons(apply, args)

        member _.Listen((name, args), listen) =
            let apply (args: NamespaceAuthorizationRuleArgs) =
                args.Listen <- io listen
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("manage")>]
        member _.Manage((name, args), manage) =
            let apply (args: NamespaceAuthorizationRuleArgs) =
                args.Manage <- input manage
                args

            ()
            name, List.Cons(apply, args)

        member _.Manage((name, args), manage) =
            let apply (args: NamespaceAuthorizationRuleArgs) =
                args.Manage <- io manage
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: NamespaceAuthorizationRuleArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: NamespaceAuthorizationRuleArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("namespaceName")>]
        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: NamespaceAuthorizationRuleArgs) =
                args.NamespaceName <- input namespaceName
                args

            ()
            name, List.Cons(apply, args)

        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: NamespaceAuthorizationRuleArgs) =
                args.NamespaceName <- io namespaceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NamespaceAuthorizationRuleArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NamespaceAuthorizationRuleArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("send")>]
        member _.Send((name, args), send) =
            let apply (args: NamespaceAuthorizationRuleArgs) =
                args.Send <- input send
                args

            ()
            name, List.Cons(apply, args)

        member _.Send((name, args), send) =
            let apply (args: NamespaceAuthorizationRuleArgs) =
                args.Send <- io send
                args

            ()
            name, List.Cons(apply, args)

    let namespaceAuthorizationRule = NamespaceAuthorizationRuleBuilder()

    type QueueBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Queue(name, (List.fold func (QueueArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("autoDeleteOnIdle")>]
        member _.AutoDeleteOnIdle((name, args), autoDeleteOnIdle) =
            let apply (args: QueueArgs) =
                args.AutoDeleteOnIdle <- input autoDeleteOnIdle
                args

            ()
            name, List.Cons(apply, args)

        member _.AutoDeleteOnIdle((name, args), autoDeleteOnIdle) =
            let apply (args: QueueArgs) =
                args.AutoDeleteOnIdle <- io autoDeleteOnIdle
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("deadLetteringOnMessageExpiration")>]
        member _.DeadLetteringOnMessageExpiration((name, args), deadLetteringOnMessageExpiration) =
            let apply (args: QueueArgs) =
                args.DeadLetteringOnMessageExpiration <- input deadLetteringOnMessageExpiration
                args

            ()
            name, List.Cons(apply, args)

        member _.DeadLetteringOnMessageExpiration((name, args), deadLetteringOnMessageExpiration) =
            let apply (args: QueueArgs) =
                args.DeadLetteringOnMessageExpiration <- io deadLetteringOnMessageExpiration
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("defaultMessageTtl")>]
        member _.DefaultMessageTtl((name, args), defaultMessageTtl) =
            let apply (args: QueueArgs) =
                args.DefaultMessageTtl <- input defaultMessageTtl
                args

            ()
            name, List.Cons(apply, args)

        member _.DefaultMessageTtl((name, args), defaultMessageTtl) =
            let apply (args: QueueArgs) =
                args.DefaultMessageTtl <- io defaultMessageTtl
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("duplicateDetectionHistoryTimeWindow")>]
        member _.DuplicateDetectionHistoryTimeWindow((name, args), duplicateDetectionHistoryTimeWindow) =
            let apply (args: QueueArgs) =
                args.DuplicateDetectionHistoryTimeWindow <- input duplicateDetectionHistoryTimeWindow
                args

            ()
            name, List.Cons(apply, args)

        member _.DuplicateDetectionHistoryTimeWindow((name, args), duplicateDetectionHistoryTimeWindow) =
            let apply (args: QueueArgs) =
                args.DuplicateDetectionHistoryTimeWindow <- io duplicateDetectionHistoryTimeWindow
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enableExpress")>]
        member _.EnableExpress((name, args), enableExpress) =
            let apply (args: QueueArgs) =
                args.EnableExpress <- input enableExpress
                args

            ()
            name, List.Cons(apply, args)

        member _.EnableExpress((name, args), enableExpress) =
            let apply (args: QueueArgs) =
                args.EnableExpress <- io enableExpress
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enablePartitioning")>]
        member _.EnablePartitioning((name, args), enablePartitioning) =
            let apply (args: QueueArgs) =
                args.EnablePartitioning <- input enablePartitioning
                args

            ()
            name, List.Cons(apply, args)

        member _.EnablePartitioning((name, args), enablePartitioning) =
            let apply (args: QueueArgs) =
                args.EnablePartitioning <- io enablePartitioning
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("lockDuration")>]
        member _.LockDuration((name, args), lockDuration) =
            let apply (args: QueueArgs) =
                args.LockDuration <- input lockDuration
                args

            ()
            name, List.Cons(apply, args)

        member _.LockDuration((name, args), lockDuration) =
            let apply (args: QueueArgs) =
                args.LockDuration <- io lockDuration
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("maxDeliveryCount")>]
        member _.MaxDeliveryCount((name, args), maxDeliveryCount) =
            let apply (args: QueueArgs) =
                args.MaxDeliveryCount <- input maxDeliveryCount
                args

            ()
            name, List.Cons(apply, args)

        member _.MaxDeliveryCount((name, args), maxDeliveryCount) =
            let apply (args: QueueArgs) =
                args.MaxDeliveryCount <- io maxDeliveryCount
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("maxSizeInMegabytes")>]
        member _.MaxSizeInMegabytes((name, args), maxSizeInMegabytes) =
            let apply (args: QueueArgs) =
                args.MaxSizeInMegabytes <- input maxSizeInMegabytes
                args

            ()
            name, List.Cons(apply, args)

        member _.MaxSizeInMegabytes((name, args), maxSizeInMegabytes) =
            let apply (args: QueueArgs) =
                args.MaxSizeInMegabytes <- io maxSizeInMegabytes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: QueueArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: QueueArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("namespaceName")>]
        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: QueueArgs) =
                args.NamespaceName <- input namespaceName
                args

            ()
            name, List.Cons(apply, args)

        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: QueueArgs) =
                args.NamespaceName <- io namespaceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("requiresDuplicateDetection")>]
        member _.RequiresDuplicateDetection((name, args), requiresDuplicateDetection) =
            let apply (args: QueueArgs) =
                args.RequiresDuplicateDetection <- input requiresDuplicateDetection
                args

            ()
            name, List.Cons(apply, args)

        member _.RequiresDuplicateDetection((name, args), requiresDuplicateDetection) =
            let apply (args: QueueArgs) =
                args.RequiresDuplicateDetection <- io requiresDuplicateDetection
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("requiresSession")>]
        member _.RequiresSession((name, args), requiresSession) =
            let apply (args: QueueArgs) =
                args.RequiresSession <- input requiresSession
                args

            ()
            name, List.Cons(apply, args)

        member _.RequiresSession((name, args), requiresSession) =
            let apply (args: QueueArgs) =
                args.RequiresSession <- io requiresSession
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: QueueArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: QueueArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let queue = QueueBuilder()

    type QueueAuthorizationRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            QueueAuthorizationRule(name, (List.fold func (QueueAuthorizationRuleArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("listen")>]
        member _.Listen((name, args), listen) =
            let apply (args: QueueAuthorizationRuleArgs) =
                args.Listen <- input listen
                args

            ()
            name, List.Cons(apply, args)

        member _.Listen((name, args), listen) =
            let apply (args: QueueAuthorizationRuleArgs) =
                args.Listen <- io listen
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("manage")>]
        member _.Manage((name, args), manage) =
            let apply (args: QueueAuthorizationRuleArgs) =
                args.Manage <- input manage
                args

            ()
            name, List.Cons(apply, args)

        member _.Manage((name, args), manage) =
            let apply (args: QueueAuthorizationRuleArgs) =
                args.Manage <- io manage
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: QueueAuthorizationRuleArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: QueueAuthorizationRuleArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("namespaceName")>]
        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: QueueAuthorizationRuleArgs) =
                args.NamespaceName <- input namespaceName
                args

            ()
            name, List.Cons(apply, args)

        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: QueueAuthorizationRuleArgs) =
                args.NamespaceName <- io namespaceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("queueName")>]
        member _.QueueName((name, args), queueName) =
            let apply (args: QueueAuthorizationRuleArgs) =
                args.QueueName <- input queueName
                args

            ()
            name, List.Cons(apply, args)

        member _.QueueName((name, args), queueName) =
            let apply (args: QueueAuthorizationRuleArgs) =
                args.QueueName <- io queueName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: QueueAuthorizationRuleArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: QueueAuthorizationRuleArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("send")>]
        member _.Send((name, args), send) =
            let apply (args: QueueAuthorizationRuleArgs) =
                args.Send <- input send
                args

            ()
            name, List.Cons(apply, args)

        member _.Send((name, args), send) =
            let apply (args: QueueAuthorizationRuleArgs) =
                args.Send <- io send
                args

            ()
            name, List.Cons(apply, args)

    let queueAuthorizationRule = QueueAuthorizationRuleBuilder()

    type SubscriptionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Subscription(name, (List.fold func (SubscriptionArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("autoDeleteOnIdle")>]
        member _.AutoDeleteOnIdle((name, args), autoDeleteOnIdle) =
            let apply (args: SubscriptionArgs) =
                args.AutoDeleteOnIdle <- input autoDeleteOnIdle
                args

            ()
            name, List.Cons(apply, args)

        member _.AutoDeleteOnIdle((name, args), autoDeleteOnIdle) =
            let apply (args: SubscriptionArgs) =
                args.AutoDeleteOnIdle <- io autoDeleteOnIdle
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("deadLetteringOnMessageExpiration")>]
        member _.DeadLetteringOnMessageExpiration((name, args), deadLetteringOnMessageExpiration) =
            let apply (args: SubscriptionArgs) =
                args.DeadLetteringOnMessageExpiration <- input deadLetteringOnMessageExpiration
                args

            ()
            name, List.Cons(apply, args)

        member _.DeadLetteringOnMessageExpiration((name, args), deadLetteringOnMessageExpiration) =
            let apply (args: SubscriptionArgs) =
                args.DeadLetteringOnMessageExpiration <- io deadLetteringOnMessageExpiration
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("defaultMessageTtl")>]
        member _.DefaultMessageTtl((name, args), defaultMessageTtl) =
            let apply (args: SubscriptionArgs) =
                args.DefaultMessageTtl <- input defaultMessageTtl
                args

            ()
            name, List.Cons(apply, args)

        member _.DefaultMessageTtl((name, args), defaultMessageTtl) =
            let apply (args: SubscriptionArgs) =
                args.DefaultMessageTtl <- io defaultMessageTtl
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enableBatchedOperations")>]
        member _.EnableBatchedOperations((name, args), enableBatchedOperations) =
            let apply (args: SubscriptionArgs) =
                args.EnableBatchedOperations <- input enableBatchedOperations
                args

            ()
            name, List.Cons(apply, args)

        member _.EnableBatchedOperations((name, args), enableBatchedOperations) =
            let apply (args: SubscriptionArgs) =
                args.EnableBatchedOperations <- io enableBatchedOperations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("forwardDeadLetteredMessagesTo")>]
        member _.ForwardDeadLetteredMessagesTo((name, args), forwardDeadLetteredMessagesTo) =
            let apply (args: SubscriptionArgs) =
                args.ForwardDeadLetteredMessagesTo <- input forwardDeadLetteredMessagesTo
                args

            ()
            name, List.Cons(apply, args)

        member _.ForwardDeadLetteredMessagesTo((name, args), forwardDeadLetteredMessagesTo) =
            let apply (args: SubscriptionArgs) =
                args.ForwardDeadLetteredMessagesTo <- io forwardDeadLetteredMessagesTo
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("forwardTo")>]
        member _.ForwardTo((name, args), forwardTo) =
            let apply (args: SubscriptionArgs) =
                args.ForwardTo <- input forwardTo
                args

            ()
            name, List.Cons(apply, args)

        member _.ForwardTo((name, args), forwardTo) =
            let apply (args: SubscriptionArgs) =
                args.ForwardTo <- io forwardTo
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("lockDuration")>]
        member _.LockDuration((name, args), lockDuration) =
            let apply (args: SubscriptionArgs) =
                args.LockDuration <- input lockDuration
                args

            ()
            name, List.Cons(apply, args)

        member _.LockDuration((name, args), lockDuration) =
            let apply (args: SubscriptionArgs) =
                args.LockDuration <- io lockDuration
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("maxDeliveryCount")>]
        member _.MaxDeliveryCount((name, args), maxDeliveryCount) =
            let apply (args: SubscriptionArgs) =
                args.MaxDeliveryCount <- input maxDeliveryCount
                args

            ()
            name, List.Cons(apply, args)

        member _.MaxDeliveryCount((name, args), maxDeliveryCount) =
            let apply (args: SubscriptionArgs) =
                args.MaxDeliveryCount <- io maxDeliveryCount
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: SubscriptionArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: SubscriptionArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("namespaceName")>]
        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: SubscriptionArgs) =
                args.NamespaceName <- input namespaceName
                args

            ()
            name, List.Cons(apply, args)

        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: SubscriptionArgs) =
                args.NamespaceName <- io namespaceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("requiresSession")>]
        member _.RequiresSession((name, args), requiresSession) =
            let apply (args: SubscriptionArgs) =
                args.RequiresSession <- input requiresSession
                args

            ()
            name, List.Cons(apply, args)

        member _.RequiresSession((name, args), requiresSession) =
            let apply (args: SubscriptionArgs) =
                args.RequiresSession <- io requiresSession
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SubscriptionArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SubscriptionArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("topicName")>]
        member _.TopicName((name, args), topicName) =
            let apply (args: SubscriptionArgs) =
                args.TopicName <- input topicName
                args

            ()
            name, List.Cons(apply, args)

        member _.TopicName((name, args), topicName) =
            let apply (args: SubscriptionArgs) =
                args.TopicName <- io topicName
                args

            ()
            name, List.Cons(apply, args)

    let subscription = SubscriptionBuilder()

    type SubscriptionRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            SubscriptionRule(name, (List.fold func (SubscriptionRuleArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("action")>]
        member _.Action((name, args), action) =
            let apply (args: SubscriptionRuleArgs) =
                args.Action <- input action
                args

            ()
            name, List.Cons(apply, args)

        member _.Action((name, args), action) =
            let apply (args: SubscriptionRuleArgs) =
                args.Action <- io action
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: SubscriptionRuleArgs) =
                   args.CorrelationFilter <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("filterType")>]
        member _.FilterType((name, args), filterType) =
            let apply (args: SubscriptionRuleArgs) =
                args.FilterType <- input filterType
                args

            ()
            name, List.Cons(apply, args)

        member _.FilterType((name, args), filterType) =
            let apply (args: SubscriptionRuleArgs) =
                args.FilterType <- io filterType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: SubscriptionRuleArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: SubscriptionRuleArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("namespaceName")>]
        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: SubscriptionRuleArgs) =
                args.NamespaceName <- input namespaceName
                args

            ()
            name, List.Cons(apply, args)

        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: SubscriptionRuleArgs) =
                args.NamespaceName <- io namespaceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SubscriptionRuleArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SubscriptionRuleArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sqlFilter")>]
        member _.SqlFilter((name, args), sqlFilter) =
            let apply (args: SubscriptionRuleArgs) =
                args.SqlFilter <- input sqlFilter
                args

            ()
            name, List.Cons(apply, args)

        member _.SqlFilter((name, args), sqlFilter) =
            let apply (args: SubscriptionRuleArgs) =
                args.SqlFilter <- io sqlFilter
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("subscriptionName")>]
        member _.SubscriptionName((name, args), subscriptionName) =
            let apply (args: SubscriptionRuleArgs) =
                args.SubscriptionName <- input subscriptionName
                args

            ()
            name, List.Cons(apply, args)

        member _.SubscriptionName((name, args), subscriptionName) =
            let apply (args: SubscriptionRuleArgs) =
                args.SubscriptionName <- io subscriptionName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("topicName")>]
        member _.TopicName((name, args), topicName) =
            let apply (args: SubscriptionRuleArgs) =
                args.TopicName <- input topicName
                args

            ()
            name, List.Cons(apply, args)

        member _.TopicName((name, args), topicName) =
            let apply (args: SubscriptionRuleArgs) =
                args.TopicName <- io topicName
                args

            ()
            name, List.Cons(apply, args)

    let subscriptionRule = SubscriptionRuleBuilder()

    type TopicBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Topic(name, (List.fold func (TopicArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("autoDeleteOnIdle")>]
        member _.AutoDeleteOnIdle((name, args), autoDeleteOnIdle) =
            let apply (args: TopicArgs) =
                args.AutoDeleteOnIdle <- input autoDeleteOnIdle
                args

            ()
            name, List.Cons(apply, args)

        member _.AutoDeleteOnIdle((name, args), autoDeleteOnIdle) =
            let apply (args: TopicArgs) =
                args.AutoDeleteOnIdle <- io autoDeleteOnIdle
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("defaultMessageTtl")>]
        member _.DefaultMessageTtl((name, args), defaultMessageTtl) =
            let apply (args: TopicArgs) =
                args.DefaultMessageTtl <- input defaultMessageTtl
                args

            ()
            name, List.Cons(apply, args)

        member _.DefaultMessageTtl((name, args), defaultMessageTtl) =
            let apply (args: TopicArgs) =
                args.DefaultMessageTtl <- io defaultMessageTtl
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("duplicateDetectionHistoryTimeWindow")>]
        member _.DuplicateDetectionHistoryTimeWindow((name, args), duplicateDetectionHistoryTimeWindow) =
            let apply (args: TopicArgs) =
                args.DuplicateDetectionHistoryTimeWindow <- input duplicateDetectionHistoryTimeWindow
                args

            ()
            name, List.Cons(apply, args)

        member _.DuplicateDetectionHistoryTimeWindow((name, args), duplicateDetectionHistoryTimeWindow) =
            let apply (args: TopicArgs) =
                args.DuplicateDetectionHistoryTimeWindow <- io duplicateDetectionHistoryTimeWindow
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enableBatchedOperations")>]
        member _.EnableBatchedOperations((name, args), enableBatchedOperations) =
            let apply (args: TopicArgs) =
                args.EnableBatchedOperations <- input enableBatchedOperations
                args

            ()
            name, List.Cons(apply, args)

        member _.EnableBatchedOperations((name, args), enableBatchedOperations) =
            let apply (args: TopicArgs) =
                args.EnableBatchedOperations <- io enableBatchedOperations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enableExpress")>]
        member _.EnableExpress((name, args), enableExpress) =
            let apply (args: TopicArgs) =
                args.EnableExpress <- input enableExpress
                args

            ()
            name, List.Cons(apply, args)

        member _.EnableExpress((name, args), enableExpress) =
            let apply (args: TopicArgs) =
                args.EnableExpress <- io enableExpress
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enablePartitioning")>]
        member _.EnablePartitioning((name, args), enablePartitioning) =
            let apply (args: TopicArgs) =
                args.EnablePartitioning <- input enablePartitioning
                args

            ()
            name, List.Cons(apply, args)

        member _.EnablePartitioning((name, args), enablePartitioning) =
            let apply (args: TopicArgs) =
                args.EnablePartitioning <- io enablePartitioning
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("maxSizeInMegabytes")>]
        member _.MaxSizeInMegabytes((name, args), maxSizeInMegabytes) =
            let apply (args: TopicArgs) =
                args.MaxSizeInMegabytes <- input maxSizeInMegabytes
                args

            ()
            name, List.Cons(apply, args)

        member _.MaxSizeInMegabytes((name, args), maxSizeInMegabytes) =
            let apply (args: TopicArgs) =
                args.MaxSizeInMegabytes <- io maxSizeInMegabytes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: TopicArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: TopicArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("namespaceName")>]
        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: TopicArgs) =
                args.NamespaceName <- input namespaceName
                args

            ()
            name, List.Cons(apply, args)

        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: TopicArgs) =
                args.NamespaceName <- io namespaceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("requiresDuplicateDetection")>]
        member _.RequiresDuplicateDetection((name, args), requiresDuplicateDetection) =
            let apply (args: TopicArgs) =
                args.RequiresDuplicateDetection <- input requiresDuplicateDetection
                args

            ()
            name, List.Cons(apply, args)

        member _.RequiresDuplicateDetection((name, args), requiresDuplicateDetection) =
            let apply (args: TopicArgs) =
                args.RequiresDuplicateDetection <- io requiresDuplicateDetection
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: TopicArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: TopicArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("status")>]
        member _.Status((name, args), status) =
            let apply (args: TopicArgs) =
                args.Status <- input status
                args

            ()
            name, List.Cons(apply, args)

        member _.Status((name, args), status) =
            let apply (args: TopicArgs) =
                args.Status <- io status
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("supportOrdering")>]
        member _.SupportOrdering((name, args), supportOrdering) =
            let apply (args: TopicArgs) =
                args.SupportOrdering <- input supportOrdering
                args

            ()
            name, List.Cons(apply, args)

        member _.SupportOrdering((name, args), supportOrdering) =
            let apply (args: TopicArgs) =
                args.SupportOrdering <- io supportOrdering
                args

            ()
            name, List.Cons(apply, args)

    let topic = TopicBuilder()

    type TopicAuthorizationRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            TopicAuthorizationRule(name, (List.fold func (TopicAuthorizationRuleArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("listen")>]
        member _.Listen((name, args), listen) =
            let apply (args: TopicAuthorizationRuleArgs) =
                args.Listen <- input listen
                args

            ()
            name, List.Cons(apply, args)

        member _.Listen((name, args), listen) =
            let apply (args: TopicAuthorizationRuleArgs) =
                args.Listen <- io listen
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("manage")>]
        member _.Manage((name, args), manage) =
            let apply (args: TopicAuthorizationRuleArgs) =
                args.Manage <- input manage
                args

            ()
            name, List.Cons(apply, args)

        member _.Manage((name, args), manage) =
            let apply (args: TopicAuthorizationRuleArgs) =
                args.Manage <- io manage
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: TopicAuthorizationRuleArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: TopicAuthorizationRuleArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("namespaceName")>]
        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: TopicAuthorizationRuleArgs) =
                args.NamespaceName <- input namespaceName
                args

            ()
            name, List.Cons(apply, args)

        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: TopicAuthorizationRuleArgs) =
                args.NamespaceName <- io namespaceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: TopicAuthorizationRuleArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: TopicAuthorizationRuleArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("send")>]
        member _.Send((name, args), send) =
            let apply (args: TopicAuthorizationRuleArgs) =
                args.Send <- input send
                args

            ()
            name, List.Cons(apply, args)

        member _.Send((name, args), send) =
            let apply (args: TopicAuthorizationRuleArgs) =
                args.Send <- io send
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("topicName")>]
        member _.TopicName((name, args), topicName) =
            let apply (args: TopicAuthorizationRuleArgs) =
                args.TopicName <- input topicName
                args

            ()
            name, List.Cons(apply, args)

        member _.TopicName((name, args), topicName) =
            let apply (args: TopicAuthorizationRuleArgs) =
                args.TopicName <- io topicName
                args

            ()
            name, List.Cons(apply, args)

    let topicAuthorizationRule = TopicAuthorizationRuleBuilder()

module FrontDoor =
    open Pulumi.Azure.FrontDoor
    open Pulumi.Azure.FrontDoor.Inputs

    type FirewallPolicyCustomRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FirewallPolicyCustomRuleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("action")>]
        member _.Action((n, args), action) =
            let apply (args: FirewallPolicyCustomRuleArgs) =
                args.Action <- input action
                args

            ()
            n, List.Cons(apply, args)

        member _.Action((n, args), action) =
            let apply (args: FirewallPolicyCustomRuleArgs) =
                args.Action <- io action
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: FirewallPolicyCustomRuleArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: FirewallPolicyCustomRuleArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("matchConditions")>]
        member _.MatchConditions((n, args), matchConditions) =
            let apply (args: FirewallPolicyCustomRuleArgs) =
                args.MatchConditions <- inputList matchConditions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: FirewallPolicyCustomRuleArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: FirewallPolicyCustomRuleArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("priority")>]
        member _.Priority((n, args), priority) =
            let apply (args: FirewallPolicyCustomRuleArgs) =
                args.Priority <- input priority
                args

            ()
            n, List.Cons(apply, args)

        member _.Priority((n, args), priority) =
            let apply (args: FirewallPolicyCustomRuleArgs) =
                args.Priority <- io priority
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("rateLimitDurationInMinutes")>]
        member _.RateLimitDurationInMinutes((n, args), rateLimitDurationInMinutes) =
            let apply (args: FirewallPolicyCustomRuleArgs) =
                args.RateLimitDurationInMinutes <- input rateLimitDurationInMinutes
                args

            ()
            n, List.Cons(apply, args)

        member _.RateLimitDurationInMinutes((n, args), rateLimitDurationInMinutes) =
            let apply (args: FirewallPolicyCustomRuleArgs) =
                args.RateLimitDurationInMinutes <- io rateLimitDurationInMinutes
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("rateLimitThreshold")>]
        member _.RateLimitThreshold((n, args), rateLimitThreshold) =
            let apply (args: FirewallPolicyCustomRuleArgs) =
                args.RateLimitThreshold <- input rateLimitThreshold
                args

            ()
            n, List.Cons(apply, args)

        member _.RateLimitThreshold((n, args), rateLimitThreshold) =
            let apply (args: FirewallPolicyCustomRuleArgs) =
                args.RateLimitThreshold <- io rateLimitThreshold
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: FirewallPolicyCustomRuleArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: FirewallPolicyCustomRuleArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let firewallPolicyCustomRule = FirewallPolicyCustomRuleBuilder()

    type FirewallPolicyCustomRuleMatchConditionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FirewallPolicyCustomRuleMatchConditionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("matchValues")>]
        member _.MatchValues((n, args), matchValues) =
            let apply (args: FirewallPolicyCustomRuleMatchConditionArgs) =
                args.MatchValues <- inputList matchValues
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("matchVariable")>]
        member _.MatchVariable((n, args), matchVariable) =
            let apply (args: FirewallPolicyCustomRuleMatchConditionArgs) =
                args.MatchVariable <- input matchVariable
                args

            ()
            n, List.Cons(apply, args)

        member _.MatchVariable((n, args), matchVariable) =
            let apply (args: FirewallPolicyCustomRuleMatchConditionArgs) =
                args.MatchVariable <- io matchVariable
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("negationCondition")>]
        member _.NegationCondition((n, args), negationCondition) =
            let apply (args: FirewallPolicyCustomRuleMatchConditionArgs) =
                args.NegationCondition <- input negationCondition
                args

            ()
            n, List.Cons(apply, args)

        member _.NegationCondition((n, args), negationCondition) =
            let apply (args: FirewallPolicyCustomRuleMatchConditionArgs) =
                args.NegationCondition <- io negationCondition
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: FirewallPolicyCustomRuleMatchConditionArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: FirewallPolicyCustomRuleMatchConditionArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("selector")>]
        member _.Selector((n, args), selector) =
            let apply (args: FirewallPolicyCustomRuleMatchConditionArgs) =
                args.Selector <- input selector
                args

            ()
            n, List.Cons(apply, args)

        member _.Selector((n, args), selector) =
            let apply (args: FirewallPolicyCustomRuleMatchConditionArgs) =
                args.Selector <- io selector
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("transforms")>]
        member _.Transforms((n, args), transforms) =
            let apply (args: FirewallPolicyCustomRuleMatchConditionArgs) =
                args.Transforms <- inputList transforms
                args

            ()
            n, List.Cons(apply, args)

    let firewallPolicyCustomRuleMatchCondition =
        FirewallPolicyCustomRuleMatchConditionBuilder()

    type FirewallPolicyManagedRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FirewallPolicyManagedRuleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("exclusions")>]
        member _.Exclusions((n, args), exclusions) =
            let apply (args: FirewallPolicyManagedRuleArgs) =
                args.Exclusions <- inputList exclusions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("overrides")>]
        member _.Overrides((n, args), overrides) =
            let apply (args: FirewallPolicyManagedRuleArgs) =
                args.Overrides <- inputList overrides
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: FirewallPolicyManagedRuleArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: FirewallPolicyManagedRuleArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("version")>]
        member _.Version((n, args), version) =
            let apply (args: FirewallPolicyManagedRuleArgs) =
                args.Version <- input version
                args

            ()
            n, List.Cons(apply, args)

        member _.Version((n, args), version) =
            let apply (args: FirewallPolicyManagedRuleArgs) =
                args.Version <- io version
                args

            ()
            n, List.Cons(apply, args)

    let firewallPolicyManagedRule = FirewallPolicyManagedRuleBuilder()

    type FirewallPolicyManagedRuleExclusionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FirewallPolicyManagedRuleExclusionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("matchVariable")>]
        member _.MatchVariable((n, args), matchVariable) =
            let apply (args: FirewallPolicyManagedRuleExclusionArgs) =
                args.MatchVariable <- input matchVariable
                args

            ()
            n, List.Cons(apply, args)

        member _.MatchVariable((n, args), matchVariable) =
            let apply (args: FirewallPolicyManagedRuleExclusionArgs) =
                args.MatchVariable <- io matchVariable
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: FirewallPolicyManagedRuleExclusionArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: FirewallPolicyManagedRuleExclusionArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("selector")>]
        member _.Selector((n, args), selector) =
            let apply (args: FirewallPolicyManagedRuleExclusionArgs) =
                args.Selector <- input selector
                args

            ()
            n, List.Cons(apply, args)

        member _.Selector((n, args), selector) =
            let apply (args: FirewallPolicyManagedRuleExclusionArgs) =
                args.Selector <- io selector
                args

            ()
            n, List.Cons(apply, args)

    let firewallPolicyManagedRuleExclusion =
        FirewallPolicyManagedRuleExclusionBuilder()

    type FirewallPolicyManagedRuleOverrideBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FirewallPolicyManagedRuleOverrideArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("exclusions")>]
        member _.Exclusions((n, args), exclusions) =
            let apply (args: FirewallPolicyManagedRuleOverrideArgs) =
                args.Exclusions <- inputList exclusions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ruleGroupName")>]
        member _.RuleGroupName((n, args), ruleGroupName) =
            let apply (args: FirewallPolicyManagedRuleOverrideArgs) =
                args.RuleGroupName <- input ruleGroupName
                args

            ()
            n, List.Cons(apply, args)

        member _.RuleGroupName((n, args), ruleGroupName) =
            let apply (args: FirewallPolicyManagedRuleOverrideArgs) =
                args.RuleGroupName <- io ruleGroupName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("rules")>]
        member _.Rules((n, args), rules) =
            let apply (args: FirewallPolicyManagedRuleOverrideArgs) =
                args.Rules <- inputList rules
                args

            ()
            n, List.Cons(apply, args)

    let firewallPolicyManagedRuleOverride =
        FirewallPolicyManagedRuleOverrideBuilder()

    type FirewallPolicyManagedRuleOverrideExclusionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FirewallPolicyManagedRuleOverrideExclusionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("matchVariable")>]
        member _.MatchVariable((n, args), matchVariable) =
            let apply (args: FirewallPolicyManagedRuleOverrideExclusionArgs) =
                args.MatchVariable <- input matchVariable
                args

            ()
            n, List.Cons(apply, args)

        member _.MatchVariable((n, args), matchVariable) =
            let apply (args: FirewallPolicyManagedRuleOverrideExclusionArgs) =
                args.MatchVariable <- io matchVariable
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: FirewallPolicyManagedRuleOverrideExclusionArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: FirewallPolicyManagedRuleOverrideExclusionArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("selector")>]
        member _.Selector((n, args), selector) =
            let apply (args: FirewallPolicyManagedRuleOverrideExclusionArgs) =
                args.Selector <- input selector
                args

            ()
            n, List.Cons(apply, args)

        member _.Selector((n, args), selector) =
            let apply (args: FirewallPolicyManagedRuleOverrideExclusionArgs) =
                args.Selector <- io selector
                args

            ()
            n, List.Cons(apply, args)

    let firewallPolicyManagedRuleOverrideExclusion =
        FirewallPolicyManagedRuleOverrideExclusionBuilder()

    type FirewallPolicyManagedRuleOverrideRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FirewallPolicyManagedRuleOverrideRuleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("action")>]
        member _.Action((n, args), action) =
            let apply (args: FirewallPolicyManagedRuleOverrideRuleArgs) =
                args.Action <- input action
                args

            ()
            n, List.Cons(apply, args)

        member _.Action((n, args), action) =
            let apply (args: FirewallPolicyManagedRuleOverrideRuleArgs) =
                args.Action <- io action
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: FirewallPolicyManagedRuleOverrideRuleArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: FirewallPolicyManagedRuleOverrideRuleArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("exclusions")>]
        member _.Exclusions((n, args), exclusions) =
            let apply (args: FirewallPolicyManagedRuleOverrideRuleArgs) =
                args.Exclusions <- inputList exclusions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ruleId")>]
        member _.RuleId((n, args), ruleId) =
            let apply (args: FirewallPolicyManagedRuleOverrideRuleArgs) =
                args.RuleId <- input ruleId
                args

            ()
            n, List.Cons(apply, args)

        member _.RuleId((n, args), ruleId) =
            let apply (args: FirewallPolicyManagedRuleOverrideRuleArgs) =
                args.RuleId <- io ruleId
                args

            ()
            n, List.Cons(apply, args)

    let firewallPolicyManagedRuleOverrideRule =
        FirewallPolicyManagedRuleOverrideRuleBuilder()

    type FirewallPolicyManagedRuleOverrideRuleExclusionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FirewallPolicyManagedRuleOverrideRuleExclusionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("matchVariable")>]
        member _.MatchVariable((n, args), matchVariable) =
            let apply (args: FirewallPolicyManagedRuleOverrideRuleExclusionArgs) =
                args.MatchVariable <- input matchVariable
                args

            ()
            n, List.Cons(apply, args)

        member _.MatchVariable((n, args), matchVariable) =
            let apply (args: FirewallPolicyManagedRuleOverrideRuleExclusionArgs) =
                args.MatchVariable <- io matchVariable
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: FirewallPolicyManagedRuleOverrideRuleExclusionArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: FirewallPolicyManagedRuleOverrideRuleExclusionArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("selector")>]
        member _.Selector((n, args), selector) =
            let apply (args: FirewallPolicyManagedRuleOverrideRuleExclusionArgs) =
                args.Selector <- input selector
                args

            ()
            n, List.Cons(apply, args)

        member _.Selector((n, args), selector) =
            let apply (args: FirewallPolicyManagedRuleOverrideRuleExclusionArgs) =
                args.Selector <- io selector
                args

            ()
            n, List.Cons(apply, args)

    let firewallPolicyManagedRuleOverrideRuleExclusion =
        FirewallPolicyManagedRuleOverrideRuleExclusionBuilder()

    type FrontdoorBackendPoolBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FrontdoorBackendPoolArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("backends")>]
        member _.Backends((n, args), backends) =
            let apply (args: FrontdoorBackendPoolArgs) =
                args.Backends <- inputList backends
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("healthProbeName")>]
        member _.HealthProbeName((n, args), healthProbeName) =
            let apply (args: FrontdoorBackendPoolArgs) =
                args.HealthProbeName <- input healthProbeName
                args

            ()
            n, List.Cons(apply, args)

        member _.HealthProbeName((n, args), healthProbeName) =
            let apply (args: FrontdoorBackendPoolArgs) =
                args.HealthProbeName <- io healthProbeName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: FrontdoorBackendPoolArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: FrontdoorBackendPoolArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("loadBalancingName")>]
        member _.LoadBalancingName((n, args), loadBalancingName) =
            let apply (args: FrontdoorBackendPoolArgs) =
                args.LoadBalancingName <- input loadBalancingName
                args

            ()
            n, List.Cons(apply, args)

        member _.LoadBalancingName((n, args), loadBalancingName) =
            let apply (args: FrontdoorBackendPoolArgs) =
                args.LoadBalancingName <- io loadBalancingName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: FrontdoorBackendPoolArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: FrontdoorBackendPoolArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

    let frontdoorBackendPool = FrontdoorBackendPoolBuilder()

    type FrontdoorBackendPoolBackendBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FrontdoorBackendPoolBackendArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("address")>]
        member _.Address((n, args), address) =
            let apply (args: FrontdoorBackendPoolBackendArgs) =
                args.Address <- input address
                args

            ()
            n, List.Cons(apply, args)

        member _.Address((n, args), address) =
            let apply (args: FrontdoorBackendPoolBackendArgs) =
                args.Address <- io address
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: FrontdoorBackendPoolBackendArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: FrontdoorBackendPoolBackendArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("hostHeader")>]
        member _.HostHeader((n, args), hostHeader) =
            let apply (args: FrontdoorBackendPoolBackendArgs) =
                args.HostHeader <- input hostHeader
                args

            ()
            n, List.Cons(apply, args)

        member _.HostHeader((n, args), hostHeader) =
            let apply (args: FrontdoorBackendPoolBackendArgs) =
                args.HostHeader <- io hostHeader
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("httpPort")>]
        member _.HttpPort((n, args), httpPort) =
            let apply (args: FrontdoorBackendPoolBackendArgs) =
                args.HttpPort <- input httpPort
                args

            ()
            n, List.Cons(apply, args)

        member _.HttpPort((n, args), httpPort) =
            let apply (args: FrontdoorBackendPoolBackendArgs) =
                args.HttpPort <- io httpPort
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("httpsPort")>]
        member _.HttpsPort((n, args), httpsPort) =
            let apply (args: FrontdoorBackendPoolBackendArgs) =
                args.HttpsPort <- input httpsPort
                args

            ()
            n, List.Cons(apply, args)

        member _.HttpsPort((n, args), httpsPort) =
            let apply (args: FrontdoorBackendPoolBackendArgs) =
                args.HttpsPort <- io httpsPort
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("priority")>]
        member _.Priority((n, args), priority) =
            let apply (args: FrontdoorBackendPoolBackendArgs) =
                args.Priority <- input priority
                args

            ()
            n, List.Cons(apply, args)

        member _.Priority((n, args), priority) =
            let apply (args: FrontdoorBackendPoolBackendArgs) =
                args.Priority <- io priority
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("weight")>]
        member _.Weight((n, args), weight) =
            let apply (args: FrontdoorBackendPoolBackendArgs) =
                args.Weight <- input weight
                args

            ()
            n, List.Cons(apply, args)

        member _.Weight((n, args), weight) =
            let apply (args: FrontdoorBackendPoolBackendArgs) =
                args.Weight <- io weight
                args

            ()
            n, List.Cons(apply, args)

    let frontdoorBackendPoolBackend = FrontdoorBackendPoolBackendBuilder()

    type FrontdoorBackendPoolHealthProbeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FrontdoorBackendPoolHealthProbeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: FrontdoorBackendPoolHealthProbeArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: FrontdoorBackendPoolHealthProbeArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: FrontdoorBackendPoolHealthProbeArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: FrontdoorBackendPoolHealthProbeArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("intervalInSeconds")>]
        member _.IntervalInSeconds((n, args), intervalInSeconds) =
            let apply (args: FrontdoorBackendPoolHealthProbeArgs) =
                args.IntervalInSeconds <- input intervalInSeconds
                args

            ()
            n, List.Cons(apply, args)

        member _.IntervalInSeconds((n, args), intervalInSeconds) =
            let apply (args: FrontdoorBackendPoolHealthProbeArgs) =
                args.IntervalInSeconds <- io intervalInSeconds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: FrontdoorBackendPoolHealthProbeArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: FrontdoorBackendPoolHealthProbeArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("path")>]
        member _.Path((n, args), path) =
            let apply (args: FrontdoorBackendPoolHealthProbeArgs) =
                args.Path <- input path
                args

            ()
            n, List.Cons(apply, args)

        member _.Path((n, args), path) =
            let apply (args: FrontdoorBackendPoolHealthProbeArgs) =
                args.Path <- io path
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("probeMethod")>]
        member _.ProbeMethod((n, args), probeMethod) =
            let apply (args: FrontdoorBackendPoolHealthProbeArgs) =
                args.ProbeMethod <- input probeMethod
                args

            ()
            n, List.Cons(apply, args)

        member _.ProbeMethod((n, args), probeMethod) =
            let apply (args: FrontdoorBackendPoolHealthProbeArgs) =
                args.ProbeMethod <- io probeMethod
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("protocol")>]
        member _.Protocol((n, args), protocol) =
            let apply (args: FrontdoorBackendPoolHealthProbeArgs) =
                args.Protocol <- input protocol
                args

            ()
            n, List.Cons(apply, args)

        member _.Protocol((n, args), protocol) =
            let apply (args: FrontdoorBackendPoolHealthProbeArgs) =
                args.Protocol <- io protocol
                args

            ()
            n, List.Cons(apply, args)

    let frontdoorBackendPoolHealthProbe = FrontdoorBackendPoolHealthProbeBuilder()

    type FrontdoorBackendPoolLoadBalancingBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FrontdoorBackendPoolLoadBalancingArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("additionalLatencyMilliseconds")>]
        member _.AdditionalLatencyMilliseconds((n, args), additionalLatencyMilliseconds) =
            let apply (args: FrontdoorBackendPoolLoadBalancingArgs) =
                args.AdditionalLatencyMilliseconds <- input additionalLatencyMilliseconds
                args

            ()
            n, List.Cons(apply, args)

        member _.AdditionalLatencyMilliseconds((n, args), additionalLatencyMilliseconds) =
            let apply (args: FrontdoorBackendPoolLoadBalancingArgs) =
                args.AdditionalLatencyMilliseconds <- io additionalLatencyMilliseconds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: FrontdoorBackendPoolLoadBalancingArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: FrontdoorBackendPoolLoadBalancingArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: FrontdoorBackendPoolLoadBalancingArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: FrontdoorBackendPoolLoadBalancingArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sampleSize")>]
        member _.SampleSize((n, args), sampleSize) =
            let apply (args: FrontdoorBackendPoolLoadBalancingArgs) =
                args.SampleSize <- input sampleSize
                args

            ()
            n, List.Cons(apply, args)

        member _.SampleSize((n, args), sampleSize) =
            let apply (args: FrontdoorBackendPoolLoadBalancingArgs) =
                args.SampleSize <- io sampleSize
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("successfulSamplesRequired")>]
        member _.SuccessfulSamplesRequired((n, args), successfulSamplesRequired) =
            let apply (args: FrontdoorBackendPoolLoadBalancingArgs) =
                args.SuccessfulSamplesRequired <- input successfulSamplesRequired
                args

            ()
            n, List.Cons(apply, args)

        member _.SuccessfulSamplesRequired((n, args), successfulSamplesRequired) =
            let apply (args: FrontdoorBackendPoolLoadBalancingArgs) =
                args.SuccessfulSamplesRequired <- io successfulSamplesRequired
                args

            ()
            n, List.Cons(apply, args)

    let frontdoorBackendPoolLoadBalancing =
        FrontdoorBackendPoolLoadBalancingBuilder()

    type FrontdoorFrontendEndpointBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FrontdoorFrontendEndpointArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: FrontdoorFrontendEndpointArgs) =
                   args.CustomHttpsConfiguration <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("customHttpsProvisioningEnabled")>]
        member _.CustomHttpsProvisioningEnabled((n, args), customHttpsProvisioningEnabled) =
            let apply (args: FrontdoorFrontendEndpointArgs) =
                args.CustomHttpsProvisioningEnabled <- input customHttpsProvisioningEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.CustomHttpsProvisioningEnabled((n, args), customHttpsProvisioningEnabled) =
            let apply (args: FrontdoorFrontendEndpointArgs) =
                args.CustomHttpsProvisioningEnabled <- io customHttpsProvisioningEnabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("hostName")>]
        member _.HostName((n, args), hostName) =
            let apply (args: FrontdoorFrontendEndpointArgs) =
                args.HostName <- input hostName
                args

            ()
            n, List.Cons(apply, args)

        member _.HostName((n, args), hostName) =
            let apply (args: FrontdoorFrontendEndpointArgs) =
                args.HostName <- io hostName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: FrontdoorFrontendEndpointArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: FrontdoorFrontendEndpointArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: FrontdoorFrontendEndpointArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: FrontdoorFrontendEndpointArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sessionAffinityEnabled")>]
        member _.SessionAffinityEnabled((n, args), sessionAffinityEnabled) =
            let apply (args: FrontdoorFrontendEndpointArgs) =
                args.SessionAffinityEnabled <- input sessionAffinityEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.SessionAffinityEnabled((n, args), sessionAffinityEnabled) =
            let apply (args: FrontdoorFrontendEndpointArgs) =
                args.SessionAffinityEnabled <- io sessionAffinityEnabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sessionAffinityTtlSeconds")>]
        member _.SessionAffinityTtlSeconds((n, args), sessionAffinityTtlSeconds) =
            let apply (args: FrontdoorFrontendEndpointArgs) =
                args.SessionAffinityTtlSeconds <- input sessionAffinityTtlSeconds
                args

            ()
            n, List.Cons(apply, args)

        member _.SessionAffinityTtlSeconds((n, args), sessionAffinityTtlSeconds) =
            let apply (args: FrontdoorFrontendEndpointArgs) =
                args.SessionAffinityTtlSeconds <- io sessionAffinityTtlSeconds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("webApplicationFirewallPolicyLinkId")>]
        member _.WebApplicationFirewallPolicyLinkId((n, args), webApplicationFirewallPolicyLinkId) =
            let apply (args: FrontdoorFrontendEndpointArgs) =
                args.WebApplicationFirewallPolicyLinkId <- input webApplicationFirewallPolicyLinkId
                args

            ()
            n, List.Cons(apply, args)

        member _.WebApplicationFirewallPolicyLinkId((n, args), webApplicationFirewallPolicyLinkId) =
            let apply (args: FrontdoorFrontendEndpointArgs) =
                args.WebApplicationFirewallPolicyLinkId <- io webApplicationFirewallPolicyLinkId
                args

            ()
            n, List.Cons(apply, args)

    let frontdoorFrontendEndpoint = FrontdoorFrontendEndpointBuilder()

    type FrontdoorFrontendEndpointCustomHttpsConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FrontdoorFrontendEndpointCustomHttpsConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("azureKeyVaultCertificateSecretName")>]
        member _.AzureKeyVaultCertificateSecretName((n, args), azureKeyVaultCertificateSecretName) =
            let apply (args: FrontdoorFrontendEndpointCustomHttpsConfigurationArgs) =
                args.AzureKeyVaultCertificateSecretName <- input azureKeyVaultCertificateSecretName
                args

            ()
            n, List.Cons(apply, args)

        member _.AzureKeyVaultCertificateSecretName((n, args), azureKeyVaultCertificateSecretName) =
            let apply (args: FrontdoorFrontendEndpointCustomHttpsConfigurationArgs) =
                args.AzureKeyVaultCertificateSecretName <- io azureKeyVaultCertificateSecretName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("azureKeyVaultCertificateSecretVersion")>]
        member _.AzureKeyVaultCertificateSecretVersion((n, args), azureKeyVaultCertificateSecretVersion) =
            let apply (args: FrontdoorFrontendEndpointCustomHttpsConfigurationArgs) =
                args.AzureKeyVaultCertificateSecretVersion <- input azureKeyVaultCertificateSecretVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.AzureKeyVaultCertificateSecretVersion((n, args), azureKeyVaultCertificateSecretVersion) =
            let apply (args: FrontdoorFrontendEndpointCustomHttpsConfigurationArgs) =
                args.AzureKeyVaultCertificateSecretVersion <- io azureKeyVaultCertificateSecretVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("azureKeyVaultCertificateVaultId")>]
        member _.AzureKeyVaultCertificateVaultId((n, args), azureKeyVaultCertificateVaultId) =
            let apply (args: FrontdoorFrontendEndpointCustomHttpsConfigurationArgs) =
                args.AzureKeyVaultCertificateVaultId <- input azureKeyVaultCertificateVaultId
                args

            ()
            n, List.Cons(apply, args)

        member _.AzureKeyVaultCertificateVaultId((n, args), azureKeyVaultCertificateVaultId) =
            let apply (args: FrontdoorFrontendEndpointCustomHttpsConfigurationArgs) =
                args.AzureKeyVaultCertificateVaultId <- io azureKeyVaultCertificateVaultId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("certificateSource")>]
        member _.CertificateSource((n, args), certificateSource) =
            let apply (args: FrontdoorFrontendEndpointCustomHttpsConfigurationArgs) =
                args.CertificateSource <- input certificateSource
                args

            ()
            n, List.Cons(apply, args)

        member _.CertificateSource((n, args), certificateSource) =
            let apply (args: FrontdoorFrontendEndpointCustomHttpsConfigurationArgs) =
                args.CertificateSource <- io certificateSource
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("minimumTlsVersion")>]
        member _.MinimumTlsVersion((n, args), minimumTlsVersion) =
            let apply (args: FrontdoorFrontendEndpointCustomHttpsConfigurationArgs) =
                args.MinimumTlsVersion <- input minimumTlsVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.MinimumTlsVersion((n, args), minimumTlsVersion) =
            let apply (args: FrontdoorFrontendEndpointCustomHttpsConfigurationArgs) =
                args.MinimumTlsVersion <- io minimumTlsVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("provisioningState")>]
        member _.ProvisioningState((n, args), provisioningState) =
            let apply (args: FrontdoorFrontendEndpointCustomHttpsConfigurationArgs) =
                args.ProvisioningState <- input provisioningState
                args

            ()
            n, List.Cons(apply, args)

        member _.ProvisioningState((n, args), provisioningState) =
            let apply (args: FrontdoorFrontendEndpointCustomHttpsConfigurationArgs) =
                args.ProvisioningState <- io provisioningState
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("provisioningSubstate")>]
        member _.ProvisioningSubstate((n, args), provisioningSubstate) =
            let apply (args: FrontdoorFrontendEndpointCustomHttpsConfigurationArgs) =
                args.ProvisioningSubstate <- input provisioningSubstate
                args

            ()
            n, List.Cons(apply, args)

        member _.ProvisioningSubstate((n, args), provisioningSubstate) =
            let apply (args: FrontdoorFrontendEndpointCustomHttpsConfigurationArgs) =
                args.ProvisioningSubstate <- io provisioningSubstate
                args

            ()
            n, List.Cons(apply, args)

    let frontdoorFrontendEndpointCustomHttpsConfiguration =
        FrontdoorFrontendEndpointCustomHttpsConfigurationBuilder()

    type FrontdoorRoutingRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FrontdoorRoutingRuleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("acceptedProtocols")>]
        member _.AcceptedProtocols((n, args), acceptedProtocols) =
            let apply (args: FrontdoorRoutingRuleArgs) =
                args.AcceptedProtocols <- inputList acceptedProtocols
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: FrontdoorRoutingRuleArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: FrontdoorRoutingRuleArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: FrontdoorRoutingRuleArgs) =
                   args.ForwardingConfiguration <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("frontendEndpoints")>]
        member _.FrontendEndpoints((n, args), frontendEndpoints) =
            let apply (args: FrontdoorRoutingRuleArgs) =
                args.FrontendEndpoints <- inputList frontendEndpoints
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: FrontdoorRoutingRuleArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: FrontdoorRoutingRuleArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: FrontdoorRoutingRuleArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: FrontdoorRoutingRuleArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("patternsToMatches")>]
        member _.PatternsToMatches((n, args), patternsToMatches) =
            let apply (args: FrontdoorRoutingRuleArgs) =
                args.PatternsToMatches <- inputList patternsToMatches
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: FrontdoorRoutingRuleArgs) =
                   args.RedirectConfiguration <- input arg
                   args

               ()
               func) ]

    let frontdoorRoutingRule = FrontdoorRoutingRuleBuilder()

    type FrontdoorRoutingRuleForwardingConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FrontdoorRoutingRuleForwardingConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("backendPoolName")>]
        member _.BackendPoolName((n, args), backendPoolName) =
            let apply (args: FrontdoorRoutingRuleForwardingConfigurationArgs) =
                args.BackendPoolName <- input backendPoolName
                args

            ()
            n, List.Cons(apply, args)

        member _.BackendPoolName((n, args), backendPoolName) =
            let apply (args: FrontdoorRoutingRuleForwardingConfigurationArgs) =
                args.BackendPoolName <- io backendPoolName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("cacheEnabled")>]
        member _.CacheEnabled((n, args), cacheEnabled) =
            let apply (args: FrontdoorRoutingRuleForwardingConfigurationArgs) =
                args.CacheEnabled <- input cacheEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.CacheEnabled((n, args), cacheEnabled) =
            let apply (args: FrontdoorRoutingRuleForwardingConfigurationArgs) =
                args.CacheEnabled <- io cacheEnabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("cacheQueryParameterStripDirective")>]
        member _.CacheQueryParameterStripDirective((n, args), cacheQueryParameterStripDirective) =
            let apply (args: FrontdoorRoutingRuleForwardingConfigurationArgs) =
                args.CacheQueryParameterStripDirective <- input cacheQueryParameterStripDirective
                args

            ()
            n, List.Cons(apply, args)

        member _.CacheQueryParameterStripDirective((n, args), cacheQueryParameterStripDirective) =
            let apply (args: FrontdoorRoutingRuleForwardingConfigurationArgs) =
                args.CacheQueryParameterStripDirective <- io cacheQueryParameterStripDirective
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("cacheUseDynamicCompression")>]
        member _.CacheUseDynamicCompression((n, args), cacheUseDynamicCompression) =
            let apply (args: FrontdoorRoutingRuleForwardingConfigurationArgs) =
                args.CacheUseDynamicCompression <- input cacheUseDynamicCompression
                args

            ()
            n, List.Cons(apply, args)

        member _.CacheUseDynamicCompression((n, args), cacheUseDynamicCompression) =
            let apply (args: FrontdoorRoutingRuleForwardingConfigurationArgs) =
                args.CacheUseDynamicCompression <- io cacheUseDynamicCompression
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("customForwardingPath")>]
        member _.CustomForwardingPath((n, args), customForwardingPath) =
            let apply (args: FrontdoorRoutingRuleForwardingConfigurationArgs) =
                args.CustomForwardingPath <- input customForwardingPath
                args

            ()
            n, List.Cons(apply, args)

        member _.CustomForwardingPath((n, args), customForwardingPath) =
            let apply (args: FrontdoorRoutingRuleForwardingConfigurationArgs) =
                args.CustomForwardingPath <- io customForwardingPath
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("forwardingProtocol")>]
        member _.ForwardingProtocol((n, args), forwardingProtocol) =
            let apply (args: FrontdoorRoutingRuleForwardingConfigurationArgs) =
                args.ForwardingProtocol <- input forwardingProtocol
                args

            ()
            n, List.Cons(apply, args)

        member _.ForwardingProtocol((n, args), forwardingProtocol) =
            let apply (args: FrontdoorRoutingRuleForwardingConfigurationArgs) =
                args.ForwardingProtocol <- io forwardingProtocol
                args

            ()
            n, List.Cons(apply, args)

    let frontdoorRoutingRuleForwardingConfiguration =
        FrontdoorRoutingRuleForwardingConfigurationBuilder()

    type FrontdoorRoutingRuleRedirectConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FrontdoorRoutingRuleRedirectConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("customFragment")>]
        member _.CustomFragment((n, args), customFragment) =
            let apply (args: FrontdoorRoutingRuleRedirectConfigurationArgs) =
                args.CustomFragment <- input customFragment
                args

            ()
            n, List.Cons(apply, args)

        member _.CustomFragment((n, args), customFragment) =
            let apply (args: FrontdoorRoutingRuleRedirectConfigurationArgs) =
                args.CustomFragment <- io customFragment
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("customHost")>]
        member _.CustomHost((n, args), customHost) =
            let apply (args: FrontdoorRoutingRuleRedirectConfigurationArgs) =
                args.CustomHost <- input customHost
                args

            ()
            n, List.Cons(apply, args)

        member _.CustomHost((n, args), customHost) =
            let apply (args: FrontdoorRoutingRuleRedirectConfigurationArgs) =
                args.CustomHost <- io customHost
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("customPath")>]
        member _.CustomPath((n, args), customPath) =
            let apply (args: FrontdoorRoutingRuleRedirectConfigurationArgs) =
                args.CustomPath <- input customPath
                args

            ()
            n, List.Cons(apply, args)

        member _.CustomPath((n, args), customPath) =
            let apply (args: FrontdoorRoutingRuleRedirectConfigurationArgs) =
                args.CustomPath <- io customPath
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("customQueryString")>]
        member _.CustomQueryString((n, args), customQueryString) =
            let apply (args: FrontdoorRoutingRuleRedirectConfigurationArgs) =
                args.CustomQueryString <- input customQueryString
                args

            ()
            n, List.Cons(apply, args)

        member _.CustomQueryString((n, args), customQueryString) =
            let apply (args: FrontdoorRoutingRuleRedirectConfigurationArgs) =
                args.CustomQueryString <- io customQueryString
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("redirectProtocol")>]
        member _.RedirectProtocol((n, args), redirectProtocol) =
            let apply (args: FrontdoorRoutingRuleRedirectConfigurationArgs) =
                args.RedirectProtocol <- input redirectProtocol
                args

            ()
            n, List.Cons(apply, args)

        member _.RedirectProtocol((n, args), redirectProtocol) =
            let apply (args: FrontdoorRoutingRuleRedirectConfigurationArgs) =
                args.RedirectProtocol <- io redirectProtocol
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("redirectType")>]
        member _.RedirectType((n, args), redirectType) =
            let apply (args: FrontdoorRoutingRuleRedirectConfigurationArgs) =
                args.RedirectType <- input redirectType
                args

            ()
            n, List.Cons(apply, args)

        member _.RedirectType((n, args), redirectType) =
            let apply (args: FrontdoorRoutingRuleRedirectConfigurationArgs) =
                args.RedirectType <- io redirectType
                args

            ()
            n, List.Cons(apply, args)

    let frontdoorRoutingRuleRedirectConfiguration =
        FrontdoorRoutingRuleRedirectConfigurationBuilder()

    type FirewallPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            FirewallPolicy(name, (List.fold func (FirewallPolicyArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("customBlockResponseBody")>]
        member _.CustomBlockResponseBody((name, args), customBlockResponseBody) =
            let apply (args: FirewallPolicyArgs) =
                args.CustomBlockResponseBody <- input customBlockResponseBody
                args

            ()
            name, List.Cons(apply, args)

        member _.CustomBlockResponseBody((name, args), customBlockResponseBody) =
            let apply (args: FirewallPolicyArgs) =
                args.CustomBlockResponseBody <- io customBlockResponseBody
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("customBlockResponseStatusCode")>]
        member _.CustomBlockResponseStatusCode((name, args), customBlockResponseStatusCode) =
            let apply (args: FirewallPolicyArgs) =
                args.CustomBlockResponseStatusCode <- input customBlockResponseStatusCode
                args

            ()
            name, List.Cons(apply, args)

        member _.CustomBlockResponseStatusCode((name, args), customBlockResponseStatusCode) =
            let apply (args: FirewallPolicyArgs) =
                args.CustomBlockResponseStatusCode <- io customBlockResponseStatusCode
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("customRules")>]
        member _.CustomRules((name, args), customRules) =
            let apply (args: FirewallPolicyArgs) =
                args.CustomRules <- inputList customRules
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((name, args), enabled) =
            let apply (args: FirewallPolicyArgs) =
                args.Enabled <- input enabled
                args

            ()
            name, List.Cons(apply, args)

        member _.Enabled((name, args), enabled) =
            let apply (args: FirewallPolicyArgs) =
                args.Enabled <- io enabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("managedRules")>]
        member _.ManagedRules((name, args), managedRules) =
            let apply (args: FirewallPolicyArgs) =
                args.ManagedRules <- inputList managedRules
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("mode")>]
        member _.Mode((name, args), mode) =
            let apply (args: FirewallPolicyArgs) =
                args.Mode <- input mode
                args

            ()
            name, List.Cons(apply, args)

        member _.Mode((name, args), mode) =
            let apply (args: FirewallPolicyArgs) =
                args.Mode <- io mode
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: FirewallPolicyArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: FirewallPolicyArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("redirectUrl")>]
        member _.RedirectUrl((name, args), redirectUrl) =
            let apply (args: FirewallPolicyArgs) =
                args.RedirectUrl <- input redirectUrl
                args

            ()
            name, List.Cons(apply, args)

        member _.RedirectUrl((name, args), redirectUrl) =
            let apply (args: FirewallPolicyArgs) =
                args.RedirectUrl <- io redirectUrl
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FirewallPolicyArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FirewallPolicyArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: FirewallPolicyArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let firewallPolicy = FirewallPolicyBuilder()

    type FrontdoorBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Frontdoor(name, (List.fold func (FrontdoorArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("backendPoolHealthProbes")>]
        member _.BackendPoolHealthProbes((name, args), backendPoolHealthProbes) =
            let apply (args: FrontdoorArgs) =
                args.BackendPoolHealthProbes <- inputList backendPoolHealthProbes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("backendPoolLoadBalancings")>]
        member _.BackendPoolLoadBalancings((name, args), backendPoolLoadBalancings) =
            let apply (args: FrontdoorArgs) =
                args.BackendPoolLoadBalancings <- inputList backendPoolLoadBalancings
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("backendPools")>]
        member _.BackendPools((name, args), backendPools) =
            let apply (args: FrontdoorArgs) =
                args.BackendPools <- inputList backendPools
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("backendPoolsSendReceiveTimeoutSeconds")>]
        member _.BackendPoolsSendReceiveTimeoutSeconds((name, args), backendPoolsSendReceiveTimeoutSeconds) =
            let apply (args: FrontdoorArgs) =
                args.BackendPoolsSendReceiveTimeoutSeconds <- input backendPoolsSendReceiveTimeoutSeconds
                args

            ()
            name, List.Cons(apply, args)

        member _.BackendPoolsSendReceiveTimeoutSeconds((name, args), backendPoolsSendReceiveTimeoutSeconds) =
            let apply (args: FrontdoorArgs) =
                args.BackendPoolsSendReceiveTimeoutSeconds <- io backendPoolsSendReceiveTimeoutSeconds
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enforceBackendPoolsCertificateNameCheck")>]
        member _.EnforceBackendPoolsCertificateNameCheck((name, args), enforceBackendPoolsCertificateNameCheck) =
            let apply (args: FrontdoorArgs) =
                args.EnforceBackendPoolsCertificateNameCheck <- input enforceBackendPoolsCertificateNameCheck
                args

            ()
            name, List.Cons(apply, args)

        member _.EnforceBackendPoolsCertificateNameCheck((name, args), enforceBackendPoolsCertificateNameCheck) =
            let apply (args: FrontdoorArgs) =
                args.EnforceBackendPoolsCertificateNameCheck <- io enforceBackendPoolsCertificateNameCheck
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("friendlyName")>]
        member _.FriendlyName((name, args), friendlyName) =
            let apply (args: FrontdoorArgs) =
                args.FriendlyName <- input friendlyName
                args

            ()
            name, List.Cons(apply, args)

        member _.FriendlyName((name, args), friendlyName) =
            let apply (args: FrontdoorArgs) =
                args.FriendlyName <- io friendlyName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("frontendEndpoints")>]
        member _.FrontendEndpoints((name, args), frontendEndpoints) =
            let apply (args: FrontdoorArgs) =
                args.FrontendEndpoints <- inputList frontendEndpoints
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("loadBalancerEnabled")>]
        member _.LoadBalancerEnabled((name, args), loadBalancerEnabled) =
            let apply (args: FrontdoorArgs) =
                args.LoadBalancerEnabled <- input loadBalancerEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.LoadBalancerEnabled((name, args), loadBalancerEnabled) =
            let apply (args: FrontdoorArgs) =
                args.LoadBalancerEnabled <- io loadBalancerEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: FrontdoorArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: FrontdoorArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: FrontdoorArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: FrontdoorArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FrontdoorArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FrontdoorArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("routingRules")>]
        member _.RoutingRules((name, args), routingRules) =
            let apply (args: FrontdoorArgs) =
                args.RoutingRules <- inputList routingRules
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: FrontdoorArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let frontdoor = FrontdoorBuilder()

module HDInsight =
    open Pulumi.Azure.HDInsight
    open Pulumi.Azure.HDInsight.Inputs

    type HBaseClusterComponentVersionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (HBaseClusterComponentVersionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("hbase")>]
        member _.Hbase((n, args), hbase) =
            let apply (args: HBaseClusterComponentVersionArgs) =
                args.Hbase <- input hbase
                args

            ()
            n, List.Cons(apply, args)

        member _.Hbase((n, args), hbase) =
            let apply (args: HBaseClusterComponentVersionArgs) =
                args.Hbase <- io hbase
                args

            ()
            n, List.Cons(apply, args)

    let hBaseClusterComponentVersion = HBaseClusterComponentVersionBuilder()

    type HBaseClusterGatewayBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (HBaseClusterGatewayArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: HBaseClusterGatewayArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: HBaseClusterGatewayArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: HBaseClusterGatewayArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: HBaseClusterGatewayArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: HBaseClusterGatewayArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: HBaseClusterGatewayArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

    let hBaseClusterGateway = HBaseClusterGatewayBuilder()

    type HBaseClusterRolesBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (HBaseClusterRolesArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: HBaseClusterRolesArgs) =
                   args.HeadNode <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: HBaseClusterRolesArgs) =
                   args.WorkerNode <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: HBaseClusterRolesArgs) =
                   args.ZookeeperNode <- input arg
                   args

               ()
               func) ]

    let hBaseClusterRoles = HBaseClusterRolesBuilder()

    type HBaseClusterRolesHeadNodeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (HBaseClusterRolesHeadNodeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: HBaseClusterRolesHeadNodeArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: HBaseClusterRolesHeadNodeArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sshKeys")>]
        member _.SshKeys((n, args), sshKeys) =
            let apply (args: HBaseClusterRolesHeadNodeArgs) =
                args.SshKeys <- inputList sshKeys
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: HBaseClusterRolesHeadNodeArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: HBaseClusterRolesHeadNodeArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: HBaseClusterRolesHeadNodeArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: HBaseClusterRolesHeadNodeArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkId")>]
        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: HBaseClusterRolesHeadNodeArgs) =
                args.VirtualNetworkId <- input virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: HBaseClusterRolesHeadNodeArgs) =
                args.VirtualNetworkId <- io virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vmSize")>]
        member _.VmSize((n, args), vmSize) =
            let apply (args: HBaseClusterRolesHeadNodeArgs) =
                args.VmSize <- input vmSize
                args

            ()
            n, List.Cons(apply, args)

        member _.VmSize((n, args), vmSize) =
            let apply (args: HBaseClusterRolesHeadNodeArgs) =
                args.VmSize <- io vmSize
                args

            ()
            n, List.Cons(apply, args)

    let hBaseClusterRolesHeadNode = HBaseClusterRolesHeadNodeBuilder()

    type HBaseClusterRolesWorkerNodeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (HBaseClusterRolesWorkerNodeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("minInstanceCount")>]
        member _.MinInstanceCount((n, args), minInstanceCount) =
            let apply (args: HBaseClusterRolesWorkerNodeArgs) =
                args.MinInstanceCount <- input minInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        member _.MinInstanceCount((n, args), minInstanceCount) =
            let apply (args: HBaseClusterRolesWorkerNodeArgs) =
                args.MinInstanceCount <- io minInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: HBaseClusterRolesWorkerNodeArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: HBaseClusterRolesWorkerNodeArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sshKeys")>]
        member _.SshKeys((n, args), sshKeys) =
            let apply (args: HBaseClusterRolesWorkerNodeArgs) =
                args.SshKeys <- inputList sshKeys
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: HBaseClusterRolesWorkerNodeArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: HBaseClusterRolesWorkerNodeArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("targetInstanceCount")>]
        member _.TargetInstanceCount((n, args), targetInstanceCount) =
            let apply (args: HBaseClusterRolesWorkerNodeArgs) =
                args.TargetInstanceCount <- input targetInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        member _.TargetInstanceCount((n, args), targetInstanceCount) =
            let apply (args: HBaseClusterRolesWorkerNodeArgs) =
                args.TargetInstanceCount <- io targetInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: HBaseClusterRolesWorkerNodeArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: HBaseClusterRolesWorkerNodeArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkId")>]
        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: HBaseClusterRolesWorkerNodeArgs) =
                args.VirtualNetworkId <- input virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: HBaseClusterRolesWorkerNodeArgs) =
                args.VirtualNetworkId <- io virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vmSize")>]
        member _.VmSize((n, args), vmSize) =
            let apply (args: HBaseClusterRolesWorkerNodeArgs) =
                args.VmSize <- input vmSize
                args

            ()
            n, List.Cons(apply, args)

        member _.VmSize((n, args), vmSize) =
            let apply (args: HBaseClusterRolesWorkerNodeArgs) =
                args.VmSize <- io vmSize
                args

            ()
            n, List.Cons(apply, args)

    let hBaseClusterRolesWorkerNode = HBaseClusterRolesWorkerNodeBuilder()

    type HBaseClusterRolesZookeeperNodeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (HBaseClusterRolesZookeeperNodeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: HBaseClusterRolesZookeeperNodeArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: HBaseClusterRolesZookeeperNodeArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sshKeys")>]
        member _.SshKeys((n, args), sshKeys) =
            let apply (args: HBaseClusterRolesZookeeperNodeArgs) =
                args.SshKeys <- inputList sshKeys
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: HBaseClusterRolesZookeeperNodeArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: HBaseClusterRolesZookeeperNodeArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: HBaseClusterRolesZookeeperNodeArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: HBaseClusterRolesZookeeperNodeArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkId")>]
        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: HBaseClusterRolesZookeeperNodeArgs) =
                args.VirtualNetworkId <- input virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: HBaseClusterRolesZookeeperNodeArgs) =
                args.VirtualNetworkId <- io virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vmSize")>]
        member _.VmSize((n, args), vmSize) =
            let apply (args: HBaseClusterRolesZookeeperNodeArgs) =
                args.VmSize <- input vmSize
                args

            ()
            n, List.Cons(apply, args)

        member _.VmSize((n, args), vmSize) =
            let apply (args: HBaseClusterRolesZookeeperNodeArgs) =
                args.VmSize <- io vmSize
                args

            ()
            n, List.Cons(apply, args)

    let hBaseClusterRolesZookeeperNode = HBaseClusterRolesZookeeperNodeBuilder()

    type HBaseClusterStorageAccountBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (HBaseClusterStorageAccountArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("isDefault")>]
        member _.IsDefault((n, args), isDefault) =
            let apply (args: HBaseClusterStorageAccountArgs) =
                args.IsDefault <- input isDefault
                args

            ()
            n, List.Cons(apply, args)

        member _.IsDefault((n, args), isDefault) =
            let apply (args: HBaseClusterStorageAccountArgs) =
                args.IsDefault <- io isDefault
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageAccountKey")>]
        member _.StorageAccountKey((n, args), storageAccountKey) =
            let apply (args: HBaseClusterStorageAccountArgs) =
                args.StorageAccountKey <- input storageAccountKey
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountKey((n, args), storageAccountKey) =
            let apply (args: HBaseClusterStorageAccountArgs) =
                args.StorageAccountKey <- io storageAccountKey
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageContainerId")>]
        member _.StorageContainerId((n, args), storageContainerId) =
            let apply (args: HBaseClusterStorageAccountArgs) =
                args.StorageContainerId <- input storageContainerId
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageContainerId((n, args), storageContainerId) =
            let apply (args: HBaseClusterStorageAccountArgs) =
                args.StorageContainerId <- io storageContainerId
                args

            ()
            n, List.Cons(apply, args)

    let hBaseClusterStorageAccount = HBaseClusterStorageAccountBuilder()

    type HBaseClusterStorageAccountGen2Builder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (HBaseClusterStorageAccountGen2Args()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("filesystemId")>]
        member _.FilesystemId((n, args), filesystemId) =
            let apply (args: HBaseClusterStorageAccountGen2Args) =
                args.FilesystemId <- input filesystemId
                args

            ()
            n, List.Cons(apply, args)

        member _.FilesystemId((n, args), filesystemId) =
            let apply (args: HBaseClusterStorageAccountGen2Args) =
                args.FilesystemId <- io filesystemId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("isDefault")>]
        member _.IsDefault((n, args), isDefault) =
            let apply (args: HBaseClusterStorageAccountGen2Args) =
                args.IsDefault <- input isDefault
                args

            ()
            n, List.Cons(apply, args)

        member _.IsDefault((n, args), isDefault) =
            let apply (args: HBaseClusterStorageAccountGen2Args) =
                args.IsDefault <- io isDefault
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("managedIdentityResourceId")>]
        member _.ManagedIdentityResourceId((n, args), managedIdentityResourceId) =
            let apply (args: HBaseClusterStorageAccountGen2Args) =
                args.ManagedIdentityResourceId <- input managedIdentityResourceId
                args

            ()
            n, List.Cons(apply, args)

        member _.ManagedIdentityResourceId((n, args), managedIdentityResourceId) =
            let apply (args: HBaseClusterStorageAccountGen2Args) =
                args.ManagedIdentityResourceId <- io managedIdentityResourceId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageResourceId")>]
        member _.StorageResourceId((n, args), storageResourceId) =
            let apply (args: HBaseClusterStorageAccountGen2Args) =
                args.StorageResourceId <- input storageResourceId
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageResourceId((n, args), storageResourceId) =
            let apply (args: HBaseClusterStorageAccountGen2Args) =
                args.StorageResourceId <- io storageResourceId
                args

            ()
            n, List.Cons(apply, args)

    let hBaseClusterStorageAccountGen2 = HBaseClusterStorageAccountGen2Builder()

    type HadoopClusterComponentVersionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (HadoopClusterComponentVersionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("hadoop")>]
        member _.Hadoop((n, args), hadoop) =
            let apply (args: HadoopClusterComponentVersionArgs) =
                args.Hadoop <- input hadoop
                args

            ()
            n, List.Cons(apply, args)

        member _.Hadoop((n, args), hadoop) =
            let apply (args: HadoopClusterComponentVersionArgs) =
                args.Hadoop <- io hadoop
                args

            ()
            n, List.Cons(apply, args)

    let hadoopClusterComponentVersion = HadoopClusterComponentVersionBuilder()

    type HadoopClusterGatewayBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (HadoopClusterGatewayArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: HadoopClusterGatewayArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: HadoopClusterGatewayArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: HadoopClusterGatewayArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: HadoopClusterGatewayArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: HadoopClusterGatewayArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: HadoopClusterGatewayArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

    let hadoopClusterGateway = HadoopClusterGatewayBuilder()

    type HadoopClusterMetastoresBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (HadoopClusterMetastoresArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: HadoopClusterMetastoresArgs) =
                   args.Ambari <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: HadoopClusterMetastoresArgs) =
                   args.Hive <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: HadoopClusterMetastoresArgs) =
                   args.Oozie <- input arg
                   args

               ()
               func) ]

    let hadoopClusterMetastores = HadoopClusterMetastoresBuilder()

    type HadoopClusterMetastoresAmbariBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (HadoopClusterMetastoresAmbariArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("databaseName")>]
        member _.DatabaseName((n, args), databaseName) =
            let apply (args: HadoopClusterMetastoresAmbariArgs) =
                args.DatabaseName <- input databaseName
                args

            ()
            n, List.Cons(apply, args)

        member _.DatabaseName((n, args), databaseName) =
            let apply (args: HadoopClusterMetastoresAmbariArgs) =
                args.DatabaseName <- io databaseName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: HadoopClusterMetastoresAmbariArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: HadoopClusterMetastoresAmbariArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("server")>]
        member _.Server((n, args), server) =
            let apply (args: HadoopClusterMetastoresAmbariArgs) =
                args.Server <- input server
                args

            ()
            n, List.Cons(apply, args)

        member _.Server((n, args), server) =
            let apply (args: HadoopClusterMetastoresAmbariArgs) =
                args.Server <- io server
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: HadoopClusterMetastoresAmbariArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: HadoopClusterMetastoresAmbariArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

    let hadoopClusterMetastoresAmbari = HadoopClusterMetastoresAmbariBuilder()

    type HadoopClusterMetastoresHiveBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (HadoopClusterMetastoresHiveArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("databaseName")>]
        member _.DatabaseName((n, args), databaseName) =
            let apply (args: HadoopClusterMetastoresHiveArgs) =
                args.DatabaseName <- input databaseName
                args

            ()
            n, List.Cons(apply, args)

        member _.DatabaseName((n, args), databaseName) =
            let apply (args: HadoopClusterMetastoresHiveArgs) =
                args.DatabaseName <- io databaseName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: HadoopClusterMetastoresHiveArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: HadoopClusterMetastoresHiveArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("server")>]
        member _.Server((n, args), server) =
            let apply (args: HadoopClusterMetastoresHiveArgs) =
                args.Server <- input server
                args

            ()
            n, List.Cons(apply, args)

        member _.Server((n, args), server) =
            let apply (args: HadoopClusterMetastoresHiveArgs) =
                args.Server <- io server
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: HadoopClusterMetastoresHiveArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: HadoopClusterMetastoresHiveArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

    let hadoopClusterMetastoresHive = HadoopClusterMetastoresHiveBuilder()

    type HadoopClusterMetastoresOozieBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (HadoopClusterMetastoresOozieArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("databaseName")>]
        member _.DatabaseName((n, args), databaseName) =
            let apply (args: HadoopClusterMetastoresOozieArgs) =
                args.DatabaseName <- input databaseName
                args

            ()
            n, List.Cons(apply, args)

        member _.DatabaseName((n, args), databaseName) =
            let apply (args: HadoopClusterMetastoresOozieArgs) =
                args.DatabaseName <- io databaseName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: HadoopClusterMetastoresOozieArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: HadoopClusterMetastoresOozieArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("server")>]
        member _.Server((n, args), server) =
            let apply (args: HadoopClusterMetastoresOozieArgs) =
                args.Server <- input server
                args

            ()
            n, List.Cons(apply, args)

        member _.Server((n, args), server) =
            let apply (args: HadoopClusterMetastoresOozieArgs) =
                args.Server <- io server
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: HadoopClusterMetastoresOozieArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: HadoopClusterMetastoresOozieArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

    let hadoopClusterMetastoresOozie = HadoopClusterMetastoresOozieBuilder()

    type HadoopClusterRolesBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (HadoopClusterRolesArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: HadoopClusterRolesArgs) =
                   args.EdgeNode <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: HadoopClusterRolesArgs) =
                   args.HeadNode <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: HadoopClusterRolesArgs) =
                   args.WorkerNode <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: HadoopClusterRolesArgs) =
                   args.ZookeeperNode <- input arg
                   args

               ()
               func) ]

    let hadoopClusterRoles = HadoopClusterRolesBuilder()

    type HadoopClusterRolesEdgeNodeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (HadoopClusterRolesEdgeNodeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("installScriptActions")>]
        member _.InstallScriptActions((n, args), installScriptActions) =
            let apply (args: HadoopClusterRolesEdgeNodeArgs) =
                args.InstallScriptActions <- inputList installScriptActions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("targetInstanceCount")>]
        member _.TargetInstanceCount((n, args), targetInstanceCount) =
            let apply (args: HadoopClusterRolesEdgeNodeArgs) =
                args.TargetInstanceCount <- input targetInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        member _.TargetInstanceCount((n, args), targetInstanceCount) =
            let apply (args: HadoopClusterRolesEdgeNodeArgs) =
                args.TargetInstanceCount <- io targetInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vmSize")>]
        member _.VmSize((n, args), vmSize) =
            let apply (args: HadoopClusterRolesEdgeNodeArgs) =
                args.VmSize <- input vmSize
                args

            ()
            n, List.Cons(apply, args)

        member _.VmSize((n, args), vmSize) =
            let apply (args: HadoopClusterRolesEdgeNodeArgs) =
                args.VmSize <- io vmSize
                args

            ()
            n, List.Cons(apply, args)

    let hadoopClusterRolesEdgeNode = HadoopClusterRolesEdgeNodeBuilder()

    type HadoopClusterRolesEdgeNodeInstallScriptActionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (HadoopClusterRolesEdgeNodeInstallScriptActionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: HadoopClusterRolesEdgeNodeInstallScriptActionArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: HadoopClusterRolesEdgeNodeInstallScriptActionArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("uri")>]
        member _.Uri((n, args), uri) =
            let apply (args: HadoopClusterRolesEdgeNodeInstallScriptActionArgs) =
                args.Uri <- input uri
                args

            ()
            n, List.Cons(apply, args)

        member _.Uri((n, args), uri) =
            let apply (args: HadoopClusterRolesEdgeNodeInstallScriptActionArgs) =
                args.Uri <- io uri
                args

            ()
            n, List.Cons(apply, args)

    let hadoopClusterRolesEdgeNodeInstallScriptAction =
        HadoopClusterRolesEdgeNodeInstallScriptActionBuilder()

    type HadoopClusterRolesHeadNodeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (HadoopClusterRolesHeadNodeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: HadoopClusterRolesHeadNodeArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: HadoopClusterRolesHeadNodeArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sshKeys")>]
        member _.SshKeys((n, args), sshKeys) =
            let apply (args: HadoopClusterRolesHeadNodeArgs) =
                args.SshKeys <- inputList sshKeys
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: HadoopClusterRolesHeadNodeArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: HadoopClusterRolesHeadNodeArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: HadoopClusterRolesHeadNodeArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: HadoopClusterRolesHeadNodeArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkId")>]
        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: HadoopClusterRolesHeadNodeArgs) =
                args.VirtualNetworkId <- input virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: HadoopClusterRolesHeadNodeArgs) =
                args.VirtualNetworkId <- io virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vmSize")>]
        member _.VmSize((n, args), vmSize) =
            let apply (args: HadoopClusterRolesHeadNodeArgs) =
                args.VmSize <- input vmSize
                args

            ()
            n, List.Cons(apply, args)

        member _.VmSize((n, args), vmSize) =
            let apply (args: HadoopClusterRolesHeadNodeArgs) =
                args.VmSize <- io vmSize
                args

            ()
            n, List.Cons(apply, args)

    let hadoopClusterRolesHeadNode = HadoopClusterRolesHeadNodeBuilder()

    type HadoopClusterRolesWorkerNodeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (HadoopClusterRolesWorkerNodeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("minInstanceCount")>]
        member _.MinInstanceCount((n, args), minInstanceCount) =
            let apply (args: HadoopClusterRolesWorkerNodeArgs) =
                args.MinInstanceCount <- input minInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        member _.MinInstanceCount((n, args), minInstanceCount) =
            let apply (args: HadoopClusterRolesWorkerNodeArgs) =
                args.MinInstanceCount <- io minInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: HadoopClusterRolesWorkerNodeArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: HadoopClusterRolesWorkerNodeArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sshKeys")>]
        member _.SshKeys((n, args), sshKeys) =
            let apply (args: HadoopClusterRolesWorkerNodeArgs) =
                args.SshKeys <- inputList sshKeys
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: HadoopClusterRolesWorkerNodeArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: HadoopClusterRolesWorkerNodeArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("targetInstanceCount")>]
        member _.TargetInstanceCount((n, args), targetInstanceCount) =
            let apply (args: HadoopClusterRolesWorkerNodeArgs) =
                args.TargetInstanceCount <- input targetInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        member _.TargetInstanceCount((n, args), targetInstanceCount) =
            let apply (args: HadoopClusterRolesWorkerNodeArgs) =
                args.TargetInstanceCount <- io targetInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: HadoopClusterRolesWorkerNodeArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: HadoopClusterRolesWorkerNodeArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkId")>]
        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: HadoopClusterRolesWorkerNodeArgs) =
                args.VirtualNetworkId <- input virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: HadoopClusterRolesWorkerNodeArgs) =
                args.VirtualNetworkId <- io virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vmSize")>]
        member _.VmSize((n, args), vmSize) =
            let apply (args: HadoopClusterRolesWorkerNodeArgs) =
                args.VmSize <- input vmSize
                args

            ()
            n, List.Cons(apply, args)

        member _.VmSize((n, args), vmSize) =
            let apply (args: HadoopClusterRolesWorkerNodeArgs) =
                args.VmSize <- io vmSize
                args

            ()
            n, List.Cons(apply, args)

    let hadoopClusterRolesWorkerNode = HadoopClusterRolesWorkerNodeBuilder()

    type HadoopClusterRolesZookeeperNodeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (HadoopClusterRolesZookeeperNodeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: HadoopClusterRolesZookeeperNodeArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: HadoopClusterRolesZookeeperNodeArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sshKeys")>]
        member _.SshKeys((n, args), sshKeys) =
            let apply (args: HadoopClusterRolesZookeeperNodeArgs) =
                args.SshKeys <- inputList sshKeys
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: HadoopClusterRolesZookeeperNodeArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: HadoopClusterRolesZookeeperNodeArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: HadoopClusterRolesZookeeperNodeArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: HadoopClusterRolesZookeeperNodeArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkId")>]
        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: HadoopClusterRolesZookeeperNodeArgs) =
                args.VirtualNetworkId <- input virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: HadoopClusterRolesZookeeperNodeArgs) =
                args.VirtualNetworkId <- io virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vmSize")>]
        member _.VmSize((n, args), vmSize) =
            let apply (args: HadoopClusterRolesZookeeperNodeArgs) =
                args.VmSize <- input vmSize
                args

            ()
            n, List.Cons(apply, args)

        member _.VmSize((n, args), vmSize) =
            let apply (args: HadoopClusterRolesZookeeperNodeArgs) =
                args.VmSize <- io vmSize
                args

            ()
            n, List.Cons(apply, args)

    let hadoopClusterRolesZookeeperNode = HadoopClusterRolesZookeeperNodeBuilder()

    type HadoopClusterStorageAccountBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (HadoopClusterStorageAccountArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("isDefault")>]
        member _.IsDefault((n, args), isDefault) =
            let apply (args: HadoopClusterStorageAccountArgs) =
                args.IsDefault <- input isDefault
                args

            ()
            n, List.Cons(apply, args)

        member _.IsDefault((n, args), isDefault) =
            let apply (args: HadoopClusterStorageAccountArgs) =
                args.IsDefault <- io isDefault
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageAccountKey")>]
        member _.StorageAccountKey((n, args), storageAccountKey) =
            let apply (args: HadoopClusterStorageAccountArgs) =
                args.StorageAccountKey <- input storageAccountKey
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountKey((n, args), storageAccountKey) =
            let apply (args: HadoopClusterStorageAccountArgs) =
                args.StorageAccountKey <- io storageAccountKey
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageContainerId")>]
        member _.StorageContainerId((n, args), storageContainerId) =
            let apply (args: HadoopClusterStorageAccountArgs) =
                args.StorageContainerId <- input storageContainerId
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageContainerId((n, args), storageContainerId) =
            let apply (args: HadoopClusterStorageAccountArgs) =
                args.StorageContainerId <- io storageContainerId
                args

            ()
            n, List.Cons(apply, args)

    let hadoopClusterStorageAccount = HadoopClusterStorageAccountBuilder()

    type HadoopClusterStorageAccountGen2Builder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (HadoopClusterStorageAccountGen2Args()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("filesystemId")>]
        member _.FilesystemId((n, args), filesystemId) =
            let apply (args: HadoopClusterStorageAccountGen2Args) =
                args.FilesystemId <- input filesystemId
                args

            ()
            n, List.Cons(apply, args)

        member _.FilesystemId((n, args), filesystemId) =
            let apply (args: HadoopClusterStorageAccountGen2Args) =
                args.FilesystemId <- io filesystemId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("isDefault")>]
        member _.IsDefault((n, args), isDefault) =
            let apply (args: HadoopClusterStorageAccountGen2Args) =
                args.IsDefault <- input isDefault
                args

            ()
            n, List.Cons(apply, args)

        member _.IsDefault((n, args), isDefault) =
            let apply (args: HadoopClusterStorageAccountGen2Args) =
                args.IsDefault <- io isDefault
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("managedIdentityResourceId")>]
        member _.ManagedIdentityResourceId((n, args), managedIdentityResourceId) =
            let apply (args: HadoopClusterStorageAccountGen2Args) =
                args.ManagedIdentityResourceId <- input managedIdentityResourceId
                args

            ()
            n, List.Cons(apply, args)

        member _.ManagedIdentityResourceId((n, args), managedIdentityResourceId) =
            let apply (args: HadoopClusterStorageAccountGen2Args) =
                args.ManagedIdentityResourceId <- io managedIdentityResourceId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageResourceId")>]
        member _.StorageResourceId((n, args), storageResourceId) =
            let apply (args: HadoopClusterStorageAccountGen2Args) =
                args.StorageResourceId <- input storageResourceId
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageResourceId((n, args), storageResourceId) =
            let apply (args: HadoopClusterStorageAccountGen2Args) =
                args.StorageResourceId <- io storageResourceId
                args

            ()
            n, List.Cons(apply, args)

    let hadoopClusterStorageAccountGen2 = HadoopClusterStorageAccountGen2Builder()

    type InteractiveQueryClusterComponentVersionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (InteractiveQueryClusterComponentVersionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("interactiveHive")>]
        member _.InteractiveHive((n, args), interactiveHive) =
            let apply (args: InteractiveQueryClusterComponentVersionArgs) =
                args.InteractiveHive <- input interactiveHive
                args

            ()
            n, List.Cons(apply, args)

        member _.InteractiveHive((n, args), interactiveHive) =
            let apply (args: InteractiveQueryClusterComponentVersionArgs) =
                args.InteractiveHive <- io interactiveHive
                args

            ()
            n, List.Cons(apply, args)

    let interactiveQueryClusterComponentVersion =
        InteractiveQueryClusterComponentVersionBuilder()

    type InteractiveQueryClusterGatewayBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (InteractiveQueryClusterGatewayArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: InteractiveQueryClusterGatewayArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: InteractiveQueryClusterGatewayArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: InteractiveQueryClusterGatewayArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: InteractiveQueryClusterGatewayArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: InteractiveQueryClusterGatewayArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: InteractiveQueryClusterGatewayArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

    let interactiveQueryClusterGateway = InteractiveQueryClusterGatewayBuilder()

    type InteractiveQueryClusterRolesBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (InteractiveQueryClusterRolesArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: InteractiveQueryClusterRolesArgs) =
                   args.HeadNode <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: InteractiveQueryClusterRolesArgs) =
                   args.WorkerNode <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: InteractiveQueryClusterRolesArgs) =
                   args.ZookeeperNode <- input arg
                   args

               ()
               func) ]

    let interactiveQueryClusterRoles = InteractiveQueryClusterRolesBuilder()

    type InteractiveQueryClusterRolesHeadNodeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (InteractiveQueryClusterRolesHeadNodeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: InteractiveQueryClusterRolesHeadNodeArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: InteractiveQueryClusterRolesHeadNodeArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sshKeys")>]
        member _.SshKeys((n, args), sshKeys) =
            let apply (args: InteractiveQueryClusterRolesHeadNodeArgs) =
                args.SshKeys <- inputList sshKeys
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: InteractiveQueryClusterRolesHeadNodeArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: InteractiveQueryClusterRolesHeadNodeArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: InteractiveQueryClusterRolesHeadNodeArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: InteractiveQueryClusterRolesHeadNodeArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkId")>]
        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: InteractiveQueryClusterRolesHeadNodeArgs) =
                args.VirtualNetworkId <- input virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: InteractiveQueryClusterRolesHeadNodeArgs) =
                args.VirtualNetworkId <- io virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vmSize")>]
        member _.VmSize((n, args), vmSize) =
            let apply (args: InteractiveQueryClusterRolesHeadNodeArgs) =
                args.VmSize <- input vmSize
                args

            ()
            n, List.Cons(apply, args)

        member _.VmSize((n, args), vmSize) =
            let apply (args: InteractiveQueryClusterRolesHeadNodeArgs) =
                args.VmSize <- io vmSize
                args

            ()
            n, List.Cons(apply, args)

    let interactiveQueryClusterRolesHeadNode =
        InteractiveQueryClusterRolesHeadNodeBuilder()

    type InteractiveQueryClusterRolesWorkerNodeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (InteractiveQueryClusterRolesWorkerNodeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("minInstanceCount")>]
        member _.MinInstanceCount((n, args), minInstanceCount) =
            let apply (args: InteractiveQueryClusterRolesWorkerNodeArgs) =
                args.MinInstanceCount <- input minInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        member _.MinInstanceCount((n, args), minInstanceCount) =
            let apply (args: InteractiveQueryClusterRolesWorkerNodeArgs) =
                args.MinInstanceCount <- io minInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: InteractiveQueryClusterRolesWorkerNodeArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: InteractiveQueryClusterRolesWorkerNodeArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sshKeys")>]
        member _.SshKeys((n, args), sshKeys) =
            let apply (args: InteractiveQueryClusterRolesWorkerNodeArgs) =
                args.SshKeys <- inputList sshKeys
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: InteractiveQueryClusterRolesWorkerNodeArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: InteractiveQueryClusterRolesWorkerNodeArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("targetInstanceCount")>]
        member _.TargetInstanceCount((n, args), targetInstanceCount) =
            let apply (args: InteractiveQueryClusterRolesWorkerNodeArgs) =
                args.TargetInstanceCount <- input targetInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        member _.TargetInstanceCount((n, args), targetInstanceCount) =
            let apply (args: InteractiveQueryClusterRolesWorkerNodeArgs) =
                args.TargetInstanceCount <- io targetInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: InteractiveQueryClusterRolesWorkerNodeArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: InteractiveQueryClusterRolesWorkerNodeArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkId")>]
        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: InteractiveQueryClusterRolesWorkerNodeArgs) =
                args.VirtualNetworkId <- input virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: InteractiveQueryClusterRolesWorkerNodeArgs) =
                args.VirtualNetworkId <- io virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vmSize")>]
        member _.VmSize((n, args), vmSize) =
            let apply (args: InteractiveQueryClusterRolesWorkerNodeArgs) =
                args.VmSize <- input vmSize
                args

            ()
            n, List.Cons(apply, args)

        member _.VmSize((n, args), vmSize) =
            let apply (args: InteractiveQueryClusterRolesWorkerNodeArgs) =
                args.VmSize <- io vmSize
                args

            ()
            n, List.Cons(apply, args)

    let interactiveQueryClusterRolesWorkerNode =
        InteractiveQueryClusterRolesWorkerNodeBuilder()

    type InteractiveQueryClusterRolesZookeeperNodeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (InteractiveQueryClusterRolesZookeeperNodeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: InteractiveQueryClusterRolesZookeeperNodeArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: InteractiveQueryClusterRolesZookeeperNodeArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sshKeys")>]
        member _.SshKeys((n, args), sshKeys) =
            let apply (args: InteractiveQueryClusterRolesZookeeperNodeArgs) =
                args.SshKeys <- inputList sshKeys
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: InteractiveQueryClusterRolesZookeeperNodeArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: InteractiveQueryClusterRolesZookeeperNodeArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: InteractiveQueryClusterRolesZookeeperNodeArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: InteractiveQueryClusterRolesZookeeperNodeArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkId")>]
        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: InteractiveQueryClusterRolesZookeeperNodeArgs) =
                args.VirtualNetworkId <- input virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: InteractiveQueryClusterRolesZookeeperNodeArgs) =
                args.VirtualNetworkId <- io virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vmSize")>]
        member _.VmSize((n, args), vmSize) =
            let apply (args: InteractiveQueryClusterRolesZookeeperNodeArgs) =
                args.VmSize <- input vmSize
                args

            ()
            n, List.Cons(apply, args)

        member _.VmSize((n, args), vmSize) =
            let apply (args: InteractiveQueryClusterRolesZookeeperNodeArgs) =
                args.VmSize <- io vmSize
                args

            ()
            n, List.Cons(apply, args)

    let interactiveQueryClusterRolesZookeeperNode =
        InteractiveQueryClusterRolesZookeeperNodeBuilder()

    type InteractiveQueryClusterStorageAccountBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (InteractiveQueryClusterStorageAccountArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("isDefault")>]
        member _.IsDefault((n, args), isDefault) =
            let apply (args: InteractiveQueryClusterStorageAccountArgs) =
                args.IsDefault <- input isDefault
                args

            ()
            n, List.Cons(apply, args)

        member _.IsDefault((n, args), isDefault) =
            let apply (args: InteractiveQueryClusterStorageAccountArgs) =
                args.IsDefault <- io isDefault
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageAccountKey")>]
        member _.StorageAccountKey((n, args), storageAccountKey) =
            let apply (args: InteractiveQueryClusterStorageAccountArgs) =
                args.StorageAccountKey <- input storageAccountKey
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountKey((n, args), storageAccountKey) =
            let apply (args: InteractiveQueryClusterStorageAccountArgs) =
                args.StorageAccountKey <- io storageAccountKey
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageContainerId")>]
        member _.StorageContainerId((n, args), storageContainerId) =
            let apply (args: InteractiveQueryClusterStorageAccountArgs) =
                args.StorageContainerId <- input storageContainerId
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageContainerId((n, args), storageContainerId) =
            let apply (args: InteractiveQueryClusterStorageAccountArgs) =
                args.StorageContainerId <- io storageContainerId
                args

            ()
            n, List.Cons(apply, args)

    let interactiveQueryClusterStorageAccount =
        InteractiveQueryClusterStorageAccountBuilder()

    type InteractiveQueryClusterStorageAccountGen2Builder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (InteractiveQueryClusterStorageAccountGen2Args()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("filesystemId")>]
        member _.FilesystemId((n, args), filesystemId) =
            let apply (args: InteractiveQueryClusterStorageAccountGen2Args) =
                args.FilesystemId <- input filesystemId
                args

            ()
            n, List.Cons(apply, args)

        member _.FilesystemId((n, args), filesystemId) =
            let apply (args: InteractiveQueryClusterStorageAccountGen2Args) =
                args.FilesystemId <- io filesystemId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("isDefault")>]
        member _.IsDefault((n, args), isDefault) =
            let apply (args: InteractiveQueryClusterStorageAccountGen2Args) =
                args.IsDefault <- input isDefault
                args

            ()
            n, List.Cons(apply, args)

        member _.IsDefault((n, args), isDefault) =
            let apply (args: InteractiveQueryClusterStorageAccountGen2Args) =
                args.IsDefault <- io isDefault
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("managedIdentityResourceId")>]
        member _.ManagedIdentityResourceId((n, args), managedIdentityResourceId) =
            let apply (args: InteractiveQueryClusterStorageAccountGen2Args) =
                args.ManagedIdentityResourceId <- input managedIdentityResourceId
                args

            ()
            n, List.Cons(apply, args)

        member _.ManagedIdentityResourceId((n, args), managedIdentityResourceId) =
            let apply (args: InteractiveQueryClusterStorageAccountGen2Args) =
                args.ManagedIdentityResourceId <- io managedIdentityResourceId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageResourceId")>]
        member _.StorageResourceId((n, args), storageResourceId) =
            let apply (args: InteractiveQueryClusterStorageAccountGen2Args) =
                args.StorageResourceId <- input storageResourceId
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageResourceId((n, args), storageResourceId) =
            let apply (args: InteractiveQueryClusterStorageAccountGen2Args) =
                args.StorageResourceId <- io storageResourceId
                args

            ()
            n, List.Cons(apply, args)

    let interactiveQueryClusterStorageAccountGen2 =
        InteractiveQueryClusterStorageAccountGen2Builder()

    type KafkaClusterComponentVersionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (KafkaClusterComponentVersionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("kafka")>]
        member _.Kafka((n, args), kafka) =
            let apply (args: KafkaClusterComponentVersionArgs) =
                args.Kafka <- input kafka
                args

            ()
            n, List.Cons(apply, args)

        member _.Kafka((n, args), kafka) =
            let apply (args: KafkaClusterComponentVersionArgs) =
                args.Kafka <- io kafka
                args

            ()
            n, List.Cons(apply, args)

    let kafkaClusterComponentVersion = KafkaClusterComponentVersionBuilder()

    type KafkaClusterGatewayBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (KafkaClusterGatewayArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: KafkaClusterGatewayArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: KafkaClusterGatewayArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: KafkaClusterGatewayArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: KafkaClusterGatewayArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: KafkaClusterGatewayArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: KafkaClusterGatewayArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

    let kafkaClusterGateway = KafkaClusterGatewayBuilder()

    type KafkaClusterRolesBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (KafkaClusterRolesArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: KafkaClusterRolesArgs) =
                   args.HeadNode <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: KafkaClusterRolesArgs) =
                   args.WorkerNode <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: KafkaClusterRolesArgs) =
                   args.ZookeeperNode <- input arg
                   args

               ()
               func) ]

    let kafkaClusterRoles = KafkaClusterRolesBuilder()

    type KafkaClusterRolesHeadNodeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (KafkaClusterRolesHeadNodeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: KafkaClusterRolesHeadNodeArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: KafkaClusterRolesHeadNodeArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sshKeys")>]
        member _.SshKeys((n, args), sshKeys) =
            let apply (args: KafkaClusterRolesHeadNodeArgs) =
                args.SshKeys <- inputList sshKeys
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: KafkaClusterRolesHeadNodeArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: KafkaClusterRolesHeadNodeArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: KafkaClusterRolesHeadNodeArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: KafkaClusterRolesHeadNodeArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkId")>]
        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: KafkaClusterRolesHeadNodeArgs) =
                args.VirtualNetworkId <- input virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: KafkaClusterRolesHeadNodeArgs) =
                args.VirtualNetworkId <- io virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vmSize")>]
        member _.VmSize((n, args), vmSize) =
            let apply (args: KafkaClusterRolesHeadNodeArgs) =
                args.VmSize <- input vmSize
                args

            ()
            n, List.Cons(apply, args)

        member _.VmSize((n, args), vmSize) =
            let apply (args: KafkaClusterRolesHeadNodeArgs) =
                args.VmSize <- io vmSize
                args

            ()
            n, List.Cons(apply, args)

    let kafkaClusterRolesHeadNode = KafkaClusterRolesHeadNodeBuilder()

    type KafkaClusterRolesWorkerNodeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (KafkaClusterRolesWorkerNodeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("minInstanceCount")>]
        member _.MinInstanceCount((n, args), minInstanceCount) =
            let apply (args: KafkaClusterRolesWorkerNodeArgs) =
                args.MinInstanceCount <- input minInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        member _.MinInstanceCount((n, args), minInstanceCount) =
            let apply (args: KafkaClusterRolesWorkerNodeArgs) =
                args.MinInstanceCount <- io minInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("numberOfDisksPerNode")>]
        member _.NumberOfDisksPerNode((n, args), numberOfDisksPerNode) =
            let apply (args: KafkaClusterRolesWorkerNodeArgs) =
                args.NumberOfDisksPerNode <- input numberOfDisksPerNode
                args

            ()
            n, List.Cons(apply, args)

        member _.NumberOfDisksPerNode((n, args), numberOfDisksPerNode) =
            let apply (args: KafkaClusterRolesWorkerNodeArgs) =
                args.NumberOfDisksPerNode <- io numberOfDisksPerNode
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: KafkaClusterRolesWorkerNodeArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: KafkaClusterRolesWorkerNodeArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sshKeys")>]
        member _.SshKeys((n, args), sshKeys) =
            let apply (args: KafkaClusterRolesWorkerNodeArgs) =
                args.SshKeys <- inputList sshKeys
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: KafkaClusterRolesWorkerNodeArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: KafkaClusterRolesWorkerNodeArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("targetInstanceCount")>]
        member _.TargetInstanceCount((n, args), targetInstanceCount) =
            let apply (args: KafkaClusterRolesWorkerNodeArgs) =
                args.TargetInstanceCount <- input targetInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        member _.TargetInstanceCount((n, args), targetInstanceCount) =
            let apply (args: KafkaClusterRolesWorkerNodeArgs) =
                args.TargetInstanceCount <- io targetInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: KafkaClusterRolesWorkerNodeArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: KafkaClusterRolesWorkerNodeArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkId")>]
        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: KafkaClusterRolesWorkerNodeArgs) =
                args.VirtualNetworkId <- input virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: KafkaClusterRolesWorkerNodeArgs) =
                args.VirtualNetworkId <- io virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vmSize")>]
        member _.VmSize((n, args), vmSize) =
            let apply (args: KafkaClusterRolesWorkerNodeArgs) =
                args.VmSize <- input vmSize
                args

            ()
            n, List.Cons(apply, args)

        member _.VmSize((n, args), vmSize) =
            let apply (args: KafkaClusterRolesWorkerNodeArgs) =
                args.VmSize <- io vmSize
                args

            ()
            n, List.Cons(apply, args)

    let kafkaClusterRolesWorkerNode = KafkaClusterRolesWorkerNodeBuilder()

    type KafkaClusterRolesZookeeperNodeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (KafkaClusterRolesZookeeperNodeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: KafkaClusterRolesZookeeperNodeArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: KafkaClusterRolesZookeeperNodeArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sshKeys")>]
        member _.SshKeys((n, args), sshKeys) =
            let apply (args: KafkaClusterRolesZookeeperNodeArgs) =
                args.SshKeys <- inputList sshKeys
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: KafkaClusterRolesZookeeperNodeArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: KafkaClusterRolesZookeeperNodeArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: KafkaClusterRolesZookeeperNodeArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: KafkaClusterRolesZookeeperNodeArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkId")>]
        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: KafkaClusterRolesZookeeperNodeArgs) =
                args.VirtualNetworkId <- input virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: KafkaClusterRolesZookeeperNodeArgs) =
                args.VirtualNetworkId <- io virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vmSize")>]
        member _.VmSize((n, args), vmSize) =
            let apply (args: KafkaClusterRolesZookeeperNodeArgs) =
                args.VmSize <- input vmSize
                args

            ()
            n, List.Cons(apply, args)

        member _.VmSize((n, args), vmSize) =
            let apply (args: KafkaClusterRolesZookeeperNodeArgs) =
                args.VmSize <- io vmSize
                args

            ()
            n, List.Cons(apply, args)

    let kafkaClusterRolesZookeeperNode = KafkaClusterRolesZookeeperNodeBuilder()

    type KafkaClusterStorageAccountBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (KafkaClusterStorageAccountArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("isDefault")>]
        member _.IsDefault((n, args), isDefault) =
            let apply (args: KafkaClusterStorageAccountArgs) =
                args.IsDefault <- input isDefault
                args

            ()
            n, List.Cons(apply, args)

        member _.IsDefault((n, args), isDefault) =
            let apply (args: KafkaClusterStorageAccountArgs) =
                args.IsDefault <- io isDefault
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageAccountKey")>]
        member _.StorageAccountKey((n, args), storageAccountKey) =
            let apply (args: KafkaClusterStorageAccountArgs) =
                args.StorageAccountKey <- input storageAccountKey
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountKey((n, args), storageAccountKey) =
            let apply (args: KafkaClusterStorageAccountArgs) =
                args.StorageAccountKey <- io storageAccountKey
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageContainerId")>]
        member _.StorageContainerId((n, args), storageContainerId) =
            let apply (args: KafkaClusterStorageAccountArgs) =
                args.StorageContainerId <- input storageContainerId
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageContainerId((n, args), storageContainerId) =
            let apply (args: KafkaClusterStorageAccountArgs) =
                args.StorageContainerId <- io storageContainerId
                args

            ()
            n, List.Cons(apply, args)

    let kafkaClusterStorageAccount = KafkaClusterStorageAccountBuilder()

    type KafkaClusterStorageAccountGen2Builder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (KafkaClusterStorageAccountGen2Args()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("filesystemId")>]
        member _.FilesystemId((n, args), filesystemId) =
            let apply (args: KafkaClusterStorageAccountGen2Args) =
                args.FilesystemId <- input filesystemId
                args

            ()
            n, List.Cons(apply, args)

        member _.FilesystemId((n, args), filesystemId) =
            let apply (args: KafkaClusterStorageAccountGen2Args) =
                args.FilesystemId <- io filesystemId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("isDefault")>]
        member _.IsDefault((n, args), isDefault) =
            let apply (args: KafkaClusterStorageAccountGen2Args) =
                args.IsDefault <- input isDefault
                args

            ()
            n, List.Cons(apply, args)

        member _.IsDefault((n, args), isDefault) =
            let apply (args: KafkaClusterStorageAccountGen2Args) =
                args.IsDefault <- io isDefault
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("managedIdentityResourceId")>]
        member _.ManagedIdentityResourceId((n, args), managedIdentityResourceId) =
            let apply (args: KafkaClusterStorageAccountGen2Args) =
                args.ManagedIdentityResourceId <- input managedIdentityResourceId
                args

            ()
            n, List.Cons(apply, args)

        member _.ManagedIdentityResourceId((n, args), managedIdentityResourceId) =
            let apply (args: KafkaClusterStorageAccountGen2Args) =
                args.ManagedIdentityResourceId <- io managedIdentityResourceId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageResourceId")>]
        member _.StorageResourceId((n, args), storageResourceId) =
            let apply (args: KafkaClusterStorageAccountGen2Args) =
                args.StorageResourceId <- input storageResourceId
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageResourceId((n, args), storageResourceId) =
            let apply (args: KafkaClusterStorageAccountGen2Args) =
                args.StorageResourceId <- io storageResourceId
                args

            ()
            n, List.Cons(apply, args)

    let kafkaClusterStorageAccountGen2 = KafkaClusterStorageAccountGen2Builder()

    type MLServicesClusterGatewayBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (MLServicesClusterGatewayArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: MLServicesClusterGatewayArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: MLServicesClusterGatewayArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: MLServicesClusterGatewayArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: MLServicesClusterGatewayArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: MLServicesClusterGatewayArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: MLServicesClusterGatewayArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

    let mLServicesClusterGateway = MLServicesClusterGatewayBuilder()

    type MLServicesClusterRolesBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (MLServicesClusterRolesArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: MLServicesClusterRolesArgs) =
                   args.EdgeNode <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: MLServicesClusterRolesArgs) =
                   args.HeadNode <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: MLServicesClusterRolesArgs) =
                   args.WorkerNode <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: MLServicesClusterRolesArgs) =
                   args.ZookeeperNode <- input arg
                   args

               ()
               func) ]

    let mLServicesClusterRoles = MLServicesClusterRolesBuilder()

    type MLServicesClusterRolesEdgeNodeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (MLServicesClusterRolesEdgeNodeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: MLServicesClusterRolesEdgeNodeArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: MLServicesClusterRolesEdgeNodeArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sshKeys")>]
        member _.SshKeys((n, args), sshKeys) =
            let apply (args: MLServicesClusterRolesEdgeNodeArgs) =
                args.SshKeys <- inputList sshKeys
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: MLServicesClusterRolesEdgeNodeArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: MLServicesClusterRolesEdgeNodeArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: MLServicesClusterRolesEdgeNodeArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: MLServicesClusterRolesEdgeNodeArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkId")>]
        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: MLServicesClusterRolesEdgeNodeArgs) =
                args.VirtualNetworkId <- input virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: MLServicesClusterRolesEdgeNodeArgs) =
                args.VirtualNetworkId <- io virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vmSize")>]
        member _.VmSize((n, args), vmSize) =
            let apply (args: MLServicesClusterRolesEdgeNodeArgs) =
                args.VmSize <- input vmSize
                args

            ()
            n, List.Cons(apply, args)

        member _.VmSize((n, args), vmSize) =
            let apply (args: MLServicesClusterRolesEdgeNodeArgs) =
                args.VmSize <- io vmSize
                args

            ()
            n, List.Cons(apply, args)

    let mLServicesClusterRolesEdgeNode = MLServicesClusterRolesEdgeNodeBuilder()

    type MLServicesClusterRolesHeadNodeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (MLServicesClusterRolesHeadNodeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: MLServicesClusterRolesHeadNodeArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: MLServicesClusterRolesHeadNodeArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sshKeys")>]
        member _.SshKeys((n, args), sshKeys) =
            let apply (args: MLServicesClusterRolesHeadNodeArgs) =
                args.SshKeys <- inputList sshKeys
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: MLServicesClusterRolesHeadNodeArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: MLServicesClusterRolesHeadNodeArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: MLServicesClusterRolesHeadNodeArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: MLServicesClusterRolesHeadNodeArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkId")>]
        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: MLServicesClusterRolesHeadNodeArgs) =
                args.VirtualNetworkId <- input virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: MLServicesClusterRolesHeadNodeArgs) =
                args.VirtualNetworkId <- io virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vmSize")>]
        member _.VmSize((n, args), vmSize) =
            let apply (args: MLServicesClusterRolesHeadNodeArgs) =
                args.VmSize <- input vmSize
                args

            ()
            n, List.Cons(apply, args)

        member _.VmSize((n, args), vmSize) =
            let apply (args: MLServicesClusterRolesHeadNodeArgs) =
                args.VmSize <- io vmSize
                args

            ()
            n, List.Cons(apply, args)

    let mLServicesClusterRolesHeadNode = MLServicesClusterRolesHeadNodeBuilder()

    type MLServicesClusterRolesWorkerNodeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (MLServicesClusterRolesWorkerNodeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("minInstanceCount")>]
        member _.MinInstanceCount((n, args), minInstanceCount) =
            let apply (args: MLServicesClusterRolesWorkerNodeArgs) =
                args.MinInstanceCount <- input minInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        member _.MinInstanceCount((n, args), minInstanceCount) =
            let apply (args: MLServicesClusterRolesWorkerNodeArgs) =
                args.MinInstanceCount <- io minInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: MLServicesClusterRolesWorkerNodeArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: MLServicesClusterRolesWorkerNodeArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sshKeys")>]
        member _.SshKeys((n, args), sshKeys) =
            let apply (args: MLServicesClusterRolesWorkerNodeArgs) =
                args.SshKeys <- inputList sshKeys
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: MLServicesClusterRolesWorkerNodeArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: MLServicesClusterRolesWorkerNodeArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("targetInstanceCount")>]
        member _.TargetInstanceCount((n, args), targetInstanceCount) =
            let apply (args: MLServicesClusterRolesWorkerNodeArgs) =
                args.TargetInstanceCount <- input targetInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        member _.TargetInstanceCount((n, args), targetInstanceCount) =
            let apply (args: MLServicesClusterRolesWorkerNodeArgs) =
                args.TargetInstanceCount <- io targetInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: MLServicesClusterRolesWorkerNodeArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: MLServicesClusterRolesWorkerNodeArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkId")>]
        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: MLServicesClusterRolesWorkerNodeArgs) =
                args.VirtualNetworkId <- input virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: MLServicesClusterRolesWorkerNodeArgs) =
                args.VirtualNetworkId <- io virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vmSize")>]
        member _.VmSize((n, args), vmSize) =
            let apply (args: MLServicesClusterRolesWorkerNodeArgs) =
                args.VmSize <- input vmSize
                args

            ()
            n, List.Cons(apply, args)

        member _.VmSize((n, args), vmSize) =
            let apply (args: MLServicesClusterRolesWorkerNodeArgs) =
                args.VmSize <- io vmSize
                args

            ()
            n, List.Cons(apply, args)

    let mLServicesClusterRolesWorkerNode =
        MLServicesClusterRolesWorkerNodeBuilder()

    type MLServicesClusterRolesZookeeperNodeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (MLServicesClusterRolesZookeeperNodeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: MLServicesClusterRolesZookeeperNodeArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: MLServicesClusterRolesZookeeperNodeArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sshKeys")>]
        member _.SshKeys((n, args), sshKeys) =
            let apply (args: MLServicesClusterRolesZookeeperNodeArgs) =
                args.SshKeys <- inputList sshKeys
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: MLServicesClusterRolesZookeeperNodeArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: MLServicesClusterRolesZookeeperNodeArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: MLServicesClusterRolesZookeeperNodeArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: MLServicesClusterRolesZookeeperNodeArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkId")>]
        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: MLServicesClusterRolesZookeeperNodeArgs) =
                args.VirtualNetworkId <- input virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: MLServicesClusterRolesZookeeperNodeArgs) =
                args.VirtualNetworkId <- io virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vmSize")>]
        member _.VmSize((n, args), vmSize) =
            let apply (args: MLServicesClusterRolesZookeeperNodeArgs) =
                args.VmSize <- input vmSize
                args

            ()
            n, List.Cons(apply, args)

        member _.VmSize((n, args), vmSize) =
            let apply (args: MLServicesClusterRolesZookeeperNodeArgs) =
                args.VmSize <- io vmSize
                args

            ()
            n, List.Cons(apply, args)

    let mLServicesClusterRolesZookeeperNode =
        MLServicesClusterRolesZookeeperNodeBuilder()

    type MLServicesClusterStorageAccountBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (MLServicesClusterStorageAccountArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("isDefault")>]
        member _.IsDefault((n, args), isDefault) =
            let apply (args: MLServicesClusterStorageAccountArgs) =
                args.IsDefault <- input isDefault
                args

            ()
            n, List.Cons(apply, args)

        member _.IsDefault((n, args), isDefault) =
            let apply (args: MLServicesClusterStorageAccountArgs) =
                args.IsDefault <- io isDefault
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageAccountKey")>]
        member _.StorageAccountKey((n, args), storageAccountKey) =
            let apply (args: MLServicesClusterStorageAccountArgs) =
                args.StorageAccountKey <- input storageAccountKey
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountKey((n, args), storageAccountKey) =
            let apply (args: MLServicesClusterStorageAccountArgs) =
                args.StorageAccountKey <- io storageAccountKey
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageContainerId")>]
        member _.StorageContainerId((n, args), storageContainerId) =
            let apply (args: MLServicesClusterStorageAccountArgs) =
                args.StorageContainerId <- input storageContainerId
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageContainerId((n, args), storageContainerId) =
            let apply (args: MLServicesClusterStorageAccountArgs) =
                args.StorageContainerId <- io storageContainerId
                args

            ()
            n, List.Cons(apply, args)

    let mLServicesClusterStorageAccount = MLServicesClusterStorageAccountBuilder()

    type RServerClusterGatewayBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (RServerClusterGatewayArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: RServerClusterGatewayArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: RServerClusterGatewayArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: RServerClusterGatewayArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: RServerClusterGatewayArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: RServerClusterGatewayArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: RServerClusterGatewayArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

    let rServerClusterGateway = RServerClusterGatewayBuilder()

    type RServerClusterRolesBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (RServerClusterRolesArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: RServerClusterRolesArgs) =
                   args.EdgeNode <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: RServerClusterRolesArgs) =
                   args.HeadNode <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: RServerClusterRolesArgs) =
                   args.WorkerNode <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: RServerClusterRolesArgs) =
                   args.ZookeeperNode <- input arg
                   args

               ()
               func) ]

    let rServerClusterRoles = RServerClusterRolesBuilder()

    type RServerClusterRolesEdgeNodeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (RServerClusterRolesEdgeNodeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: RServerClusterRolesEdgeNodeArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: RServerClusterRolesEdgeNodeArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sshKeys")>]
        member _.SshKeys((n, args), sshKeys) =
            let apply (args: RServerClusterRolesEdgeNodeArgs) =
                args.SshKeys <- inputList sshKeys
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: RServerClusterRolesEdgeNodeArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: RServerClusterRolesEdgeNodeArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: RServerClusterRolesEdgeNodeArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: RServerClusterRolesEdgeNodeArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkId")>]
        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: RServerClusterRolesEdgeNodeArgs) =
                args.VirtualNetworkId <- input virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: RServerClusterRolesEdgeNodeArgs) =
                args.VirtualNetworkId <- io virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vmSize")>]
        member _.VmSize((n, args), vmSize) =
            let apply (args: RServerClusterRolesEdgeNodeArgs) =
                args.VmSize <- input vmSize
                args

            ()
            n, List.Cons(apply, args)

        member _.VmSize((n, args), vmSize) =
            let apply (args: RServerClusterRolesEdgeNodeArgs) =
                args.VmSize <- io vmSize
                args

            ()
            n, List.Cons(apply, args)

    let rServerClusterRolesEdgeNode = RServerClusterRolesEdgeNodeBuilder()

    type RServerClusterRolesHeadNodeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (RServerClusterRolesHeadNodeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: RServerClusterRolesHeadNodeArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: RServerClusterRolesHeadNodeArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sshKeys")>]
        member _.SshKeys((n, args), sshKeys) =
            let apply (args: RServerClusterRolesHeadNodeArgs) =
                args.SshKeys <- inputList sshKeys
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: RServerClusterRolesHeadNodeArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: RServerClusterRolesHeadNodeArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: RServerClusterRolesHeadNodeArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: RServerClusterRolesHeadNodeArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkId")>]
        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: RServerClusterRolesHeadNodeArgs) =
                args.VirtualNetworkId <- input virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: RServerClusterRolesHeadNodeArgs) =
                args.VirtualNetworkId <- io virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vmSize")>]
        member _.VmSize((n, args), vmSize) =
            let apply (args: RServerClusterRolesHeadNodeArgs) =
                args.VmSize <- input vmSize
                args

            ()
            n, List.Cons(apply, args)

        member _.VmSize((n, args), vmSize) =
            let apply (args: RServerClusterRolesHeadNodeArgs) =
                args.VmSize <- io vmSize
                args

            ()
            n, List.Cons(apply, args)

    let rServerClusterRolesHeadNode = RServerClusterRolesHeadNodeBuilder()

    type RServerClusterRolesWorkerNodeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (RServerClusterRolesWorkerNodeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("minInstanceCount")>]
        member _.MinInstanceCount((n, args), minInstanceCount) =
            let apply (args: RServerClusterRolesWorkerNodeArgs) =
                args.MinInstanceCount <- input minInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        member _.MinInstanceCount((n, args), minInstanceCount) =
            let apply (args: RServerClusterRolesWorkerNodeArgs) =
                args.MinInstanceCount <- io minInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: RServerClusterRolesWorkerNodeArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: RServerClusterRolesWorkerNodeArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sshKeys")>]
        member _.SshKeys((n, args), sshKeys) =
            let apply (args: RServerClusterRolesWorkerNodeArgs) =
                args.SshKeys <- inputList sshKeys
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: RServerClusterRolesWorkerNodeArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: RServerClusterRolesWorkerNodeArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("targetInstanceCount")>]
        member _.TargetInstanceCount((n, args), targetInstanceCount) =
            let apply (args: RServerClusterRolesWorkerNodeArgs) =
                args.TargetInstanceCount <- input targetInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        member _.TargetInstanceCount((n, args), targetInstanceCount) =
            let apply (args: RServerClusterRolesWorkerNodeArgs) =
                args.TargetInstanceCount <- io targetInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: RServerClusterRolesWorkerNodeArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: RServerClusterRolesWorkerNodeArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkId")>]
        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: RServerClusterRolesWorkerNodeArgs) =
                args.VirtualNetworkId <- input virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: RServerClusterRolesWorkerNodeArgs) =
                args.VirtualNetworkId <- io virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vmSize")>]
        member _.VmSize((n, args), vmSize) =
            let apply (args: RServerClusterRolesWorkerNodeArgs) =
                args.VmSize <- input vmSize
                args

            ()
            n, List.Cons(apply, args)

        member _.VmSize((n, args), vmSize) =
            let apply (args: RServerClusterRolesWorkerNodeArgs) =
                args.VmSize <- io vmSize
                args

            ()
            n, List.Cons(apply, args)

    let rServerClusterRolesWorkerNode = RServerClusterRolesWorkerNodeBuilder()

    type RServerClusterRolesZookeeperNodeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (RServerClusterRolesZookeeperNodeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: RServerClusterRolesZookeeperNodeArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: RServerClusterRolesZookeeperNodeArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sshKeys")>]
        member _.SshKeys((n, args), sshKeys) =
            let apply (args: RServerClusterRolesZookeeperNodeArgs) =
                args.SshKeys <- inputList sshKeys
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: RServerClusterRolesZookeeperNodeArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: RServerClusterRolesZookeeperNodeArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: RServerClusterRolesZookeeperNodeArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: RServerClusterRolesZookeeperNodeArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkId")>]
        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: RServerClusterRolesZookeeperNodeArgs) =
                args.VirtualNetworkId <- input virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: RServerClusterRolesZookeeperNodeArgs) =
                args.VirtualNetworkId <- io virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vmSize")>]
        member _.VmSize((n, args), vmSize) =
            let apply (args: RServerClusterRolesZookeeperNodeArgs) =
                args.VmSize <- input vmSize
                args

            ()
            n, List.Cons(apply, args)

        member _.VmSize((n, args), vmSize) =
            let apply (args: RServerClusterRolesZookeeperNodeArgs) =
                args.VmSize <- io vmSize
                args

            ()
            n, List.Cons(apply, args)

    let rServerClusterRolesZookeeperNode =
        RServerClusterRolesZookeeperNodeBuilder()

    type RServerClusterStorageAccountBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (RServerClusterStorageAccountArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("isDefault")>]
        member _.IsDefault((n, args), isDefault) =
            let apply (args: RServerClusterStorageAccountArgs) =
                args.IsDefault <- input isDefault
                args

            ()
            n, List.Cons(apply, args)

        member _.IsDefault((n, args), isDefault) =
            let apply (args: RServerClusterStorageAccountArgs) =
                args.IsDefault <- io isDefault
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageAccountKey")>]
        member _.StorageAccountKey((n, args), storageAccountKey) =
            let apply (args: RServerClusterStorageAccountArgs) =
                args.StorageAccountKey <- input storageAccountKey
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountKey((n, args), storageAccountKey) =
            let apply (args: RServerClusterStorageAccountArgs) =
                args.StorageAccountKey <- io storageAccountKey
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageContainerId")>]
        member _.StorageContainerId((n, args), storageContainerId) =
            let apply (args: RServerClusterStorageAccountArgs) =
                args.StorageContainerId <- input storageContainerId
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageContainerId((n, args), storageContainerId) =
            let apply (args: RServerClusterStorageAccountArgs) =
                args.StorageContainerId <- io storageContainerId
                args

            ()
            n, List.Cons(apply, args)

    let rServerClusterStorageAccount = RServerClusterStorageAccountBuilder()

    type SparkClusterComponentVersionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SparkClusterComponentVersionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("spark")>]
        member _.Spark((n, args), spark) =
            let apply (args: SparkClusterComponentVersionArgs) =
                args.Spark <- input spark
                args

            ()
            n, List.Cons(apply, args)

        member _.Spark((n, args), spark) =
            let apply (args: SparkClusterComponentVersionArgs) =
                args.Spark <- io spark
                args

            ()
            n, List.Cons(apply, args)

    let sparkClusterComponentVersion = SparkClusterComponentVersionBuilder()

    type SparkClusterGatewayBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SparkClusterGatewayArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: SparkClusterGatewayArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: SparkClusterGatewayArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: SparkClusterGatewayArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: SparkClusterGatewayArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: SparkClusterGatewayArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: SparkClusterGatewayArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

    let sparkClusterGateway = SparkClusterGatewayBuilder()

    type SparkClusterRolesBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SparkClusterRolesArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: SparkClusterRolesArgs) =
                   args.HeadNode <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: SparkClusterRolesArgs) =
                   args.WorkerNode <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: SparkClusterRolesArgs) =
                   args.ZookeeperNode <- input arg
                   args

               ()
               func) ]

    let sparkClusterRoles = SparkClusterRolesBuilder()

    type SparkClusterRolesHeadNodeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SparkClusterRolesHeadNodeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: SparkClusterRolesHeadNodeArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: SparkClusterRolesHeadNodeArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sshKeys")>]
        member _.SshKeys((n, args), sshKeys) =
            let apply (args: SparkClusterRolesHeadNodeArgs) =
                args.SshKeys <- inputList sshKeys
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: SparkClusterRolesHeadNodeArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: SparkClusterRolesHeadNodeArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: SparkClusterRolesHeadNodeArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: SparkClusterRolesHeadNodeArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkId")>]
        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: SparkClusterRolesHeadNodeArgs) =
                args.VirtualNetworkId <- input virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: SparkClusterRolesHeadNodeArgs) =
                args.VirtualNetworkId <- io virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vmSize")>]
        member _.VmSize((n, args), vmSize) =
            let apply (args: SparkClusterRolesHeadNodeArgs) =
                args.VmSize <- input vmSize
                args

            ()
            n, List.Cons(apply, args)

        member _.VmSize((n, args), vmSize) =
            let apply (args: SparkClusterRolesHeadNodeArgs) =
                args.VmSize <- io vmSize
                args

            ()
            n, List.Cons(apply, args)

    let sparkClusterRolesHeadNode = SparkClusterRolesHeadNodeBuilder()

    type SparkClusterRolesWorkerNodeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SparkClusterRolesWorkerNodeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("minInstanceCount")>]
        member _.MinInstanceCount((n, args), minInstanceCount) =
            let apply (args: SparkClusterRolesWorkerNodeArgs) =
                args.MinInstanceCount <- input minInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        member _.MinInstanceCount((n, args), minInstanceCount) =
            let apply (args: SparkClusterRolesWorkerNodeArgs) =
                args.MinInstanceCount <- io minInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: SparkClusterRolesWorkerNodeArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: SparkClusterRolesWorkerNodeArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sshKeys")>]
        member _.SshKeys((n, args), sshKeys) =
            let apply (args: SparkClusterRolesWorkerNodeArgs) =
                args.SshKeys <- inputList sshKeys
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: SparkClusterRolesWorkerNodeArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: SparkClusterRolesWorkerNodeArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("targetInstanceCount")>]
        member _.TargetInstanceCount((n, args), targetInstanceCount) =
            let apply (args: SparkClusterRolesWorkerNodeArgs) =
                args.TargetInstanceCount <- input targetInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        member _.TargetInstanceCount((n, args), targetInstanceCount) =
            let apply (args: SparkClusterRolesWorkerNodeArgs) =
                args.TargetInstanceCount <- io targetInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: SparkClusterRolesWorkerNodeArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: SparkClusterRolesWorkerNodeArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkId")>]
        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: SparkClusterRolesWorkerNodeArgs) =
                args.VirtualNetworkId <- input virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: SparkClusterRolesWorkerNodeArgs) =
                args.VirtualNetworkId <- io virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vmSize")>]
        member _.VmSize((n, args), vmSize) =
            let apply (args: SparkClusterRolesWorkerNodeArgs) =
                args.VmSize <- input vmSize
                args

            ()
            n, List.Cons(apply, args)

        member _.VmSize((n, args), vmSize) =
            let apply (args: SparkClusterRolesWorkerNodeArgs) =
                args.VmSize <- io vmSize
                args

            ()
            n, List.Cons(apply, args)

    let sparkClusterRolesWorkerNode = SparkClusterRolesWorkerNodeBuilder()

    type SparkClusterRolesZookeeperNodeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SparkClusterRolesZookeeperNodeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: SparkClusterRolesZookeeperNodeArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: SparkClusterRolesZookeeperNodeArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sshKeys")>]
        member _.SshKeys((n, args), sshKeys) =
            let apply (args: SparkClusterRolesZookeeperNodeArgs) =
                args.SshKeys <- inputList sshKeys
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: SparkClusterRolesZookeeperNodeArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: SparkClusterRolesZookeeperNodeArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: SparkClusterRolesZookeeperNodeArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: SparkClusterRolesZookeeperNodeArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkId")>]
        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: SparkClusterRolesZookeeperNodeArgs) =
                args.VirtualNetworkId <- input virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: SparkClusterRolesZookeeperNodeArgs) =
                args.VirtualNetworkId <- io virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vmSize")>]
        member _.VmSize((n, args), vmSize) =
            let apply (args: SparkClusterRolesZookeeperNodeArgs) =
                args.VmSize <- input vmSize
                args

            ()
            n, List.Cons(apply, args)

        member _.VmSize((n, args), vmSize) =
            let apply (args: SparkClusterRolesZookeeperNodeArgs) =
                args.VmSize <- io vmSize
                args

            ()
            n, List.Cons(apply, args)

    let sparkClusterRolesZookeeperNode = SparkClusterRolesZookeeperNodeBuilder()

    type SparkClusterStorageAccountBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SparkClusterStorageAccountArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("isDefault")>]
        member _.IsDefault((n, args), isDefault) =
            let apply (args: SparkClusterStorageAccountArgs) =
                args.IsDefault <- input isDefault
                args

            ()
            n, List.Cons(apply, args)

        member _.IsDefault((n, args), isDefault) =
            let apply (args: SparkClusterStorageAccountArgs) =
                args.IsDefault <- io isDefault
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageAccountKey")>]
        member _.StorageAccountKey((n, args), storageAccountKey) =
            let apply (args: SparkClusterStorageAccountArgs) =
                args.StorageAccountKey <- input storageAccountKey
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountKey((n, args), storageAccountKey) =
            let apply (args: SparkClusterStorageAccountArgs) =
                args.StorageAccountKey <- io storageAccountKey
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageContainerId")>]
        member _.StorageContainerId((n, args), storageContainerId) =
            let apply (args: SparkClusterStorageAccountArgs) =
                args.StorageContainerId <- input storageContainerId
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageContainerId((n, args), storageContainerId) =
            let apply (args: SparkClusterStorageAccountArgs) =
                args.StorageContainerId <- io storageContainerId
                args

            ()
            n, List.Cons(apply, args)

    let sparkClusterStorageAccount = SparkClusterStorageAccountBuilder()

    type SparkClusterStorageAccountGen2Builder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SparkClusterStorageAccountGen2Args()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("filesystemId")>]
        member _.FilesystemId((n, args), filesystemId) =
            let apply (args: SparkClusterStorageAccountGen2Args) =
                args.FilesystemId <- input filesystemId
                args

            ()
            n, List.Cons(apply, args)

        member _.FilesystemId((n, args), filesystemId) =
            let apply (args: SparkClusterStorageAccountGen2Args) =
                args.FilesystemId <- io filesystemId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("isDefault")>]
        member _.IsDefault((n, args), isDefault) =
            let apply (args: SparkClusterStorageAccountGen2Args) =
                args.IsDefault <- input isDefault
                args

            ()
            n, List.Cons(apply, args)

        member _.IsDefault((n, args), isDefault) =
            let apply (args: SparkClusterStorageAccountGen2Args) =
                args.IsDefault <- io isDefault
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("managedIdentityResourceId")>]
        member _.ManagedIdentityResourceId((n, args), managedIdentityResourceId) =
            let apply (args: SparkClusterStorageAccountGen2Args) =
                args.ManagedIdentityResourceId <- input managedIdentityResourceId
                args

            ()
            n, List.Cons(apply, args)

        member _.ManagedIdentityResourceId((n, args), managedIdentityResourceId) =
            let apply (args: SparkClusterStorageAccountGen2Args) =
                args.ManagedIdentityResourceId <- io managedIdentityResourceId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageResourceId")>]
        member _.StorageResourceId((n, args), storageResourceId) =
            let apply (args: SparkClusterStorageAccountGen2Args) =
                args.StorageResourceId <- input storageResourceId
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageResourceId((n, args), storageResourceId) =
            let apply (args: SparkClusterStorageAccountGen2Args) =
                args.StorageResourceId <- io storageResourceId
                args

            ()
            n, List.Cons(apply, args)

    let sparkClusterStorageAccountGen2 = SparkClusterStorageAccountGen2Builder()

    type StormClusterComponentVersionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (StormClusterComponentVersionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("storm")>]
        member _.Storm((n, args), storm) =
            let apply (args: StormClusterComponentVersionArgs) =
                args.Storm <- input storm
                args

            ()
            n, List.Cons(apply, args)

        member _.Storm((n, args), storm) =
            let apply (args: StormClusterComponentVersionArgs) =
                args.Storm <- io storm
                args

            ()
            n, List.Cons(apply, args)

    let stormClusterComponentVersion = StormClusterComponentVersionBuilder()

    type StormClusterGatewayBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (StormClusterGatewayArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: StormClusterGatewayArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: StormClusterGatewayArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: StormClusterGatewayArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: StormClusterGatewayArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: StormClusterGatewayArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: StormClusterGatewayArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

    let stormClusterGateway = StormClusterGatewayBuilder()

    type StormClusterRolesBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (StormClusterRolesArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: StormClusterRolesArgs) =
                   args.HeadNode <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: StormClusterRolesArgs) =
                   args.WorkerNode <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: StormClusterRolesArgs) =
                   args.ZookeeperNode <- input arg
                   args

               ()
               func) ]

    let stormClusterRoles = StormClusterRolesBuilder()

    type StormClusterRolesHeadNodeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (StormClusterRolesHeadNodeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: StormClusterRolesHeadNodeArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: StormClusterRolesHeadNodeArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sshKeys")>]
        member _.SshKeys((n, args), sshKeys) =
            let apply (args: StormClusterRolesHeadNodeArgs) =
                args.SshKeys <- inputList sshKeys
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: StormClusterRolesHeadNodeArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: StormClusterRolesHeadNodeArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: StormClusterRolesHeadNodeArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: StormClusterRolesHeadNodeArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkId")>]
        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: StormClusterRolesHeadNodeArgs) =
                args.VirtualNetworkId <- input virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: StormClusterRolesHeadNodeArgs) =
                args.VirtualNetworkId <- io virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vmSize")>]
        member _.VmSize((n, args), vmSize) =
            let apply (args: StormClusterRolesHeadNodeArgs) =
                args.VmSize <- input vmSize
                args

            ()
            n, List.Cons(apply, args)

        member _.VmSize((n, args), vmSize) =
            let apply (args: StormClusterRolesHeadNodeArgs) =
                args.VmSize <- io vmSize
                args

            ()
            n, List.Cons(apply, args)

    let stormClusterRolesHeadNode = StormClusterRolesHeadNodeBuilder()

    type StormClusterRolesWorkerNodeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (StormClusterRolesWorkerNodeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("minInstanceCount")>]
        member _.MinInstanceCount((n, args), minInstanceCount) =
            let apply (args: StormClusterRolesWorkerNodeArgs) =
                args.MinInstanceCount <- input minInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        member _.MinInstanceCount((n, args), minInstanceCount) =
            let apply (args: StormClusterRolesWorkerNodeArgs) =
                args.MinInstanceCount <- io minInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: StormClusterRolesWorkerNodeArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: StormClusterRolesWorkerNodeArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sshKeys")>]
        member _.SshKeys((n, args), sshKeys) =
            let apply (args: StormClusterRolesWorkerNodeArgs) =
                args.SshKeys <- inputList sshKeys
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: StormClusterRolesWorkerNodeArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: StormClusterRolesWorkerNodeArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("targetInstanceCount")>]
        member _.TargetInstanceCount((n, args), targetInstanceCount) =
            let apply (args: StormClusterRolesWorkerNodeArgs) =
                args.TargetInstanceCount <- input targetInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        member _.TargetInstanceCount((n, args), targetInstanceCount) =
            let apply (args: StormClusterRolesWorkerNodeArgs) =
                args.TargetInstanceCount <- io targetInstanceCount
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: StormClusterRolesWorkerNodeArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: StormClusterRolesWorkerNodeArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkId")>]
        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: StormClusterRolesWorkerNodeArgs) =
                args.VirtualNetworkId <- input virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: StormClusterRolesWorkerNodeArgs) =
                args.VirtualNetworkId <- io virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vmSize")>]
        member _.VmSize((n, args), vmSize) =
            let apply (args: StormClusterRolesWorkerNodeArgs) =
                args.VmSize <- input vmSize
                args

            ()
            n, List.Cons(apply, args)

        member _.VmSize((n, args), vmSize) =
            let apply (args: StormClusterRolesWorkerNodeArgs) =
                args.VmSize <- io vmSize
                args

            ()
            n, List.Cons(apply, args)

    let stormClusterRolesWorkerNode = StormClusterRolesWorkerNodeBuilder()

    type StormClusterRolesZookeeperNodeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (StormClusterRolesZookeeperNodeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: StormClusterRolesZookeeperNodeArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: StormClusterRolesZookeeperNodeArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sshKeys")>]
        member _.SshKeys((n, args), sshKeys) =
            let apply (args: StormClusterRolesZookeeperNodeArgs) =
                args.SshKeys <- inputList sshKeys
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: StormClusterRolesZookeeperNodeArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: StormClusterRolesZookeeperNodeArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: StormClusterRolesZookeeperNodeArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: StormClusterRolesZookeeperNodeArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkId")>]
        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: StormClusterRolesZookeeperNodeArgs) =
                args.VirtualNetworkId <- input virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        member _.VirtualNetworkId((n, args), virtualNetworkId) =
            let apply (args: StormClusterRolesZookeeperNodeArgs) =
                args.VirtualNetworkId <- io virtualNetworkId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vmSize")>]
        member _.VmSize((n, args), vmSize) =
            let apply (args: StormClusterRolesZookeeperNodeArgs) =
                args.VmSize <- input vmSize
                args

            ()
            n, List.Cons(apply, args)

        member _.VmSize((n, args), vmSize) =
            let apply (args: StormClusterRolesZookeeperNodeArgs) =
                args.VmSize <- io vmSize
                args

            ()
            n, List.Cons(apply, args)

    let stormClusterRolesZookeeperNode = StormClusterRolesZookeeperNodeBuilder()

    type StormClusterStorageAccountBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (StormClusterStorageAccountArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("isDefault")>]
        member _.IsDefault((n, args), isDefault) =
            let apply (args: StormClusterStorageAccountArgs) =
                args.IsDefault <- input isDefault
                args

            ()
            n, List.Cons(apply, args)

        member _.IsDefault((n, args), isDefault) =
            let apply (args: StormClusterStorageAccountArgs) =
                args.IsDefault <- io isDefault
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageAccountKey")>]
        member _.StorageAccountKey((n, args), storageAccountKey) =
            let apply (args: StormClusterStorageAccountArgs) =
                args.StorageAccountKey <- input storageAccountKey
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountKey((n, args), storageAccountKey) =
            let apply (args: StormClusterStorageAccountArgs) =
                args.StorageAccountKey <- io storageAccountKey
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageContainerId")>]
        member _.StorageContainerId((n, args), storageContainerId) =
            let apply (args: StormClusterStorageAccountArgs) =
                args.StorageContainerId <- input storageContainerId
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageContainerId((n, args), storageContainerId) =
            let apply (args: StormClusterStorageAccountArgs) =
                args.StorageContainerId <- io storageContainerId
                args

            ()
            n, List.Cons(apply, args)

    let stormClusterStorageAccount = StormClusterStorageAccountBuilder()

    type HBaseClusterBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            HBaseCluster(name, (List.fold func (HBaseClusterArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("clusterVersion")>]
        member _.ClusterVersion((name, args), clusterVersion) =
            let apply (args: HBaseClusterArgs) =
                args.ClusterVersion <- input clusterVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.ClusterVersion((name, args), clusterVersion) =
            let apply (args: HBaseClusterArgs) =
                args.ClusterVersion <- io clusterVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: HBaseClusterArgs) =
                   args.ComponentVersion <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: HBaseClusterArgs) =
                   args.Gateway <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: HBaseClusterArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: HBaseClusterArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: HBaseClusterArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: HBaseClusterArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: HBaseClusterArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: HBaseClusterArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: HBaseClusterArgs) =
                   args.Roles <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: HBaseClusterArgs) =
                   args.StorageAccountGen2 <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("storageAccounts")>]
        member _.StorageAccounts((name, args), storageAccounts) =
            let apply (args: HBaseClusterArgs) =
                args.StorageAccounts <- inputList storageAccounts
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: HBaseClusterArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tier")>]
        member _.Tier((name, args), tier) =
            let apply (args: HBaseClusterArgs) =
                args.Tier <- input tier
                args

            ()
            name, List.Cons(apply, args)

        member _.Tier((name, args), tier) =
            let apply (args: HBaseClusterArgs) =
                args.Tier <- io tier
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tlsMinVersion")>]
        member _.TlsMinVersion((name, args), tlsMinVersion) =
            let apply (args: HBaseClusterArgs) =
                args.TlsMinVersion <- input tlsMinVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.TlsMinVersion((name, args), tlsMinVersion) =
            let apply (args: HBaseClusterArgs) =
                args.TlsMinVersion <- io tlsMinVersion
                args

            ()
            name, List.Cons(apply, args)

    let hBaseCluster = HBaseClusterBuilder()

    type HadoopClusterBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            HadoopCluster(name, (List.fold func (HadoopClusterArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("clusterVersion")>]
        member _.ClusterVersion((name, args), clusterVersion) =
            let apply (args: HadoopClusterArgs) =
                args.ClusterVersion <- input clusterVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.ClusterVersion((name, args), clusterVersion) =
            let apply (args: HadoopClusterArgs) =
                args.ClusterVersion <- io clusterVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: HadoopClusterArgs) =
                   args.ComponentVersion <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: HadoopClusterArgs) =
                   args.Gateway <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: HadoopClusterArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: HadoopClusterArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: HadoopClusterArgs) =
                   args.Metastores <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: HadoopClusterArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: HadoopClusterArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: HadoopClusterArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: HadoopClusterArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: HadoopClusterArgs) =
                   args.Roles <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: HadoopClusterArgs) =
                   args.StorageAccountGen2 <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("storageAccounts")>]
        member _.StorageAccounts((name, args), storageAccounts) =
            let apply (args: HadoopClusterArgs) =
                args.StorageAccounts <- inputList storageAccounts
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: HadoopClusterArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tier")>]
        member _.Tier((name, args), tier) =
            let apply (args: HadoopClusterArgs) =
                args.Tier <- input tier
                args

            ()
            name, List.Cons(apply, args)

        member _.Tier((name, args), tier) =
            let apply (args: HadoopClusterArgs) =
                args.Tier <- io tier
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tlsMinVersion")>]
        member _.TlsMinVersion((name, args), tlsMinVersion) =
            let apply (args: HadoopClusterArgs) =
                args.TlsMinVersion <- input tlsMinVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.TlsMinVersion((name, args), tlsMinVersion) =
            let apply (args: HadoopClusterArgs) =
                args.TlsMinVersion <- io tlsMinVersion
                args

            ()
            name, List.Cons(apply, args)

    let hadoopCluster = HadoopClusterBuilder()

    type InteractiveQueryClusterBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            InteractiveQueryCluster(name, (List.fold func (InteractiveQueryClusterArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("clusterVersion")>]
        member _.ClusterVersion((name, args), clusterVersion) =
            let apply (args: InteractiveQueryClusterArgs) =
                args.ClusterVersion <- input clusterVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.ClusterVersion((name, args), clusterVersion) =
            let apply (args: InteractiveQueryClusterArgs) =
                args.ClusterVersion <- io clusterVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: InteractiveQueryClusterArgs) =
                   args.ComponentVersion <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: InteractiveQueryClusterArgs) =
                   args.Gateway <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: InteractiveQueryClusterArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: InteractiveQueryClusterArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: InteractiveQueryClusterArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: InteractiveQueryClusterArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: InteractiveQueryClusterArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: InteractiveQueryClusterArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: InteractiveQueryClusterArgs) =
                   args.Roles <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: InteractiveQueryClusterArgs) =
                   args.StorageAccountGen2 <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("storageAccounts")>]
        member _.StorageAccounts((name, args), storageAccounts) =
            let apply (args: InteractiveQueryClusterArgs) =
                args.StorageAccounts <- inputList storageAccounts
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: InteractiveQueryClusterArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tier")>]
        member _.Tier((name, args), tier) =
            let apply (args: InteractiveQueryClusterArgs) =
                args.Tier <- input tier
                args

            ()
            name, List.Cons(apply, args)

        member _.Tier((name, args), tier) =
            let apply (args: InteractiveQueryClusterArgs) =
                args.Tier <- io tier
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tlsMinVersion")>]
        member _.TlsMinVersion((name, args), tlsMinVersion) =
            let apply (args: InteractiveQueryClusterArgs) =
                args.TlsMinVersion <- input tlsMinVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.TlsMinVersion((name, args), tlsMinVersion) =
            let apply (args: InteractiveQueryClusterArgs) =
                args.TlsMinVersion <- io tlsMinVersion
                args

            ()
            name, List.Cons(apply, args)

    let interactiveQueryCluster = InteractiveQueryClusterBuilder()

    type KafkaClusterBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            KafkaCluster(name, (List.fold func (KafkaClusterArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("clusterVersion")>]
        member _.ClusterVersion((name, args), clusterVersion) =
            let apply (args: KafkaClusterArgs) =
                args.ClusterVersion <- input clusterVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.ClusterVersion((name, args), clusterVersion) =
            let apply (args: KafkaClusterArgs) =
                args.ClusterVersion <- io clusterVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: KafkaClusterArgs) =
                   args.ComponentVersion <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: KafkaClusterArgs) =
                   args.Gateway <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: KafkaClusterArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: KafkaClusterArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: KafkaClusterArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: KafkaClusterArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: KafkaClusterArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: KafkaClusterArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: KafkaClusterArgs) =
                   args.Roles <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: KafkaClusterArgs) =
                   args.StorageAccountGen2 <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("storageAccounts")>]
        member _.StorageAccounts((name, args), storageAccounts) =
            let apply (args: KafkaClusterArgs) =
                args.StorageAccounts <- inputList storageAccounts
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: KafkaClusterArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tier")>]
        member _.Tier((name, args), tier) =
            let apply (args: KafkaClusterArgs) =
                args.Tier <- input tier
                args

            ()
            name, List.Cons(apply, args)

        member _.Tier((name, args), tier) =
            let apply (args: KafkaClusterArgs) =
                args.Tier <- io tier
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tlsMinVersion")>]
        member _.TlsMinVersion((name, args), tlsMinVersion) =
            let apply (args: KafkaClusterArgs) =
                args.TlsMinVersion <- input tlsMinVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.TlsMinVersion((name, args), tlsMinVersion) =
            let apply (args: KafkaClusterArgs) =
                args.TlsMinVersion <- io tlsMinVersion
                args

            ()
            name, List.Cons(apply, args)

    let kafkaCluster = KafkaClusterBuilder()

    type MLServicesClusterBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            MLServicesCluster(name, (List.fold func (MLServicesClusterArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("clusterVersion")>]
        member _.ClusterVersion((name, args), clusterVersion) =
            let apply (args: MLServicesClusterArgs) =
                args.ClusterVersion <- input clusterVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.ClusterVersion((name, args), clusterVersion) =
            let apply (args: MLServicesClusterArgs) =
                args.ClusterVersion <- io clusterVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: MLServicesClusterArgs) =
                   args.Gateway <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: MLServicesClusterArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: MLServicesClusterArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: MLServicesClusterArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: MLServicesClusterArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: MLServicesClusterArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: MLServicesClusterArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: MLServicesClusterArgs) =
                   args.Roles <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("rstudio")>]
        member _.Rstudio((name, args), rstudio) =
            let apply (args: MLServicesClusterArgs) =
                args.Rstudio <- input rstudio
                args

            ()
            name, List.Cons(apply, args)

        member _.Rstudio((name, args), rstudio) =
            let apply (args: MLServicesClusterArgs) =
                args.Rstudio <- io rstudio
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageAccounts")>]
        member _.StorageAccounts((name, args), storageAccounts) =
            let apply (args: MLServicesClusterArgs) =
                args.StorageAccounts <- inputList storageAccounts
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: MLServicesClusterArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tier")>]
        member _.Tier((name, args), tier) =
            let apply (args: MLServicesClusterArgs) =
                args.Tier <- input tier
                args

            ()
            name, List.Cons(apply, args)

        member _.Tier((name, args), tier) =
            let apply (args: MLServicesClusterArgs) =
                args.Tier <- io tier
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tlsMinVersion")>]
        member _.TlsMinVersion((name, args), tlsMinVersion) =
            let apply (args: MLServicesClusterArgs) =
                args.TlsMinVersion <- input tlsMinVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.TlsMinVersion((name, args), tlsMinVersion) =
            let apply (args: MLServicesClusterArgs) =
                args.TlsMinVersion <- io tlsMinVersion
                args

            ()
            name, List.Cons(apply, args)

    let mLServicesCluster = MLServicesClusterBuilder()

    type RServerClusterBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            RServerCluster(name, (List.fold func (RServerClusterArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("clusterVersion")>]
        member _.ClusterVersion((name, args), clusterVersion) =
            let apply (args: RServerClusterArgs) =
                args.ClusterVersion <- input clusterVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.ClusterVersion((name, args), clusterVersion) =
            let apply (args: RServerClusterArgs) =
                args.ClusterVersion <- io clusterVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: RServerClusterArgs) =
                   args.Gateway <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: RServerClusterArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: RServerClusterArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: RServerClusterArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: RServerClusterArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: RServerClusterArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: RServerClusterArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: RServerClusterArgs) =
                   args.Roles <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("rstudio")>]
        member _.Rstudio((name, args), rstudio) =
            let apply (args: RServerClusterArgs) =
                args.Rstudio <- input rstudio
                args

            ()
            name, List.Cons(apply, args)

        member _.Rstudio((name, args), rstudio) =
            let apply (args: RServerClusterArgs) =
                args.Rstudio <- io rstudio
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageAccounts")>]
        member _.StorageAccounts((name, args), storageAccounts) =
            let apply (args: RServerClusterArgs) =
                args.StorageAccounts <- inputList storageAccounts
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: RServerClusterArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tier")>]
        member _.Tier((name, args), tier) =
            let apply (args: RServerClusterArgs) =
                args.Tier <- input tier
                args

            ()
            name, List.Cons(apply, args)

        member _.Tier((name, args), tier) =
            let apply (args: RServerClusterArgs) =
                args.Tier <- io tier
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tlsMinVersion")>]
        member _.TlsMinVersion((name, args), tlsMinVersion) =
            let apply (args: RServerClusterArgs) =
                args.TlsMinVersion <- input tlsMinVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.TlsMinVersion((name, args), tlsMinVersion) =
            let apply (args: RServerClusterArgs) =
                args.TlsMinVersion <- io tlsMinVersion
                args

            ()
            name, List.Cons(apply, args)

    let rServerCluster = RServerClusterBuilder()

    type SparkClusterBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            SparkCluster(name, (List.fold func (SparkClusterArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("clusterVersion")>]
        member _.ClusterVersion((name, args), clusterVersion) =
            let apply (args: SparkClusterArgs) =
                args.ClusterVersion <- input clusterVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.ClusterVersion((name, args), clusterVersion) =
            let apply (args: SparkClusterArgs) =
                args.ClusterVersion <- io clusterVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: SparkClusterArgs) =
                   args.ComponentVersion <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: SparkClusterArgs) =
                   args.Gateway <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: SparkClusterArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: SparkClusterArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: SparkClusterArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: SparkClusterArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SparkClusterArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SparkClusterArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: SparkClusterArgs) =
                   args.Roles <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: SparkClusterArgs) =
                   args.StorageAccountGen2 <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("storageAccounts")>]
        member _.StorageAccounts((name, args), storageAccounts) =
            let apply (args: SparkClusterArgs) =
                args.StorageAccounts <- inputList storageAccounts
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: SparkClusterArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tier")>]
        member _.Tier((name, args), tier) =
            let apply (args: SparkClusterArgs) =
                args.Tier <- input tier
                args

            ()
            name, List.Cons(apply, args)

        member _.Tier((name, args), tier) =
            let apply (args: SparkClusterArgs) =
                args.Tier <- io tier
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tlsMinVersion")>]
        member _.TlsMinVersion((name, args), tlsMinVersion) =
            let apply (args: SparkClusterArgs) =
                args.TlsMinVersion <- input tlsMinVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.TlsMinVersion((name, args), tlsMinVersion) =
            let apply (args: SparkClusterArgs) =
                args.TlsMinVersion <- io tlsMinVersion
                args

            ()
            name, List.Cons(apply, args)

    let sparkCluster = SparkClusterBuilder()

    type StormClusterBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            StormCluster(name, (List.fold func (StormClusterArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("clusterVersion")>]
        member _.ClusterVersion((name, args), clusterVersion) =
            let apply (args: StormClusterArgs) =
                args.ClusterVersion <- input clusterVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.ClusterVersion((name, args), clusterVersion) =
            let apply (args: StormClusterArgs) =
                args.ClusterVersion <- io clusterVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: StormClusterArgs) =
                   args.ComponentVersion <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: StormClusterArgs) =
                   args.Gateway <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: StormClusterArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: StormClusterArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: StormClusterArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: StormClusterArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: StormClusterArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: StormClusterArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: StormClusterArgs) =
                   args.Roles <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("storageAccounts")>]
        member _.StorageAccounts((name, args), storageAccounts) =
            let apply (args: StormClusterArgs) =
                args.StorageAccounts <- inputList storageAccounts
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: StormClusterArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tier")>]
        member _.Tier((name, args), tier) =
            let apply (args: StormClusterArgs) =
                args.Tier <- input tier
                args

            ()
            name, List.Cons(apply, args)

        member _.Tier((name, args), tier) =
            let apply (args: StormClusterArgs) =
                args.Tier <- io tier
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tlsMinVersion")>]
        member _.TlsMinVersion((name, args), tlsMinVersion) =
            let apply (args: StormClusterArgs) =
                args.TlsMinVersion <- input tlsMinVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.TlsMinVersion((name, args), tlsMinVersion) =
            let apply (args: StormClusterArgs) =
                args.TlsMinVersion <- io tlsMinVersion
                args

            ()
            name, List.Cons(apply, args)

    let stormCluster = StormClusterBuilder()

module Healthcare =
    open Pulumi.Azure.Healthcare
    open Pulumi.Azure.Healthcare.Inputs

    type ServiceAuthenticationConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ServiceAuthenticationConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("audience")>]
        member _.Audience((n, args), audience) =
            let apply (args: ServiceAuthenticationConfigurationArgs) =
                args.Audience <- input audience
                args

            ()
            n, List.Cons(apply, args)

        member _.Audience((n, args), audience) =
            let apply (args: ServiceAuthenticationConfigurationArgs) =
                args.Audience <- io audience
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("authority")>]
        member _.Authority((n, args), authority) =
            let apply (args: ServiceAuthenticationConfigurationArgs) =
                args.Authority <- input authority
                args

            ()
            n, List.Cons(apply, args)

        member _.Authority((n, args), authority) =
            let apply (args: ServiceAuthenticationConfigurationArgs) =
                args.Authority <- io authority
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("smartProxyEnabled")>]
        member _.SmartProxyEnabled((n, args), smartProxyEnabled) =
            let apply (args: ServiceAuthenticationConfigurationArgs) =
                args.SmartProxyEnabled <- input smartProxyEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.SmartProxyEnabled((n, args), smartProxyEnabled) =
            let apply (args: ServiceAuthenticationConfigurationArgs) =
                args.SmartProxyEnabled <- io smartProxyEnabled
                args

            ()
            n, List.Cons(apply, args)

    let serviceAuthenticationConfiguration =
        ServiceAuthenticationConfigurationBuilder()

    type ServiceCorsConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ServiceCorsConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("allowCredentials")>]
        member _.AllowCredentials((n, args), allowCredentials) =
            let apply (args: ServiceCorsConfigurationArgs) =
                args.AllowCredentials <- input allowCredentials
                args

            ()
            n, List.Cons(apply, args)

        member _.AllowCredentials((n, args), allowCredentials) =
            let apply (args: ServiceCorsConfigurationArgs) =
                args.AllowCredentials <- io allowCredentials
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("allowedHeaders")>]
        member _.AllowedHeaders((n, args), allowedHeaders) =
            let apply (args: ServiceCorsConfigurationArgs) =
                args.AllowedHeaders <- inputList allowedHeaders
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("allowedMethods")>]
        member _.AllowedMethods((n, args), allowedMethods) =
            let apply (args: ServiceCorsConfigurationArgs) =
                args.AllowedMethods <- inputList allowedMethods
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("allowedOrigins")>]
        member _.AllowedOrigins((n, args), allowedOrigins) =
            let apply (args: ServiceCorsConfigurationArgs) =
                args.AllowedOrigins <- inputList allowedOrigins
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("maxAgeInSeconds")>]
        member _.MaxAgeInSeconds((n, args), maxAgeInSeconds) =
            let apply (args: ServiceCorsConfigurationArgs) =
                args.MaxAgeInSeconds <- input maxAgeInSeconds
                args

            ()
            n, List.Cons(apply, args)

        member _.MaxAgeInSeconds((n, args), maxAgeInSeconds) =
            let apply (args: ServiceCorsConfigurationArgs) =
                args.MaxAgeInSeconds <- io maxAgeInSeconds
                args

            ()
            n, List.Cons(apply, args)

    let serviceCorsConfiguration = ServiceCorsConfigurationBuilder()

    type ServiceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Service(name, (List.fold func (ServiceArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("accessPolicyObjectIds")>]
        member _.AccessPolicyObjectIds((name, args), accessPolicyObjectIds) =
            let apply (args: ServiceArgs) =
                args.AccessPolicyObjectIds <- inputList accessPolicyObjectIds
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ServiceArgs) =
                   args.AuthenticationConfiguration <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: ServiceArgs) =
                   args.CorsConfiguration <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("cosmosdbThroughput")>]
        member _.CosmosdbThroughput((name, args), cosmosdbThroughput) =
            let apply (args: ServiceArgs) =
                args.CosmosdbThroughput <- input cosmosdbThroughput
                args

            ()
            name, List.Cons(apply, args)

        member _.CosmosdbThroughput((name, args), cosmosdbThroughput) =
            let apply (args: ServiceArgs) =
                args.CosmosdbThroughput <- io cosmosdbThroughput
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("kind")>]
        member _.Kind((name, args), kind) =
            let apply (args: ServiceArgs) =
                args.Kind <- input kind
                args

            ()
            name, List.Cons(apply, args)

        member _.Kind((name, args), kind) =
            let apply (args: ServiceArgs) =
                args.Kind <- io kind
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ServiceArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ServiceArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ServiceArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ServiceArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ServiceArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ServiceArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ServiceArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let service = ServiceBuilder()

module Hpc =
    open Pulumi.Azure.Hpc
    open Pulumi.Azure.Hpc.Inputs

    type CacheNfsTargetNamespaceJunctionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (CacheNfsTargetNamespaceJunctionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("namespacePath")>]
        member _.NamespacePath((n, args), namespacePath) =
            let apply (args: CacheNfsTargetNamespaceJunctionArgs) =
                args.NamespacePath <- input namespacePath
                args

            ()
            n, List.Cons(apply, args)

        member _.NamespacePath((n, args), namespacePath) =
            let apply (args: CacheNfsTargetNamespaceJunctionArgs) =
                args.NamespacePath <- io namespacePath
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("nfsExport")>]
        member _.NfsExport((n, args), nfsExport) =
            let apply (args: CacheNfsTargetNamespaceJunctionArgs) =
                args.NfsExport <- input nfsExport
                args

            ()
            n, List.Cons(apply, args)

        member _.NfsExport((n, args), nfsExport) =
            let apply (args: CacheNfsTargetNamespaceJunctionArgs) =
                args.NfsExport <- io nfsExport
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("targetPath")>]
        member _.TargetPath((n, args), targetPath) =
            let apply (args: CacheNfsTargetNamespaceJunctionArgs) =
                args.TargetPath <- input targetPath
                args

            ()
            n, List.Cons(apply, args)

        member _.TargetPath((n, args), targetPath) =
            let apply (args: CacheNfsTargetNamespaceJunctionArgs) =
                args.TargetPath <- io targetPath
                args

            ()
            n, List.Cons(apply, args)

    let cacheNfsTargetNamespaceJunction = CacheNfsTargetNamespaceJunctionBuilder()

    type CacheBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Cache(name, (List.fold func (CacheArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("cacheSizeInGb")>]
        member _.CacheSizeInGb((name, args), cacheSizeInGb) =
            let apply (args: CacheArgs) =
                args.CacheSizeInGb <- input cacheSizeInGb
                args

            ()
            name, List.Cons(apply, args)

        member _.CacheSizeInGb((name, args), cacheSizeInGb) =
            let apply (args: CacheArgs) =
                args.CacheSizeInGb <- io cacheSizeInGb
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: CacheArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: CacheArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: CacheArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: CacheArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: CacheArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: CacheArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("skuName")>]
        member _.SkuName((name, args), skuName) =
            let apply (args: CacheArgs) =
                args.SkuName <- input skuName
                args

            ()
            name, List.Cons(apply, args)

        member _.SkuName((name, args), skuName) =
            let apply (args: CacheArgs) =
                args.SkuName <- io skuName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((name, args), subnetId) =
            let apply (args: CacheArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            name, List.Cons(apply, args)

        member _.SubnetId((name, args), subnetId) =
            let apply (args: CacheArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            name, List.Cons(apply, args)

    let cache = CacheBuilder()

    type CacheBlobTargetBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            CacheBlobTarget(name, (List.fold func (CacheBlobTargetArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("cacheName")>]
        member _.CacheName((name, args), cacheName) =
            let apply (args: CacheBlobTargetArgs) =
                args.CacheName <- input cacheName
                args

            ()
            name, List.Cons(apply, args)

        member _.CacheName((name, args), cacheName) =
            let apply (args: CacheBlobTargetArgs) =
                args.CacheName <- io cacheName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: CacheBlobTargetArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: CacheBlobTargetArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("namespacePath")>]
        member _.NamespacePath((name, args), namespacePath) =
            let apply (args: CacheBlobTargetArgs) =
                args.NamespacePath <- input namespacePath
                args

            ()
            name, List.Cons(apply, args)

        member _.NamespacePath((name, args), namespacePath) =
            let apply (args: CacheBlobTargetArgs) =
                args.NamespacePath <- io namespacePath
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: CacheBlobTargetArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: CacheBlobTargetArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageContainerId")>]
        member _.StorageContainerId((name, args), storageContainerId) =
            let apply (args: CacheBlobTargetArgs) =
                args.StorageContainerId <- input storageContainerId
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageContainerId((name, args), storageContainerId) =
            let apply (args: CacheBlobTargetArgs) =
                args.StorageContainerId <- io storageContainerId
                args

            ()
            name, List.Cons(apply, args)

    let cacheBlobTarget = CacheBlobTargetBuilder()

    type CacheNfsTargetBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            CacheNfsTarget(name, (List.fold func (CacheNfsTargetArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("cacheName")>]
        member _.CacheName((name, args), cacheName) =
            let apply (args: CacheNfsTargetArgs) =
                args.CacheName <- input cacheName
                args

            ()
            name, List.Cons(apply, args)

        member _.CacheName((name, args), cacheName) =
            let apply (args: CacheNfsTargetArgs) =
                args.CacheName <- io cacheName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: CacheNfsTargetArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: CacheNfsTargetArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("namespaceJunctions")>]
        member _.NamespaceJunctions((name, args), namespaceJunctions) =
            let apply (args: CacheNfsTargetArgs) =
                args.NamespaceJunctions <- inputList namespaceJunctions
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: CacheNfsTargetArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: CacheNfsTargetArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("targetHostName")>]
        member _.TargetHostName((name, args), targetHostName) =
            let apply (args: CacheNfsTargetArgs) =
                args.TargetHostName <- input targetHostName
                args

            ()
            name, List.Cons(apply, args)

        member _.TargetHostName((name, args), targetHostName) =
            let apply (args: CacheNfsTargetArgs) =
                args.TargetHostName <- io targetHostName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("usageModel")>]
        member _.UsageModel((name, args), usageModel) =
            let apply (args: CacheNfsTargetArgs) =
                args.UsageModel <- input usageModel
                args

            ()
            name, List.Cons(apply, args)

        member _.UsageModel((name, args), usageModel) =
            let apply (args: CacheNfsTargetArgs) =
                args.UsageModel <- io usageModel
                args

            ()
            name, List.Cons(apply, args)

    let cacheNfsTarget = CacheNfsTargetBuilder()

module Iot =
    open Pulumi.Azure.Iot
    open Pulumi.Azure.Iot.Inputs

    type IoTHubEndpointBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (IoTHubEndpointArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("batchFrequencyInSeconds")>]
        member _.BatchFrequencyInSeconds((n, args), batchFrequencyInSeconds) =
            let apply (args: IoTHubEndpointArgs) =
                args.BatchFrequencyInSeconds <- input batchFrequencyInSeconds
                args

            ()
            n, List.Cons(apply, args)

        member _.BatchFrequencyInSeconds((n, args), batchFrequencyInSeconds) =
            let apply (args: IoTHubEndpointArgs) =
                args.BatchFrequencyInSeconds <- io batchFrequencyInSeconds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("connectionString")>]
        member _.ConnectionString((n, args), connectionString) =
            let apply (args: IoTHubEndpointArgs) =
                args.ConnectionString <- input connectionString
                args

            ()
            n, List.Cons(apply, args)

        member _.ConnectionString((n, args), connectionString) =
            let apply (args: IoTHubEndpointArgs) =
                args.ConnectionString <- io connectionString
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("containerName")>]
        member _.ContainerName((n, args), containerName) =
            let apply (args: IoTHubEndpointArgs) =
                args.ContainerName <- input containerName
                args

            ()
            n, List.Cons(apply, args)

        member _.ContainerName((n, args), containerName) =
            let apply (args: IoTHubEndpointArgs) =
                args.ContainerName <- io containerName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("encoding")>]
        member _.Encoding((n, args), encoding) =
            let apply (args: IoTHubEndpointArgs) =
                args.Encoding <- input encoding
                args

            ()
            n, List.Cons(apply, args)

        member _.Encoding((n, args), encoding) =
            let apply (args: IoTHubEndpointArgs) =
                args.Encoding <- io encoding
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("fileNameFormat")>]
        member _.FileNameFormat((n, args), fileNameFormat) =
            let apply (args: IoTHubEndpointArgs) =
                args.FileNameFormat <- input fileNameFormat
                args

            ()
            n, List.Cons(apply, args)

        member _.FileNameFormat((n, args), fileNameFormat) =
            let apply (args: IoTHubEndpointArgs) =
                args.FileNameFormat <- io fileNameFormat
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("maxChunkSizeInBytes")>]
        member _.MaxChunkSizeInBytes((n, args), maxChunkSizeInBytes) =
            let apply (args: IoTHubEndpointArgs) =
                args.MaxChunkSizeInBytes <- input maxChunkSizeInBytes
                args

            ()
            n, List.Cons(apply, args)

        member _.MaxChunkSizeInBytes((n, args), maxChunkSizeInBytes) =
            let apply (args: IoTHubEndpointArgs) =
                args.MaxChunkSizeInBytes <- io maxChunkSizeInBytes
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: IoTHubEndpointArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: IoTHubEndpointArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: IoTHubEndpointArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: IoTHubEndpointArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let ioTHubEndpoint = IoTHubEndpointBuilder()

    type IoTHubFallbackRouteBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (IoTHubFallbackRouteArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("condition")>]
        member _.Condition((n, args), condition) =
            let apply (args: IoTHubFallbackRouteArgs) =
                args.Condition <- input condition
                args

            ()
            n, List.Cons(apply, args)

        member _.Condition((n, args), condition) =
            let apply (args: IoTHubFallbackRouteArgs) =
                args.Condition <- io condition
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: IoTHubFallbackRouteArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: IoTHubFallbackRouteArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("endpointNames")>]
        member _.EndpointNames((n, args), endpointNames) =
            let apply (args: IoTHubFallbackRouteArgs) =
                args.EndpointNames <- inputList endpointNames
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("source")>]
        member _.Source((n, args), source) =
            let apply (args: IoTHubFallbackRouteArgs) =
                args.Source <- input source
                args

            ()
            n, List.Cons(apply, args)

        member _.Source((n, args), source) =
            let apply (args: IoTHubFallbackRouteArgs) =
                args.Source <- io source
                args

            ()
            n, List.Cons(apply, args)

    let ioTHubFallbackRoute = IoTHubFallbackRouteBuilder()

    type IoTHubFileUploadBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (IoTHubFileUploadArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("connectionString")>]
        member _.ConnectionString((n, args), connectionString) =
            let apply (args: IoTHubFileUploadArgs) =
                args.ConnectionString <- input connectionString
                args

            ()
            n, List.Cons(apply, args)

        member _.ConnectionString((n, args), connectionString) =
            let apply (args: IoTHubFileUploadArgs) =
                args.ConnectionString <- io connectionString
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("containerName")>]
        member _.ContainerName((n, args), containerName) =
            let apply (args: IoTHubFileUploadArgs) =
                args.ContainerName <- input containerName
                args

            ()
            n, List.Cons(apply, args)

        member _.ContainerName((n, args), containerName) =
            let apply (args: IoTHubFileUploadArgs) =
                args.ContainerName <- io containerName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("defaultTtl")>]
        member _.DefaultTtl((n, args), defaultTtl) =
            let apply (args: IoTHubFileUploadArgs) =
                args.DefaultTtl <- input defaultTtl
                args

            ()
            n, List.Cons(apply, args)

        member _.DefaultTtl((n, args), defaultTtl) =
            let apply (args: IoTHubFileUploadArgs) =
                args.DefaultTtl <- io defaultTtl
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("lockDuration")>]
        member _.LockDuration((n, args), lockDuration) =
            let apply (args: IoTHubFileUploadArgs) =
                args.LockDuration <- input lockDuration
                args

            ()
            n, List.Cons(apply, args)

        member _.LockDuration((n, args), lockDuration) =
            let apply (args: IoTHubFileUploadArgs) =
                args.LockDuration <- io lockDuration
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("maxDeliveryCount")>]
        member _.MaxDeliveryCount((n, args), maxDeliveryCount) =
            let apply (args: IoTHubFileUploadArgs) =
                args.MaxDeliveryCount <- input maxDeliveryCount
                args

            ()
            n, List.Cons(apply, args)

        member _.MaxDeliveryCount((n, args), maxDeliveryCount) =
            let apply (args: IoTHubFileUploadArgs) =
                args.MaxDeliveryCount <- io maxDeliveryCount
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("notifications")>]
        member _.Notifications((n, args), notifications) =
            let apply (args: IoTHubFileUploadArgs) =
                args.Notifications <- input notifications
                args

            ()
            n, List.Cons(apply, args)

        member _.Notifications((n, args), notifications) =
            let apply (args: IoTHubFileUploadArgs) =
                args.Notifications <- io notifications
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sasTtl")>]
        member _.SasTtl((n, args), sasTtl) =
            let apply (args: IoTHubFileUploadArgs) =
                args.SasTtl <- input sasTtl
                args

            ()
            n, List.Cons(apply, args)

        member _.SasTtl((n, args), sasTtl) =
            let apply (args: IoTHubFileUploadArgs) =
                args.SasTtl <- io sasTtl
                args

            ()
            n, List.Cons(apply, args)

    let ioTHubFileUpload = IoTHubFileUploadBuilder()

    type IoTHubIpFilterRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (IoTHubIpFilterRuleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("action")>]
        member _.Action((n, args), action) =
            let apply (args: IoTHubIpFilterRuleArgs) =
                args.Action <- input action
                args

            ()
            n, List.Cons(apply, args)

        member _.Action((n, args), action) =
            let apply (args: IoTHubIpFilterRuleArgs) =
                args.Action <- io action
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ipMask")>]
        member _.IpMask((n, args), ipMask) =
            let apply (args: IoTHubIpFilterRuleArgs) =
                args.IpMask <- input ipMask
                args

            ()
            n, List.Cons(apply, args)

        member _.IpMask((n, args), ipMask) =
            let apply (args: IoTHubIpFilterRuleArgs) =
                args.IpMask <- io ipMask
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: IoTHubIpFilterRuleArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: IoTHubIpFilterRuleArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

    let ioTHubIpFilterRule = IoTHubIpFilterRuleBuilder()

    type IoTHubRouteBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (IoTHubRouteArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("condition")>]
        member _.Condition((n, args), condition) =
            let apply (args: IoTHubRouteArgs) =
                args.Condition <- input condition
                args

            ()
            n, List.Cons(apply, args)

        member _.Condition((n, args), condition) =
            let apply (args: IoTHubRouteArgs) =
                args.Condition <- io condition
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: IoTHubRouteArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: IoTHubRouteArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("endpointNames")>]
        member _.EndpointNames((n, args), endpointNames) =
            let apply (args: IoTHubRouteArgs) =
                args.EndpointNames <- inputList endpointNames
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: IoTHubRouteArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: IoTHubRouteArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("source")>]
        member _.Source((n, args), source) =
            let apply (args: IoTHubRouteArgs) =
                args.Source <- input source
                args

            ()
            n, List.Cons(apply, args)

        member _.Source((n, args), source) =
            let apply (args: IoTHubRouteArgs) =
                args.Source <- io source
                args

            ()
            n, List.Cons(apply, args)

    let ioTHubRoute = IoTHubRouteBuilder()

    type IoTHubSharedAccessPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (IoTHubSharedAccessPolicyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("keyName")>]
        member _.KeyName((n, args), keyName) =
            let apply (args: IoTHubSharedAccessPolicyArgs) =
                args.KeyName <- input keyName
                args

            ()
            n, List.Cons(apply, args)

        member _.KeyName((n, args), keyName) =
            let apply (args: IoTHubSharedAccessPolicyArgs) =
                args.KeyName <- io keyName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("permissions")>]
        member _.Permissions((n, args), permissions) =
            let apply (args: IoTHubSharedAccessPolicyArgs) =
                args.Permissions <- input permissions
                args

            ()
            n, List.Cons(apply, args)

        member _.Permissions((n, args), permissions) =
            let apply (args: IoTHubSharedAccessPolicyArgs) =
                args.Permissions <- io permissions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("primaryKey")>]
        member _.PrimaryKey((n, args), primaryKey) =
            let apply (args: IoTHubSharedAccessPolicyArgs) =
                args.PrimaryKey <- input primaryKey
                args

            ()
            n, List.Cons(apply, args)

        member _.PrimaryKey((n, args), primaryKey) =
            let apply (args: IoTHubSharedAccessPolicyArgs) =
                args.PrimaryKey <- io primaryKey
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("secondaryKey")>]
        member _.SecondaryKey((n, args), secondaryKey) =
            let apply (args: IoTHubSharedAccessPolicyArgs) =
                args.SecondaryKey <- input secondaryKey
                args

            ()
            n, List.Cons(apply, args)

        member _.SecondaryKey((n, args), secondaryKey) =
            let apply (args: IoTHubSharedAccessPolicyArgs) =
                args.SecondaryKey <- io secondaryKey
                args

            ()
            n, List.Cons(apply, args)

    let ioTHubSharedAccessPolicy = IoTHubSharedAccessPolicyBuilder()

    type IoTHubSkuBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (IoTHubSkuArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("capacity")>]
        member _.Capacity((n, args), capacity) =
            let apply (args: IoTHubSkuArgs) =
                args.Capacity <- input capacity
                args

            ()
            n, List.Cons(apply, args)

        member _.Capacity((n, args), capacity) =
            let apply (args: IoTHubSkuArgs) =
                args.Capacity <- io capacity
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: IoTHubSkuArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: IoTHubSkuArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

    let ioTHubSku = IoTHubSkuBuilder()

    type IotHubDpsLinkedHubBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (IotHubDpsLinkedHubArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("allocationWeight")>]
        member _.AllocationWeight((n, args), allocationWeight) =
            let apply (args: IotHubDpsLinkedHubArgs) =
                args.AllocationWeight <- input allocationWeight
                args

            ()
            n, List.Cons(apply, args)

        member _.AllocationWeight((n, args), allocationWeight) =
            let apply (args: IotHubDpsLinkedHubArgs) =
                args.AllocationWeight <- io allocationWeight
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("applyAllocationPolicy")>]
        member _.ApplyAllocationPolicy((n, args), applyAllocationPolicy) =
            let apply (args: IotHubDpsLinkedHubArgs) =
                args.ApplyAllocationPolicy <- input applyAllocationPolicy
                args

            ()
            n, List.Cons(apply, args)

        member _.ApplyAllocationPolicy((n, args), applyAllocationPolicy) =
            let apply (args: IotHubDpsLinkedHubArgs) =
                args.ApplyAllocationPolicy <- io applyAllocationPolicy
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("connectionString")>]
        member _.ConnectionString((n, args), connectionString) =
            let apply (args: IotHubDpsLinkedHubArgs) =
                args.ConnectionString <- input connectionString
                args

            ()
            n, List.Cons(apply, args)

        member _.ConnectionString((n, args), connectionString) =
            let apply (args: IotHubDpsLinkedHubArgs) =
                args.ConnectionString <- io connectionString
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("hostname")>]
        member _.Hostname((n, args), hostname) =
            let apply (args: IotHubDpsLinkedHubArgs) =
                args.Hostname <- input hostname
                args

            ()
            n, List.Cons(apply, args)

        member _.Hostname((n, args), hostname) =
            let apply (args: IotHubDpsLinkedHubArgs) =
                args.Hostname <- io hostname
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((n, args), location) =
            let apply (args: IotHubDpsLinkedHubArgs) =
                args.Location <- input location
                args

            ()
            n, List.Cons(apply, args)

        member _.Location((n, args), location) =
            let apply (args: IotHubDpsLinkedHubArgs) =
                args.Location <- io location
                args

            ()
            n, List.Cons(apply, args)

    let iotHubDpsLinkedHub = IotHubDpsLinkedHubBuilder()

    type IotHubDpsSkuBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (IotHubDpsSkuArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("capacity")>]
        member _.Capacity((n, args), capacity) =
            let apply (args: IotHubDpsSkuArgs) =
                args.Capacity <- input capacity
                args

            ()
            n, List.Cons(apply, args)

        member _.Capacity((n, args), capacity) =
            let apply (args: IotHubDpsSkuArgs) =
                args.Capacity <- io capacity
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: IotHubDpsSkuArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: IotHubDpsSkuArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

    let iotHubDpsSku = IotHubDpsSkuBuilder()

    type TimeSeriesInsightsReferenceDataSetKeyPropertyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (TimeSeriesInsightsReferenceDataSetKeyPropertyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: TimeSeriesInsightsReferenceDataSetKeyPropertyArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: TimeSeriesInsightsReferenceDataSetKeyPropertyArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: TimeSeriesInsightsReferenceDataSetKeyPropertyArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: TimeSeriesInsightsReferenceDataSetKeyPropertyArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let timeSeriesInsightsReferenceDataSetKeyProperty =
        TimeSeriesInsightsReferenceDataSetKeyPropertyBuilder()

    type ConsumerGroupBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ConsumerGroup(name, (List.fold func (ConsumerGroupArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("eventhubEndpointName")>]
        member _.EventhubEndpointName((name, args), eventhubEndpointName) =
            let apply (args: ConsumerGroupArgs) =
                args.EventhubEndpointName <- input eventhubEndpointName
                args

            ()
            name, List.Cons(apply, args)

        member _.EventhubEndpointName((name, args), eventhubEndpointName) =
            let apply (args: ConsumerGroupArgs) =
                args.EventhubEndpointName <- io eventhubEndpointName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("iothubName")>]
        member _.IothubName((name, args), iothubName) =
            let apply (args: ConsumerGroupArgs) =
                args.IothubName <- input iothubName
                args

            ()
            name, List.Cons(apply, args)

        member _.IothubName((name, args), iothubName) =
            let apply (args: ConsumerGroupArgs) =
                args.IothubName <- io iothubName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ConsumerGroupArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ConsumerGroupArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ConsumerGroupArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ConsumerGroupArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let consumerGroup = ConsumerGroupBuilder()

    type DpsSharedAccessPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            DpsSharedAccessPolicy(name, (List.fold func (DpsSharedAccessPolicyArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("enrollmentRead")>]
        member _.EnrollmentRead((name, args), enrollmentRead) =
            let apply (args: DpsSharedAccessPolicyArgs) =
                args.EnrollmentRead <- input enrollmentRead
                args

            ()
            name, List.Cons(apply, args)

        member _.EnrollmentRead((name, args), enrollmentRead) =
            let apply (args: DpsSharedAccessPolicyArgs) =
                args.EnrollmentRead <- io enrollmentRead
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enrollmentWrite")>]
        member _.EnrollmentWrite((name, args), enrollmentWrite) =
            let apply (args: DpsSharedAccessPolicyArgs) =
                args.EnrollmentWrite <- input enrollmentWrite
                args

            ()
            name, List.Cons(apply, args)

        member _.EnrollmentWrite((name, args), enrollmentWrite) =
            let apply (args: DpsSharedAccessPolicyArgs) =
                args.EnrollmentWrite <- io enrollmentWrite
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("iothubDpsName")>]
        member _.IothubDpsName((name, args), iothubDpsName) =
            let apply (args: DpsSharedAccessPolicyArgs) =
                args.IothubDpsName <- input iothubDpsName
                args

            ()
            name, List.Cons(apply, args)

        member _.IothubDpsName((name, args), iothubDpsName) =
            let apply (args: DpsSharedAccessPolicyArgs) =
                args.IothubDpsName <- io iothubDpsName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: DpsSharedAccessPolicyArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: DpsSharedAccessPolicyArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("registrationRead")>]
        member _.RegistrationRead((name, args), registrationRead) =
            let apply (args: DpsSharedAccessPolicyArgs) =
                args.RegistrationRead <- input registrationRead
                args

            ()
            name, List.Cons(apply, args)

        member _.RegistrationRead((name, args), registrationRead) =
            let apply (args: DpsSharedAccessPolicyArgs) =
                args.RegistrationRead <- io registrationRead
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("registrationWrite")>]
        member _.RegistrationWrite((name, args), registrationWrite) =
            let apply (args: DpsSharedAccessPolicyArgs) =
                args.RegistrationWrite <- input registrationWrite
                args

            ()
            name, List.Cons(apply, args)

        member _.RegistrationWrite((name, args), registrationWrite) =
            let apply (args: DpsSharedAccessPolicyArgs) =
                args.RegistrationWrite <- io registrationWrite
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DpsSharedAccessPolicyArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DpsSharedAccessPolicyArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serviceConfig")>]
        member _.ServiceConfig((name, args), serviceConfig) =
            let apply (args: DpsSharedAccessPolicyArgs) =
                args.ServiceConfig <- input serviceConfig
                args

            ()
            name, List.Cons(apply, args)

        member _.ServiceConfig((name, args), serviceConfig) =
            let apply (args: DpsSharedAccessPolicyArgs) =
                args.ServiceConfig <- io serviceConfig
                args

            ()
            name, List.Cons(apply, args)

    let dpsSharedAccessPolicy = DpsSharedAccessPolicyBuilder()

    type EndpointEventhubBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            EndpointEventhub(name, (List.fold func (EndpointEventhubArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("connectionString")>]
        member _.ConnectionString((name, args), connectionString) =
            let apply (args: EndpointEventhubArgs) =
                args.ConnectionString <- input connectionString
                args

            ()
            name, List.Cons(apply, args)

        member _.ConnectionString((name, args), connectionString) =
            let apply (args: EndpointEventhubArgs) =
                args.ConnectionString <- io connectionString
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("iothubName")>]
        member _.IothubName((name, args), iothubName) =
            let apply (args: EndpointEventhubArgs) =
                args.IothubName <- input iothubName
                args

            ()
            name, List.Cons(apply, args)

        member _.IothubName((name, args), iothubName) =
            let apply (args: EndpointEventhubArgs) =
                args.IothubName <- io iothubName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: EndpointEventhubArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: EndpointEventhubArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: EndpointEventhubArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: EndpointEventhubArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let endpointEventhub = EndpointEventhubBuilder()

    type EndpointServicebusQueueBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            EndpointServicebusQueue(name, (List.fold func (EndpointServicebusQueueArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("connectionString")>]
        member _.ConnectionString((name, args), connectionString) =
            let apply (args: EndpointServicebusQueueArgs) =
                args.ConnectionString <- input connectionString
                args

            ()
            name, List.Cons(apply, args)

        member _.ConnectionString((name, args), connectionString) =
            let apply (args: EndpointServicebusQueueArgs) =
                args.ConnectionString <- io connectionString
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("iothubName")>]
        member _.IothubName((name, args), iothubName) =
            let apply (args: EndpointServicebusQueueArgs) =
                args.IothubName <- input iothubName
                args

            ()
            name, List.Cons(apply, args)

        member _.IothubName((name, args), iothubName) =
            let apply (args: EndpointServicebusQueueArgs) =
                args.IothubName <- io iothubName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: EndpointServicebusQueueArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: EndpointServicebusQueueArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: EndpointServicebusQueueArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: EndpointServicebusQueueArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let endpointServicebusQueue = EndpointServicebusQueueBuilder()

    type EndpointServicebusTopicBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            EndpointServicebusTopic(name, (List.fold func (EndpointServicebusTopicArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("connectionString")>]
        member _.ConnectionString((name, args), connectionString) =
            let apply (args: EndpointServicebusTopicArgs) =
                args.ConnectionString <- input connectionString
                args

            ()
            name, List.Cons(apply, args)

        member _.ConnectionString((name, args), connectionString) =
            let apply (args: EndpointServicebusTopicArgs) =
                args.ConnectionString <- io connectionString
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("iothubName")>]
        member _.IothubName((name, args), iothubName) =
            let apply (args: EndpointServicebusTopicArgs) =
                args.IothubName <- input iothubName
                args

            ()
            name, List.Cons(apply, args)

        member _.IothubName((name, args), iothubName) =
            let apply (args: EndpointServicebusTopicArgs) =
                args.IothubName <- io iothubName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: EndpointServicebusTopicArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: EndpointServicebusTopicArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: EndpointServicebusTopicArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: EndpointServicebusTopicArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let endpointServicebusTopic = EndpointServicebusTopicBuilder()

    type EndpointStorageContainerBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            EndpointStorageContainer(name, (List.fold func (EndpointStorageContainerArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("batchFrequencyInSeconds")>]
        member _.BatchFrequencyInSeconds((name, args), batchFrequencyInSeconds) =
            let apply (args: EndpointStorageContainerArgs) =
                args.BatchFrequencyInSeconds <- input batchFrequencyInSeconds
                args

            ()
            name, List.Cons(apply, args)

        member _.BatchFrequencyInSeconds((name, args), batchFrequencyInSeconds) =
            let apply (args: EndpointStorageContainerArgs) =
                args.BatchFrequencyInSeconds <- io batchFrequencyInSeconds
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("connectionString")>]
        member _.ConnectionString((name, args), connectionString) =
            let apply (args: EndpointStorageContainerArgs) =
                args.ConnectionString <- input connectionString
                args

            ()
            name, List.Cons(apply, args)

        member _.ConnectionString((name, args), connectionString) =
            let apply (args: EndpointStorageContainerArgs) =
                args.ConnectionString <- io connectionString
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("containerName")>]
        member _.ContainerName((name, args), containerName) =
            let apply (args: EndpointStorageContainerArgs) =
                args.ContainerName <- input containerName
                args

            ()
            name, List.Cons(apply, args)

        member _.ContainerName((name, args), containerName) =
            let apply (args: EndpointStorageContainerArgs) =
                args.ContainerName <- io containerName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("encoding")>]
        member _.Encoding((name, args), encoding) =
            let apply (args: EndpointStorageContainerArgs) =
                args.Encoding <- input encoding
                args

            ()
            name, List.Cons(apply, args)

        member _.Encoding((name, args), encoding) =
            let apply (args: EndpointStorageContainerArgs) =
                args.Encoding <- io encoding
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("fileNameFormat")>]
        member _.FileNameFormat((name, args), fileNameFormat) =
            let apply (args: EndpointStorageContainerArgs) =
                args.FileNameFormat <- input fileNameFormat
                args

            ()
            name, List.Cons(apply, args)

        member _.FileNameFormat((name, args), fileNameFormat) =
            let apply (args: EndpointStorageContainerArgs) =
                args.FileNameFormat <- io fileNameFormat
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("iothubName")>]
        member _.IothubName((name, args), iothubName) =
            let apply (args: EndpointStorageContainerArgs) =
                args.IothubName <- input iothubName
                args

            ()
            name, List.Cons(apply, args)

        member _.IothubName((name, args), iothubName) =
            let apply (args: EndpointStorageContainerArgs) =
                args.IothubName <- io iothubName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("maxChunkSizeInBytes")>]
        member _.MaxChunkSizeInBytes((name, args), maxChunkSizeInBytes) =
            let apply (args: EndpointStorageContainerArgs) =
                args.MaxChunkSizeInBytes <- input maxChunkSizeInBytes
                args

            ()
            name, List.Cons(apply, args)

        member _.MaxChunkSizeInBytes((name, args), maxChunkSizeInBytes) =
            let apply (args: EndpointStorageContainerArgs) =
                args.MaxChunkSizeInBytes <- io maxChunkSizeInBytes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: EndpointStorageContainerArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: EndpointStorageContainerArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: EndpointStorageContainerArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: EndpointStorageContainerArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let endpointStorageContainer = EndpointStorageContainerBuilder()

    type FallbackRouteBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            FallbackRoute(name, (List.fold func (FallbackRouteArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("condition")>]
        member _.Condition((name, args), condition) =
            let apply (args: FallbackRouteArgs) =
                args.Condition <- input condition
                args

            ()
            name, List.Cons(apply, args)

        member _.Condition((name, args), condition) =
            let apply (args: FallbackRouteArgs) =
                args.Condition <- io condition
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((name, args), enabled) =
            let apply (args: FallbackRouteArgs) =
                args.Enabled <- input enabled
                args

            ()
            name, List.Cons(apply, args)

        member _.Enabled((name, args), enabled) =
            let apply (args: FallbackRouteArgs) =
                args.Enabled <- io enabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("endpointNames")>]
        member _.EndpointNames((name, args), endpointNames) =
            let apply (args: FallbackRouteArgs) =
                args.EndpointNames <- input endpointNames
                args

            ()
            name, List.Cons(apply, args)

        member _.EndpointNames((name, args), endpointNames) =
            let apply (args: FallbackRouteArgs) =
                args.EndpointNames <- io endpointNames
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("iothubName")>]
        member _.IothubName((name, args), iothubName) =
            let apply (args: FallbackRouteArgs) =
                args.IothubName <- input iothubName
                args

            ()
            name, List.Cons(apply, args)

        member _.IothubName((name, args), iothubName) =
            let apply (args: FallbackRouteArgs) =
                args.IothubName <- io iothubName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FallbackRouteArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FallbackRouteArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let fallbackRoute = FallbackRouteBuilder()

    type IoTHubBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            IoTHub(name, (List.fold func (IoTHubArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("endpoints")>]
        member _.Endpoints((name, args), endpoints) =
            let apply (args: IoTHubArgs) =
                args.Endpoints <- inputList endpoints
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("eventHubPartitionCount")>]
        member _.EventHubPartitionCount((name, args), eventHubPartitionCount) =
            let apply (args: IoTHubArgs) =
                args.EventHubPartitionCount <- input eventHubPartitionCount
                args

            ()
            name, List.Cons(apply, args)

        member _.EventHubPartitionCount((name, args), eventHubPartitionCount) =
            let apply (args: IoTHubArgs) =
                args.EventHubPartitionCount <- io eventHubPartitionCount
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("eventHubRetentionInDays")>]
        member _.EventHubRetentionInDays((name, args), eventHubRetentionInDays) =
            let apply (args: IoTHubArgs) =
                args.EventHubRetentionInDays <- input eventHubRetentionInDays
                args

            ()
            name, List.Cons(apply, args)

        member _.EventHubRetentionInDays((name, args), eventHubRetentionInDays) =
            let apply (args: IoTHubArgs) =
                args.EventHubRetentionInDays <- io eventHubRetentionInDays
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: IoTHubArgs) =
                   args.FallbackRoute <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: IoTHubArgs) =
                   args.FileUpload <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("ipFilterRules")>]
        member _.IpFilterRules((name, args), ipFilterRules) =
            let apply (args: IoTHubArgs) =
                args.IpFilterRules <- inputList ipFilterRules
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: IoTHubArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: IoTHubArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: IoTHubArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: IoTHubArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: IoTHubArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: IoTHubArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("routes")>]
        member _.Routes((name, args), routes) =
            let apply (args: IoTHubArgs) =
                args.Routes <- inputList routes
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: IoTHubArgs) =
                   args.Sku <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: IoTHubArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let ioTHub = IoTHubBuilder()

    type IotHubCertificateBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            IotHubCertificate(name, (List.fold func (IotHubCertificateArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("certificateContent")>]
        member _.CertificateContent((name, args), certificateContent) =
            let apply (args: IotHubCertificateArgs) =
                args.CertificateContent <- input certificateContent
                args

            ()
            name, List.Cons(apply, args)

        member _.CertificateContent((name, args), certificateContent) =
            let apply (args: IotHubCertificateArgs) =
                args.CertificateContent <- io certificateContent
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("iotDpsName")>]
        member _.IotDpsName((name, args), iotDpsName) =
            let apply (args: IotHubCertificateArgs) =
                args.IotDpsName <- input iotDpsName
                args

            ()
            name, List.Cons(apply, args)

        member _.IotDpsName((name, args), iotDpsName) =
            let apply (args: IotHubCertificateArgs) =
                args.IotDpsName <- io iotDpsName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: IotHubCertificateArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: IotHubCertificateArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: IotHubCertificateArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: IotHubCertificateArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let iotHubCertificate = IotHubCertificateBuilder()

    type IotHubDpsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            IotHubDps(name, (List.fold func (IotHubDpsArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("linkedHubs")>]
        member _.LinkedHubs((name, args), linkedHubs) =
            let apply (args: IotHubDpsArgs) =
                args.LinkedHubs <- inputList linkedHubs
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: IotHubDpsArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: IotHubDpsArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: IotHubDpsArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: IotHubDpsArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: IotHubDpsArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: IotHubDpsArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: IotHubDpsArgs) =
                   args.Sku <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: IotHubDpsArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let iotHubDps = IotHubDpsBuilder()

    type RouteBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Route(name, (List.fold func (RouteArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("condition")>]
        member _.Condition((name, args), condition) =
            let apply (args: RouteArgs) =
                args.Condition <- input condition
                args

            ()
            name, List.Cons(apply, args)

        member _.Condition((name, args), condition) =
            let apply (args: RouteArgs) =
                args.Condition <- io condition
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((name, args), enabled) =
            let apply (args: RouteArgs) =
                args.Enabled <- input enabled
                args

            ()
            name, List.Cons(apply, args)

        member _.Enabled((name, args), enabled) =
            let apply (args: RouteArgs) =
                args.Enabled <- io enabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("endpointNames")>]
        member _.EndpointNames((name, args), endpointNames) =
            let apply (args: RouteArgs) =
                args.EndpointNames <- input endpointNames
                args

            ()
            name, List.Cons(apply, args)

        member _.EndpointNames((name, args), endpointNames) =
            let apply (args: RouteArgs) =
                args.EndpointNames <- io endpointNames
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("iothubName")>]
        member _.IothubName((name, args), iothubName) =
            let apply (args: RouteArgs) =
                args.IothubName <- input iothubName
                args

            ()
            name, List.Cons(apply, args)

        member _.IothubName((name, args), iothubName) =
            let apply (args: RouteArgs) =
                args.IothubName <- io iothubName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: RouteArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: RouteArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: RouteArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: RouteArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("source")>]
        member _.Source((name, args), source) =
            let apply (args: RouteArgs) =
                args.Source <- input source
                args

            ()
            name, List.Cons(apply, args)

        member _.Source((name, args), source) =
            let apply (args: RouteArgs) =
                args.Source <- io source
                args

            ()
            name, List.Cons(apply, args)

    let route = RouteBuilder()

    type SharedAccessPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            SharedAccessPolicy(name, (List.fold func (SharedAccessPolicyArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("deviceConnect")>]
        member _.DeviceConnect((name, args), deviceConnect) =
            let apply (args: SharedAccessPolicyArgs) =
                args.DeviceConnect <- input deviceConnect
                args

            ()
            name, List.Cons(apply, args)

        member _.DeviceConnect((name, args), deviceConnect) =
            let apply (args: SharedAccessPolicyArgs) =
                args.DeviceConnect <- io deviceConnect
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("iothubName")>]
        member _.IothubName((name, args), iothubName) =
            let apply (args: SharedAccessPolicyArgs) =
                args.IothubName <- input iothubName
                args

            ()
            name, List.Cons(apply, args)

        member _.IothubName((name, args), iothubName) =
            let apply (args: SharedAccessPolicyArgs) =
                args.IothubName <- io iothubName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: SharedAccessPolicyArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: SharedAccessPolicyArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("registryRead")>]
        member _.RegistryRead((name, args), registryRead) =
            let apply (args: SharedAccessPolicyArgs) =
                args.RegistryRead <- input registryRead
                args

            ()
            name, List.Cons(apply, args)

        member _.RegistryRead((name, args), registryRead) =
            let apply (args: SharedAccessPolicyArgs) =
                args.RegistryRead <- io registryRead
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("registryWrite")>]
        member _.RegistryWrite((name, args), registryWrite) =
            let apply (args: SharedAccessPolicyArgs) =
                args.RegistryWrite <- input registryWrite
                args

            ()
            name, List.Cons(apply, args)

        member _.RegistryWrite((name, args), registryWrite) =
            let apply (args: SharedAccessPolicyArgs) =
                args.RegistryWrite <- io registryWrite
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SharedAccessPolicyArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SharedAccessPolicyArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serviceConnect")>]
        member _.ServiceConnect((name, args), serviceConnect) =
            let apply (args: SharedAccessPolicyArgs) =
                args.ServiceConnect <- input serviceConnect
                args

            ()
            name, List.Cons(apply, args)

        member _.ServiceConnect((name, args), serviceConnect) =
            let apply (args: SharedAccessPolicyArgs) =
                args.ServiceConnect <- io serviceConnect
                args

            ()
            name, List.Cons(apply, args)

    let sharedAccessPolicy = SharedAccessPolicyBuilder()

    type TimeSeriesInsightsAccessPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            TimeSeriesInsightsAccessPolicy(name, (List.fold func (TimeSeriesInsightsAccessPolicyArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: TimeSeriesInsightsAccessPolicyArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: TimeSeriesInsightsAccessPolicyArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: TimeSeriesInsightsAccessPolicyArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: TimeSeriesInsightsAccessPolicyArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("principalObjectId")>]
        member _.PrincipalObjectId((name, args), principalObjectId) =
            let apply (args: TimeSeriesInsightsAccessPolicyArgs) =
                args.PrincipalObjectId <- input principalObjectId
                args

            ()
            name, List.Cons(apply, args)

        member _.PrincipalObjectId((name, args), principalObjectId) =
            let apply (args: TimeSeriesInsightsAccessPolicyArgs) =
                args.PrincipalObjectId <- io principalObjectId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("roles")>]
        member _.Roles((name, args), roles) =
            let apply (args: TimeSeriesInsightsAccessPolicyArgs) =
                args.Roles <- inputList roles
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("timeSeriesInsightsEnvironmentId")>]
        member _.TimeSeriesInsightsEnvironmentId((name, args), timeSeriesInsightsEnvironmentId) =
            let apply (args: TimeSeriesInsightsAccessPolicyArgs) =
                args.TimeSeriesInsightsEnvironmentId <- input timeSeriesInsightsEnvironmentId
                args

            ()
            name, List.Cons(apply, args)

        member _.TimeSeriesInsightsEnvironmentId((name, args), timeSeriesInsightsEnvironmentId) =
            let apply (args: TimeSeriesInsightsAccessPolicyArgs) =
                args.TimeSeriesInsightsEnvironmentId <- io timeSeriesInsightsEnvironmentId
                args

            ()
            name, List.Cons(apply, args)

    let timeSeriesInsightsAccessPolicy = TimeSeriesInsightsAccessPolicyBuilder()

    type TimeSeriesInsightsReferenceDataSetBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            TimeSeriesInsightsReferenceDataSet(name, (List.fold func (TimeSeriesInsightsReferenceDataSetArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("dataStringComparisonBehavior")>]
        member _.DataStringComparisonBehavior((name, args), dataStringComparisonBehavior) =
            let apply (args: TimeSeriesInsightsReferenceDataSetArgs) =
                args.DataStringComparisonBehavior <- input dataStringComparisonBehavior
                args

            ()
            name, List.Cons(apply, args)

        member _.DataStringComparisonBehavior((name, args), dataStringComparisonBehavior) =
            let apply (args: TimeSeriesInsightsReferenceDataSetArgs) =
                args.DataStringComparisonBehavior <- io dataStringComparisonBehavior
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("keyProperties")>]
        member _.KeyProperties((name, args), keyProperties) =
            let apply (args: TimeSeriesInsightsReferenceDataSetArgs) =
                args.KeyProperties <- inputList keyProperties
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: TimeSeriesInsightsReferenceDataSetArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: TimeSeriesInsightsReferenceDataSetArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: TimeSeriesInsightsReferenceDataSetArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: TimeSeriesInsightsReferenceDataSetArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: TimeSeriesInsightsReferenceDataSetArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("timeSeriesInsightsEnvironmentId")>]
        member _.TimeSeriesInsightsEnvironmentId((name, args), timeSeriesInsightsEnvironmentId) =
            let apply (args: TimeSeriesInsightsReferenceDataSetArgs) =
                args.TimeSeriesInsightsEnvironmentId <- input timeSeriesInsightsEnvironmentId
                args

            ()
            name, List.Cons(apply, args)

        member _.TimeSeriesInsightsEnvironmentId((name, args), timeSeriesInsightsEnvironmentId) =
            let apply (args: TimeSeriesInsightsReferenceDataSetArgs) =
                args.TimeSeriesInsightsEnvironmentId <- io timeSeriesInsightsEnvironmentId
                args

            ()
            name, List.Cons(apply, args)

    let timeSeriesInsightsReferenceDataSet =
        TimeSeriesInsightsReferenceDataSetBuilder()

    type TimeSeriesInsightsStandardEnvironmentBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            TimeSeriesInsightsStandardEnvironment
                (name, (List.fold func (TimeSeriesInsightsStandardEnvironmentArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("dataRetentionTime")>]
        member _.DataRetentionTime((name, args), dataRetentionTime) =
            let apply (args: TimeSeriesInsightsStandardEnvironmentArgs) =
                args.DataRetentionTime <- input dataRetentionTime
                args

            ()
            name, List.Cons(apply, args)

        member _.DataRetentionTime((name, args), dataRetentionTime) =
            let apply (args: TimeSeriesInsightsStandardEnvironmentArgs) =
                args.DataRetentionTime <- io dataRetentionTime
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: TimeSeriesInsightsStandardEnvironmentArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: TimeSeriesInsightsStandardEnvironmentArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: TimeSeriesInsightsStandardEnvironmentArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: TimeSeriesInsightsStandardEnvironmentArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("partitionKey")>]
        member _.PartitionKey((name, args), partitionKey) =
            let apply (args: TimeSeriesInsightsStandardEnvironmentArgs) =
                args.PartitionKey <- input partitionKey
                args

            ()
            name, List.Cons(apply, args)

        member _.PartitionKey((name, args), partitionKey) =
            let apply (args: TimeSeriesInsightsStandardEnvironmentArgs) =
                args.PartitionKey <- io partitionKey
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: TimeSeriesInsightsStandardEnvironmentArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: TimeSeriesInsightsStandardEnvironmentArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("skuName")>]
        member _.SkuName((name, args), skuName) =
            let apply (args: TimeSeriesInsightsStandardEnvironmentArgs) =
                args.SkuName <- input skuName
                args

            ()
            name, List.Cons(apply, args)

        member _.SkuName((name, args), skuName) =
            let apply (args: TimeSeriesInsightsStandardEnvironmentArgs) =
                args.SkuName <- io skuName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageLimitExceededBehavior")>]
        member _.StorageLimitExceededBehavior((name, args), storageLimitExceededBehavior) =
            let apply (args: TimeSeriesInsightsStandardEnvironmentArgs) =
                args.StorageLimitExceededBehavior <- input storageLimitExceededBehavior
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageLimitExceededBehavior((name, args), storageLimitExceededBehavior) =
            let apply (args: TimeSeriesInsightsStandardEnvironmentArgs) =
                args.StorageLimitExceededBehavior <- io storageLimitExceededBehavior
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: TimeSeriesInsightsStandardEnvironmentArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let timeSeriesInsightsStandardEnvironment =
        TimeSeriesInsightsStandardEnvironmentBuilder()

module KeyVault =
    open Pulumi.Azure.KeyVault
    open Pulumi.Azure.KeyVault.Inputs

    type CertifiateCertificateBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (CertifiateCertificateArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("contents")>]
        member _.Contents((n, args), contents) =
            let apply (args: CertifiateCertificateArgs) =
                args.Contents <- input contents
                args

            ()
            n, List.Cons(apply, args)

        member _.Contents((n, args), contents) =
            let apply (args: CertifiateCertificateArgs) =
                args.Contents <- io contents
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: CertifiateCertificateArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: CertifiateCertificateArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

    let certifiateCertificate = CertifiateCertificateBuilder()

    type CertifiateCertificatePolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (CertifiateCertificatePolicyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: CertifiateCertificatePolicyArgs) =
                   args.IssuerParameters <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: CertifiateCertificatePolicyArgs) =
                   args.KeyProperties <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("lifetimeActions")>]
        member _.LifetimeActions((n, args), lifetimeActions) =
            let apply (args: CertifiateCertificatePolicyArgs) =
                args.LifetimeActions <- inputList lifetimeActions
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: CertifiateCertificatePolicyArgs) =
                   args.SecretProperties <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: CertifiateCertificatePolicyArgs) =
                   args.X509CertificateProperties <- input arg
                   args

               ()
               func) ]

    let certifiateCertificatePolicy = CertifiateCertificatePolicyBuilder()

    type CertifiateCertificatePolicyIssuerParametersBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (CertifiateCertificatePolicyIssuerParametersArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: CertifiateCertificatePolicyIssuerParametersArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: CertifiateCertificatePolicyIssuerParametersArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

    let certifiateCertificatePolicyIssuerParameters =
        CertifiateCertificatePolicyIssuerParametersBuilder()

    type CertifiateCertificatePolicyKeyPropertiesBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (CertifiateCertificatePolicyKeyPropertiesArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("exportable")>]
        member _.Exportable((n, args), exportable) =
            let apply (args: CertifiateCertificatePolicyKeyPropertiesArgs) =
                args.Exportable <- input exportable
                args

            ()
            n, List.Cons(apply, args)

        member _.Exportable((n, args), exportable) =
            let apply (args: CertifiateCertificatePolicyKeyPropertiesArgs) =
                args.Exportable <- io exportable
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("keySize")>]
        member _.KeySize((n, args), keySize) =
            let apply (args: CertifiateCertificatePolicyKeyPropertiesArgs) =
                args.KeySize <- input keySize
                args

            ()
            n, List.Cons(apply, args)

        member _.KeySize((n, args), keySize) =
            let apply (args: CertifiateCertificatePolicyKeyPropertiesArgs) =
                args.KeySize <- io keySize
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("keyType")>]
        member _.KeyType((n, args), keyType) =
            let apply (args: CertifiateCertificatePolicyKeyPropertiesArgs) =
                args.KeyType <- input keyType
                args

            ()
            n, List.Cons(apply, args)

        member _.KeyType((n, args), keyType) =
            let apply (args: CertifiateCertificatePolicyKeyPropertiesArgs) =
                args.KeyType <- io keyType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("reuseKey")>]
        member _.ReuseKey((n, args), reuseKey) =
            let apply (args: CertifiateCertificatePolicyKeyPropertiesArgs) =
                args.ReuseKey <- input reuseKey
                args

            ()
            n, List.Cons(apply, args)

        member _.ReuseKey((n, args), reuseKey) =
            let apply (args: CertifiateCertificatePolicyKeyPropertiesArgs) =
                args.ReuseKey <- io reuseKey
                args

            ()
            n, List.Cons(apply, args)

    let certifiateCertificatePolicyKeyProperties =
        CertifiateCertificatePolicyKeyPropertiesBuilder()

    type CertifiateCertificatePolicyLifetimeActionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (CertifiateCertificatePolicyLifetimeActionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: CertifiateCertificatePolicyLifetimeActionArgs) =
                   args.Action <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: CertifiateCertificatePolicyLifetimeActionArgs) =
                   args.Trigger <- input arg
                   args

               ()
               func) ]

    let certifiateCertificatePolicyLifetimeAction =
        CertifiateCertificatePolicyLifetimeActionBuilder()

    type CertifiateCertificatePolicyLifetimeActionActionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (CertifiateCertificatePolicyLifetimeActionActionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("actionType")>]
        member _.ActionType((n, args), actionType) =
            let apply (args: CertifiateCertificatePolicyLifetimeActionActionArgs) =
                args.ActionType <- input actionType
                args

            ()
            n, List.Cons(apply, args)

        member _.ActionType((n, args), actionType) =
            let apply (args: CertifiateCertificatePolicyLifetimeActionActionArgs) =
                args.ActionType <- io actionType
                args

            ()
            n, List.Cons(apply, args)

    let certifiateCertificatePolicyLifetimeActionAction =
        CertifiateCertificatePolicyLifetimeActionActionBuilder()

    type CertifiateCertificatePolicyLifetimeActionTriggerBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (CertifiateCertificatePolicyLifetimeActionTriggerArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("daysBeforeExpiry")>]
        member _.DaysBeforeExpiry((n, args), daysBeforeExpiry) =
            let apply (args: CertifiateCertificatePolicyLifetimeActionTriggerArgs) =
                args.DaysBeforeExpiry <- input daysBeforeExpiry
                args

            ()
            n, List.Cons(apply, args)

        member _.DaysBeforeExpiry((n, args), daysBeforeExpiry) =
            let apply (args: CertifiateCertificatePolicyLifetimeActionTriggerArgs) =
                args.DaysBeforeExpiry <- io daysBeforeExpiry
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("lifetimePercentage")>]
        member _.LifetimePercentage((n, args), lifetimePercentage) =
            let apply (args: CertifiateCertificatePolicyLifetimeActionTriggerArgs) =
                args.LifetimePercentage <- input lifetimePercentage
                args

            ()
            n, List.Cons(apply, args)

        member _.LifetimePercentage((n, args), lifetimePercentage) =
            let apply (args: CertifiateCertificatePolicyLifetimeActionTriggerArgs) =
                args.LifetimePercentage <- io lifetimePercentage
                args

            ()
            n, List.Cons(apply, args)

    let certifiateCertificatePolicyLifetimeActionTrigger =
        CertifiateCertificatePolicyLifetimeActionTriggerBuilder()

    type CertifiateCertificatePolicySecretPropertiesBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (CertifiateCertificatePolicySecretPropertiesArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("contentType")>]
        member _.ContentType((n, args), contentType) =
            let apply (args: CertifiateCertificatePolicySecretPropertiesArgs) =
                args.ContentType <- input contentType
                args

            ()
            n, List.Cons(apply, args)

        member _.ContentType((n, args), contentType) =
            let apply (args: CertifiateCertificatePolicySecretPropertiesArgs) =
                args.ContentType <- io contentType
                args

            ()
            n, List.Cons(apply, args)

    let certifiateCertificatePolicySecretProperties =
        CertifiateCertificatePolicySecretPropertiesBuilder()

    type CertifiateCertificatePolicyX509CertificatePropertiesBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (CertifiateCertificatePolicyX509CertificatePropertiesArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("extendedKeyUsages")>]
        member _.ExtendedKeyUsages((n, args), extendedKeyUsages) =
            let apply (args: CertifiateCertificatePolicyX509CertificatePropertiesArgs) =
                args.ExtendedKeyUsages <- inputList extendedKeyUsages
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("keyUsages")>]
        member _.KeyUsages((n, args), keyUsages) =
            let apply (args: CertifiateCertificatePolicyX509CertificatePropertiesArgs) =
                args.KeyUsages <- inputList keyUsages
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subject")>]
        member _.Subject((n, args), subject) =
            let apply (args: CertifiateCertificatePolicyX509CertificatePropertiesArgs) =
                args.Subject <- input subject
                args

            ()
            n, List.Cons(apply, args)

        member _.Subject((n, args), subject) =
            let apply (args: CertifiateCertificatePolicyX509CertificatePropertiesArgs) =
                args.Subject <- io subject
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: CertifiateCertificatePolicyX509CertificatePropertiesArgs) =
                   args.SubjectAlternativeNames <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("validityInMonths")>]
        member _.ValidityInMonths((n, args), validityInMonths) =
            let apply (args: CertifiateCertificatePolicyX509CertificatePropertiesArgs) =
                args.ValidityInMonths <- input validityInMonths
                args

            ()
            n, List.Cons(apply, args)

        member _.ValidityInMonths((n, args), validityInMonths) =
            let apply (args: CertifiateCertificatePolicyX509CertificatePropertiesArgs) =
                args.ValidityInMonths <- io validityInMonths
                args

            ()
            n, List.Cons(apply, args)

    let certifiateCertificatePolicyX509CertificateProperties =
        CertifiateCertificatePolicyX509CertificatePropertiesBuilder()

    type CertifiateCertificatePolicyX509CertificatePropertiesSubjectAlternativeNamesBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (CertifiateCertificatePolicyX509CertificatePropertiesSubjectAlternativeNamesArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("dnsNames")>]
        member _.DnsNames((n, args), dnsNames) =
            let apply (args: CertifiateCertificatePolicyX509CertificatePropertiesSubjectAlternativeNamesArgs) =
                args.DnsNames <- inputList dnsNames
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("emails")>]
        member _.Emails((n, args), emails) =
            let apply (args: CertifiateCertificatePolicyX509CertificatePropertiesSubjectAlternativeNamesArgs) =
                args.Emails <- inputList emails
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("upns")>]
        member _.Upns((n, args), upns) =
            let apply (args: CertifiateCertificatePolicyX509CertificatePropertiesSubjectAlternativeNamesArgs) =
                args.Upns <- inputList upns
                args

            ()
            n, List.Cons(apply, args)

    let certifiateCertificatePolicyX509CertificatePropertiesSubjectAlternativeNames =
        CertifiateCertificatePolicyX509CertificatePropertiesSubjectAlternativeNamesBuilder()

    type CertificateCertificateBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (CertificateCertificateArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("contents")>]
        member _.Contents((n, args), contents) =
            let apply (args: CertificateCertificateArgs) =
                args.Contents <- input contents
                args

            ()
            n, List.Cons(apply, args)

        member _.Contents((n, args), contents) =
            let apply (args: CertificateCertificateArgs) =
                args.Contents <- io contents
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: CertificateCertificateArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: CertificateCertificateArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

    let certificateCertificate = CertificateCertificateBuilder()

    type CertificateCertificatePolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (CertificateCertificatePolicyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: CertificateCertificatePolicyArgs) =
                   args.IssuerParameters <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: CertificateCertificatePolicyArgs) =
                   args.KeyProperties <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("lifetimeActions")>]
        member _.LifetimeActions((n, args), lifetimeActions) =
            let apply (args: CertificateCertificatePolicyArgs) =
                args.LifetimeActions <- inputList lifetimeActions
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: CertificateCertificatePolicyArgs) =
                   args.SecretProperties <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: CertificateCertificatePolicyArgs) =
                   args.X509CertificateProperties <- input arg
                   args

               ()
               func) ]

    let certificateCertificatePolicy = CertificateCertificatePolicyBuilder()

    type CertificateCertificatePolicyIssuerParametersBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (CertificateCertificatePolicyIssuerParametersArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: CertificateCertificatePolicyIssuerParametersArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: CertificateCertificatePolicyIssuerParametersArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

    let certificateCertificatePolicyIssuerParameters =
        CertificateCertificatePolicyIssuerParametersBuilder()

    type CertificateCertificatePolicyKeyPropertiesBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (CertificateCertificatePolicyKeyPropertiesArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("exportable")>]
        member _.Exportable((n, args), exportable) =
            let apply (args: CertificateCertificatePolicyKeyPropertiesArgs) =
                args.Exportable <- input exportable
                args

            ()
            n, List.Cons(apply, args)

        member _.Exportable((n, args), exportable) =
            let apply (args: CertificateCertificatePolicyKeyPropertiesArgs) =
                args.Exportable <- io exportable
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("keySize")>]
        member _.KeySize((n, args), keySize) =
            let apply (args: CertificateCertificatePolicyKeyPropertiesArgs) =
                args.KeySize <- input keySize
                args

            ()
            n, List.Cons(apply, args)

        member _.KeySize((n, args), keySize) =
            let apply (args: CertificateCertificatePolicyKeyPropertiesArgs) =
                args.KeySize <- io keySize
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("keyType")>]
        member _.KeyType((n, args), keyType) =
            let apply (args: CertificateCertificatePolicyKeyPropertiesArgs) =
                args.KeyType <- input keyType
                args

            ()
            n, List.Cons(apply, args)

        member _.KeyType((n, args), keyType) =
            let apply (args: CertificateCertificatePolicyKeyPropertiesArgs) =
                args.KeyType <- io keyType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("reuseKey")>]
        member _.ReuseKey((n, args), reuseKey) =
            let apply (args: CertificateCertificatePolicyKeyPropertiesArgs) =
                args.ReuseKey <- input reuseKey
                args

            ()
            n, List.Cons(apply, args)

        member _.ReuseKey((n, args), reuseKey) =
            let apply (args: CertificateCertificatePolicyKeyPropertiesArgs) =
                args.ReuseKey <- io reuseKey
                args

            ()
            n, List.Cons(apply, args)

    let certificateCertificatePolicyKeyProperties =
        CertificateCertificatePolicyKeyPropertiesBuilder()

    type CertificateCertificatePolicyLifetimeActionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (CertificateCertificatePolicyLifetimeActionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: CertificateCertificatePolicyLifetimeActionArgs) =
                   args.Action <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: CertificateCertificatePolicyLifetimeActionArgs) =
                   args.Trigger <- input arg
                   args

               ()
               func) ]

    let certificateCertificatePolicyLifetimeAction =
        CertificateCertificatePolicyLifetimeActionBuilder()

    type CertificateCertificatePolicyLifetimeActionActionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (CertificateCertificatePolicyLifetimeActionActionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("actionType")>]
        member _.ActionType((n, args), actionType) =
            let apply (args: CertificateCertificatePolicyLifetimeActionActionArgs) =
                args.ActionType <- input actionType
                args

            ()
            n, List.Cons(apply, args)

        member _.ActionType((n, args), actionType) =
            let apply (args: CertificateCertificatePolicyLifetimeActionActionArgs) =
                args.ActionType <- io actionType
                args

            ()
            n, List.Cons(apply, args)

    let certificateCertificatePolicyLifetimeActionAction =
        CertificateCertificatePolicyLifetimeActionActionBuilder()

    type CertificateCertificatePolicyLifetimeActionTriggerBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (CertificateCertificatePolicyLifetimeActionTriggerArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("daysBeforeExpiry")>]
        member _.DaysBeforeExpiry((n, args), daysBeforeExpiry) =
            let apply (args: CertificateCertificatePolicyLifetimeActionTriggerArgs) =
                args.DaysBeforeExpiry <- input daysBeforeExpiry
                args

            ()
            n, List.Cons(apply, args)

        member _.DaysBeforeExpiry((n, args), daysBeforeExpiry) =
            let apply (args: CertificateCertificatePolicyLifetimeActionTriggerArgs) =
                args.DaysBeforeExpiry <- io daysBeforeExpiry
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("lifetimePercentage")>]
        member _.LifetimePercentage((n, args), lifetimePercentage) =
            let apply (args: CertificateCertificatePolicyLifetimeActionTriggerArgs) =
                args.LifetimePercentage <- input lifetimePercentage
                args

            ()
            n, List.Cons(apply, args)

        member _.LifetimePercentage((n, args), lifetimePercentage) =
            let apply (args: CertificateCertificatePolicyLifetimeActionTriggerArgs) =
                args.LifetimePercentage <- io lifetimePercentage
                args

            ()
            n, List.Cons(apply, args)

    let certificateCertificatePolicyLifetimeActionTrigger =
        CertificateCertificatePolicyLifetimeActionTriggerBuilder()

    type CertificateCertificatePolicySecretPropertiesBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (CertificateCertificatePolicySecretPropertiesArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("contentType")>]
        member _.ContentType((n, args), contentType) =
            let apply (args: CertificateCertificatePolicySecretPropertiesArgs) =
                args.ContentType <- input contentType
                args

            ()
            n, List.Cons(apply, args)

        member _.ContentType((n, args), contentType) =
            let apply (args: CertificateCertificatePolicySecretPropertiesArgs) =
                args.ContentType <- io contentType
                args

            ()
            n, List.Cons(apply, args)

    let certificateCertificatePolicySecretProperties =
        CertificateCertificatePolicySecretPropertiesBuilder()

    type CertificateCertificatePolicyX509CertificatePropertiesBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (CertificateCertificatePolicyX509CertificatePropertiesArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("extendedKeyUsages")>]
        member _.ExtendedKeyUsages((n, args), extendedKeyUsages) =
            let apply (args: CertificateCertificatePolicyX509CertificatePropertiesArgs) =
                args.ExtendedKeyUsages <- inputList extendedKeyUsages
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("keyUsages")>]
        member _.KeyUsages((n, args), keyUsages) =
            let apply (args: CertificateCertificatePolicyX509CertificatePropertiesArgs) =
                args.KeyUsages <- inputList keyUsages
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subject")>]
        member _.Subject((n, args), subject) =
            let apply (args: CertificateCertificatePolicyX509CertificatePropertiesArgs) =
                args.Subject <- input subject
                args

            ()
            n, List.Cons(apply, args)

        member _.Subject((n, args), subject) =
            let apply (args: CertificateCertificatePolicyX509CertificatePropertiesArgs) =
                args.Subject <- io subject
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: CertificateCertificatePolicyX509CertificatePropertiesArgs) =
                   args.SubjectAlternativeNames <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("validityInMonths")>]
        member _.ValidityInMonths((n, args), validityInMonths) =
            let apply (args: CertificateCertificatePolicyX509CertificatePropertiesArgs) =
                args.ValidityInMonths <- input validityInMonths
                args

            ()
            n, List.Cons(apply, args)

        member _.ValidityInMonths((n, args), validityInMonths) =
            let apply (args: CertificateCertificatePolicyX509CertificatePropertiesArgs) =
                args.ValidityInMonths <- io validityInMonths
                args

            ()
            n, List.Cons(apply, args)

    let certificateCertificatePolicyX509CertificateProperties =
        CertificateCertificatePolicyX509CertificatePropertiesBuilder()

    type CertificateCertificatePolicyX509CertificatePropertiesSubjectAlternativeNamesBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (CertificateCertificatePolicyX509CertificatePropertiesSubjectAlternativeNamesArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("dnsNames")>]
        member _.DnsNames((n, args), dnsNames) =
            let apply (args: CertificateCertificatePolicyX509CertificatePropertiesSubjectAlternativeNamesArgs) =
                args.DnsNames <- inputList dnsNames
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("emails")>]
        member _.Emails((n, args), emails) =
            let apply (args: CertificateCertificatePolicyX509CertificatePropertiesSubjectAlternativeNamesArgs) =
                args.Emails <- inputList emails
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("upns")>]
        member _.Upns((n, args), upns) =
            let apply (args: CertificateCertificatePolicyX509CertificatePropertiesSubjectAlternativeNamesArgs) =
                args.Upns <- inputList upns
                args

            ()
            n, List.Cons(apply, args)

    let certificateCertificatePolicyX509CertificatePropertiesSubjectAlternativeNames =
        CertificateCertificatePolicyX509CertificatePropertiesSubjectAlternativeNamesBuilder()

    type KeyVaultAccessPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (KeyVaultAccessPolicyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("applicationId")>]
        member _.ApplicationId((n, args), applicationId) =
            let apply (args: KeyVaultAccessPolicyArgs) =
                args.ApplicationId <- input applicationId
                args

            ()
            n, List.Cons(apply, args)

        member _.ApplicationId((n, args), applicationId) =
            let apply (args: KeyVaultAccessPolicyArgs) =
                args.ApplicationId <- io applicationId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("certificatePermissions")>]
        member _.CertificatePermissions((n, args), certificatePermissions) =
            let apply (args: KeyVaultAccessPolicyArgs) =
                args.CertificatePermissions <- inputList certificatePermissions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("keyPermissions")>]
        member _.KeyPermissions((n, args), keyPermissions) =
            let apply (args: KeyVaultAccessPolicyArgs) =
                args.KeyPermissions <- inputList keyPermissions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("objectId")>]
        member _.ObjectId((n, args), objectId) =
            let apply (args: KeyVaultAccessPolicyArgs) =
                args.ObjectId <- input objectId
                args

            ()
            n, List.Cons(apply, args)

        member _.ObjectId((n, args), objectId) =
            let apply (args: KeyVaultAccessPolicyArgs) =
                args.ObjectId <- io objectId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("secretPermissions")>]
        member _.SecretPermissions((n, args), secretPermissions) =
            let apply (args: KeyVaultAccessPolicyArgs) =
                args.SecretPermissions <- inputList secretPermissions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storagePermissions")>]
        member _.StoragePermissions((n, args), storagePermissions) =
            let apply (args: KeyVaultAccessPolicyArgs) =
                args.StoragePermissions <- inputList storagePermissions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tenantId")>]
        member _.TenantId((n, args), tenantId) =
            let apply (args: KeyVaultAccessPolicyArgs) =
                args.TenantId <- input tenantId
                args

            ()
            n, List.Cons(apply, args)

        member _.TenantId((n, args), tenantId) =
            let apply (args: KeyVaultAccessPolicyArgs) =
                args.TenantId <- io tenantId
                args

            ()
            n, List.Cons(apply, args)

    let keyVaultAccessPolicy = KeyVaultAccessPolicyBuilder()

    type KeyVaultNetworkAclsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (KeyVaultNetworkAclsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("bypass")>]
        member _.Bypass((n, args), bypass) =
            let apply (args: KeyVaultNetworkAclsArgs) =
                args.Bypass <- input bypass
                args

            ()
            n, List.Cons(apply, args)

        member _.Bypass((n, args), bypass) =
            let apply (args: KeyVaultNetworkAclsArgs) =
                args.Bypass <- io bypass
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("defaultAction")>]
        member _.DefaultAction((n, args), defaultAction) =
            let apply (args: KeyVaultNetworkAclsArgs) =
                args.DefaultAction <- input defaultAction
                args

            ()
            n, List.Cons(apply, args)

        member _.DefaultAction((n, args), defaultAction) =
            let apply (args: KeyVaultNetworkAclsArgs) =
                args.DefaultAction <- io defaultAction
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ipRules")>]
        member _.IpRules((n, args), ipRules) =
            let apply (args: KeyVaultNetworkAclsArgs) =
                args.IpRules <- inputList ipRules
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkSubnetIds")>]
        member _.VirtualNetworkSubnetIds((n, args), virtualNetworkSubnetIds) =
            let apply (args: KeyVaultNetworkAclsArgs) =
                args.VirtualNetworkSubnetIds <- inputList virtualNetworkSubnetIds
                args

            ()
            n, List.Cons(apply, args)

    let keyVaultNetworkAcls = KeyVaultNetworkAclsBuilder()

    type AccessPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            AccessPolicy(name, (List.fold func (AccessPolicyArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("applicationId")>]
        member _.ApplicationId((name, args), applicationId) =
            let apply (args: AccessPolicyArgs) =
                args.ApplicationId <- input applicationId
                args

            ()
            name, List.Cons(apply, args)

        member _.ApplicationId((name, args), applicationId) =
            let apply (args: AccessPolicyArgs) =
                args.ApplicationId <- io applicationId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("certificatePermissions")>]
        member _.CertificatePermissions((name, args), certificatePermissions) =
            let apply (args: AccessPolicyArgs) =
                args.CertificatePermissions <- inputList certificatePermissions
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("keyPermissions")>]
        member _.KeyPermissions((name, args), keyPermissions) =
            let apply (args: AccessPolicyArgs) =
                args.KeyPermissions <- inputList keyPermissions
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("keyVaultId")>]
        member _.KeyVaultId((name, args), keyVaultId) =
            let apply (args: AccessPolicyArgs) =
                args.KeyVaultId <- input keyVaultId
                args

            ()
            name, List.Cons(apply, args)

        member _.KeyVaultId((name, args), keyVaultId) =
            let apply (args: AccessPolicyArgs) =
                args.KeyVaultId <- io keyVaultId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("objectId")>]
        member _.ObjectId((name, args), objectId) =
            let apply (args: AccessPolicyArgs) =
                args.ObjectId <- input objectId
                args

            ()
            name, List.Cons(apply, args)

        member _.ObjectId((name, args), objectId) =
            let apply (args: AccessPolicyArgs) =
                args.ObjectId <- io objectId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("secretPermissions")>]
        member _.SecretPermissions((name, args), secretPermissions) =
            let apply (args: AccessPolicyArgs) =
                args.SecretPermissions <- inputList secretPermissions
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storagePermissions")>]
        member _.StoragePermissions((name, args), storagePermissions) =
            let apply (args: AccessPolicyArgs) =
                args.StoragePermissions <- inputList storagePermissions
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tenantId")>]
        member _.TenantId((name, args), tenantId) =
            let apply (args: AccessPolicyArgs) =
                args.TenantId <- input tenantId
                args

            ()
            name, List.Cons(apply, args)

        member _.TenantId((name, args), tenantId) =
            let apply (args: AccessPolicyArgs) =
                args.TenantId <- io tenantId
                args

            ()
            name, List.Cons(apply, args)

    let accessPolicy = AccessPolicyBuilder()

    type CertifiateBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Certifiate(name, (List.fold func (CertifiateArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: CertifiateArgs) =
                   args.KeyVaultCertificate <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: CertifiateArgs) =
                   args.CertificatePolicy <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("keyVaultId")>]
        member _.KeyVaultId((name, args), keyVaultId) =
            let apply (args: CertifiateArgs) =
                args.KeyVaultId <- input keyVaultId
                args

            ()
            name, List.Cons(apply, args)

        member _.KeyVaultId((name, args), keyVaultId) =
            let apply (args: CertifiateArgs) =
                args.KeyVaultId <- io keyVaultId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: CertifiateArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: CertifiateArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: CertifiateArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let certifiate = CertifiateBuilder()

    type CertificateBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Certificate(name, (List.fold func (CertificateArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: CertificateArgs) =
                   args.KeyVaultCertificate <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: CertificateArgs) =
                   args.CertificatePolicy <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("keyVaultId")>]
        member _.KeyVaultId((name, args), keyVaultId) =
            let apply (args: CertificateArgs) =
                args.KeyVaultId <- input keyVaultId
                args

            ()
            name, List.Cons(apply, args)

        member _.KeyVaultId((name, args), keyVaultId) =
            let apply (args: CertificateArgs) =
                args.KeyVaultId <- io keyVaultId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: CertificateArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: CertificateArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: CertificateArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let certificate = CertificateBuilder()

    type KeyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Key(name, (List.fold func (KeyArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("curve")>]
        member _.Curve((name, args), curve) =
            let apply (args: KeyArgs) =
                args.Curve <- input curve
                args

            ()
            name, List.Cons(apply, args)

        member _.Curve((name, args), curve) =
            let apply (args: KeyArgs) =
                args.Curve <- io curve
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("expirationDate")>]
        member _.ExpirationDate((name, args), expirationDate) =
            let apply (args: KeyArgs) =
                args.ExpirationDate <- input expirationDate
                args

            ()
            name, List.Cons(apply, args)

        member _.ExpirationDate((name, args), expirationDate) =
            let apply (args: KeyArgs) =
                args.ExpirationDate <- io expirationDate
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("keyOpts")>]
        member _.KeyOpts((name, args), keyOpts) =
            let apply (args: KeyArgs) =
                args.KeyOpts <- inputList keyOpts
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("keySize")>]
        member _.KeySize((name, args), keySize) =
            let apply (args: KeyArgs) =
                args.KeySize <- input keySize
                args

            ()
            name, List.Cons(apply, args)

        member _.KeySize((name, args), keySize) =
            let apply (args: KeyArgs) =
                args.KeySize <- io keySize
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("keyType")>]
        member _.KeyType((name, args), keyType) =
            let apply (args: KeyArgs) =
                args.KeyType <- input keyType
                args

            ()
            name, List.Cons(apply, args)

        member _.KeyType((name, args), keyType) =
            let apply (args: KeyArgs) =
                args.KeyType <- io keyType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("keyVaultId")>]
        member _.KeyVaultId((name, args), keyVaultId) =
            let apply (args: KeyArgs) =
                args.KeyVaultId <- input keyVaultId
                args

            ()
            name, List.Cons(apply, args)

        member _.KeyVaultId((name, args), keyVaultId) =
            let apply (args: KeyArgs) =
                args.KeyVaultId <- io keyVaultId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: KeyArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: KeyArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("notBeforeDate")>]
        member _.NotBeforeDate((name, args), notBeforeDate) =
            let apply (args: KeyArgs) =
                args.NotBeforeDate <- input notBeforeDate
                args

            ()
            name, List.Cons(apply, args)

        member _.NotBeforeDate((name, args), notBeforeDate) =
            let apply (args: KeyArgs) =
                args.NotBeforeDate <- io notBeforeDate
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: KeyArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let key = KeyBuilder()

    type KeyVaultBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            KeyVault(name, (List.fold func (KeyVaultArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("accessPolicies")>]
        member _.AccessPolicies((name, args), accessPolicies) =
            let apply (args: KeyVaultArgs) =
                args.AccessPolicies <- inputList accessPolicies
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enabledForDeployment")>]
        member _.EnabledForDeployment((name, args), enabledForDeployment) =
            let apply (args: KeyVaultArgs) =
                args.EnabledForDeployment <- input enabledForDeployment
                args

            ()
            name, List.Cons(apply, args)

        member _.EnabledForDeployment((name, args), enabledForDeployment) =
            let apply (args: KeyVaultArgs) =
                args.EnabledForDeployment <- io enabledForDeployment
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enabledForDiskEncryption")>]
        member _.EnabledForDiskEncryption((name, args), enabledForDiskEncryption) =
            let apply (args: KeyVaultArgs) =
                args.EnabledForDiskEncryption <- input enabledForDiskEncryption
                args

            ()
            name, List.Cons(apply, args)

        member _.EnabledForDiskEncryption((name, args), enabledForDiskEncryption) =
            let apply (args: KeyVaultArgs) =
                args.EnabledForDiskEncryption <- io enabledForDiskEncryption
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enabledForTemplateDeployment")>]
        member _.EnabledForTemplateDeployment((name, args), enabledForTemplateDeployment) =
            let apply (args: KeyVaultArgs) =
                args.EnabledForTemplateDeployment <- input enabledForTemplateDeployment
                args

            ()
            name, List.Cons(apply, args)

        member _.EnabledForTemplateDeployment((name, args), enabledForTemplateDeployment) =
            let apply (args: KeyVaultArgs) =
                args.EnabledForTemplateDeployment <- io enabledForTemplateDeployment
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: KeyVaultArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: KeyVaultArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: KeyVaultArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: KeyVaultArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: KeyVaultArgs) =
                   args.NetworkAcls <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("purgeProtectionEnabled")>]
        member _.PurgeProtectionEnabled((name, args), purgeProtectionEnabled) =
            let apply (args: KeyVaultArgs) =
                args.PurgeProtectionEnabled <- input purgeProtectionEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.PurgeProtectionEnabled((name, args), purgeProtectionEnabled) =
            let apply (args: KeyVaultArgs) =
                args.PurgeProtectionEnabled <- io purgeProtectionEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: KeyVaultArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: KeyVaultArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("skuName")>]
        member _.SkuName((name, args), skuName) =
            let apply (args: KeyVaultArgs) =
                args.SkuName <- input skuName
                args

            ()
            name, List.Cons(apply, args)

        member _.SkuName((name, args), skuName) =
            let apply (args: KeyVaultArgs) =
                args.SkuName <- io skuName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("softDeleteEnabled")>]
        member _.SoftDeleteEnabled((name, args), softDeleteEnabled) =
            let apply (args: KeyVaultArgs) =
                args.SoftDeleteEnabled <- input softDeleteEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.SoftDeleteEnabled((name, args), softDeleteEnabled) =
            let apply (args: KeyVaultArgs) =
                args.SoftDeleteEnabled <- io softDeleteEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: KeyVaultArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tenantId")>]
        member _.TenantId((name, args), tenantId) =
            let apply (args: KeyVaultArgs) =
                args.TenantId <- input tenantId
                args

            ()
            name, List.Cons(apply, args)

        member _.TenantId((name, args), tenantId) =
            let apply (args: KeyVaultArgs) =
                args.TenantId <- io tenantId
                args

            ()
            name, List.Cons(apply, args)

    let keyVault = KeyVaultBuilder()

    type SecretBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Secret(name, (List.fold func (SecretArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("contentType")>]
        member _.ContentType((name, args), contentType) =
            let apply (args: SecretArgs) =
                args.ContentType <- input contentType
                args

            ()
            name, List.Cons(apply, args)

        member _.ContentType((name, args), contentType) =
            let apply (args: SecretArgs) =
                args.ContentType <- io contentType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("expirationDate")>]
        member _.ExpirationDate((name, args), expirationDate) =
            let apply (args: SecretArgs) =
                args.ExpirationDate <- input expirationDate
                args

            ()
            name, List.Cons(apply, args)

        member _.ExpirationDate((name, args), expirationDate) =
            let apply (args: SecretArgs) =
                args.ExpirationDate <- io expirationDate
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("keyVaultId")>]
        member _.KeyVaultId((name, args), keyVaultId) =
            let apply (args: SecretArgs) =
                args.KeyVaultId <- input keyVaultId
                args

            ()
            name, List.Cons(apply, args)

        member _.KeyVaultId((name, args), keyVaultId) =
            let apply (args: SecretArgs) =
                args.KeyVaultId <- io keyVaultId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: SecretArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: SecretArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("notBeforeDate")>]
        member _.NotBeforeDate((name, args), notBeforeDate) =
            let apply (args: SecretArgs) =
                args.NotBeforeDate <- input notBeforeDate
                args

            ()
            name, List.Cons(apply, args)

        member _.NotBeforeDate((name, args), notBeforeDate) =
            let apply (args: SecretArgs) =
                args.NotBeforeDate <- io notBeforeDate
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: SecretArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((name, args), value) =
            let apply (args: SecretArgs) =
                args.Value <- input value
                args

            ()
            name, List.Cons(apply, args)

        member _.Value((name, args), value) =
            let apply (args: SecretArgs) =
                args.Value <- io value
                args

            ()
            name, List.Cons(apply, args)

    let secret = SecretBuilder()

module Kusto =
    open Pulumi.Azure.Kusto
    open Pulumi.Azure.Kusto.Inputs

    type ClusterIdentityBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ClusterIdentityArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("identityIds")>]
        member _.IdentityIds((n, args), identityIds) =
            let apply (args: ClusterIdentityArgs) =
                args.IdentityIds <- inputList identityIds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("principalId")>]
        member _.PrincipalId((n, args), principalId) =
            let apply (args: ClusterIdentityArgs) =
                args.PrincipalId <- input principalId
                args

            ()
            n, List.Cons(apply, args)

        member _.PrincipalId((n, args), principalId) =
            let apply (args: ClusterIdentityArgs) =
                args.PrincipalId <- io principalId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tenantId")>]
        member _.TenantId((n, args), tenantId) =
            let apply (args: ClusterIdentityArgs) =
                args.TenantId <- input tenantId
                args

            ()
            n, List.Cons(apply, args)

        member _.TenantId((n, args), tenantId) =
            let apply (args: ClusterIdentityArgs) =
                args.TenantId <- io tenantId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: ClusterIdentityArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: ClusterIdentityArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let clusterIdentity = ClusterIdentityBuilder()

    type ClusterSkuBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ClusterSkuArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("capacity")>]
        member _.Capacity((n, args), capacity) =
            let apply (args: ClusterSkuArgs) =
                args.Capacity <- input capacity
                args

            ()
            n, List.Cons(apply, args)

        member _.Capacity((n, args), capacity) =
            let apply (args: ClusterSkuArgs) =
                args.Capacity <- io capacity
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ClusterSkuArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ClusterSkuArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

    let clusterSku = ClusterSkuBuilder()

    type ClusterVirtualNetworkConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ClusterVirtualNetworkConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("dataManagementPublicIpId")>]
        member _.DataManagementPublicIpId((n, args), dataManagementPublicIpId) =
            let apply (args: ClusterVirtualNetworkConfigurationArgs) =
                args.DataManagementPublicIpId <- input dataManagementPublicIpId
                args

            ()
            n, List.Cons(apply, args)

        member _.DataManagementPublicIpId((n, args), dataManagementPublicIpId) =
            let apply (args: ClusterVirtualNetworkConfigurationArgs) =
                args.DataManagementPublicIpId <- io dataManagementPublicIpId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enginePublicIpId")>]
        member _.EnginePublicIpId((n, args), enginePublicIpId) =
            let apply (args: ClusterVirtualNetworkConfigurationArgs) =
                args.EnginePublicIpId <- input enginePublicIpId
                args

            ()
            n, List.Cons(apply, args)

        member _.EnginePublicIpId((n, args), enginePublicIpId) =
            let apply (args: ClusterVirtualNetworkConfigurationArgs) =
                args.EnginePublicIpId <- io enginePublicIpId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: ClusterVirtualNetworkConfigurationArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: ClusterVirtualNetworkConfigurationArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

    let clusterVirtualNetworkConfiguration =
        ClusterVirtualNetworkConfigurationBuilder()

    type ClusterBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Cluster(name, (List.fold func (ClusterArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("enableDiskEncryption")>]
        member _.EnableDiskEncryption((name, args), enableDiskEncryption) =
            let apply (args: ClusterArgs) =
                args.EnableDiskEncryption <- input enableDiskEncryption
                args

            ()
            name, List.Cons(apply, args)

        member _.EnableDiskEncryption((name, args), enableDiskEncryption) =
            let apply (args: ClusterArgs) =
                args.EnableDiskEncryption <- io enableDiskEncryption
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enablePurge")>]
        member _.EnablePurge((name, args), enablePurge) =
            let apply (args: ClusterArgs) =
                args.EnablePurge <- input enablePurge
                args

            ()
            name, List.Cons(apply, args)

        member _.EnablePurge((name, args), enablePurge) =
            let apply (args: ClusterArgs) =
                args.EnablePurge <- io enablePurge
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enableStreamingIngest")>]
        member _.EnableStreamingIngest((name, args), enableStreamingIngest) =
            let apply (args: ClusterArgs) =
                args.EnableStreamingIngest <- input enableStreamingIngest
                args

            ()
            name, List.Cons(apply, args)

        member _.EnableStreamingIngest((name, args), enableStreamingIngest) =
            let apply (args: ClusterArgs) =
                args.EnableStreamingIngest <- io enableStreamingIngest
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ClusterArgs) =
                   args.Identity <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ClusterArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ClusterArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ClusterArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ClusterArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ClusterArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ClusterArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ClusterArgs) =
                   args.Sku <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ClusterArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ClusterArgs) =
                   args.VirtualNetworkConfiguration <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("zones")>]
        member _.Zones((name, args), zones) =
            let apply (args: ClusterArgs) =
                args.Zones <- inputList zones
                args

            ()
            name, List.Cons(apply, args)

    let cluster = ClusterBuilder()

    type DatabaseBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Database(name, (List.fold func (DatabaseArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("clusterName")>]
        member _.ClusterName((name, args), clusterName) =
            let apply (args: DatabaseArgs) =
                args.ClusterName <- input clusterName
                args

            ()
            name, List.Cons(apply, args)

        member _.ClusterName((name, args), clusterName) =
            let apply (args: DatabaseArgs) =
                args.ClusterName <- io clusterName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("hotCachePeriod")>]
        member _.HotCachePeriod((name, args), hotCachePeriod) =
            let apply (args: DatabaseArgs) =
                args.HotCachePeriod <- input hotCachePeriod
                args

            ()
            name, List.Cons(apply, args)

        member _.HotCachePeriod((name, args), hotCachePeriod) =
            let apply (args: DatabaseArgs) =
                args.HotCachePeriod <- io hotCachePeriod
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: DatabaseArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: DatabaseArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: DatabaseArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: DatabaseArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DatabaseArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DatabaseArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("softDeletePeriod")>]
        member _.SoftDeletePeriod((name, args), softDeletePeriod) =
            let apply (args: DatabaseArgs) =
                args.SoftDeletePeriod <- input softDeletePeriod
                args

            ()
            name, List.Cons(apply, args)

        member _.SoftDeletePeriod((name, args), softDeletePeriod) =
            let apply (args: DatabaseArgs) =
                args.SoftDeletePeriod <- io softDeletePeriod
                args

            ()
            name, List.Cons(apply, args)

    let database = DatabaseBuilder()

    type DatabasePrincipalBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            DatabasePrincipal(name, (List.fold func (DatabasePrincipalArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("clientId")>]
        member _.ClientId((name, args), clientId) =
            let apply (args: DatabasePrincipalArgs) =
                args.ClientId <- input clientId
                args

            ()
            name, List.Cons(apply, args)

        member _.ClientId((name, args), clientId) =
            let apply (args: DatabasePrincipalArgs) =
                args.ClientId <- io clientId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("clusterName")>]
        member _.ClusterName((name, args), clusterName) =
            let apply (args: DatabasePrincipalArgs) =
                args.ClusterName <- input clusterName
                args

            ()
            name, List.Cons(apply, args)

        member _.ClusterName((name, args), clusterName) =
            let apply (args: DatabasePrincipalArgs) =
                args.ClusterName <- io clusterName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("databaseName")>]
        member _.DatabaseName((name, args), databaseName) =
            let apply (args: DatabasePrincipalArgs) =
                args.DatabaseName <- input databaseName
                args

            ()
            name, List.Cons(apply, args)

        member _.DatabaseName((name, args), databaseName) =
            let apply (args: DatabasePrincipalArgs) =
                args.DatabaseName <- io databaseName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("objectId")>]
        member _.ObjectId((name, args), objectId) =
            let apply (args: DatabasePrincipalArgs) =
                args.ObjectId <- input objectId
                args

            ()
            name, List.Cons(apply, args)

        member _.ObjectId((name, args), objectId) =
            let apply (args: DatabasePrincipalArgs) =
                args.ObjectId <- io objectId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DatabasePrincipalArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DatabasePrincipalArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("role")>]
        member _.Role((name, args), role) =
            let apply (args: DatabasePrincipalArgs) =
                args.Role <- input role
                args

            ()
            name, List.Cons(apply, args)

        member _.Role((name, args), role) =
            let apply (args: DatabasePrincipalArgs) =
                args.Role <- io role
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((name, args), ``type``) =
            let apply (args: DatabasePrincipalArgs) =
                args.Type <- input ``type``
                args

            ()
            name, List.Cons(apply, args)

        member _.Type((name, args), ``type``) =
            let apply (args: DatabasePrincipalArgs) =
                args.Type <- io ``type``
                args

            ()
            name, List.Cons(apply, args)

    let databasePrincipal = DatabasePrincipalBuilder()

    type EventhubDataConnectionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            EventhubDataConnection(name, (List.fold func (EventhubDataConnectionArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("clusterName")>]
        member _.ClusterName((name, args), clusterName) =
            let apply (args: EventhubDataConnectionArgs) =
                args.ClusterName <- input clusterName
                args

            ()
            name, List.Cons(apply, args)

        member _.ClusterName((name, args), clusterName) =
            let apply (args: EventhubDataConnectionArgs) =
                args.ClusterName <- io clusterName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("consumerGroup")>]
        member _.ConsumerGroup((name, args), consumerGroup) =
            let apply (args: EventhubDataConnectionArgs) =
                args.ConsumerGroup <- input consumerGroup
                args

            ()
            name, List.Cons(apply, args)

        member _.ConsumerGroup((name, args), consumerGroup) =
            let apply (args: EventhubDataConnectionArgs) =
                args.ConsumerGroup <- io consumerGroup
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("dataFormat")>]
        member _.DataFormat((name, args), dataFormat) =
            let apply (args: EventhubDataConnectionArgs) =
                args.DataFormat <- input dataFormat
                args

            ()
            name, List.Cons(apply, args)

        member _.DataFormat((name, args), dataFormat) =
            let apply (args: EventhubDataConnectionArgs) =
                args.DataFormat <- io dataFormat
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("databaseName")>]
        member _.DatabaseName((name, args), databaseName) =
            let apply (args: EventhubDataConnectionArgs) =
                args.DatabaseName <- input databaseName
                args

            ()
            name, List.Cons(apply, args)

        member _.DatabaseName((name, args), databaseName) =
            let apply (args: EventhubDataConnectionArgs) =
                args.DatabaseName <- io databaseName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("eventhubId")>]
        member _.EventhubId((name, args), eventhubId) =
            let apply (args: EventhubDataConnectionArgs) =
                args.EventhubId <- input eventhubId
                args

            ()
            name, List.Cons(apply, args)

        member _.EventhubId((name, args), eventhubId) =
            let apply (args: EventhubDataConnectionArgs) =
                args.EventhubId <- io eventhubId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: EventhubDataConnectionArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: EventhubDataConnectionArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("mappingRuleName")>]
        member _.MappingRuleName((name, args), mappingRuleName) =
            let apply (args: EventhubDataConnectionArgs) =
                args.MappingRuleName <- input mappingRuleName
                args

            ()
            name, List.Cons(apply, args)

        member _.MappingRuleName((name, args), mappingRuleName) =
            let apply (args: EventhubDataConnectionArgs) =
                args.MappingRuleName <- io mappingRuleName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: EventhubDataConnectionArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: EventhubDataConnectionArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: EventhubDataConnectionArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: EventhubDataConnectionArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tableName")>]
        member _.TableName((name, args), tableName) =
            let apply (args: EventhubDataConnectionArgs) =
                args.TableName <- input tableName
                args

            ()
            name, List.Cons(apply, args)

        member _.TableName((name, args), tableName) =
            let apply (args: EventhubDataConnectionArgs) =
                args.TableName <- io tableName
                args

            ()
            name, List.Cons(apply, args)

    let eventhubDataConnection = EventhubDataConnectionBuilder()

module Lb =
    open Pulumi.Azure.Lb
    open Pulumi.Azure.Lb.Inputs

    type LoadBalancerFrontendIpConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LoadBalancerFrontendIpConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: LoadBalancerFrontendIpConfigurationArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: LoadBalancerFrontendIpConfigurationArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("inboundNatRules")>]
        member _.InboundNatRules((n, args), inboundNatRules) =
            let apply (args: LoadBalancerFrontendIpConfigurationArgs) =
                args.InboundNatRules <- inputList inboundNatRules
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("loadBalancerRules")>]
        member _.LoadBalancerRules((n, args), loadBalancerRules) =
            let apply (args: LoadBalancerFrontendIpConfigurationArgs) =
                args.LoadBalancerRules <- inputList loadBalancerRules
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: LoadBalancerFrontendIpConfigurationArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: LoadBalancerFrontendIpConfigurationArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("outboundRules")>]
        member _.OutboundRules((n, args), outboundRules) =
            let apply (args: LoadBalancerFrontendIpConfigurationArgs) =
                args.OutboundRules <- inputList outboundRules
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("privateIpAddress")>]
        member _.PrivateIpAddress((n, args), privateIpAddress) =
            let apply (args: LoadBalancerFrontendIpConfigurationArgs) =
                args.PrivateIpAddress <- input privateIpAddress
                args

            ()
            n, List.Cons(apply, args)

        member _.PrivateIpAddress((n, args), privateIpAddress) =
            let apply (args: LoadBalancerFrontendIpConfigurationArgs) =
                args.PrivateIpAddress <- io privateIpAddress
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("privateIpAddressAllocation")>]
        member _.PrivateIpAddressAllocation((n, args), privateIpAddressAllocation) =
            let apply (args: LoadBalancerFrontendIpConfigurationArgs) =
                args.PrivateIpAddressAllocation <- input privateIpAddressAllocation
                args

            ()
            n, List.Cons(apply, args)

        member _.PrivateIpAddressAllocation((n, args), privateIpAddressAllocation) =
            let apply (args: LoadBalancerFrontendIpConfigurationArgs) =
                args.PrivateIpAddressAllocation <- io privateIpAddressAllocation
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("privateIpAddressVersion")>]
        member _.PrivateIpAddressVersion((n, args), privateIpAddressVersion) =
            let apply (args: LoadBalancerFrontendIpConfigurationArgs) =
                args.PrivateIpAddressVersion <- input privateIpAddressVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.PrivateIpAddressVersion((n, args), privateIpAddressVersion) =
            let apply (args: LoadBalancerFrontendIpConfigurationArgs) =
                args.PrivateIpAddressVersion <- io privateIpAddressVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publicIpAddressId")>]
        member _.PublicIpAddressId((n, args), publicIpAddressId) =
            let apply (args: LoadBalancerFrontendIpConfigurationArgs) =
                args.PublicIpAddressId <- input publicIpAddressId
                args

            ()
            n, List.Cons(apply, args)

        member _.PublicIpAddressId((n, args), publicIpAddressId) =
            let apply (args: LoadBalancerFrontendIpConfigurationArgs) =
                args.PublicIpAddressId <- io publicIpAddressId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publicIpPrefixId")>]
        member _.PublicIpPrefixId((n, args), publicIpPrefixId) =
            let apply (args: LoadBalancerFrontendIpConfigurationArgs) =
                args.PublicIpPrefixId <- input publicIpPrefixId
                args

            ()
            n, List.Cons(apply, args)

        member _.PublicIpPrefixId((n, args), publicIpPrefixId) =
            let apply (args: LoadBalancerFrontendIpConfigurationArgs) =
                args.PublicIpPrefixId <- io publicIpPrefixId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: LoadBalancerFrontendIpConfigurationArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: LoadBalancerFrontendIpConfigurationArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("zones")>]
        member _.Zones((n, args), zones) =
            let apply (args: LoadBalancerFrontendIpConfigurationArgs) =
                args.Zones <- input zones
                args

            ()
            n, List.Cons(apply, args)

        member _.Zones((n, args), zones) =
            let apply (args: LoadBalancerFrontendIpConfigurationArgs) =
                args.Zones <- io zones
                args

            ()
            n, List.Cons(apply, args)

    let loadBalancerFrontendIpConfiguration =
        LoadBalancerFrontendIpConfigurationBuilder()

    type OutboundRuleFrontendIpConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (OutboundRuleFrontendIpConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: OutboundRuleFrontendIpConfigurationArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: OutboundRuleFrontendIpConfigurationArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: OutboundRuleFrontendIpConfigurationArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: OutboundRuleFrontendIpConfigurationArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

    let outboundRuleFrontendIpConfiguration =
        OutboundRuleFrontendIpConfigurationBuilder()

    type BackendAddressPoolBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            BackendAddressPool(name, (List.fold func (BackendAddressPoolArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("loadbalancerId")>]
        member _.LoadbalancerId((name, args), loadbalancerId) =
            let apply (args: BackendAddressPoolArgs) =
                args.LoadbalancerId <- input loadbalancerId
                args

            ()
            name, List.Cons(apply, args)

        member _.LoadbalancerId((name, args), loadbalancerId) =
            let apply (args: BackendAddressPoolArgs) =
                args.LoadbalancerId <- io loadbalancerId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: BackendAddressPoolArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: BackendAddressPoolArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: BackendAddressPoolArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: BackendAddressPoolArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let backendAddressPool = BackendAddressPoolBuilder()

    type LoadBalancerBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            LoadBalancer(name, (List.fold func (LoadBalancerArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("frontendIpConfigurations")>]
        member _.FrontendIpConfigurations((name, args), frontendIpConfigurations) =
            let apply (args: LoadBalancerArgs) =
                args.FrontendIpConfigurations <- inputList frontendIpConfigurations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: LoadBalancerArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: LoadBalancerArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: LoadBalancerArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: LoadBalancerArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: LoadBalancerArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: LoadBalancerArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sku")>]
        member _.Sku((name, args), sku) =
            let apply (args: LoadBalancerArgs) =
                args.Sku <- input sku
                args

            ()
            name, List.Cons(apply, args)

        member _.Sku((name, args), sku) =
            let apply (args: LoadBalancerArgs) =
                args.Sku <- io sku
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: LoadBalancerArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let loadBalancer = LoadBalancerBuilder()

    type NatPoolBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            NatPool(name, (List.fold func (NatPoolArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("backendPort")>]
        member _.BackendPort((name, args), backendPort) =
            let apply (args: NatPoolArgs) =
                args.BackendPort <- input backendPort
                args

            ()
            name, List.Cons(apply, args)

        member _.BackendPort((name, args), backendPort) =
            let apply (args: NatPoolArgs) =
                args.BackendPort <- io backendPort
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("frontendIpConfigurationName")>]
        member _.FrontendIpConfigurationName((name, args), frontendIpConfigurationName) =
            let apply (args: NatPoolArgs) =
                args.FrontendIpConfigurationName <- input frontendIpConfigurationName
                args

            ()
            name, List.Cons(apply, args)

        member _.FrontendIpConfigurationName((name, args), frontendIpConfigurationName) =
            let apply (args: NatPoolArgs) =
                args.FrontendIpConfigurationName <- io frontendIpConfigurationName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("frontendPortEnd")>]
        member _.FrontendPortEnd((name, args), frontendPortEnd) =
            let apply (args: NatPoolArgs) =
                args.FrontendPortEnd <- input frontendPortEnd
                args

            ()
            name, List.Cons(apply, args)

        member _.FrontendPortEnd((name, args), frontendPortEnd) =
            let apply (args: NatPoolArgs) =
                args.FrontendPortEnd <- io frontendPortEnd
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("frontendPortStart")>]
        member _.FrontendPortStart((name, args), frontendPortStart) =
            let apply (args: NatPoolArgs) =
                args.FrontendPortStart <- input frontendPortStart
                args

            ()
            name, List.Cons(apply, args)

        member _.FrontendPortStart((name, args), frontendPortStart) =
            let apply (args: NatPoolArgs) =
                args.FrontendPortStart <- io frontendPortStart
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("loadbalancerId")>]
        member _.LoadbalancerId((name, args), loadbalancerId) =
            let apply (args: NatPoolArgs) =
                args.LoadbalancerId <- input loadbalancerId
                args

            ()
            name, List.Cons(apply, args)

        member _.LoadbalancerId((name, args), loadbalancerId) =
            let apply (args: NatPoolArgs) =
                args.LoadbalancerId <- io loadbalancerId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: NatPoolArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: NatPoolArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("protocol")>]
        member _.Protocol((name, args), protocol) =
            let apply (args: NatPoolArgs) =
                args.Protocol <- input protocol
                args

            ()
            name, List.Cons(apply, args)

        member _.Protocol((name, args), protocol) =
            let apply (args: NatPoolArgs) =
                args.Protocol <- io protocol
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NatPoolArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NatPoolArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let natPool = NatPoolBuilder()

    type NatRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            NatRule(name, (List.fold func (NatRuleArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("backendPort")>]
        member _.BackendPort((name, args), backendPort) =
            let apply (args: NatRuleArgs) =
                args.BackendPort <- input backendPort
                args

            ()
            name, List.Cons(apply, args)

        member _.BackendPort((name, args), backendPort) =
            let apply (args: NatRuleArgs) =
                args.BackendPort <- io backendPort
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enableFloatingIp")>]
        member _.EnableFloatingIp((name, args), enableFloatingIp) =
            let apply (args: NatRuleArgs) =
                args.EnableFloatingIp <- input enableFloatingIp
                args

            ()
            name, List.Cons(apply, args)

        member _.EnableFloatingIp((name, args), enableFloatingIp) =
            let apply (args: NatRuleArgs) =
                args.EnableFloatingIp <- io enableFloatingIp
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enableTcpReset")>]
        member _.EnableTcpReset((name, args), enableTcpReset) =
            let apply (args: NatRuleArgs) =
                args.EnableTcpReset <- input enableTcpReset
                args

            ()
            name, List.Cons(apply, args)

        member _.EnableTcpReset((name, args), enableTcpReset) =
            let apply (args: NatRuleArgs) =
                args.EnableTcpReset <- io enableTcpReset
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("frontendIpConfigurationName")>]
        member _.FrontendIpConfigurationName((name, args), frontendIpConfigurationName) =
            let apply (args: NatRuleArgs) =
                args.FrontendIpConfigurationName <- input frontendIpConfigurationName
                args

            ()
            name, List.Cons(apply, args)

        member _.FrontendIpConfigurationName((name, args), frontendIpConfigurationName) =
            let apply (args: NatRuleArgs) =
                args.FrontendIpConfigurationName <- io frontendIpConfigurationName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("frontendPort")>]
        member _.FrontendPort((name, args), frontendPort) =
            let apply (args: NatRuleArgs) =
                args.FrontendPort <- input frontendPort
                args

            ()
            name, List.Cons(apply, args)

        member _.FrontendPort((name, args), frontendPort) =
            let apply (args: NatRuleArgs) =
                args.FrontendPort <- io frontendPort
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("idleTimeoutInMinutes")>]
        member _.IdleTimeoutInMinutes((name, args), idleTimeoutInMinutes) =
            let apply (args: NatRuleArgs) =
                args.IdleTimeoutInMinutes <- input idleTimeoutInMinutes
                args

            ()
            name, List.Cons(apply, args)

        member _.IdleTimeoutInMinutes((name, args), idleTimeoutInMinutes) =
            let apply (args: NatRuleArgs) =
                args.IdleTimeoutInMinutes <- io idleTimeoutInMinutes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("loadbalancerId")>]
        member _.LoadbalancerId((name, args), loadbalancerId) =
            let apply (args: NatRuleArgs) =
                args.LoadbalancerId <- input loadbalancerId
                args

            ()
            name, List.Cons(apply, args)

        member _.LoadbalancerId((name, args), loadbalancerId) =
            let apply (args: NatRuleArgs) =
                args.LoadbalancerId <- io loadbalancerId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: NatRuleArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: NatRuleArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("protocol")>]
        member _.Protocol((name, args), protocol) =
            let apply (args: NatRuleArgs) =
                args.Protocol <- input protocol
                args

            ()
            name, List.Cons(apply, args)

        member _.Protocol((name, args), protocol) =
            let apply (args: NatRuleArgs) =
                args.Protocol <- io protocol
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NatRuleArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NatRuleArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let natRule = NatRuleBuilder()

    type OutboundRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            OutboundRule(name, (List.fold func (OutboundRuleArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("allocatedOutboundPorts")>]
        member _.AllocatedOutboundPorts((name, args), allocatedOutboundPorts) =
            let apply (args: OutboundRuleArgs) =
                args.AllocatedOutboundPorts <- input allocatedOutboundPorts
                args

            ()
            name, List.Cons(apply, args)

        member _.AllocatedOutboundPorts((name, args), allocatedOutboundPorts) =
            let apply (args: OutboundRuleArgs) =
                args.AllocatedOutboundPorts <- io allocatedOutboundPorts
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("backendAddressPoolId")>]
        member _.BackendAddressPoolId((name, args), backendAddressPoolId) =
            let apply (args: OutboundRuleArgs) =
                args.BackendAddressPoolId <- input backendAddressPoolId
                args

            ()
            name, List.Cons(apply, args)

        member _.BackendAddressPoolId((name, args), backendAddressPoolId) =
            let apply (args: OutboundRuleArgs) =
                args.BackendAddressPoolId <- io backendAddressPoolId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enableTcpReset")>]
        member _.EnableTcpReset((name, args), enableTcpReset) =
            let apply (args: OutboundRuleArgs) =
                args.EnableTcpReset <- input enableTcpReset
                args

            ()
            name, List.Cons(apply, args)

        member _.EnableTcpReset((name, args), enableTcpReset) =
            let apply (args: OutboundRuleArgs) =
                args.EnableTcpReset <- io enableTcpReset
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("frontendIpConfigurations")>]
        member _.FrontendIpConfigurations((name, args), frontendIpConfigurations) =
            let apply (args: OutboundRuleArgs) =
                args.FrontendIpConfigurations <- inputList frontendIpConfigurations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("idleTimeoutInMinutes")>]
        member _.IdleTimeoutInMinutes((name, args), idleTimeoutInMinutes) =
            let apply (args: OutboundRuleArgs) =
                args.IdleTimeoutInMinutes <- input idleTimeoutInMinutes
                args

            ()
            name, List.Cons(apply, args)

        member _.IdleTimeoutInMinutes((name, args), idleTimeoutInMinutes) =
            let apply (args: OutboundRuleArgs) =
                args.IdleTimeoutInMinutes <- io idleTimeoutInMinutes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("loadbalancerId")>]
        member _.LoadbalancerId((name, args), loadbalancerId) =
            let apply (args: OutboundRuleArgs) =
                args.LoadbalancerId <- input loadbalancerId
                args

            ()
            name, List.Cons(apply, args)

        member _.LoadbalancerId((name, args), loadbalancerId) =
            let apply (args: OutboundRuleArgs) =
                args.LoadbalancerId <- io loadbalancerId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: OutboundRuleArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: OutboundRuleArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("protocol")>]
        member _.Protocol((name, args), protocol) =
            let apply (args: OutboundRuleArgs) =
                args.Protocol <- input protocol
                args

            ()
            name, List.Cons(apply, args)

        member _.Protocol((name, args), protocol) =
            let apply (args: OutboundRuleArgs) =
                args.Protocol <- io protocol
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: OutboundRuleArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: OutboundRuleArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let outboundRule = OutboundRuleBuilder()

    type ProbeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Probe(name, (List.fold func (ProbeArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("intervalInSeconds")>]
        member _.IntervalInSeconds((name, args), intervalInSeconds) =
            let apply (args: ProbeArgs) =
                args.IntervalInSeconds <- input intervalInSeconds
                args

            ()
            name, List.Cons(apply, args)

        member _.IntervalInSeconds((name, args), intervalInSeconds) =
            let apply (args: ProbeArgs) =
                args.IntervalInSeconds <- io intervalInSeconds
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("loadbalancerId")>]
        member _.LoadbalancerId((name, args), loadbalancerId) =
            let apply (args: ProbeArgs) =
                args.LoadbalancerId <- input loadbalancerId
                args

            ()
            name, List.Cons(apply, args)

        member _.LoadbalancerId((name, args), loadbalancerId) =
            let apply (args: ProbeArgs) =
                args.LoadbalancerId <- io loadbalancerId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ProbeArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ProbeArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("numberOfProbes")>]
        member _.NumberOfProbes((name, args), numberOfProbes) =
            let apply (args: ProbeArgs) =
                args.NumberOfProbes <- input numberOfProbes
                args

            ()
            name, List.Cons(apply, args)

        member _.NumberOfProbes((name, args), numberOfProbes) =
            let apply (args: ProbeArgs) =
                args.NumberOfProbes <- io numberOfProbes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("port")>]
        member _.Port((name, args), port) =
            let apply (args: ProbeArgs) =
                args.Port <- input port
                args

            ()
            name, List.Cons(apply, args)

        member _.Port((name, args), port) =
            let apply (args: ProbeArgs) =
                args.Port <- io port
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("protocol")>]
        member _.Protocol((name, args), protocol) =
            let apply (args: ProbeArgs) =
                args.Protocol <- input protocol
                args

            ()
            name, List.Cons(apply, args)

        member _.Protocol((name, args), protocol) =
            let apply (args: ProbeArgs) =
                args.Protocol <- io protocol
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("requestPath")>]
        member _.RequestPath((name, args), requestPath) =
            let apply (args: ProbeArgs) =
                args.RequestPath <- input requestPath
                args

            ()
            name, List.Cons(apply, args)

        member _.RequestPath((name, args), requestPath) =
            let apply (args: ProbeArgs) =
                args.RequestPath <- io requestPath
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ProbeArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ProbeArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let probe = ProbeBuilder()

    type RuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Rule(name, (List.fold func (RuleArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("backendAddressPoolId")>]
        member _.BackendAddressPoolId((name, args), backendAddressPoolId) =
            let apply (args: RuleArgs) =
                args.BackendAddressPoolId <- input backendAddressPoolId
                args

            ()
            name, List.Cons(apply, args)

        member _.BackendAddressPoolId((name, args), backendAddressPoolId) =
            let apply (args: RuleArgs) =
                args.BackendAddressPoolId <- io backendAddressPoolId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("backendPort")>]
        member _.BackendPort((name, args), backendPort) =
            let apply (args: RuleArgs) =
                args.BackendPort <- input backendPort
                args

            ()
            name, List.Cons(apply, args)

        member _.BackendPort((name, args), backendPort) =
            let apply (args: RuleArgs) =
                args.BackendPort <- io backendPort
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("disableOutboundSnat")>]
        member _.DisableOutboundSnat((name, args), disableOutboundSnat) =
            let apply (args: RuleArgs) =
                args.DisableOutboundSnat <- input disableOutboundSnat
                args

            ()
            name, List.Cons(apply, args)

        member _.DisableOutboundSnat((name, args), disableOutboundSnat) =
            let apply (args: RuleArgs) =
                args.DisableOutboundSnat <- io disableOutboundSnat
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enableFloatingIp")>]
        member _.EnableFloatingIp((name, args), enableFloatingIp) =
            let apply (args: RuleArgs) =
                args.EnableFloatingIp <- input enableFloatingIp
                args

            ()
            name, List.Cons(apply, args)

        member _.EnableFloatingIp((name, args), enableFloatingIp) =
            let apply (args: RuleArgs) =
                args.EnableFloatingIp <- io enableFloatingIp
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enableTcpReset")>]
        member _.EnableTcpReset((name, args), enableTcpReset) =
            let apply (args: RuleArgs) =
                args.EnableTcpReset <- input enableTcpReset
                args

            ()
            name, List.Cons(apply, args)

        member _.EnableTcpReset((name, args), enableTcpReset) =
            let apply (args: RuleArgs) =
                args.EnableTcpReset <- io enableTcpReset
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("frontendIpConfigurationName")>]
        member _.FrontendIpConfigurationName((name, args), frontendIpConfigurationName) =
            let apply (args: RuleArgs) =
                args.FrontendIpConfigurationName <- input frontendIpConfigurationName
                args

            ()
            name, List.Cons(apply, args)

        member _.FrontendIpConfigurationName((name, args), frontendIpConfigurationName) =
            let apply (args: RuleArgs) =
                args.FrontendIpConfigurationName <- io frontendIpConfigurationName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("frontendPort")>]
        member _.FrontendPort((name, args), frontendPort) =
            let apply (args: RuleArgs) =
                args.FrontendPort <- input frontendPort
                args

            ()
            name, List.Cons(apply, args)

        member _.FrontendPort((name, args), frontendPort) =
            let apply (args: RuleArgs) =
                args.FrontendPort <- io frontendPort
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("idleTimeoutInMinutes")>]
        member _.IdleTimeoutInMinutes((name, args), idleTimeoutInMinutes) =
            let apply (args: RuleArgs) =
                args.IdleTimeoutInMinutes <- input idleTimeoutInMinutes
                args

            ()
            name, List.Cons(apply, args)

        member _.IdleTimeoutInMinutes((name, args), idleTimeoutInMinutes) =
            let apply (args: RuleArgs) =
                args.IdleTimeoutInMinutes <- io idleTimeoutInMinutes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("loadDistribution")>]
        member _.LoadDistribution((name, args), loadDistribution) =
            let apply (args: RuleArgs) =
                args.LoadDistribution <- input loadDistribution
                args

            ()
            name, List.Cons(apply, args)

        member _.LoadDistribution((name, args), loadDistribution) =
            let apply (args: RuleArgs) =
                args.LoadDistribution <- io loadDistribution
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("loadbalancerId")>]
        member _.LoadbalancerId((name, args), loadbalancerId) =
            let apply (args: RuleArgs) =
                args.LoadbalancerId <- input loadbalancerId
                args

            ()
            name, List.Cons(apply, args)

        member _.LoadbalancerId((name, args), loadbalancerId) =
            let apply (args: RuleArgs) =
                args.LoadbalancerId <- io loadbalancerId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: RuleArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: RuleArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("probeId")>]
        member _.ProbeId((name, args), probeId) =
            let apply (args: RuleArgs) =
                args.ProbeId <- input probeId
                args

            ()
            name, List.Cons(apply, args)

        member _.ProbeId((name, args), probeId) =
            let apply (args: RuleArgs) =
                args.ProbeId <- io probeId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("protocol")>]
        member _.Protocol((name, args), protocol) =
            let apply (args: RuleArgs) =
                args.Protocol <- input protocol
                args

            ()
            name, List.Cons(apply, args)

        member _.Protocol((name, args), protocol) =
            let apply (args: RuleArgs) =
                args.Protocol <- io protocol
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: RuleArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: RuleArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let rule = RuleBuilder()

module LogicApps =
    open Pulumi.Azure.LogicApps
    open Pulumi.Azure.LogicApps.Inputs

    type ActionHttpRunAfterBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ActionHttpRunAfterArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("actionName")>]
        member _.ActionName((n, args), actionName) =
            let apply (args: ActionHttpRunAfterArgs) =
                args.ActionName <- input actionName
                args

            ()
            n, List.Cons(apply, args)

        member _.ActionName((n, args), actionName) =
            let apply (args: ActionHttpRunAfterArgs) =
                args.ActionName <- io actionName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("actionResult")>]
        member _.ActionResult((n, args), actionResult) =
            let apply (args: ActionHttpRunAfterArgs) =
                args.ActionResult <- input actionResult
                args

            ()
            n, List.Cons(apply, args)

        member _.ActionResult((n, args), actionResult) =
            let apply (args: ActionHttpRunAfterArgs) =
                args.ActionResult <- io actionResult
                args

            ()
            n, List.Cons(apply, args)

    let actionHttpRunAfter = ActionHttpRunAfterBuilder()

    type ActionCustomBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ActionCustom(name, (List.fold func (ActionCustomArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("body")>]
        member _.Body((name, args), body) =
            let apply (args: ActionCustomArgs) =
                args.Body <- input body
                args

            ()
            name, List.Cons(apply, args)

        member _.Body((name, args), body) =
            let apply (args: ActionCustomArgs) =
                args.Body <- io body
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("logicAppId")>]
        member _.LogicAppId((name, args), logicAppId) =
            let apply (args: ActionCustomArgs) =
                args.LogicAppId <- input logicAppId
                args

            ()
            name, List.Cons(apply, args)

        member _.LogicAppId((name, args), logicAppId) =
            let apply (args: ActionCustomArgs) =
                args.LogicAppId <- io logicAppId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ActionCustomArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ActionCustomArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

    let actionCustom = ActionCustomBuilder()

    type ActionHttpBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ActionHttp(name, (List.fold func (ActionHttpArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("body")>]
        member _.Body((name, args), body) =
            let apply (args: ActionHttpArgs) =
                args.Body <- input body
                args

            ()
            name, List.Cons(apply, args)

        member _.Body((name, args), body) =
            let apply (args: ActionHttpArgs) =
                args.Body <- io body
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("headers")>]
        member _.Headers((name, args), headers) =
            let apply (args: ActionHttpArgs) =
                args.Headers <- inputMap headers
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("logicAppId")>]
        member _.LogicAppId((name, args), logicAppId) =
            let apply (args: ActionHttpArgs) =
                args.LogicAppId <- input logicAppId
                args

            ()
            name, List.Cons(apply, args)

        member _.LogicAppId((name, args), logicAppId) =
            let apply (args: ActionHttpArgs) =
                args.LogicAppId <- io logicAppId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("method")>]
        member _.Method((name, args), method) =
            let apply (args: ActionHttpArgs) =
                args.Method <- input method
                args

            ()
            name, List.Cons(apply, args)

        member _.Method((name, args), method) =
            let apply (args: ActionHttpArgs) =
                args.Method <- io method
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ActionHttpArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ActionHttpArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("runAfters")>]
        member _.RunAfters((name, args), runAfters) =
            let apply (args: ActionHttpArgs) =
                args.RunAfters <- inputList runAfters
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("uri")>]
        member _.Uri((name, args), uri) =
            let apply (args: ActionHttpArgs) =
                args.Uri <- input uri
                args

            ()
            name, List.Cons(apply, args)

        member _.Uri((name, args), uri) =
            let apply (args: ActionHttpArgs) =
                args.Uri <- io uri
                args

            ()
            name, List.Cons(apply, args)

    let actionHttp = ActionHttpBuilder()

    type IntegrationAccountBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            IntegrationAccount(name, (List.fold func (IntegrationAccountArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: IntegrationAccountArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: IntegrationAccountArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: IntegrationAccountArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: IntegrationAccountArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: IntegrationAccountArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: IntegrationAccountArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("skuName")>]
        member _.SkuName((name, args), skuName) =
            let apply (args: IntegrationAccountArgs) =
                args.SkuName <- input skuName
                args

            ()
            name, List.Cons(apply, args)

        member _.SkuName((name, args), skuName) =
            let apply (args: IntegrationAccountArgs) =
                args.SkuName <- io skuName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: IntegrationAccountArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let integrationAccount = IntegrationAccountBuilder()

    type TriggerCustomBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            TriggerCustom(name, (List.fold func (TriggerCustomArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("body")>]
        member _.Body((name, args), body) =
            let apply (args: TriggerCustomArgs) =
                args.Body <- input body
                args

            ()
            name, List.Cons(apply, args)

        member _.Body((name, args), body) =
            let apply (args: TriggerCustomArgs) =
                args.Body <- io body
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("logicAppId")>]
        member _.LogicAppId((name, args), logicAppId) =
            let apply (args: TriggerCustomArgs) =
                args.LogicAppId <- input logicAppId
                args

            ()
            name, List.Cons(apply, args)

        member _.LogicAppId((name, args), logicAppId) =
            let apply (args: TriggerCustomArgs) =
                args.LogicAppId <- io logicAppId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: TriggerCustomArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: TriggerCustomArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

    let triggerCustom = TriggerCustomBuilder()

    type TriggerHttpRequestBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            TriggerHttpRequest(name, (List.fold func (TriggerHttpRequestArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("logicAppId")>]
        member _.LogicAppId((name, args), logicAppId) =
            let apply (args: TriggerHttpRequestArgs) =
                args.LogicAppId <- input logicAppId
                args

            ()
            name, List.Cons(apply, args)

        member _.LogicAppId((name, args), logicAppId) =
            let apply (args: TriggerHttpRequestArgs) =
                args.LogicAppId <- io logicAppId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("method")>]
        member _.Method((name, args), method) =
            let apply (args: TriggerHttpRequestArgs) =
                args.Method <- input method
                args

            ()
            name, List.Cons(apply, args)

        member _.Method((name, args), method) =
            let apply (args: TriggerHttpRequestArgs) =
                args.Method <- io method
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: TriggerHttpRequestArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: TriggerHttpRequestArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("relativePath")>]
        member _.RelativePath((name, args), relativePath) =
            let apply (args: TriggerHttpRequestArgs) =
                args.RelativePath <- input relativePath
                args

            ()
            name, List.Cons(apply, args)

        member _.RelativePath((name, args), relativePath) =
            let apply (args: TriggerHttpRequestArgs) =
                args.RelativePath <- io relativePath
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("schema")>]
        member _.Schema((name, args), schema) =
            let apply (args: TriggerHttpRequestArgs) =
                args.Schema <- input schema
                args

            ()
            name, List.Cons(apply, args)

        member _.Schema((name, args), schema) =
            let apply (args: TriggerHttpRequestArgs) =
                args.Schema <- io schema
                args

            ()
            name, List.Cons(apply, args)

    let triggerHttpRequest = TriggerHttpRequestBuilder()

    type TriggerRecurrenceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            TriggerRecurrence(name, (List.fold func (TriggerRecurrenceArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("frequency")>]
        member _.Frequency((name, args), frequency) =
            let apply (args: TriggerRecurrenceArgs) =
                args.Frequency <- input frequency
                args

            ()
            name, List.Cons(apply, args)

        member _.Frequency((name, args), frequency) =
            let apply (args: TriggerRecurrenceArgs) =
                args.Frequency <- io frequency
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("interval")>]
        member _.Interval((name, args), interval) =
            let apply (args: TriggerRecurrenceArgs) =
                args.Interval <- input interval
                args

            ()
            name, List.Cons(apply, args)

        member _.Interval((name, args), interval) =
            let apply (args: TriggerRecurrenceArgs) =
                args.Interval <- io interval
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("logicAppId")>]
        member _.LogicAppId((name, args), logicAppId) =
            let apply (args: TriggerRecurrenceArgs) =
                args.LogicAppId <- input logicAppId
                args

            ()
            name, List.Cons(apply, args)

        member _.LogicAppId((name, args), logicAppId) =
            let apply (args: TriggerRecurrenceArgs) =
                args.LogicAppId <- io logicAppId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: TriggerRecurrenceArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: TriggerRecurrenceArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("startTime")>]
        member _.StartTime((name, args), startTime) =
            let apply (args: TriggerRecurrenceArgs) =
                args.StartTime <- input startTime
                args

            ()
            name, List.Cons(apply, args)

        member _.StartTime((name, args), startTime) =
            let apply (args: TriggerRecurrenceArgs) =
                args.StartTime <- io startTime
                args

            ()
            name, List.Cons(apply, args)

    let triggerRecurrence = TriggerRecurrenceBuilder()

    type WorkflowBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Workflow(name, (List.fold func (WorkflowArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: WorkflowArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: WorkflowArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("logicAppIntegrationAccountId")>]
        member _.LogicAppIntegrationAccountId((name, args), logicAppIntegrationAccountId) =
            let apply (args: WorkflowArgs) =
                args.LogicAppIntegrationAccountId <- input logicAppIntegrationAccountId
                args

            ()
            name, List.Cons(apply, args)

        member _.LogicAppIntegrationAccountId((name, args), logicAppIntegrationAccountId) =
            let apply (args: WorkflowArgs) =
                args.LogicAppIntegrationAccountId <- io logicAppIntegrationAccountId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: WorkflowArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: WorkflowArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("parameters")>]
        member _.Parameters((name, args), parameters) =
            let apply (args: WorkflowArgs) =
                args.Parameters <- inputMap parameters
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: WorkflowArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: WorkflowArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: WorkflowArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("workflowSchema")>]
        member _.WorkflowSchema((name, args), workflowSchema) =
            let apply (args: WorkflowArgs) =
                args.WorkflowSchema <- input workflowSchema
                args

            ()
            name, List.Cons(apply, args)

        member _.WorkflowSchema((name, args), workflowSchema) =
            let apply (args: WorkflowArgs) =
                args.WorkflowSchema <- io workflowSchema
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("workflowVersion")>]
        member _.WorkflowVersion((name, args), workflowVersion) =
            let apply (args: WorkflowArgs) =
                args.WorkflowVersion <- input workflowVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.WorkflowVersion((name, args), workflowVersion) =
            let apply (args: WorkflowArgs) =
                args.WorkflowVersion <- io workflowVersion
                args

            ()
            name, List.Cons(apply, args)

    let workflow = WorkflowBuilder()

module MachineLearning =
    open Pulumi.Azure.MachineLearning
    open Pulumi.Azure.MachineLearning.Inputs

    type WorkspaceIdentityBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (WorkspaceIdentityArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("principalId")>]
        member _.PrincipalId((n, args), principalId) =
            let apply (args: WorkspaceIdentityArgs) =
                args.PrincipalId <- input principalId
                args

            ()
            n, List.Cons(apply, args)

        member _.PrincipalId((n, args), principalId) =
            let apply (args: WorkspaceIdentityArgs) =
                args.PrincipalId <- io principalId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tenantId")>]
        member _.TenantId((n, args), tenantId) =
            let apply (args: WorkspaceIdentityArgs) =
                args.TenantId <- input tenantId
                args

            ()
            n, List.Cons(apply, args)

        member _.TenantId((n, args), tenantId) =
            let apply (args: WorkspaceIdentityArgs) =
                args.TenantId <- io tenantId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: WorkspaceIdentityArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: WorkspaceIdentityArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let workspaceIdentity = WorkspaceIdentityBuilder()

    type WorkspaceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Workspace(name, (List.fold func (WorkspaceArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("applicationInsightsId")>]
        member _.ApplicationInsightsId((name, args), applicationInsightsId) =
            let apply (args: WorkspaceArgs) =
                args.ApplicationInsightsId <- input applicationInsightsId
                args

            ()
            name, List.Cons(apply, args)

        member _.ApplicationInsightsId((name, args), applicationInsightsId) =
            let apply (args: WorkspaceArgs) =
                args.ApplicationInsightsId <- io applicationInsightsId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("containerRegistryId")>]
        member _.ContainerRegistryId((name, args), containerRegistryId) =
            let apply (args: WorkspaceArgs) =
                args.ContainerRegistryId <- input containerRegistryId
                args

            ()
            name, List.Cons(apply, args)

        member _.ContainerRegistryId((name, args), containerRegistryId) =
            let apply (args: WorkspaceArgs) =
                args.ContainerRegistryId <- io containerRegistryId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: WorkspaceArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: WorkspaceArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("friendlyName")>]
        member _.FriendlyName((name, args), friendlyName) =
            let apply (args: WorkspaceArgs) =
                args.FriendlyName <- input friendlyName
                args

            ()
            name, List.Cons(apply, args)

        member _.FriendlyName((name, args), friendlyName) =
            let apply (args: WorkspaceArgs) =
                args.FriendlyName <- io friendlyName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: WorkspaceArgs) =
                   args.Identity <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("keyVaultId")>]
        member _.KeyVaultId((name, args), keyVaultId) =
            let apply (args: WorkspaceArgs) =
                args.KeyVaultId <- input keyVaultId
                args

            ()
            name, List.Cons(apply, args)

        member _.KeyVaultId((name, args), keyVaultId) =
            let apply (args: WorkspaceArgs) =
                args.KeyVaultId <- io keyVaultId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: WorkspaceArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: WorkspaceArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: WorkspaceArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: WorkspaceArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: WorkspaceArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: WorkspaceArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("skuName")>]
        member _.SkuName((name, args), skuName) =
            let apply (args: WorkspaceArgs) =
                args.SkuName <- input skuName
                args

            ()
            name, List.Cons(apply, args)

        member _.SkuName((name, args), skuName) =
            let apply (args: WorkspaceArgs) =
                args.SkuName <- io skuName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageAccountId")>]
        member _.StorageAccountId((name, args), storageAccountId) =
            let apply (args: WorkspaceArgs) =
                args.StorageAccountId <- input storageAccountId
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageAccountId((name, args), storageAccountId) =
            let apply (args: WorkspaceArgs) =
                args.StorageAccountId <- io storageAccountId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: WorkspaceArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let workspace = WorkspaceBuilder()

module ManagedApplication =
    open Pulumi.Azure.ManagedApplication
    open Pulumi.Azure.ManagedApplication.Inputs

    type ApplicationPlanBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApplicationPlanArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ApplicationPlanArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ApplicationPlanArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("product")>]
        member _.Product((n, args), product) =
            let apply (args: ApplicationPlanArgs) =
                args.Product <- input product
                args

            ()
            n, List.Cons(apply, args)

        member _.Product((n, args), product) =
            let apply (args: ApplicationPlanArgs) =
                args.Product <- io product
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("promotionCode")>]
        member _.PromotionCode((n, args), promotionCode) =
            let apply (args: ApplicationPlanArgs) =
                args.PromotionCode <- input promotionCode
                args

            ()
            n, List.Cons(apply, args)

        member _.PromotionCode((n, args), promotionCode) =
            let apply (args: ApplicationPlanArgs) =
                args.PromotionCode <- io promotionCode
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publisher")>]
        member _.Publisher((n, args), publisher) =
            let apply (args: ApplicationPlanArgs) =
                args.Publisher <- input publisher
                args

            ()
            n, List.Cons(apply, args)

        member _.Publisher((n, args), publisher) =
            let apply (args: ApplicationPlanArgs) =
                args.Publisher <- io publisher
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("version")>]
        member _.Version((n, args), version) =
            let apply (args: ApplicationPlanArgs) =
                args.Version <- input version
                args

            ()
            n, List.Cons(apply, args)

        member _.Version((n, args), version) =
            let apply (args: ApplicationPlanArgs) =
                args.Version <- io version
                args

            ()
            n, List.Cons(apply, args)

    let applicationPlan = ApplicationPlanBuilder()

    type DefinitionAuthorizationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (DefinitionAuthorizationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("roleDefinitionId")>]
        member _.RoleDefinitionId((n, args), roleDefinitionId) =
            let apply (args: DefinitionAuthorizationArgs) =
                args.RoleDefinitionId <- input roleDefinitionId
                args

            ()
            n, List.Cons(apply, args)

        member _.RoleDefinitionId((n, args), roleDefinitionId) =
            let apply (args: DefinitionAuthorizationArgs) =
                args.RoleDefinitionId <- io roleDefinitionId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("servicePrincipalId")>]
        member _.ServicePrincipalId((n, args), servicePrincipalId) =
            let apply (args: DefinitionAuthorizationArgs) =
                args.ServicePrincipalId <- input servicePrincipalId
                args

            ()
            n, List.Cons(apply, args)

        member _.ServicePrincipalId((n, args), servicePrincipalId) =
            let apply (args: DefinitionAuthorizationArgs) =
                args.ServicePrincipalId <- io servicePrincipalId
                args

            ()
            n, List.Cons(apply, args)

    let definitionAuthorization = DefinitionAuthorizationBuilder()

    type ApplicationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Application(name, (List.fold func (ApplicationArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("applicationDefinitionId")>]
        member _.ApplicationDefinitionId((name, args), applicationDefinitionId) =
            let apply (args: ApplicationArgs) =
                args.ApplicationDefinitionId <- input applicationDefinitionId
                args

            ()
            name, List.Cons(apply, args)

        member _.ApplicationDefinitionId((name, args), applicationDefinitionId) =
            let apply (args: ApplicationArgs) =
                args.ApplicationDefinitionId <- io applicationDefinitionId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("kind")>]
        member _.Kind((name, args), kind) =
            let apply (args: ApplicationArgs) =
                args.Kind <- input kind
                args

            ()
            name, List.Cons(apply, args)

        member _.Kind((name, args), kind) =
            let apply (args: ApplicationArgs) =
                args.Kind <- io kind
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ApplicationArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ApplicationArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("managedResourceGroupName")>]
        member _.ManagedResourceGroupName((name, args), managedResourceGroupName) =
            let apply (args: ApplicationArgs) =
                args.ManagedResourceGroupName <- input managedResourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ManagedResourceGroupName((name, args), managedResourceGroupName) =
            let apply (args: ApplicationArgs) =
                args.ManagedResourceGroupName <- io managedResourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ApplicationArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ApplicationArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("parameters")>]
        member _.Parameters((name, args), parameters) =
            let apply (args: ApplicationArgs) =
                args.Parameters <- inputMap parameters
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ApplicationArgs) =
                   args.Plan <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ApplicationArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ApplicationArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ApplicationArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let application = ApplicationBuilder()

    type DefinitionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Definition(name, (List.fold func (DefinitionArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("authorizations")>]
        member _.Authorizations((name, args), authorizations) =
            let apply (args: DefinitionArgs) =
                args.Authorizations <- inputList authorizations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("createUiDefinition")>]
        member _.CreateUiDefinition((name, args), createUiDefinition) =
            let apply (args: DefinitionArgs) =
                args.CreateUiDefinition <- input createUiDefinition
                args

            ()
            name, List.Cons(apply, args)

        member _.CreateUiDefinition((name, args), createUiDefinition) =
            let apply (args: DefinitionArgs) =
                args.CreateUiDefinition <- io createUiDefinition
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: DefinitionArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: DefinitionArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("displayName")>]
        member _.DisplayName((name, args), displayName) =
            let apply (args: DefinitionArgs) =
                args.DisplayName <- input displayName
                args

            ()
            name, List.Cons(apply, args)

        member _.DisplayName((name, args), displayName) =
            let apply (args: DefinitionArgs) =
                args.DisplayName <- io displayName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: DefinitionArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: DefinitionArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("lockLevel")>]
        member _.LockLevel((name, args), lockLevel) =
            let apply (args: DefinitionArgs) =
                args.LockLevel <- input lockLevel
                args

            ()
            name, List.Cons(apply, args)

        member _.LockLevel((name, args), lockLevel) =
            let apply (args: DefinitionArgs) =
                args.LockLevel <- io lockLevel
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("mainTemplate")>]
        member _.MainTemplate((name, args), mainTemplate) =
            let apply (args: DefinitionArgs) =
                args.MainTemplate <- input mainTemplate
                args

            ()
            name, List.Cons(apply, args)

        member _.MainTemplate((name, args), mainTemplate) =
            let apply (args: DefinitionArgs) =
                args.MainTemplate <- io mainTemplate
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: DefinitionArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: DefinitionArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("packageEnabled")>]
        member _.PackageEnabled((name, args), packageEnabled) =
            let apply (args: DefinitionArgs) =
                args.PackageEnabled <- input packageEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.PackageEnabled((name, args), packageEnabled) =
            let apply (args: DefinitionArgs) =
                args.PackageEnabled <- io packageEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("packageFileUri")>]
        member _.PackageFileUri((name, args), packageFileUri) =
            let apply (args: DefinitionArgs) =
                args.PackageFileUri <- input packageFileUri
                args

            ()
            name, List.Cons(apply, args)

        member _.PackageFileUri((name, args), packageFileUri) =
            let apply (args: DefinitionArgs) =
                args.PackageFileUri <- io packageFileUri
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DefinitionArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DefinitionArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: DefinitionArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let definition = DefinitionBuilder()

module MariaDB =
    open Pulumi.Azure.MariaDB
    open Pulumi.Azure.MariaDB.Inputs

    type ServerStorageProfileBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ServerStorageProfileArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("autoGrow")>]
        member _.AutoGrow((n, args), autoGrow) =
            let apply (args: ServerStorageProfileArgs) =
                args.AutoGrow <- input autoGrow
                args

            ()
            n, List.Cons(apply, args)

        member _.AutoGrow((n, args), autoGrow) =
            let apply (args: ServerStorageProfileArgs) =
                args.AutoGrow <- io autoGrow
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("backupRetentionDays")>]
        member _.BackupRetentionDays((n, args), backupRetentionDays) =
            let apply (args: ServerStorageProfileArgs) =
                args.BackupRetentionDays <- input backupRetentionDays
                args

            ()
            n, List.Cons(apply, args)

        member _.BackupRetentionDays((n, args), backupRetentionDays) =
            let apply (args: ServerStorageProfileArgs) =
                args.BackupRetentionDays <- io backupRetentionDays
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("geoRedundantBackup")>]
        member _.GeoRedundantBackup((n, args), geoRedundantBackup) =
            let apply (args: ServerStorageProfileArgs) =
                args.GeoRedundantBackup <- input geoRedundantBackup
                args

            ()
            n, List.Cons(apply, args)

        member _.GeoRedundantBackup((n, args), geoRedundantBackup) =
            let apply (args: ServerStorageProfileArgs) =
                args.GeoRedundantBackup <- io geoRedundantBackup
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageMb")>]
        member _.StorageMb((n, args), storageMb) =
            let apply (args: ServerStorageProfileArgs) =
                args.StorageMb <- input storageMb
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageMb((n, args), storageMb) =
            let apply (args: ServerStorageProfileArgs) =
                args.StorageMb <- io storageMb
                args

            ()
            n, List.Cons(apply, args)

    let serverStorageProfile = ServerStorageProfileBuilder()

    type ConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Configuration(name, (List.fold func (ConfigurationArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ConfigurationArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ConfigurationArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ConfigurationArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ConfigurationArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serverName")>]
        member _.ServerName((name, args), serverName) =
            let apply (args: ConfigurationArgs) =
                args.ServerName <- input serverName
                args

            ()
            name, List.Cons(apply, args)

        member _.ServerName((name, args), serverName) =
            let apply (args: ConfigurationArgs) =
                args.ServerName <- io serverName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((name, args), value) =
            let apply (args: ConfigurationArgs) =
                args.Value <- input value
                args

            ()
            name, List.Cons(apply, args)

        member _.Value((name, args), value) =
            let apply (args: ConfigurationArgs) =
                args.Value <- io value
                args

            ()
            name, List.Cons(apply, args)

    let configuration = ConfigurationBuilder()

    type DatabaseBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Database(name, (List.fold func (DatabaseArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("charset")>]
        member _.Charset((name, args), charset) =
            let apply (args: DatabaseArgs) =
                args.Charset <- input charset
                args

            ()
            name, List.Cons(apply, args)

        member _.Charset((name, args), charset) =
            let apply (args: DatabaseArgs) =
                args.Charset <- io charset
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("collation")>]
        member _.Collation((name, args), collation) =
            let apply (args: DatabaseArgs) =
                args.Collation <- input collation
                args

            ()
            name, List.Cons(apply, args)

        member _.Collation((name, args), collation) =
            let apply (args: DatabaseArgs) =
                args.Collation <- io collation
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: DatabaseArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: DatabaseArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DatabaseArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DatabaseArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serverName")>]
        member _.ServerName((name, args), serverName) =
            let apply (args: DatabaseArgs) =
                args.ServerName <- input serverName
                args

            ()
            name, List.Cons(apply, args)

        member _.ServerName((name, args), serverName) =
            let apply (args: DatabaseArgs) =
                args.ServerName <- io serverName
                args

            ()
            name, List.Cons(apply, args)

    let database = DatabaseBuilder()

    type FirewallRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            FirewallRule(name, (List.fold func (FirewallRuleArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("endIpAddress")>]
        member _.EndIpAddress((name, args), endIpAddress) =
            let apply (args: FirewallRuleArgs) =
                args.EndIpAddress <- input endIpAddress
                args

            ()
            name, List.Cons(apply, args)

        member _.EndIpAddress((name, args), endIpAddress) =
            let apply (args: FirewallRuleArgs) =
                args.EndIpAddress <- io endIpAddress
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: FirewallRuleArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: FirewallRuleArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FirewallRuleArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FirewallRuleArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serverName")>]
        member _.ServerName((name, args), serverName) =
            let apply (args: FirewallRuleArgs) =
                args.ServerName <- input serverName
                args

            ()
            name, List.Cons(apply, args)

        member _.ServerName((name, args), serverName) =
            let apply (args: FirewallRuleArgs) =
                args.ServerName <- io serverName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("startIpAddress")>]
        member _.StartIpAddress((name, args), startIpAddress) =
            let apply (args: FirewallRuleArgs) =
                args.StartIpAddress <- input startIpAddress
                args

            ()
            name, List.Cons(apply, args)

        member _.StartIpAddress((name, args), startIpAddress) =
            let apply (args: FirewallRuleArgs) =
                args.StartIpAddress <- io startIpAddress
                args

            ()
            name, List.Cons(apply, args)

    let firewallRule = FirewallRuleBuilder()

    type ServerBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Server(name, (List.fold func (ServerArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("administratorLogin")>]
        member _.AdministratorLogin((name, args), administratorLogin) =
            let apply (args: ServerArgs) =
                args.AdministratorLogin <- input administratorLogin
                args

            ()
            name, List.Cons(apply, args)

        member _.AdministratorLogin((name, args), administratorLogin) =
            let apply (args: ServerArgs) =
                args.AdministratorLogin <- io administratorLogin
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("administratorLoginPassword")>]
        member _.AdministratorLoginPassword((name, args), administratorLoginPassword) =
            let apply (args: ServerArgs) =
                args.AdministratorLoginPassword <- input administratorLoginPassword
                args

            ()
            name, List.Cons(apply, args)

        member _.AdministratorLoginPassword((name, args), administratorLoginPassword) =
            let apply (args: ServerArgs) =
                args.AdministratorLoginPassword <- io administratorLoginPassword
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("autoGrowEnabled")>]
        member _.AutoGrowEnabled((name, args), autoGrowEnabled) =
            let apply (args: ServerArgs) =
                args.AutoGrowEnabled <- input autoGrowEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.AutoGrowEnabled((name, args), autoGrowEnabled) =
            let apply (args: ServerArgs) =
                args.AutoGrowEnabled <- io autoGrowEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("backupRetentionDays")>]
        member _.BackupRetentionDays((name, args), backupRetentionDays) =
            let apply (args: ServerArgs) =
                args.BackupRetentionDays <- input backupRetentionDays
                args

            ()
            name, List.Cons(apply, args)

        member _.BackupRetentionDays((name, args), backupRetentionDays) =
            let apply (args: ServerArgs) =
                args.BackupRetentionDays <- io backupRetentionDays
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("createMode")>]
        member _.CreateMode((name, args), createMode) =
            let apply (args: ServerArgs) =
                args.CreateMode <- input createMode
                args

            ()
            name, List.Cons(apply, args)

        member _.CreateMode((name, args), createMode) =
            let apply (args: ServerArgs) =
                args.CreateMode <- io createMode
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("creationSourceServerId")>]
        member _.CreationSourceServerId((name, args), creationSourceServerId) =
            let apply (args: ServerArgs) =
                args.CreationSourceServerId <- input creationSourceServerId
                args

            ()
            name, List.Cons(apply, args)

        member _.CreationSourceServerId((name, args), creationSourceServerId) =
            let apply (args: ServerArgs) =
                args.CreationSourceServerId <- io creationSourceServerId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("geoRedundantBackupEnabled")>]
        member _.GeoRedundantBackupEnabled((name, args), geoRedundantBackupEnabled) =
            let apply (args: ServerArgs) =
                args.GeoRedundantBackupEnabled <- input geoRedundantBackupEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.GeoRedundantBackupEnabled((name, args), geoRedundantBackupEnabled) =
            let apply (args: ServerArgs) =
                args.GeoRedundantBackupEnabled <- io geoRedundantBackupEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ServerArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ServerArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ServerArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ServerArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("publicNetworkAccessEnabled")>]
        member _.PublicNetworkAccessEnabled((name, args), publicNetworkAccessEnabled) =
            let apply (args: ServerArgs) =
                args.PublicNetworkAccessEnabled <- input publicNetworkAccessEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.PublicNetworkAccessEnabled((name, args), publicNetworkAccessEnabled) =
            let apply (args: ServerArgs) =
                args.PublicNetworkAccessEnabled <- io publicNetworkAccessEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ServerArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ServerArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("restorePointInTime")>]
        member _.RestorePointInTime((name, args), restorePointInTime) =
            let apply (args: ServerArgs) =
                args.RestorePointInTime <- input restorePointInTime
                args

            ()
            name, List.Cons(apply, args)

        member _.RestorePointInTime((name, args), restorePointInTime) =
            let apply (args: ServerArgs) =
                args.RestorePointInTime <- io restorePointInTime
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("skuName")>]
        member _.SkuName((name, args), skuName) =
            let apply (args: ServerArgs) =
                args.SkuName <- input skuName
                args

            ()
            name, List.Cons(apply, args)

        member _.SkuName((name, args), skuName) =
            let apply (args: ServerArgs) =
                args.SkuName <- io skuName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sslEnforcement")>]
        member _.SslEnforcement((name, args), sslEnforcement) =
            let apply (args: ServerArgs) =
                args.SslEnforcement <- input sslEnforcement
                args

            ()
            name, List.Cons(apply, args)

        member _.SslEnforcement((name, args), sslEnforcement) =
            let apply (args: ServerArgs) =
                args.SslEnforcement <- io sslEnforcement
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sslEnforcementEnabled")>]
        member _.SslEnforcementEnabled((name, args), sslEnforcementEnabled) =
            let apply (args: ServerArgs) =
                args.SslEnforcementEnabled <- input sslEnforcementEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.SslEnforcementEnabled((name, args), sslEnforcementEnabled) =
            let apply (args: ServerArgs) =
                args.SslEnforcementEnabled <- io sslEnforcementEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageMb")>]
        member _.StorageMb((name, args), storageMb) =
            let apply (args: ServerArgs) =
                args.StorageMb <- input storageMb
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageMb((name, args), storageMb) =
            let apply (args: ServerArgs) =
                args.StorageMb <- io storageMb
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ServerArgs) =
                   args.StorageProfile <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ServerArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("version")>]
        member _.Version((name, args), version) =
            let apply (args: ServerArgs) =
                args.Version <- input version
                args

            ()
            name, List.Cons(apply, args)

        member _.Version((name, args), version) =
            let apply (args: ServerArgs) =
                args.Version <- io version
                args

            ()
            name, List.Cons(apply, args)

    let server = ServerBuilder()

    type VirtualNetworkRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            VirtualNetworkRule(name, (List.fold func (VirtualNetworkRuleArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serverName")>]
        member _.ServerName((name, args), serverName) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.ServerName <- input serverName
                args

            ()
            name, List.Cons(apply, args)

        member _.ServerName((name, args), serverName) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.ServerName <- io serverName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((name, args), subnetId) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            name, List.Cons(apply, args)

        member _.SubnetId((name, args), subnetId) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            name, List.Cons(apply, args)

    let virtualNetworkRule = VirtualNetworkRuleBuilder()

module MediaServices =
    open Pulumi.Azure.MediaServices
    open Pulumi.Azure.MediaServices.Inputs

    type AccountStorageAccountBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AccountStorageAccountArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: AccountStorageAccountArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: AccountStorageAccountArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("isPrimary")>]
        member _.IsPrimary((n, args), isPrimary) =
            let apply (args: AccountStorageAccountArgs) =
                args.IsPrimary <- input isPrimary
                args

            ()
            n, List.Cons(apply, args)

        member _.IsPrimary((n, args), isPrimary) =
            let apply (args: AccountStorageAccountArgs) =
                args.IsPrimary <- io isPrimary
                args

            ()
            n, List.Cons(apply, args)

    let accountStorageAccount = AccountStorageAccountBuilder()

    type AccountBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Account(name, (List.fold func (AccountArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: AccountArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: AccountArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: AccountArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: AccountArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AccountArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AccountArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageAccounts")>]
        member _.StorageAccounts((name, args), storageAccounts) =
            let apply (args: AccountArgs) =
                args.StorageAccounts <- inputList storageAccounts
                args

            ()
            name, List.Cons(apply, args)

    let account = AccountBuilder()

module Monitoring =
    open Pulumi.Azure.Monitoring
    open Pulumi.Azure.Monitoring.Inputs

    type ActionGroupArmRoleReceiverBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ActionGroupArmRoleReceiverArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ActionGroupArmRoleReceiverArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ActionGroupArmRoleReceiverArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("roleId")>]
        member _.RoleId((n, args), roleId) =
            let apply (args: ActionGroupArmRoleReceiverArgs) =
                args.RoleId <- input roleId
                args

            ()
            n, List.Cons(apply, args)

        member _.RoleId((n, args), roleId) =
            let apply (args: ActionGroupArmRoleReceiverArgs) =
                args.RoleId <- io roleId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("useCommonAlertSchema")>]
        member _.UseCommonAlertSchema((n, args), useCommonAlertSchema) =
            let apply (args: ActionGroupArmRoleReceiverArgs) =
                args.UseCommonAlertSchema <- input useCommonAlertSchema
                args

            ()
            n, List.Cons(apply, args)

        member _.UseCommonAlertSchema((n, args), useCommonAlertSchema) =
            let apply (args: ActionGroupArmRoleReceiverArgs) =
                args.UseCommonAlertSchema <- io useCommonAlertSchema
                args

            ()
            n, List.Cons(apply, args)

    let actionGroupArmRoleReceiver = ActionGroupArmRoleReceiverBuilder()

    type ActionGroupAutomationRunbookReceiverBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ActionGroupAutomationRunbookReceiverArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("automationAccountId")>]
        member _.AutomationAccountId((n, args), automationAccountId) =
            let apply (args: ActionGroupAutomationRunbookReceiverArgs) =
                args.AutomationAccountId <- input automationAccountId
                args

            ()
            n, List.Cons(apply, args)

        member _.AutomationAccountId((n, args), automationAccountId) =
            let apply (args: ActionGroupAutomationRunbookReceiverArgs) =
                args.AutomationAccountId <- io automationAccountId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("isGlobalRunbook")>]
        member _.IsGlobalRunbook((n, args), isGlobalRunbook) =
            let apply (args: ActionGroupAutomationRunbookReceiverArgs) =
                args.IsGlobalRunbook <- input isGlobalRunbook
                args

            ()
            n, List.Cons(apply, args)

        member _.IsGlobalRunbook((n, args), isGlobalRunbook) =
            let apply (args: ActionGroupAutomationRunbookReceiverArgs) =
                args.IsGlobalRunbook <- io isGlobalRunbook
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ActionGroupAutomationRunbookReceiverArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ActionGroupAutomationRunbookReceiverArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("runbookName")>]
        member _.RunbookName((n, args), runbookName) =
            let apply (args: ActionGroupAutomationRunbookReceiverArgs) =
                args.RunbookName <- input runbookName
                args

            ()
            n, List.Cons(apply, args)

        member _.RunbookName((n, args), runbookName) =
            let apply (args: ActionGroupAutomationRunbookReceiverArgs) =
                args.RunbookName <- io runbookName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("serviceUri")>]
        member _.ServiceUri((n, args), serviceUri) =
            let apply (args: ActionGroupAutomationRunbookReceiverArgs) =
                args.ServiceUri <- input serviceUri
                args

            ()
            n, List.Cons(apply, args)

        member _.ServiceUri((n, args), serviceUri) =
            let apply (args: ActionGroupAutomationRunbookReceiverArgs) =
                args.ServiceUri <- io serviceUri
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("useCommonAlertSchema")>]
        member _.UseCommonAlertSchema((n, args), useCommonAlertSchema) =
            let apply (args: ActionGroupAutomationRunbookReceiverArgs) =
                args.UseCommonAlertSchema <- input useCommonAlertSchema
                args

            ()
            n, List.Cons(apply, args)

        member _.UseCommonAlertSchema((n, args), useCommonAlertSchema) =
            let apply (args: ActionGroupAutomationRunbookReceiverArgs) =
                args.UseCommonAlertSchema <- io useCommonAlertSchema
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("webhookResourceId")>]
        member _.WebhookResourceId((n, args), webhookResourceId) =
            let apply (args: ActionGroupAutomationRunbookReceiverArgs) =
                args.WebhookResourceId <- input webhookResourceId
                args

            ()
            n, List.Cons(apply, args)

        member _.WebhookResourceId((n, args), webhookResourceId) =
            let apply (args: ActionGroupAutomationRunbookReceiverArgs) =
                args.WebhookResourceId <- io webhookResourceId
                args

            ()
            n, List.Cons(apply, args)

    let actionGroupAutomationRunbookReceiver =
        ActionGroupAutomationRunbookReceiverBuilder()

    type ActionGroupAzureAppPushReceiverBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ActionGroupAzureAppPushReceiverArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("emailAddress")>]
        member _.EmailAddress((n, args), emailAddress) =
            let apply (args: ActionGroupAzureAppPushReceiverArgs) =
                args.EmailAddress <- input emailAddress
                args

            ()
            n, List.Cons(apply, args)

        member _.EmailAddress((n, args), emailAddress) =
            let apply (args: ActionGroupAzureAppPushReceiverArgs) =
                args.EmailAddress <- io emailAddress
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ActionGroupAzureAppPushReceiverArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ActionGroupAzureAppPushReceiverArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

    let actionGroupAzureAppPushReceiver = ActionGroupAzureAppPushReceiverBuilder()

    type ActionGroupAzureFunctionReceiverBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ActionGroupAzureFunctionReceiverArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("functionAppResourceId")>]
        member _.FunctionAppResourceId((n, args), functionAppResourceId) =
            let apply (args: ActionGroupAzureFunctionReceiverArgs) =
                args.FunctionAppResourceId <- input functionAppResourceId
                args

            ()
            n, List.Cons(apply, args)

        member _.FunctionAppResourceId((n, args), functionAppResourceId) =
            let apply (args: ActionGroupAzureFunctionReceiverArgs) =
                args.FunctionAppResourceId <- io functionAppResourceId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("functionName")>]
        member _.FunctionName((n, args), functionName) =
            let apply (args: ActionGroupAzureFunctionReceiverArgs) =
                args.FunctionName <- input functionName
                args

            ()
            n, List.Cons(apply, args)

        member _.FunctionName((n, args), functionName) =
            let apply (args: ActionGroupAzureFunctionReceiverArgs) =
                args.FunctionName <- io functionName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("httpTriggerUrl")>]
        member _.HttpTriggerUrl((n, args), httpTriggerUrl) =
            let apply (args: ActionGroupAzureFunctionReceiverArgs) =
                args.HttpTriggerUrl <- input httpTriggerUrl
                args

            ()
            n, List.Cons(apply, args)

        member _.HttpTriggerUrl((n, args), httpTriggerUrl) =
            let apply (args: ActionGroupAzureFunctionReceiverArgs) =
                args.HttpTriggerUrl <- io httpTriggerUrl
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ActionGroupAzureFunctionReceiverArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ActionGroupAzureFunctionReceiverArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("useCommonAlertSchema")>]
        member _.UseCommonAlertSchema((n, args), useCommonAlertSchema) =
            let apply (args: ActionGroupAzureFunctionReceiverArgs) =
                args.UseCommonAlertSchema <- input useCommonAlertSchema
                args

            ()
            n, List.Cons(apply, args)

        member _.UseCommonAlertSchema((n, args), useCommonAlertSchema) =
            let apply (args: ActionGroupAzureFunctionReceiverArgs) =
                args.UseCommonAlertSchema <- io useCommonAlertSchema
                args

            ()
            n, List.Cons(apply, args)

    let actionGroupAzureFunctionReceiver =
        ActionGroupAzureFunctionReceiverBuilder()

    type ActionGroupEmailReceiverBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ActionGroupEmailReceiverArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("emailAddress")>]
        member _.EmailAddress((n, args), emailAddress) =
            let apply (args: ActionGroupEmailReceiverArgs) =
                args.EmailAddress <- input emailAddress
                args

            ()
            n, List.Cons(apply, args)

        member _.EmailAddress((n, args), emailAddress) =
            let apply (args: ActionGroupEmailReceiverArgs) =
                args.EmailAddress <- io emailAddress
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ActionGroupEmailReceiverArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ActionGroupEmailReceiverArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("useCommonAlertSchema")>]
        member _.UseCommonAlertSchema((n, args), useCommonAlertSchema) =
            let apply (args: ActionGroupEmailReceiverArgs) =
                args.UseCommonAlertSchema <- input useCommonAlertSchema
                args

            ()
            n, List.Cons(apply, args)

        member _.UseCommonAlertSchema((n, args), useCommonAlertSchema) =
            let apply (args: ActionGroupEmailReceiverArgs) =
                args.UseCommonAlertSchema <- io useCommonAlertSchema
                args

            ()
            n, List.Cons(apply, args)

    let actionGroupEmailReceiver = ActionGroupEmailReceiverBuilder()

    type ActionGroupItsmReceiverBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ActionGroupItsmReceiverArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("connectionId")>]
        member _.ConnectionId((n, args), connectionId) =
            let apply (args: ActionGroupItsmReceiverArgs) =
                args.ConnectionId <- input connectionId
                args

            ()
            n, List.Cons(apply, args)

        member _.ConnectionId((n, args), connectionId) =
            let apply (args: ActionGroupItsmReceiverArgs) =
                args.ConnectionId <- io connectionId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ActionGroupItsmReceiverArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ActionGroupItsmReceiverArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("region")>]
        member _.Region((n, args), region) =
            let apply (args: ActionGroupItsmReceiverArgs) =
                args.Region <- input region
                args

            ()
            n, List.Cons(apply, args)

        member _.Region((n, args), region) =
            let apply (args: ActionGroupItsmReceiverArgs) =
                args.Region <- io region
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ticketConfiguration")>]
        member _.TicketConfiguration((n, args), ticketConfiguration) =
            let apply (args: ActionGroupItsmReceiverArgs) =
                args.TicketConfiguration <- input ticketConfiguration
                args

            ()
            n, List.Cons(apply, args)

        member _.TicketConfiguration((n, args), ticketConfiguration) =
            let apply (args: ActionGroupItsmReceiverArgs) =
                args.TicketConfiguration <- io ticketConfiguration
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("workspaceId")>]
        member _.WorkspaceId((n, args), workspaceId) =
            let apply (args: ActionGroupItsmReceiverArgs) =
                args.WorkspaceId <- input workspaceId
                args

            ()
            n, List.Cons(apply, args)

        member _.WorkspaceId((n, args), workspaceId) =
            let apply (args: ActionGroupItsmReceiverArgs) =
                args.WorkspaceId <- io workspaceId
                args

            ()
            n, List.Cons(apply, args)

    let actionGroupItsmReceiver = ActionGroupItsmReceiverBuilder()

    type ActionGroupLogicAppReceiverBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ActionGroupLogicAppReceiverArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("callbackUrl")>]
        member _.CallbackUrl((n, args), callbackUrl) =
            let apply (args: ActionGroupLogicAppReceiverArgs) =
                args.CallbackUrl <- input callbackUrl
                args

            ()
            n, List.Cons(apply, args)

        member _.CallbackUrl((n, args), callbackUrl) =
            let apply (args: ActionGroupLogicAppReceiverArgs) =
                args.CallbackUrl <- io callbackUrl
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ActionGroupLogicAppReceiverArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ActionGroupLogicAppReceiverArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("resourceId")>]
        member _.ResourceId((n, args), resourceId) =
            let apply (args: ActionGroupLogicAppReceiverArgs) =
                args.ResourceId <- input resourceId
                args

            ()
            n, List.Cons(apply, args)

        member _.ResourceId((n, args), resourceId) =
            let apply (args: ActionGroupLogicAppReceiverArgs) =
                args.ResourceId <- io resourceId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("useCommonAlertSchema")>]
        member _.UseCommonAlertSchema((n, args), useCommonAlertSchema) =
            let apply (args: ActionGroupLogicAppReceiverArgs) =
                args.UseCommonAlertSchema <- input useCommonAlertSchema
                args

            ()
            n, List.Cons(apply, args)

        member _.UseCommonAlertSchema((n, args), useCommonAlertSchema) =
            let apply (args: ActionGroupLogicAppReceiverArgs) =
                args.UseCommonAlertSchema <- io useCommonAlertSchema
                args

            ()
            n, List.Cons(apply, args)

    let actionGroupLogicAppReceiver = ActionGroupLogicAppReceiverBuilder()

    type ActionGroupSmsReceiverBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ActionGroupSmsReceiverArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("countryCode")>]
        member _.CountryCode((n, args), countryCode) =
            let apply (args: ActionGroupSmsReceiverArgs) =
                args.CountryCode <- input countryCode
                args

            ()
            n, List.Cons(apply, args)

        member _.CountryCode((n, args), countryCode) =
            let apply (args: ActionGroupSmsReceiverArgs) =
                args.CountryCode <- io countryCode
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ActionGroupSmsReceiverArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ActionGroupSmsReceiverArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("phoneNumber")>]
        member _.PhoneNumber((n, args), phoneNumber) =
            let apply (args: ActionGroupSmsReceiverArgs) =
                args.PhoneNumber <- input phoneNumber
                args

            ()
            n, List.Cons(apply, args)

        member _.PhoneNumber((n, args), phoneNumber) =
            let apply (args: ActionGroupSmsReceiverArgs) =
                args.PhoneNumber <- io phoneNumber
                args

            ()
            n, List.Cons(apply, args)

    let actionGroupSmsReceiver = ActionGroupSmsReceiverBuilder()

    type ActionGroupVoiceReceiverBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ActionGroupVoiceReceiverArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("countryCode")>]
        member _.CountryCode((n, args), countryCode) =
            let apply (args: ActionGroupVoiceReceiverArgs) =
                args.CountryCode <- input countryCode
                args

            ()
            n, List.Cons(apply, args)

        member _.CountryCode((n, args), countryCode) =
            let apply (args: ActionGroupVoiceReceiverArgs) =
                args.CountryCode <- io countryCode
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ActionGroupVoiceReceiverArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ActionGroupVoiceReceiverArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("phoneNumber")>]
        member _.PhoneNumber((n, args), phoneNumber) =
            let apply (args: ActionGroupVoiceReceiverArgs) =
                args.PhoneNumber <- input phoneNumber
                args

            ()
            n, List.Cons(apply, args)

        member _.PhoneNumber((n, args), phoneNumber) =
            let apply (args: ActionGroupVoiceReceiverArgs) =
                args.PhoneNumber <- io phoneNumber
                args

            ()
            n, List.Cons(apply, args)

    let actionGroupVoiceReceiver = ActionGroupVoiceReceiverBuilder()

    type ActionGroupWebhookReceiverBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ActionGroupWebhookReceiverArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ActionGroupWebhookReceiverArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ActionGroupWebhookReceiverArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("serviceUri")>]
        member _.ServiceUri((n, args), serviceUri) =
            let apply (args: ActionGroupWebhookReceiverArgs) =
                args.ServiceUri <- input serviceUri
                args

            ()
            n, List.Cons(apply, args)

        member _.ServiceUri((n, args), serviceUri) =
            let apply (args: ActionGroupWebhookReceiverArgs) =
                args.ServiceUri <- io serviceUri
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("useCommonAlertSchema")>]
        member _.UseCommonAlertSchema((n, args), useCommonAlertSchema) =
            let apply (args: ActionGroupWebhookReceiverArgs) =
                args.UseCommonAlertSchema <- input useCommonAlertSchema
                args

            ()
            n, List.Cons(apply, args)

        member _.UseCommonAlertSchema((n, args), useCommonAlertSchema) =
            let apply (args: ActionGroupWebhookReceiverArgs) =
                args.UseCommonAlertSchema <- io useCommonAlertSchema
                args

            ()
            n, List.Cons(apply, args)

    let actionGroupWebhookReceiver = ActionGroupWebhookReceiverBuilder()

    type ActionRuleActionGroupConditionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ActionRuleActionGroupConditionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: ActionRuleActionGroupConditionArgs) =
                   args.AlertContext <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: ActionRuleActionGroupConditionArgs) =
                   args.AlertRuleId <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: ActionRuleActionGroupConditionArgs) =
                   args.Description <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: ActionRuleActionGroupConditionArgs) =
                   args.Monitor <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: ActionRuleActionGroupConditionArgs) =
                   args.MonitorService <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: ActionRuleActionGroupConditionArgs) =
                   args.Severity <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: ActionRuleActionGroupConditionArgs) =
                   args.TargetResourceType <- input arg
                   args

               ()
               func) ]

    let actionRuleActionGroupCondition = ActionRuleActionGroupConditionBuilder()

    type ActionRuleActionGroupConditionAlertContextBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ActionRuleActionGroupConditionAlertContextArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: ActionRuleActionGroupConditionAlertContextArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: ActionRuleActionGroupConditionAlertContextArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: ActionRuleActionGroupConditionAlertContextArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let actionRuleActionGroupConditionAlertContext =
        ActionRuleActionGroupConditionAlertContextBuilder()

    type ActionRuleActionGroupConditionAlertRuleIdBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ActionRuleActionGroupConditionAlertRuleIdArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: ActionRuleActionGroupConditionAlertRuleIdArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: ActionRuleActionGroupConditionAlertRuleIdArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: ActionRuleActionGroupConditionAlertRuleIdArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let actionRuleActionGroupConditionAlertRuleId =
        ActionRuleActionGroupConditionAlertRuleIdBuilder()

    type ActionRuleActionGroupConditionDescriptionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ActionRuleActionGroupConditionDescriptionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: ActionRuleActionGroupConditionDescriptionArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: ActionRuleActionGroupConditionDescriptionArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: ActionRuleActionGroupConditionDescriptionArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let actionRuleActionGroupConditionDescription =
        ActionRuleActionGroupConditionDescriptionBuilder()

    type ActionRuleActionGroupConditionMonitorBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ActionRuleActionGroupConditionMonitorArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: ActionRuleActionGroupConditionMonitorArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: ActionRuleActionGroupConditionMonitorArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: ActionRuleActionGroupConditionMonitorArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let actionRuleActionGroupConditionMonitor =
        ActionRuleActionGroupConditionMonitorBuilder()

    type ActionRuleActionGroupConditionMonitorServiceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ActionRuleActionGroupConditionMonitorServiceArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: ActionRuleActionGroupConditionMonitorServiceArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: ActionRuleActionGroupConditionMonitorServiceArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: ActionRuleActionGroupConditionMonitorServiceArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let actionRuleActionGroupConditionMonitorService =
        ActionRuleActionGroupConditionMonitorServiceBuilder()

    type ActionRuleActionGroupConditionSeverityBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ActionRuleActionGroupConditionSeverityArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: ActionRuleActionGroupConditionSeverityArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: ActionRuleActionGroupConditionSeverityArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: ActionRuleActionGroupConditionSeverityArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let actionRuleActionGroupConditionSeverity =
        ActionRuleActionGroupConditionSeverityBuilder()

    type ActionRuleActionGroupConditionTargetResourceTypeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ActionRuleActionGroupConditionTargetResourceTypeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: ActionRuleActionGroupConditionTargetResourceTypeArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: ActionRuleActionGroupConditionTargetResourceTypeArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: ActionRuleActionGroupConditionTargetResourceTypeArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let actionRuleActionGroupConditionTargetResourceType =
        ActionRuleActionGroupConditionTargetResourceTypeBuilder()

    type ActionRuleActionGroupScopeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ActionRuleActionGroupScopeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("resourceIds")>]
        member _.ResourceIds((n, args), resourceIds) =
            let apply (args: ActionRuleActionGroupScopeArgs) =
                args.ResourceIds <- inputList resourceIds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: ActionRuleActionGroupScopeArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: ActionRuleActionGroupScopeArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let actionRuleActionGroupScope = ActionRuleActionGroupScopeBuilder()

    type ActionRuleSuppressionConditionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ActionRuleSuppressionConditionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: ActionRuleSuppressionConditionArgs) =
                   args.AlertContext <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: ActionRuleSuppressionConditionArgs) =
                   args.AlertRuleId <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: ActionRuleSuppressionConditionArgs) =
                   args.Description <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: ActionRuleSuppressionConditionArgs) =
                   args.Monitor <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: ActionRuleSuppressionConditionArgs) =
                   args.MonitorService <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: ActionRuleSuppressionConditionArgs) =
                   args.Severity <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: ActionRuleSuppressionConditionArgs) =
                   args.TargetResourceType <- input arg
                   args

               ()
               func) ]

    let actionRuleSuppressionCondition = ActionRuleSuppressionConditionBuilder()

    type ActionRuleSuppressionConditionAlertContextBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ActionRuleSuppressionConditionAlertContextArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: ActionRuleSuppressionConditionAlertContextArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: ActionRuleSuppressionConditionAlertContextArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: ActionRuleSuppressionConditionAlertContextArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let actionRuleSuppressionConditionAlertContext =
        ActionRuleSuppressionConditionAlertContextBuilder()

    type ActionRuleSuppressionConditionAlertRuleIdBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ActionRuleSuppressionConditionAlertRuleIdArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: ActionRuleSuppressionConditionAlertRuleIdArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: ActionRuleSuppressionConditionAlertRuleIdArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: ActionRuleSuppressionConditionAlertRuleIdArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let actionRuleSuppressionConditionAlertRuleId =
        ActionRuleSuppressionConditionAlertRuleIdBuilder()

    type ActionRuleSuppressionConditionDescriptionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ActionRuleSuppressionConditionDescriptionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: ActionRuleSuppressionConditionDescriptionArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: ActionRuleSuppressionConditionDescriptionArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: ActionRuleSuppressionConditionDescriptionArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let actionRuleSuppressionConditionDescription =
        ActionRuleSuppressionConditionDescriptionBuilder()

    type ActionRuleSuppressionConditionMonitorBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ActionRuleSuppressionConditionMonitorArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: ActionRuleSuppressionConditionMonitorArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: ActionRuleSuppressionConditionMonitorArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: ActionRuleSuppressionConditionMonitorArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let actionRuleSuppressionConditionMonitor =
        ActionRuleSuppressionConditionMonitorBuilder()

    type ActionRuleSuppressionConditionMonitorServiceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ActionRuleSuppressionConditionMonitorServiceArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: ActionRuleSuppressionConditionMonitorServiceArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: ActionRuleSuppressionConditionMonitorServiceArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: ActionRuleSuppressionConditionMonitorServiceArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let actionRuleSuppressionConditionMonitorService =
        ActionRuleSuppressionConditionMonitorServiceBuilder()

    type ActionRuleSuppressionConditionSeverityBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ActionRuleSuppressionConditionSeverityArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: ActionRuleSuppressionConditionSeverityArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: ActionRuleSuppressionConditionSeverityArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: ActionRuleSuppressionConditionSeverityArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let actionRuleSuppressionConditionSeverity =
        ActionRuleSuppressionConditionSeverityBuilder()

    type ActionRuleSuppressionConditionTargetResourceTypeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ActionRuleSuppressionConditionTargetResourceTypeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: ActionRuleSuppressionConditionTargetResourceTypeArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: ActionRuleSuppressionConditionTargetResourceTypeArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: ActionRuleSuppressionConditionTargetResourceTypeArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let actionRuleSuppressionConditionTargetResourceType =
        ActionRuleSuppressionConditionTargetResourceTypeBuilder()

    type ActionRuleSuppressionScopeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ActionRuleSuppressionScopeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("resourceIds")>]
        member _.ResourceIds((n, args), resourceIds) =
            let apply (args: ActionRuleSuppressionScopeArgs) =
                args.ResourceIds <- inputList resourceIds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: ActionRuleSuppressionScopeArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: ActionRuleSuppressionScopeArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let actionRuleSuppressionScope = ActionRuleSuppressionScopeBuilder()

    type ActionRuleSuppressionSuppressionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ActionRuleSuppressionSuppressionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("recurrenceType")>]
        member _.RecurrenceType((n, args), recurrenceType) =
            let apply (args: ActionRuleSuppressionSuppressionArgs) =
                args.RecurrenceType <- input recurrenceType
                args

            ()
            n, List.Cons(apply, args)

        member _.RecurrenceType((n, args), recurrenceType) =
            let apply (args: ActionRuleSuppressionSuppressionArgs) =
                args.RecurrenceType <- io recurrenceType
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ActionRuleSuppressionSuppressionArgs) =
                   args.Schedule <- input arg
                   args

               ()
               func) ]

    let actionRuleSuppressionSuppression =
        ActionRuleSuppressionSuppressionBuilder()

    type ActionRuleSuppressionSuppressionScheduleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ActionRuleSuppressionSuppressionScheduleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("endDateUtc")>]
        member _.EndDateUtc((n, args), endDateUtc) =
            let apply (args: ActionRuleSuppressionSuppressionScheduleArgs) =
                args.EndDateUtc <- input endDateUtc
                args

            ()
            n, List.Cons(apply, args)

        member _.EndDateUtc((n, args), endDateUtc) =
            let apply (args: ActionRuleSuppressionSuppressionScheduleArgs) =
                args.EndDateUtc <- io endDateUtc
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("recurrenceMonthlies")>]
        member _.RecurrenceMonthlies((n, args), recurrenceMonthlies) =
            let apply (args: ActionRuleSuppressionSuppressionScheduleArgs) =
                args.RecurrenceMonthlies <- inputList recurrenceMonthlies
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("recurrenceWeeklies")>]
        member _.RecurrenceWeeklies((n, args), recurrenceWeeklies) =
            let apply (args: ActionRuleSuppressionSuppressionScheduleArgs) =
                args.RecurrenceWeeklies <- inputList recurrenceWeeklies
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("startDateUtc")>]
        member _.StartDateUtc((n, args), startDateUtc) =
            let apply (args: ActionRuleSuppressionSuppressionScheduleArgs) =
                args.StartDateUtc <- input startDateUtc
                args

            ()
            n, List.Cons(apply, args)

        member _.StartDateUtc((n, args), startDateUtc) =
            let apply (args: ActionRuleSuppressionSuppressionScheduleArgs) =
                args.StartDateUtc <- io startDateUtc
                args

            ()
            n, List.Cons(apply, args)

    let actionRuleSuppressionSuppressionSchedule =
        ActionRuleSuppressionSuppressionScheduleBuilder()

    type ActivityLogAlertActionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ActivityLogAlertActionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("actionGroupId")>]
        member _.ActionGroupId((n, args), actionGroupId) =
            let apply (args: ActivityLogAlertActionArgs) =
                args.ActionGroupId <- input actionGroupId
                args

            ()
            n, List.Cons(apply, args)

        member _.ActionGroupId((n, args), actionGroupId) =
            let apply (args: ActivityLogAlertActionArgs) =
                args.ActionGroupId <- io actionGroupId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("webhookProperties")>]
        member _.WebhookProperties((n, args), webhookProperties) =
            let apply (args: ActivityLogAlertActionArgs) =
                args.WebhookProperties <- inputMap webhookProperties
                args

            ()
            n, List.Cons(apply, args)

    let activityLogAlertAction = ActivityLogAlertActionBuilder()

    type ActivityLogAlertCriteriaBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ActivityLogAlertCriteriaArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("caller")>]
        member _.Caller((n, args), caller) =
            let apply (args: ActivityLogAlertCriteriaArgs) =
                args.Caller <- input caller
                args

            ()
            n, List.Cons(apply, args)

        member _.Caller((n, args), caller) =
            let apply (args: ActivityLogAlertCriteriaArgs) =
                args.Caller <- io caller
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("category")>]
        member _.Category((n, args), category) =
            let apply (args: ActivityLogAlertCriteriaArgs) =
                args.Category <- input category
                args

            ()
            n, List.Cons(apply, args)

        member _.Category((n, args), category) =
            let apply (args: ActivityLogAlertCriteriaArgs) =
                args.Category <- io category
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("level")>]
        member _.Level((n, args), level) =
            let apply (args: ActivityLogAlertCriteriaArgs) =
                args.Level <- input level
                args

            ()
            n, List.Cons(apply, args)

        member _.Level((n, args), level) =
            let apply (args: ActivityLogAlertCriteriaArgs) =
                args.Level <- io level
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("operationName")>]
        member _.OperationName((n, args), operationName) =
            let apply (args: ActivityLogAlertCriteriaArgs) =
                args.OperationName <- input operationName
                args

            ()
            n, List.Cons(apply, args)

        member _.OperationName((n, args), operationName) =
            let apply (args: ActivityLogAlertCriteriaArgs) =
                args.OperationName <- io operationName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("recommendationCategory")>]
        member _.RecommendationCategory((n, args), recommendationCategory) =
            let apply (args: ActivityLogAlertCriteriaArgs) =
                args.RecommendationCategory <- input recommendationCategory
                args

            ()
            n, List.Cons(apply, args)

        member _.RecommendationCategory((n, args), recommendationCategory) =
            let apply (args: ActivityLogAlertCriteriaArgs) =
                args.RecommendationCategory <- io recommendationCategory
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("recommendationImpact")>]
        member _.RecommendationImpact((n, args), recommendationImpact) =
            let apply (args: ActivityLogAlertCriteriaArgs) =
                args.RecommendationImpact <- input recommendationImpact
                args

            ()
            n, List.Cons(apply, args)

        member _.RecommendationImpact((n, args), recommendationImpact) =
            let apply (args: ActivityLogAlertCriteriaArgs) =
                args.RecommendationImpact <- io recommendationImpact
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("recommendationType")>]
        member _.RecommendationType((n, args), recommendationType) =
            let apply (args: ActivityLogAlertCriteriaArgs) =
                args.RecommendationType <- input recommendationType
                args

            ()
            n, List.Cons(apply, args)

        member _.RecommendationType((n, args), recommendationType) =
            let apply (args: ActivityLogAlertCriteriaArgs) =
                args.RecommendationType <- io recommendationType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((n, args), resourceGroup) =
            let apply (args: ActivityLogAlertCriteriaArgs) =
                args.ResourceGroup <- input resourceGroup
                args

            ()
            n, List.Cons(apply, args)

        member _.ResourceGroup((n, args), resourceGroup) =
            let apply (args: ActivityLogAlertCriteriaArgs) =
                args.ResourceGroup <- io resourceGroup
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("resourceId")>]
        member _.ResourceId((n, args), resourceId) =
            let apply (args: ActivityLogAlertCriteriaArgs) =
                args.ResourceId <- input resourceId
                args

            ()
            n, List.Cons(apply, args)

        member _.ResourceId((n, args), resourceId) =
            let apply (args: ActivityLogAlertCriteriaArgs) =
                args.ResourceId <- io resourceId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("resourceProvider")>]
        member _.ResourceProvider((n, args), resourceProvider) =
            let apply (args: ActivityLogAlertCriteriaArgs) =
                args.ResourceProvider <- input resourceProvider
                args

            ()
            n, List.Cons(apply, args)

        member _.ResourceProvider((n, args), resourceProvider) =
            let apply (args: ActivityLogAlertCriteriaArgs) =
                args.ResourceProvider <- io resourceProvider
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("resourceType")>]
        member _.ResourceType((n, args), resourceType) =
            let apply (args: ActivityLogAlertCriteriaArgs) =
                args.ResourceType <- input resourceType
                args

            ()
            n, List.Cons(apply, args)

        member _.ResourceType((n, args), resourceType) =
            let apply (args: ActivityLogAlertCriteriaArgs) =
                args.ResourceType <- io resourceType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("status")>]
        member _.Status((n, args), status) =
            let apply (args: ActivityLogAlertCriteriaArgs) =
                args.Status <- input status
                args

            ()
            n, List.Cons(apply, args)

        member _.Status((n, args), status) =
            let apply (args: ActivityLogAlertCriteriaArgs) =
                args.Status <- io status
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subStatus")>]
        member _.SubStatus((n, args), subStatus) =
            let apply (args: ActivityLogAlertCriteriaArgs) =
                args.SubStatus <- input subStatus
                args

            ()
            n, List.Cons(apply, args)

        member _.SubStatus((n, args), subStatus) =
            let apply (args: ActivityLogAlertCriteriaArgs) =
                args.SubStatus <- io subStatus
                args

            ()
            n, List.Cons(apply, args)

    let activityLogAlertCriteria = ActivityLogAlertCriteriaBuilder()

    type AutoscaleSettingNotificationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AutoscaleSettingNotificationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: AutoscaleSettingNotificationArgs) =
                   args.Email <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("webhooks")>]
        member _.Webhooks((n, args), webhooks) =
            let apply (args: AutoscaleSettingNotificationArgs) =
                args.Webhooks <- inputList webhooks
                args

            ()
            n, List.Cons(apply, args)

    let autoscaleSettingNotification = AutoscaleSettingNotificationBuilder()

    type AutoscaleSettingNotificationEmailBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AutoscaleSettingNotificationEmailArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("customEmails")>]
        member _.CustomEmails((n, args), customEmails) =
            let apply (args: AutoscaleSettingNotificationEmailArgs) =
                args.CustomEmails <- inputList customEmails
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sendToSubscriptionAdministrator")>]
        member _.SendToSubscriptionAdministrator((n, args), sendToSubscriptionAdministrator) =
            let apply (args: AutoscaleSettingNotificationEmailArgs) =
                args.SendToSubscriptionAdministrator <- input sendToSubscriptionAdministrator
                args

            ()
            n, List.Cons(apply, args)

        member _.SendToSubscriptionAdministrator((n, args), sendToSubscriptionAdministrator) =
            let apply (args: AutoscaleSettingNotificationEmailArgs) =
                args.SendToSubscriptionAdministrator <- io sendToSubscriptionAdministrator
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sendToSubscriptionCoAdministrator")>]
        member _.SendToSubscriptionCoAdministrator((n, args), sendToSubscriptionCoAdministrator) =
            let apply (args: AutoscaleSettingNotificationEmailArgs) =
                args.SendToSubscriptionCoAdministrator <- input sendToSubscriptionCoAdministrator
                args

            ()
            n, List.Cons(apply, args)

        member _.SendToSubscriptionCoAdministrator((n, args), sendToSubscriptionCoAdministrator) =
            let apply (args: AutoscaleSettingNotificationEmailArgs) =
                args.SendToSubscriptionCoAdministrator <- io sendToSubscriptionCoAdministrator
                args

            ()
            n, List.Cons(apply, args)

    let autoscaleSettingNotificationEmail =
        AutoscaleSettingNotificationEmailBuilder()

    type AutoscaleSettingNotificationWebhookBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AutoscaleSettingNotificationWebhookArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("properties")>]
        member _.Properties((n, args), properties) =
            let apply (args: AutoscaleSettingNotificationWebhookArgs) =
                args.Properties <- inputMap properties
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("serviceUri")>]
        member _.ServiceUri((n, args), serviceUri) =
            let apply (args: AutoscaleSettingNotificationWebhookArgs) =
                args.ServiceUri <- input serviceUri
                args

            ()
            n, List.Cons(apply, args)

        member _.ServiceUri((n, args), serviceUri) =
            let apply (args: AutoscaleSettingNotificationWebhookArgs) =
                args.ServiceUri <- io serviceUri
                args

            ()
            n, List.Cons(apply, args)

    let autoscaleSettingNotificationWebhook =
        AutoscaleSettingNotificationWebhookBuilder()

    type AutoscaleSettingProfileBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AutoscaleSettingProfileArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: AutoscaleSettingProfileArgs) =
                   args.Capacity <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: AutoscaleSettingProfileArgs) =
                   args.FixedDate <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: AutoscaleSettingProfileArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: AutoscaleSettingProfileArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: AutoscaleSettingProfileArgs) =
                   args.Recurrence <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("rules")>]
        member _.Rules((n, args), rules) =
            let apply (args: AutoscaleSettingProfileArgs) =
                args.Rules <- inputList rules
                args

            ()
            n, List.Cons(apply, args)

    let autoscaleSettingProfile = AutoscaleSettingProfileBuilder()

    type AutoscaleSettingProfileCapacityBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AutoscaleSettingProfileCapacityArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("default")>]
        member _.Default((n, args), ``default``) =
            let apply (args: AutoscaleSettingProfileCapacityArgs) =
                args.Default <- input ``default``
                args

            ()
            n, List.Cons(apply, args)

        member _.Default((n, args), ``default``) =
            let apply (args: AutoscaleSettingProfileCapacityArgs) =
                args.Default <- io ``default``
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("maximum")>]
        member _.Maximum((n, args), maximum) =
            let apply (args: AutoscaleSettingProfileCapacityArgs) =
                args.Maximum <- input maximum
                args

            ()
            n, List.Cons(apply, args)

        member _.Maximum((n, args), maximum) =
            let apply (args: AutoscaleSettingProfileCapacityArgs) =
                args.Maximum <- io maximum
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("minimum")>]
        member _.Minimum((n, args), minimum) =
            let apply (args: AutoscaleSettingProfileCapacityArgs) =
                args.Minimum <- input minimum
                args

            ()
            n, List.Cons(apply, args)

        member _.Minimum((n, args), minimum) =
            let apply (args: AutoscaleSettingProfileCapacityArgs) =
                args.Minimum <- io minimum
                args

            ()
            n, List.Cons(apply, args)

    let autoscaleSettingProfileCapacity = AutoscaleSettingProfileCapacityBuilder()

    type AutoscaleSettingProfileFixedDateBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AutoscaleSettingProfileFixedDateArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("end")>]
        member _.End((n, args), ``end``) =
            let apply (args: AutoscaleSettingProfileFixedDateArgs) =
                args.End <- input ``end``
                args

            ()
            n, List.Cons(apply, args)

        member _.End((n, args), ``end``) =
            let apply (args: AutoscaleSettingProfileFixedDateArgs) =
                args.End <- io ``end``
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("start")>]
        member _.Start((n, args), start) =
            let apply (args: AutoscaleSettingProfileFixedDateArgs) =
                args.Start <- input start
                args

            ()
            n, List.Cons(apply, args)

        member _.Start((n, args), start) =
            let apply (args: AutoscaleSettingProfileFixedDateArgs) =
                args.Start <- io start
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("timezone")>]
        member _.Timezone((n, args), timezone) =
            let apply (args: AutoscaleSettingProfileFixedDateArgs) =
                args.Timezone <- input timezone
                args

            ()
            n, List.Cons(apply, args)

        member _.Timezone((n, args), timezone) =
            let apply (args: AutoscaleSettingProfileFixedDateArgs) =
                args.Timezone <- io timezone
                args

            ()
            n, List.Cons(apply, args)

    let autoscaleSettingProfileFixedDate =
        AutoscaleSettingProfileFixedDateBuilder()

    type AutoscaleSettingProfileRecurrenceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AutoscaleSettingProfileRecurrenceArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("days")>]
        member _.Days((n, args), days) =
            let apply (args: AutoscaleSettingProfileRecurrenceArgs) =
                args.Days <- inputList days
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("hours")>]
        member _.Hours((n, args), hours) =
            let apply (args: AutoscaleSettingProfileRecurrenceArgs) =
                args.Hours <- input hours
                args

            ()
            n, List.Cons(apply, args)

        member _.Hours((n, args), hours) =
            let apply (args: AutoscaleSettingProfileRecurrenceArgs) =
                args.Hours <- io hours
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("minutes")>]
        member _.Minutes((n, args), minutes) =
            let apply (args: AutoscaleSettingProfileRecurrenceArgs) =
                args.Minutes <- input minutes
                args

            ()
            n, List.Cons(apply, args)

        member _.Minutes((n, args), minutes) =
            let apply (args: AutoscaleSettingProfileRecurrenceArgs) =
                args.Minutes <- io minutes
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("timezone")>]
        member _.Timezone((n, args), timezone) =
            let apply (args: AutoscaleSettingProfileRecurrenceArgs) =
                args.Timezone <- input timezone
                args

            ()
            n, List.Cons(apply, args)

        member _.Timezone((n, args), timezone) =
            let apply (args: AutoscaleSettingProfileRecurrenceArgs) =
                args.Timezone <- io timezone
                args

            ()
            n, List.Cons(apply, args)

    let autoscaleSettingProfileRecurrence =
        AutoscaleSettingProfileRecurrenceBuilder()

    type AutoscaleSettingProfileRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AutoscaleSettingProfileRuleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: AutoscaleSettingProfileRuleArgs) =
                   args.MetricTrigger <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: AutoscaleSettingProfileRuleArgs) =
                   args.ScaleAction <- input arg
                   args

               ()
               func) ]

    let autoscaleSettingProfileRule = AutoscaleSettingProfileRuleBuilder()

    type AutoscaleSettingProfileRuleMetricTriggerBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AutoscaleSettingProfileRuleMetricTriggerArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("metricName")>]
        member _.MetricName((n, args), metricName) =
            let apply (args: AutoscaleSettingProfileRuleMetricTriggerArgs) =
                args.MetricName <- input metricName
                args

            ()
            n, List.Cons(apply, args)

        member _.MetricName((n, args), metricName) =
            let apply (args: AutoscaleSettingProfileRuleMetricTriggerArgs) =
                args.MetricName <- io metricName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("metricResourceId")>]
        member _.MetricResourceId((n, args), metricResourceId) =
            let apply (args: AutoscaleSettingProfileRuleMetricTriggerArgs) =
                args.MetricResourceId <- input metricResourceId
                args

            ()
            n, List.Cons(apply, args)

        member _.MetricResourceId((n, args), metricResourceId) =
            let apply (args: AutoscaleSettingProfileRuleMetricTriggerArgs) =
                args.MetricResourceId <- io metricResourceId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: AutoscaleSettingProfileRuleMetricTriggerArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: AutoscaleSettingProfileRuleMetricTriggerArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("statistic")>]
        member _.Statistic((n, args), statistic) =
            let apply (args: AutoscaleSettingProfileRuleMetricTriggerArgs) =
                args.Statistic <- input statistic
                args

            ()
            n, List.Cons(apply, args)

        member _.Statistic((n, args), statistic) =
            let apply (args: AutoscaleSettingProfileRuleMetricTriggerArgs) =
                args.Statistic <- io statistic
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("threshold")>]
        member _.Threshold((n, args), threshold) =
            let apply (args: AutoscaleSettingProfileRuleMetricTriggerArgs) =
                args.Threshold <- input threshold
                args

            ()
            n, List.Cons(apply, args)

        member _.Threshold((n, args), threshold) =
            let apply (args: AutoscaleSettingProfileRuleMetricTriggerArgs) =
                args.Threshold <- io threshold
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("timeAggregation")>]
        member _.TimeAggregation((n, args), timeAggregation) =
            let apply (args: AutoscaleSettingProfileRuleMetricTriggerArgs) =
                args.TimeAggregation <- input timeAggregation
                args

            ()
            n, List.Cons(apply, args)

        member _.TimeAggregation((n, args), timeAggregation) =
            let apply (args: AutoscaleSettingProfileRuleMetricTriggerArgs) =
                args.TimeAggregation <- io timeAggregation
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("timeGrain")>]
        member _.TimeGrain((n, args), timeGrain) =
            let apply (args: AutoscaleSettingProfileRuleMetricTriggerArgs) =
                args.TimeGrain <- input timeGrain
                args

            ()
            n, List.Cons(apply, args)

        member _.TimeGrain((n, args), timeGrain) =
            let apply (args: AutoscaleSettingProfileRuleMetricTriggerArgs) =
                args.TimeGrain <- io timeGrain
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("timeWindow")>]
        member _.TimeWindow((n, args), timeWindow) =
            let apply (args: AutoscaleSettingProfileRuleMetricTriggerArgs) =
                args.TimeWindow <- input timeWindow
                args

            ()
            n, List.Cons(apply, args)

        member _.TimeWindow((n, args), timeWindow) =
            let apply (args: AutoscaleSettingProfileRuleMetricTriggerArgs) =
                args.TimeWindow <- io timeWindow
                args

            ()
            n, List.Cons(apply, args)

    let autoscaleSettingProfileRuleMetricTrigger =
        AutoscaleSettingProfileRuleMetricTriggerBuilder()

    type AutoscaleSettingProfileRuleScaleActionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AutoscaleSettingProfileRuleScaleActionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("cooldown")>]
        member _.Cooldown((n, args), cooldown) =
            let apply (args: AutoscaleSettingProfileRuleScaleActionArgs) =
                args.Cooldown <- input cooldown
                args

            ()
            n, List.Cons(apply, args)

        member _.Cooldown((n, args), cooldown) =
            let apply (args: AutoscaleSettingProfileRuleScaleActionArgs) =
                args.Cooldown <- io cooldown
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("direction")>]
        member _.Direction((n, args), direction) =
            let apply (args: AutoscaleSettingProfileRuleScaleActionArgs) =
                args.Direction <- input direction
                args

            ()
            n, List.Cons(apply, args)

        member _.Direction((n, args), direction) =
            let apply (args: AutoscaleSettingProfileRuleScaleActionArgs) =
                args.Direction <- io direction
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: AutoscaleSettingProfileRuleScaleActionArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: AutoscaleSettingProfileRuleScaleActionArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((n, args), value) =
            let apply (args: AutoscaleSettingProfileRuleScaleActionArgs) =
                args.Value <- input value
                args

            ()
            n, List.Cons(apply, args)

        member _.Value((n, args), value) =
            let apply (args: AutoscaleSettingProfileRuleScaleActionArgs) =
                args.Value <- io value
                args

            ()
            n, List.Cons(apply, args)

    let autoscaleSettingProfileRuleScaleAction =
        AutoscaleSettingProfileRuleScaleActionBuilder()

    type DiagnosticSettingLogBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (DiagnosticSettingLogArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("category")>]
        member _.Category((n, args), category) =
            let apply (args: DiagnosticSettingLogArgs) =
                args.Category <- input category
                args

            ()
            n, List.Cons(apply, args)

        member _.Category((n, args), category) =
            let apply (args: DiagnosticSettingLogArgs) =
                args.Category <- io category
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: DiagnosticSettingLogArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: DiagnosticSettingLogArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: DiagnosticSettingLogArgs) =
                   args.RetentionPolicy <- input arg
                   args

               ()
               func) ]

    let diagnosticSettingLog = DiagnosticSettingLogBuilder()

    type DiagnosticSettingLogRetentionPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (DiagnosticSettingLogRetentionPolicyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("days")>]
        member _.Days((n, args), days) =
            let apply (args: DiagnosticSettingLogRetentionPolicyArgs) =
                args.Days <- input days
                args

            ()
            n, List.Cons(apply, args)

        member _.Days((n, args), days) =
            let apply (args: DiagnosticSettingLogRetentionPolicyArgs) =
                args.Days <- io days
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: DiagnosticSettingLogRetentionPolicyArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: DiagnosticSettingLogRetentionPolicyArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

    let diagnosticSettingLogRetentionPolicy =
        DiagnosticSettingLogRetentionPolicyBuilder()

    type DiagnosticSettingMetricBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (DiagnosticSettingMetricArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("category")>]
        member _.Category((n, args), category) =
            let apply (args: DiagnosticSettingMetricArgs) =
                args.Category <- input category
                args

            ()
            n, List.Cons(apply, args)

        member _.Category((n, args), category) =
            let apply (args: DiagnosticSettingMetricArgs) =
                args.Category <- io category
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: DiagnosticSettingMetricArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: DiagnosticSettingMetricArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: DiagnosticSettingMetricArgs) =
                   args.RetentionPolicy <- input arg
                   args

               ()
               func) ]

    let diagnosticSettingMetric = DiagnosticSettingMetricBuilder()

    type DiagnosticSettingMetricRetentionPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (DiagnosticSettingMetricRetentionPolicyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("days")>]
        member _.Days((n, args), days) =
            let apply (args: DiagnosticSettingMetricRetentionPolicyArgs) =
                args.Days <- input days
                args

            ()
            n, List.Cons(apply, args)

        member _.Days((n, args), days) =
            let apply (args: DiagnosticSettingMetricRetentionPolicyArgs) =
                args.Days <- io days
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: DiagnosticSettingMetricRetentionPolicyArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: DiagnosticSettingMetricRetentionPolicyArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

    let diagnosticSettingMetricRetentionPolicy =
        DiagnosticSettingMetricRetentionPolicyBuilder()

    type LogProfileRetentionPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LogProfileRetentionPolicyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("days")>]
        member _.Days((n, args), days) =
            let apply (args: LogProfileRetentionPolicyArgs) =
                args.Days <- input days
                args

            ()
            n, List.Cons(apply, args)

        member _.Days((n, args), days) =
            let apply (args: LogProfileRetentionPolicyArgs) =
                args.Days <- io days
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: LogProfileRetentionPolicyArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: LogProfileRetentionPolicyArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

    let logProfileRetentionPolicy = LogProfileRetentionPolicyBuilder()

    type MetricAlertActionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (MetricAlertActionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("actionGroupId")>]
        member _.ActionGroupId((n, args), actionGroupId) =
            let apply (args: MetricAlertActionArgs) =
                args.ActionGroupId <- input actionGroupId
                args

            ()
            n, List.Cons(apply, args)

        member _.ActionGroupId((n, args), actionGroupId) =
            let apply (args: MetricAlertActionArgs) =
                args.ActionGroupId <- io actionGroupId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("webhookProperties")>]
        member _.WebhookProperties((n, args), webhookProperties) =
            let apply (args: MetricAlertActionArgs) =
                args.WebhookProperties <- inputMap webhookProperties
                args

            ()
            n, List.Cons(apply, args)

    let metricAlertAction = MetricAlertActionBuilder()

    type MetricAlertCriteriaBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (MetricAlertCriteriaArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("aggregation")>]
        member _.Aggregation((n, args), aggregation) =
            let apply (args: MetricAlertCriteriaArgs) =
                args.Aggregation <- input aggregation
                args

            ()
            n, List.Cons(apply, args)

        member _.Aggregation((n, args), aggregation) =
            let apply (args: MetricAlertCriteriaArgs) =
                args.Aggregation <- io aggregation
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("dimensions")>]
        member _.Dimensions((n, args), dimensions) =
            let apply (args: MetricAlertCriteriaArgs) =
                args.Dimensions <- inputList dimensions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("metricName")>]
        member _.MetricName((n, args), metricName) =
            let apply (args: MetricAlertCriteriaArgs) =
                args.MetricName <- input metricName
                args

            ()
            n, List.Cons(apply, args)

        member _.MetricName((n, args), metricName) =
            let apply (args: MetricAlertCriteriaArgs) =
                args.MetricName <- io metricName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("metricNamespace")>]
        member _.MetricNamespace((n, args), metricNamespace) =
            let apply (args: MetricAlertCriteriaArgs) =
                args.MetricNamespace <- input metricNamespace
                args

            ()
            n, List.Cons(apply, args)

        member _.MetricNamespace((n, args), metricNamespace) =
            let apply (args: MetricAlertCriteriaArgs) =
                args.MetricNamespace <- io metricNamespace
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: MetricAlertCriteriaArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: MetricAlertCriteriaArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("threshold")>]
        member _.Threshold((n, args), threshold) =
            let apply (args: MetricAlertCriteriaArgs) =
                args.Threshold <- input threshold
                args

            ()
            n, List.Cons(apply, args)

        member _.Threshold((n, args), threshold) =
            let apply (args: MetricAlertCriteriaArgs) =
                args.Threshold <- io threshold
                args

            ()
            n, List.Cons(apply, args)

    let metricAlertCriteria = MetricAlertCriteriaBuilder()

    type MetricAlertCriteriaDimensionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (MetricAlertCriteriaDimensionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: MetricAlertCriteriaDimensionArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: MetricAlertCriteriaDimensionArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: MetricAlertCriteriaDimensionArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: MetricAlertCriteriaDimensionArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: MetricAlertCriteriaDimensionArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let metricAlertCriteriaDimension = MetricAlertCriteriaDimensionBuilder()

    type ScheduledQueryRulesAlertActionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ScheduledQueryRulesAlertActionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("actionGroups")>]
        member _.ActionGroups((n, args), actionGroups) =
            let apply (args: ScheduledQueryRulesAlertActionArgs) =
                args.ActionGroups <- inputList actionGroups
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("customWebhookPayload")>]
        member _.CustomWebhookPayload((n, args), customWebhookPayload) =
            let apply (args: ScheduledQueryRulesAlertActionArgs) =
                args.CustomWebhookPayload <- input customWebhookPayload
                args

            ()
            n, List.Cons(apply, args)

        member _.CustomWebhookPayload((n, args), customWebhookPayload) =
            let apply (args: ScheduledQueryRulesAlertActionArgs) =
                args.CustomWebhookPayload <- io customWebhookPayload
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("emailSubject")>]
        member _.EmailSubject((n, args), emailSubject) =
            let apply (args: ScheduledQueryRulesAlertActionArgs) =
                args.EmailSubject <- input emailSubject
                args

            ()
            n, List.Cons(apply, args)

        member _.EmailSubject((n, args), emailSubject) =
            let apply (args: ScheduledQueryRulesAlertActionArgs) =
                args.EmailSubject <- io emailSubject
                args

            ()
            n, List.Cons(apply, args)

    let scheduledQueryRulesAlertAction = ScheduledQueryRulesAlertActionBuilder()

    type ScheduledQueryRulesAlertTriggerBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ScheduledQueryRulesAlertTriggerArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: ScheduledQueryRulesAlertTriggerArgs) =
                   args.MetricTrigger <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: ScheduledQueryRulesAlertTriggerArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: ScheduledQueryRulesAlertTriggerArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("threshold")>]
        member _.Threshold((n, args), threshold) =
            let apply (args: ScheduledQueryRulesAlertTriggerArgs) =
                args.Threshold <- input threshold
                args

            ()
            n, List.Cons(apply, args)

        member _.Threshold((n, args), threshold) =
            let apply (args: ScheduledQueryRulesAlertTriggerArgs) =
                args.Threshold <- io threshold
                args

            ()
            n, List.Cons(apply, args)

    let scheduledQueryRulesAlertTrigger = ScheduledQueryRulesAlertTriggerBuilder()

    type ScheduledQueryRulesAlertTriggerMetricTriggerBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ScheduledQueryRulesAlertTriggerMetricTriggerArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("metricColumn")>]
        member _.MetricColumn((n, args), metricColumn) =
            let apply (args: ScheduledQueryRulesAlertTriggerMetricTriggerArgs) =
                args.MetricColumn <- input metricColumn
                args

            ()
            n, List.Cons(apply, args)

        member _.MetricColumn((n, args), metricColumn) =
            let apply (args: ScheduledQueryRulesAlertTriggerMetricTriggerArgs) =
                args.MetricColumn <- io metricColumn
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("metricTriggerType")>]
        member _.MetricTriggerType((n, args), metricTriggerType) =
            let apply (args: ScheduledQueryRulesAlertTriggerMetricTriggerArgs) =
                args.MetricTriggerType <- input metricTriggerType
                args

            ()
            n, List.Cons(apply, args)

        member _.MetricTriggerType((n, args), metricTriggerType) =
            let apply (args: ScheduledQueryRulesAlertTriggerMetricTriggerArgs) =
                args.MetricTriggerType <- io metricTriggerType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: ScheduledQueryRulesAlertTriggerMetricTriggerArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: ScheduledQueryRulesAlertTriggerMetricTriggerArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("threshold")>]
        member _.Threshold((n, args), threshold) =
            let apply (args: ScheduledQueryRulesAlertTriggerMetricTriggerArgs) =
                args.Threshold <- input threshold
                args

            ()
            n, List.Cons(apply, args)

        member _.Threshold((n, args), threshold) =
            let apply (args: ScheduledQueryRulesAlertTriggerMetricTriggerArgs) =
                args.Threshold <- io threshold
                args

            ()
            n, List.Cons(apply, args)

    let scheduledQueryRulesAlertTriggerMetricTrigger =
        ScheduledQueryRulesAlertTriggerMetricTriggerBuilder()

    type ScheduledQueryRulesLogCriteriaBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ScheduledQueryRulesLogCriteriaArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("dimensions")>]
        member _.Dimensions((n, args), dimensions) =
            let apply (args: ScheduledQueryRulesLogCriteriaArgs) =
                args.Dimensions <- inputList dimensions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("metricName")>]
        member _.MetricName((n, args), metricName) =
            let apply (args: ScheduledQueryRulesLogCriteriaArgs) =
                args.MetricName <- input metricName
                args

            ()
            n, List.Cons(apply, args)

        member _.MetricName((n, args), metricName) =
            let apply (args: ScheduledQueryRulesLogCriteriaArgs) =
                args.MetricName <- io metricName
                args

            ()
            n, List.Cons(apply, args)

    let scheduledQueryRulesLogCriteria = ScheduledQueryRulesLogCriteriaBuilder()

    type ScheduledQueryRulesLogCriteriaDimensionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ScheduledQueryRulesLogCriteriaDimensionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ScheduledQueryRulesLogCriteriaDimensionArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ScheduledQueryRulesLogCriteriaDimensionArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: ScheduledQueryRulesLogCriteriaDimensionArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: ScheduledQueryRulesLogCriteriaDimensionArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("values")>]
        member _.Values((n, args), values) =
            let apply (args: ScheduledQueryRulesLogCriteriaDimensionArgs) =
                args.Values <- inputList values
                args

            ()
            n, List.Cons(apply, args)

    let scheduledQueryRulesLogCriteriaDimension =
        ScheduledQueryRulesLogCriteriaDimensionBuilder()

    type ActionGroupBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ActionGroup(name, (List.fold func (ActionGroupArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("armRoleReceivers")>]
        member _.ArmRoleReceivers((name, args), armRoleReceivers) =
            let apply (args: ActionGroupArgs) =
                args.ArmRoleReceivers <- inputList armRoleReceivers
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("automationRunbookReceivers")>]
        member _.AutomationRunbookReceivers((name, args), automationRunbookReceivers) =
            let apply (args: ActionGroupArgs) =
                args.AutomationRunbookReceivers <- inputList automationRunbookReceivers
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("azureAppPushReceivers")>]
        member _.AzureAppPushReceivers((name, args), azureAppPushReceivers) =
            let apply (args: ActionGroupArgs) =
                args.AzureAppPushReceivers <- inputList azureAppPushReceivers
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("azureFunctionReceivers")>]
        member _.AzureFunctionReceivers((name, args), azureFunctionReceivers) =
            let apply (args: ActionGroupArgs) =
                args.AzureFunctionReceivers <- inputList azureFunctionReceivers
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("emailReceivers")>]
        member _.EmailReceivers((name, args), emailReceivers) =
            let apply (args: ActionGroupArgs) =
                args.EmailReceivers <- inputList emailReceivers
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((name, args), enabled) =
            let apply (args: ActionGroupArgs) =
                args.Enabled <- input enabled
                args

            ()
            name, List.Cons(apply, args)

        member _.Enabled((name, args), enabled) =
            let apply (args: ActionGroupArgs) =
                args.Enabled <- io enabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("itsmReceivers")>]
        member _.ItsmReceivers((name, args), itsmReceivers) =
            let apply (args: ActionGroupArgs) =
                args.ItsmReceivers <- inputList itsmReceivers
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("logicAppReceivers")>]
        member _.LogicAppReceivers((name, args), logicAppReceivers) =
            let apply (args: ActionGroupArgs) =
                args.LogicAppReceivers <- inputList logicAppReceivers
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ActionGroupArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ActionGroupArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ActionGroupArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ActionGroupArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("shortName")>]
        member _.ShortName((name, args), shortName) =
            let apply (args: ActionGroupArgs) =
                args.ShortName <- input shortName
                args

            ()
            name, List.Cons(apply, args)

        member _.ShortName((name, args), shortName) =
            let apply (args: ActionGroupArgs) =
                args.ShortName <- io shortName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("smsReceivers")>]
        member _.SmsReceivers((name, args), smsReceivers) =
            let apply (args: ActionGroupArgs) =
                args.SmsReceivers <- inputList smsReceivers
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ActionGroupArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("voiceReceivers")>]
        member _.VoiceReceivers((name, args), voiceReceivers) =
            let apply (args: ActionGroupArgs) =
                args.VoiceReceivers <- inputList voiceReceivers
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("webhookReceivers")>]
        member _.WebhookReceivers((name, args), webhookReceivers) =
            let apply (args: ActionGroupArgs) =
                args.WebhookReceivers <- inputList webhookReceivers
                args

            ()
            name, List.Cons(apply, args)

    let actionGroup = ActionGroupBuilder()

    type ActionRuleActionGroupBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ActionRuleActionGroup(name, (List.fold func (ActionRuleActionGroupArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("actionGroupId")>]
        member _.ActionGroupId((name, args), actionGroupId) =
            let apply (args: ActionRuleActionGroupArgs) =
                args.ActionGroupId <- input actionGroupId
                args

            ()
            name, List.Cons(apply, args)

        member _.ActionGroupId((name, args), actionGroupId) =
            let apply (args: ActionRuleActionGroupArgs) =
                args.ActionGroupId <- io actionGroupId
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ActionRuleActionGroupArgs) =
                   args.Condition <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: ActionRuleActionGroupArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: ActionRuleActionGroupArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((name, args), enabled) =
            let apply (args: ActionRuleActionGroupArgs) =
                args.Enabled <- input enabled
                args

            ()
            name, List.Cons(apply, args)

        member _.Enabled((name, args), enabled) =
            let apply (args: ActionRuleActionGroupArgs) =
                args.Enabled <- io enabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ActionRuleActionGroupArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ActionRuleActionGroupArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ActionRuleActionGroupArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ActionRuleActionGroupArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ActionRuleActionGroupArgs) =
                   args.Scope <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ActionRuleActionGroupArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let actionRuleActionGroup = ActionRuleActionGroupBuilder()

    type ActionRuleSuppressionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ActionRuleSuppression(name, (List.fold func (ActionRuleSuppressionArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: ActionRuleSuppressionArgs) =
                   args.Condition <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: ActionRuleSuppressionArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: ActionRuleSuppressionArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((name, args), enabled) =
            let apply (args: ActionRuleSuppressionArgs) =
                args.Enabled <- input enabled
                args

            ()
            name, List.Cons(apply, args)

        member _.Enabled((name, args), enabled) =
            let apply (args: ActionRuleSuppressionArgs) =
                args.Enabled <- io enabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ActionRuleSuppressionArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ActionRuleSuppressionArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ActionRuleSuppressionArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ActionRuleSuppressionArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ActionRuleSuppressionArgs) =
                   args.Scope <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: ActionRuleSuppressionArgs) =
                   args.Suppression <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ActionRuleSuppressionArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let actionRuleSuppression = ActionRuleSuppressionBuilder()

    type ActivityLogAlertBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ActivityLogAlert(name, (List.fold func (ActivityLogAlertArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("actions")>]
        member _.Actions((name, args), actions) =
            let apply (args: ActivityLogAlertArgs) =
                args.Actions <- inputList actions
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ActivityLogAlertArgs) =
                   args.Criteria <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: ActivityLogAlertArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: ActivityLogAlertArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((name, args), enabled) =
            let apply (args: ActivityLogAlertArgs) =
                args.Enabled <- input enabled
                args

            ()
            name, List.Cons(apply, args)

        member _.Enabled((name, args), enabled) =
            let apply (args: ActivityLogAlertArgs) =
                args.Enabled <- io enabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ActivityLogAlertArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ActivityLogAlertArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ActivityLogAlertArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ActivityLogAlertArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("scopes")>]
        member _.Scopes((name, args), scopes) =
            let apply (args: ActivityLogAlertArgs) =
                args.Scopes <- inputList scopes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ActivityLogAlertArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let activityLogAlert = ActivityLogAlertBuilder()

    type AutoscaleSettingBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            AutoscaleSetting(name, (List.fold func (AutoscaleSettingArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("enabled")>]
        member _.Enabled((name, args), enabled) =
            let apply (args: AutoscaleSettingArgs) =
                args.Enabled <- input enabled
                args

            ()
            name, List.Cons(apply, args)

        member _.Enabled((name, args), enabled) =
            let apply (args: AutoscaleSettingArgs) =
                args.Enabled <- io enabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: AutoscaleSettingArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: AutoscaleSettingArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: AutoscaleSettingArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: AutoscaleSettingArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: AutoscaleSettingArgs) =
                   args.Notification <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("profiles")>]
        member _.Profiles((name, args), profiles) =
            let apply (args: AutoscaleSettingArgs) =
                args.Profiles <- inputList profiles
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AutoscaleSettingArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AutoscaleSettingArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: AutoscaleSettingArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("targetResourceId")>]
        member _.TargetResourceId((name, args), targetResourceId) =
            let apply (args: AutoscaleSettingArgs) =
                args.TargetResourceId <- input targetResourceId
                args

            ()
            name, List.Cons(apply, args)

        member _.TargetResourceId((name, args), targetResourceId) =
            let apply (args: AutoscaleSettingArgs) =
                args.TargetResourceId <- io targetResourceId
                args

            ()
            name, List.Cons(apply, args)

    let autoscaleSetting = AutoscaleSettingBuilder()

    type DiagnosticSettingBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            DiagnosticSetting(name, (List.fold func (DiagnosticSettingArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("eventhubAuthorizationRuleId")>]
        member _.EventhubAuthorizationRuleId((name, args), eventhubAuthorizationRuleId) =
            let apply (args: DiagnosticSettingArgs) =
                args.EventhubAuthorizationRuleId <- input eventhubAuthorizationRuleId
                args

            ()
            name, List.Cons(apply, args)

        member _.EventhubAuthorizationRuleId((name, args), eventhubAuthorizationRuleId) =
            let apply (args: DiagnosticSettingArgs) =
                args.EventhubAuthorizationRuleId <- io eventhubAuthorizationRuleId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("eventhubName")>]
        member _.EventhubName((name, args), eventhubName) =
            let apply (args: DiagnosticSettingArgs) =
                args.EventhubName <- input eventhubName
                args

            ()
            name, List.Cons(apply, args)

        member _.EventhubName((name, args), eventhubName) =
            let apply (args: DiagnosticSettingArgs) =
                args.EventhubName <- io eventhubName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("logAnalyticsDestinationType")>]
        member _.LogAnalyticsDestinationType((name, args), logAnalyticsDestinationType) =
            let apply (args: DiagnosticSettingArgs) =
                args.LogAnalyticsDestinationType <- input logAnalyticsDestinationType
                args

            ()
            name, List.Cons(apply, args)

        member _.LogAnalyticsDestinationType((name, args), logAnalyticsDestinationType) =
            let apply (args: DiagnosticSettingArgs) =
                args.LogAnalyticsDestinationType <- io logAnalyticsDestinationType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("logAnalyticsWorkspaceId")>]
        member _.LogAnalyticsWorkspaceId((name, args), logAnalyticsWorkspaceId) =
            let apply (args: DiagnosticSettingArgs) =
                args.LogAnalyticsWorkspaceId <- input logAnalyticsWorkspaceId
                args

            ()
            name, List.Cons(apply, args)

        member _.LogAnalyticsWorkspaceId((name, args), logAnalyticsWorkspaceId) =
            let apply (args: DiagnosticSettingArgs) =
                args.LogAnalyticsWorkspaceId <- io logAnalyticsWorkspaceId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("logs")>]
        member _.Logs((name, args), logs) =
            let apply (args: DiagnosticSettingArgs) =
                args.Logs <- inputList logs
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("metrics")>]
        member _.Metrics((name, args), metrics) =
            let apply (args: DiagnosticSettingArgs) =
                args.Metrics <- inputList metrics
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: DiagnosticSettingArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: DiagnosticSettingArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageAccountId")>]
        member _.StorageAccountId((name, args), storageAccountId) =
            let apply (args: DiagnosticSettingArgs) =
                args.StorageAccountId <- input storageAccountId
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageAccountId((name, args), storageAccountId) =
            let apply (args: DiagnosticSettingArgs) =
                args.StorageAccountId <- io storageAccountId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("targetResourceId")>]
        member _.TargetResourceId((name, args), targetResourceId) =
            let apply (args: DiagnosticSettingArgs) =
                args.TargetResourceId <- input targetResourceId
                args

            ()
            name, List.Cons(apply, args)

        member _.TargetResourceId((name, args), targetResourceId) =
            let apply (args: DiagnosticSettingArgs) =
                args.TargetResourceId <- io targetResourceId
                args

            ()
            name, List.Cons(apply, args)

    let diagnosticSetting = DiagnosticSettingBuilder()

    type LogProfileBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            LogProfile(name, (List.fold func (LogProfileArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("categories")>]
        member _.Categories((name, args), categories) =
            let apply (args: LogProfileArgs) =
                args.Categories <- inputList categories
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("locations")>]
        member _.Locations((name, args), locations) =
            let apply (args: LogProfileArgs) =
                args.Locations <- inputList locations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: LogProfileArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: LogProfileArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: LogProfileArgs) =
                   args.RetentionPolicy <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("servicebusRuleId")>]
        member _.ServicebusRuleId((name, args), servicebusRuleId) =
            let apply (args: LogProfileArgs) =
                args.ServicebusRuleId <- input servicebusRuleId
                args

            ()
            name, List.Cons(apply, args)

        member _.ServicebusRuleId((name, args), servicebusRuleId) =
            let apply (args: LogProfileArgs) =
                args.ServicebusRuleId <- io servicebusRuleId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageAccountId")>]
        member _.StorageAccountId((name, args), storageAccountId) =
            let apply (args: LogProfileArgs) =
                args.StorageAccountId <- input storageAccountId
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageAccountId((name, args), storageAccountId) =
            let apply (args: LogProfileArgs) =
                args.StorageAccountId <- io storageAccountId
                args

            ()
            name, List.Cons(apply, args)

    let logProfile = LogProfileBuilder()

    type MetricAlertBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            MetricAlert(name, (List.fold func (MetricAlertArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("actions")>]
        member _.Actions((name, args), actions) =
            let apply (args: MetricAlertArgs) =
                args.Actions <- inputList actions
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("autoMitigate")>]
        member _.AutoMitigate((name, args), autoMitigate) =
            let apply (args: MetricAlertArgs) =
                args.AutoMitigate <- input autoMitigate
                args

            ()
            name, List.Cons(apply, args)

        member _.AutoMitigate((name, args), autoMitigate) =
            let apply (args: MetricAlertArgs) =
                args.AutoMitigate <- io autoMitigate
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("criterias")>]
        member _.Criterias((name, args), criterias) =
            let apply (args: MetricAlertArgs) =
                args.Criterias <- inputList criterias
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: MetricAlertArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: MetricAlertArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((name, args), enabled) =
            let apply (args: MetricAlertArgs) =
                args.Enabled <- input enabled
                args

            ()
            name, List.Cons(apply, args)

        member _.Enabled((name, args), enabled) =
            let apply (args: MetricAlertArgs) =
                args.Enabled <- io enabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("frequency")>]
        member _.Frequency((name, args), frequency) =
            let apply (args: MetricAlertArgs) =
                args.Frequency <- input frequency
                args

            ()
            name, List.Cons(apply, args)

        member _.Frequency((name, args), frequency) =
            let apply (args: MetricAlertArgs) =
                args.Frequency <- io frequency
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: MetricAlertArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: MetricAlertArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: MetricAlertArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: MetricAlertArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("scopes")>]
        member _.Scopes((name, args), scopes) =
            let apply (args: MetricAlertArgs) =
                args.Scopes <- input scopes
                args

            ()
            name, List.Cons(apply, args)

        member _.Scopes((name, args), scopes) =
            let apply (args: MetricAlertArgs) =
                args.Scopes <- io scopes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("severity")>]
        member _.Severity((name, args), severity) =
            let apply (args: MetricAlertArgs) =
                args.Severity <- input severity
                args

            ()
            name, List.Cons(apply, args)

        member _.Severity((name, args), severity) =
            let apply (args: MetricAlertArgs) =
                args.Severity <- io severity
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: MetricAlertArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("windowSize")>]
        member _.WindowSize((name, args), windowSize) =
            let apply (args: MetricAlertArgs) =
                args.WindowSize <- input windowSize
                args

            ()
            name, List.Cons(apply, args)

        member _.WindowSize((name, args), windowSize) =
            let apply (args: MetricAlertArgs) =
                args.WindowSize <- io windowSize
                args

            ()
            name, List.Cons(apply, args)

    let metricAlert = MetricAlertBuilder()

    type ScheduledQueryRulesAlertBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ScheduledQueryRulesAlert(name, (List.fold func (ScheduledQueryRulesAlertArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: ScheduledQueryRulesAlertArgs) =
                   args.Action <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("authorizedResourceIds")>]
        member _.AuthorizedResourceIds((name, args), authorizedResourceIds) =
            let apply (args: ScheduledQueryRulesAlertArgs) =
                args.AuthorizedResourceIds <- inputList authorizedResourceIds
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("dataSourceId")>]
        member _.DataSourceId((name, args), dataSourceId) =
            let apply (args: ScheduledQueryRulesAlertArgs) =
                args.DataSourceId <- input dataSourceId
                args

            ()
            name, List.Cons(apply, args)

        member _.DataSourceId((name, args), dataSourceId) =
            let apply (args: ScheduledQueryRulesAlertArgs) =
                args.DataSourceId <- io dataSourceId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: ScheduledQueryRulesAlertArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: ScheduledQueryRulesAlertArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((name, args), enabled) =
            let apply (args: ScheduledQueryRulesAlertArgs) =
                args.Enabled <- input enabled
                args

            ()
            name, List.Cons(apply, args)

        member _.Enabled((name, args), enabled) =
            let apply (args: ScheduledQueryRulesAlertArgs) =
                args.Enabled <- io enabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("frequency")>]
        member _.Frequency((name, args), frequency) =
            let apply (args: ScheduledQueryRulesAlertArgs) =
                args.Frequency <- input frequency
                args

            ()
            name, List.Cons(apply, args)

        member _.Frequency((name, args), frequency) =
            let apply (args: ScheduledQueryRulesAlertArgs) =
                args.Frequency <- io frequency
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ScheduledQueryRulesAlertArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ScheduledQueryRulesAlertArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ScheduledQueryRulesAlertArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ScheduledQueryRulesAlertArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("query")>]
        member _.Query((name, args), query) =
            let apply (args: ScheduledQueryRulesAlertArgs) =
                args.Query <- input query
                args

            ()
            name, List.Cons(apply, args)

        member _.Query((name, args), query) =
            let apply (args: ScheduledQueryRulesAlertArgs) =
                args.Query <- io query
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("queryType")>]
        member _.QueryType((name, args), queryType) =
            let apply (args: ScheduledQueryRulesAlertArgs) =
                args.QueryType <- input queryType
                args

            ()
            name, List.Cons(apply, args)

        member _.QueryType((name, args), queryType) =
            let apply (args: ScheduledQueryRulesAlertArgs) =
                args.QueryType <- io queryType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ScheduledQueryRulesAlertArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ScheduledQueryRulesAlertArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("severity")>]
        member _.Severity((name, args), severity) =
            let apply (args: ScheduledQueryRulesAlertArgs) =
                args.Severity <- input severity
                args

            ()
            name, List.Cons(apply, args)

        member _.Severity((name, args), severity) =
            let apply (args: ScheduledQueryRulesAlertArgs) =
                args.Severity <- io severity
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ScheduledQueryRulesAlertArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("throttling")>]
        member _.Throttling((name, args), throttling) =
            let apply (args: ScheduledQueryRulesAlertArgs) =
                args.Throttling <- input throttling
                args

            ()
            name, List.Cons(apply, args)

        member _.Throttling((name, args), throttling) =
            let apply (args: ScheduledQueryRulesAlertArgs) =
                args.Throttling <- io throttling
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("timeWindow")>]
        member _.TimeWindow((name, args), timeWindow) =
            let apply (args: ScheduledQueryRulesAlertArgs) =
                args.TimeWindow <- input timeWindow
                args

            ()
            name, List.Cons(apply, args)

        member _.TimeWindow((name, args), timeWindow) =
            let apply (args: ScheduledQueryRulesAlertArgs) =
                args.TimeWindow <- io timeWindow
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ScheduledQueryRulesAlertArgs) =
                   args.Trigger <- input arg
                   args

               ()
               func) ]

    let scheduledQueryRulesAlert = ScheduledQueryRulesAlertBuilder()

    type ScheduledQueryRulesLogBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ScheduledQueryRulesLog(name, (List.fold func (ScheduledQueryRulesLogArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("authorizedResourceIds")>]
        member _.AuthorizedResourceIds((name, args), authorizedResourceIds) =
            let apply (args: ScheduledQueryRulesLogArgs) =
                args.AuthorizedResourceIds <- inputList authorizedResourceIds
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ScheduledQueryRulesLogArgs) =
                   args.Criteria <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("dataSourceId")>]
        member _.DataSourceId((name, args), dataSourceId) =
            let apply (args: ScheduledQueryRulesLogArgs) =
                args.DataSourceId <- input dataSourceId
                args

            ()
            name, List.Cons(apply, args)

        member _.DataSourceId((name, args), dataSourceId) =
            let apply (args: ScheduledQueryRulesLogArgs) =
                args.DataSourceId <- io dataSourceId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: ScheduledQueryRulesLogArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: ScheduledQueryRulesLogArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((name, args), enabled) =
            let apply (args: ScheduledQueryRulesLogArgs) =
                args.Enabled <- input enabled
                args

            ()
            name, List.Cons(apply, args)

        member _.Enabled((name, args), enabled) =
            let apply (args: ScheduledQueryRulesLogArgs) =
                args.Enabled <- io enabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ScheduledQueryRulesLogArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ScheduledQueryRulesLogArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ScheduledQueryRulesLogArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ScheduledQueryRulesLogArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ScheduledQueryRulesLogArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ScheduledQueryRulesLogArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ScheduledQueryRulesLogArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let scheduledQueryRulesLog = ScheduledQueryRulesLogBuilder()

module MSSql =
    open Pulumi.Azure.MSSql
    open Pulumi.Azure.MSSql.Inputs

    type DatabaseExtendedAuditingPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (DatabaseExtendedAuditingPolicyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("retentionInDays")>]
        member _.RetentionInDays((n, args), retentionInDays) =
            let apply (args: DatabaseExtendedAuditingPolicyArgs) =
                args.RetentionInDays <- input retentionInDays
                args

            ()
            n, List.Cons(apply, args)

        member _.RetentionInDays((n, args), retentionInDays) =
            let apply (args: DatabaseExtendedAuditingPolicyArgs) =
                args.RetentionInDays <- io retentionInDays
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageAccountAccessKey")>]
        member _.StorageAccountAccessKey((n, args), storageAccountAccessKey) =
            let apply (args: DatabaseExtendedAuditingPolicyArgs) =
                args.StorageAccountAccessKey <- input storageAccountAccessKey
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountAccessKey((n, args), storageAccountAccessKey) =
            let apply (args: DatabaseExtendedAuditingPolicyArgs) =
                args.StorageAccountAccessKey <- io storageAccountAccessKey
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageAccountAccessKeyIsSecondary")>]
        member _.StorageAccountAccessKeyIsSecondary((n, args), storageAccountAccessKeyIsSecondary) =
            let apply (args: DatabaseExtendedAuditingPolicyArgs) =
                args.StorageAccountAccessKeyIsSecondary <- input storageAccountAccessKeyIsSecondary
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountAccessKeyIsSecondary((n, args), storageAccountAccessKeyIsSecondary) =
            let apply (args: DatabaseExtendedAuditingPolicyArgs) =
                args.StorageAccountAccessKeyIsSecondary <- io storageAccountAccessKeyIsSecondary
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageEndpoint")>]
        member _.StorageEndpoint((n, args), storageEndpoint) =
            let apply (args: DatabaseExtendedAuditingPolicyArgs) =
                args.StorageEndpoint <- input storageEndpoint
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageEndpoint((n, args), storageEndpoint) =
            let apply (args: DatabaseExtendedAuditingPolicyArgs) =
                args.StorageEndpoint <- io storageEndpoint
                args

            ()
            n, List.Cons(apply, args)

    let databaseExtendedAuditingPolicy = DatabaseExtendedAuditingPolicyBuilder()

    type DatabaseThreatDetectionPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (DatabaseThreatDetectionPolicyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("disabledAlerts")>]
        member _.DisabledAlerts((n, args), disabledAlerts) =
            let apply (args: DatabaseThreatDetectionPolicyArgs) =
                args.DisabledAlerts <- inputList disabledAlerts
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("emailAccountAdmins")>]
        member _.EmailAccountAdmins((n, args), emailAccountAdmins) =
            let apply (args: DatabaseThreatDetectionPolicyArgs) =
                args.EmailAccountAdmins <- input emailAccountAdmins
                args

            ()
            n, List.Cons(apply, args)

        member _.EmailAccountAdmins((n, args), emailAccountAdmins) =
            let apply (args: DatabaseThreatDetectionPolicyArgs) =
                args.EmailAccountAdmins <- io emailAccountAdmins
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("emailAddresses")>]
        member _.EmailAddresses((n, args), emailAddresses) =
            let apply (args: DatabaseThreatDetectionPolicyArgs) =
                args.EmailAddresses <- inputList emailAddresses
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("retentionDays")>]
        member _.RetentionDays((n, args), retentionDays) =
            let apply (args: DatabaseThreatDetectionPolicyArgs) =
                args.RetentionDays <- input retentionDays
                args

            ()
            n, List.Cons(apply, args)

        member _.RetentionDays((n, args), retentionDays) =
            let apply (args: DatabaseThreatDetectionPolicyArgs) =
                args.RetentionDays <- io retentionDays
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("state")>]
        member _.State((n, args), state) =
            let apply (args: DatabaseThreatDetectionPolicyArgs) =
                args.State <- input state
                args

            ()
            n, List.Cons(apply, args)

        member _.State((n, args), state) =
            let apply (args: DatabaseThreatDetectionPolicyArgs) =
                args.State <- io state
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageAccountAccessKey")>]
        member _.StorageAccountAccessKey((n, args), storageAccountAccessKey) =
            let apply (args: DatabaseThreatDetectionPolicyArgs) =
                args.StorageAccountAccessKey <- input storageAccountAccessKey
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountAccessKey((n, args), storageAccountAccessKey) =
            let apply (args: DatabaseThreatDetectionPolicyArgs) =
                args.StorageAccountAccessKey <- io storageAccountAccessKey
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageEndpoint")>]
        member _.StorageEndpoint((n, args), storageEndpoint) =
            let apply (args: DatabaseThreatDetectionPolicyArgs) =
                args.StorageEndpoint <- input storageEndpoint
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageEndpoint((n, args), storageEndpoint) =
            let apply (args: DatabaseThreatDetectionPolicyArgs) =
                args.StorageEndpoint <- io storageEndpoint
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("useServerDefault")>]
        member _.UseServerDefault((n, args), useServerDefault) =
            let apply (args: DatabaseThreatDetectionPolicyArgs) =
                args.UseServerDefault <- input useServerDefault
                args

            ()
            n, List.Cons(apply, args)

        member _.UseServerDefault((n, args), useServerDefault) =
            let apply (args: DatabaseThreatDetectionPolicyArgs) =
                args.UseServerDefault <- io useServerDefault
                args

            ()
            n, List.Cons(apply, args)

    let databaseThreatDetectionPolicy = DatabaseThreatDetectionPolicyBuilder()

    type DatabaseVulnerabilityAssessmentRuleBaselineBaselineResultBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (DatabaseVulnerabilityAssessmentRuleBaselineBaselineResultArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("results")>]
        member _.Results((n, args), results) =
            let apply (args: DatabaseVulnerabilityAssessmentRuleBaselineBaselineResultArgs) =
                args.Results <- inputList results
                args

            ()
            n, List.Cons(apply, args)

    let databaseVulnerabilityAssessmentRuleBaselineBaselineResult =
        DatabaseVulnerabilityAssessmentRuleBaselineBaselineResultBuilder()

    type ElasticPoolPerDatabaseSettingsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ElasticPoolPerDatabaseSettingsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("maxCapacity")>]
        member _.MaxCapacity((n, args), maxCapacity) =
            let apply (args: ElasticPoolPerDatabaseSettingsArgs) =
                args.MaxCapacity <- input maxCapacity
                args

            ()
            n, List.Cons(apply, args)

        member _.MaxCapacity((n, args), maxCapacity) =
            let apply (args: ElasticPoolPerDatabaseSettingsArgs) =
                args.MaxCapacity <- io maxCapacity
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("minCapacity")>]
        member _.MinCapacity((n, args), minCapacity) =
            let apply (args: ElasticPoolPerDatabaseSettingsArgs) =
                args.MinCapacity <- input minCapacity
                args

            ()
            n, List.Cons(apply, args)

        member _.MinCapacity((n, args), minCapacity) =
            let apply (args: ElasticPoolPerDatabaseSettingsArgs) =
                args.MinCapacity <- io minCapacity
                args

            ()
            n, List.Cons(apply, args)

    let elasticPoolPerDatabaseSettings = ElasticPoolPerDatabaseSettingsBuilder()

    type ElasticPoolSkuBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ElasticPoolSkuArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("capacity")>]
        member _.Capacity((n, args), capacity) =
            let apply (args: ElasticPoolSkuArgs) =
                args.Capacity <- input capacity
                args

            ()
            n, List.Cons(apply, args)

        member _.Capacity((n, args), capacity) =
            let apply (args: ElasticPoolSkuArgs) =
                args.Capacity <- io capacity
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("family")>]
        member _.Family((n, args), family) =
            let apply (args: ElasticPoolSkuArgs) =
                args.Family <- input family
                args

            ()
            n, List.Cons(apply, args)

        member _.Family((n, args), family) =
            let apply (args: ElasticPoolSkuArgs) =
                args.Family <- io family
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ElasticPoolSkuArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ElasticPoolSkuArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tier")>]
        member _.Tier((n, args), tier) =
            let apply (args: ElasticPoolSkuArgs) =
                args.Tier <- input tier
                args

            ()
            n, List.Cons(apply, args)

        member _.Tier((n, args), tier) =
            let apply (args: ElasticPoolSkuArgs) =
                args.Tier <- io tier
                args

            ()
            n, List.Cons(apply, args)

    let elasticPoolSku = ElasticPoolSkuBuilder()

    type ServerAzureadAdministratorBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ServerAzureadAdministratorArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("loginUsername")>]
        member _.LoginUsername((n, args), loginUsername) =
            let apply (args: ServerAzureadAdministratorArgs) =
                args.LoginUsername <- input loginUsername
                args

            ()
            n, List.Cons(apply, args)

        member _.LoginUsername((n, args), loginUsername) =
            let apply (args: ServerAzureadAdministratorArgs) =
                args.LoginUsername <- io loginUsername
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("objectId")>]
        member _.ObjectId((n, args), objectId) =
            let apply (args: ServerAzureadAdministratorArgs) =
                args.ObjectId <- input objectId
                args

            ()
            n, List.Cons(apply, args)

        member _.ObjectId((n, args), objectId) =
            let apply (args: ServerAzureadAdministratorArgs) =
                args.ObjectId <- io objectId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tenantId")>]
        member _.TenantId((n, args), tenantId) =
            let apply (args: ServerAzureadAdministratorArgs) =
                args.TenantId <- input tenantId
                args

            ()
            n, List.Cons(apply, args)

        member _.TenantId((n, args), tenantId) =
            let apply (args: ServerAzureadAdministratorArgs) =
                args.TenantId <- io tenantId
                args

            ()
            n, List.Cons(apply, args)

    let serverAzureadAdministrator = ServerAzureadAdministratorBuilder()

    type ServerExtendedAuditingPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ServerExtendedAuditingPolicyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("retentionInDays")>]
        member _.RetentionInDays((n, args), retentionInDays) =
            let apply (args: ServerExtendedAuditingPolicyArgs) =
                args.RetentionInDays <- input retentionInDays
                args

            ()
            n, List.Cons(apply, args)

        member _.RetentionInDays((n, args), retentionInDays) =
            let apply (args: ServerExtendedAuditingPolicyArgs) =
                args.RetentionInDays <- io retentionInDays
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageAccountAccessKey")>]
        member _.StorageAccountAccessKey((n, args), storageAccountAccessKey) =
            let apply (args: ServerExtendedAuditingPolicyArgs) =
                args.StorageAccountAccessKey <- input storageAccountAccessKey
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountAccessKey((n, args), storageAccountAccessKey) =
            let apply (args: ServerExtendedAuditingPolicyArgs) =
                args.StorageAccountAccessKey <- io storageAccountAccessKey
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageAccountAccessKeyIsSecondary")>]
        member _.StorageAccountAccessKeyIsSecondary((n, args), storageAccountAccessKeyIsSecondary) =
            let apply (args: ServerExtendedAuditingPolicyArgs) =
                args.StorageAccountAccessKeyIsSecondary <- input storageAccountAccessKeyIsSecondary
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountAccessKeyIsSecondary((n, args), storageAccountAccessKeyIsSecondary) =
            let apply (args: ServerExtendedAuditingPolicyArgs) =
                args.StorageAccountAccessKeyIsSecondary <- io storageAccountAccessKeyIsSecondary
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageEndpoint")>]
        member _.StorageEndpoint((n, args), storageEndpoint) =
            let apply (args: ServerExtendedAuditingPolicyArgs) =
                args.StorageEndpoint <- input storageEndpoint
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageEndpoint((n, args), storageEndpoint) =
            let apply (args: ServerExtendedAuditingPolicyArgs) =
                args.StorageEndpoint <- io storageEndpoint
                args

            ()
            n, List.Cons(apply, args)

    let serverExtendedAuditingPolicy = ServerExtendedAuditingPolicyBuilder()

    type ServerIdentityBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ServerIdentityArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("principalId")>]
        member _.PrincipalId((n, args), principalId) =
            let apply (args: ServerIdentityArgs) =
                args.PrincipalId <- input principalId
                args

            ()
            n, List.Cons(apply, args)

        member _.PrincipalId((n, args), principalId) =
            let apply (args: ServerIdentityArgs) =
                args.PrincipalId <- io principalId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tenantId")>]
        member _.TenantId((n, args), tenantId) =
            let apply (args: ServerIdentityArgs) =
                args.TenantId <- input tenantId
                args

            ()
            n, List.Cons(apply, args)

        member _.TenantId((n, args), tenantId) =
            let apply (args: ServerIdentityArgs) =
                args.TenantId <- io tenantId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: ServerIdentityArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: ServerIdentityArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let serverIdentity = ServerIdentityBuilder()

    type ServerVulnerabilityAssessmentRecurringScansBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ServerVulnerabilityAssessmentRecurringScansArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("emailSubscriptionAdmins")>]
        member _.EmailSubscriptionAdmins((n, args), emailSubscriptionAdmins) =
            let apply (args: ServerVulnerabilityAssessmentRecurringScansArgs) =
                args.EmailSubscriptionAdmins <- input emailSubscriptionAdmins
                args

            ()
            n, List.Cons(apply, args)

        member _.EmailSubscriptionAdmins((n, args), emailSubscriptionAdmins) =
            let apply (args: ServerVulnerabilityAssessmentRecurringScansArgs) =
                args.EmailSubscriptionAdmins <- io emailSubscriptionAdmins
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("emails")>]
        member _.Emails((n, args), emails) =
            let apply (args: ServerVulnerabilityAssessmentRecurringScansArgs) =
                args.Emails <- inputList emails
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: ServerVulnerabilityAssessmentRecurringScansArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: ServerVulnerabilityAssessmentRecurringScansArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

    let serverVulnerabilityAssessmentRecurringScans =
        ServerVulnerabilityAssessmentRecurringScansBuilder()

    type VirtualMachineAutoPatchingBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VirtualMachineAutoPatchingArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("dayOfWeek")>]
        member _.DayOfWeek((n, args), dayOfWeek) =
            let apply (args: VirtualMachineAutoPatchingArgs) =
                args.DayOfWeek <- input dayOfWeek
                args

            ()
            n, List.Cons(apply, args)

        member _.DayOfWeek((n, args), dayOfWeek) =
            let apply (args: VirtualMachineAutoPatchingArgs) =
                args.DayOfWeek <- io dayOfWeek
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("maintenanceWindowDurationInMinutes")>]
        member _.MaintenanceWindowDurationInMinutes((n, args), maintenanceWindowDurationInMinutes) =
            let apply (args: VirtualMachineAutoPatchingArgs) =
                args.MaintenanceWindowDurationInMinutes <- input maintenanceWindowDurationInMinutes
                args

            ()
            n, List.Cons(apply, args)

        member _.MaintenanceWindowDurationInMinutes((n, args), maintenanceWindowDurationInMinutes) =
            let apply (args: VirtualMachineAutoPatchingArgs) =
                args.MaintenanceWindowDurationInMinutes <- io maintenanceWindowDurationInMinutes
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("maintenanceWindowStartingHour")>]
        member _.MaintenanceWindowStartingHour((n, args), maintenanceWindowStartingHour) =
            let apply (args: VirtualMachineAutoPatchingArgs) =
                args.MaintenanceWindowStartingHour <- input maintenanceWindowStartingHour
                args

            ()
            n, List.Cons(apply, args)

        member _.MaintenanceWindowStartingHour((n, args), maintenanceWindowStartingHour) =
            let apply (args: VirtualMachineAutoPatchingArgs) =
                args.MaintenanceWindowStartingHour <- io maintenanceWindowStartingHour
                args

            ()
            n, List.Cons(apply, args)

    let virtualMachineAutoPatching = VirtualMachineAutoPatchingBuilder()

    type VirtualMachineKeyVaultCredentialBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VirtualMachineKeyVaultCredentialArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("keyVaultUrl")>]
        member _.KeyVaultUrl((n, args), keyVaultUrl) =
            let apply (args: VirtualMachineKeyVaultCredentialArgs) =
                args.KeyVaultUrl <- input keyVaultUrl
                args

            ()
            n, List.Cons(apply, args)

        member _.KeyVaultUrl((n, args), keyVaultUrl) =
            let apply (args: VirtualMachineKeyVaultCredentialArgs) =
                args.KeyVaultUrl <- io keyVaultUrl
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: VirtualMachineKeyVaultCredentialArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: VirtualMachineKeyVaultCredentialArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("servicePrincipalName")>]
        member _.ServicePrincipalName((n, args), servicePrincipalName) =
            let apply (args: VirtualMachineKeyVaultCredentialArgs) =
                args.ServicePrincipalName <- input servicePrincipalName
                args

            ()
            n, List.Cons(apply, args)

        member _.ServicePrincipalName((n, args), servicePrincipalName) =
            let apply (args: VirtualMachineKeyVaultCredentialArgs) =
                args.ServicePrincipalName <- io servicePrincipalName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("servicePrincipalSecret")>]
        member _.ServicePrincipalSecret((n, args), servicePrincipalSecret) =
            let apply (args: VirtualMachineKeyVaultCredentialArgs) =
                args.ServicePrincipalSecret <- input servicePrincipalSecret
                args

            ()
            n, List.Cons(apply, args)

        member _.ServicePrincipalSecret((n, args), servicePrincipalSecret) =
            let apply (args: VirtualMachineKeyVaultCredentialArgs) =
                args.ServicePrincipalSecret <- io servicePrincipalSecret
                args

            ()
            n, List.Cons(apply, args)

    let virtualMachineKeyVaultCredential =
        VirtualMachineKeyVaultCredentialBuilder()

    type DatabaseBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Database(name, (List.fold func (DatabaseArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("autoPauseDelayInMinutes")>]
        member _.AutoPauseDelayInMinutes((name, args), autoPauseDelayInMinutes) =
            let apply (args: DatabaseArgs) =
                args.AutoPauseDelayInMinutes <- input autoPauseDelayInMinutes
                args

            ()
            name, List.Cons(apply, args)

        member _.AutoPauseDelayInMinutes((name, args), autoPauseDelayInMinutes) =
            let apply (args: DatabaseArgs) =
                args.AutoPauseDelayInMinutes <- io autoPauseDelayInMinutes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("collation")>]
        member _.Collation((name, args), collation) =
            let apply (args: DatabaseArgs) =
                args.Collation <- input collation
                args

            ()
            name, List.Cons(apply, args)

        member _.Collation((name, args), collation) =
            let apply (args: DatabaseArgs) =
                args.Collation <- io collation
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("createMode")>]
        member _.CreateMode((name, args), createMode) =
            let apply (args: DatabaseArgs) =
                args.CreateMode <- input createMode
                args

            ()
            name, List.Cons(apply, args)

        member _.CreateMode((name, args), createMode) =
            let apply (args: DatabaseArgs) =
                args.CreateMode <- io createMode
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("creationSourceDatabaseId")>]
        member _.CreationSourceDatabaseId((name, args), creationSourceDatabaseId) =
            let apply (args: DatabaseArgs) =
                args.CreationSourceDatabaseId <- input creationSourceDatabaseId
                args

            ()
            name, List.Cons(apply, args)

        member _.CreationSourceDatabaseId((name, args), creationSourceDatabaseId) =
            let apply (args: DatabaseArgs) =
                args.CreationSourceDatabaseId <- io creationSourceDatabaseId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("elasticPoolId")>]
        member _.ElasticPoolId((name, args), elasticPoolId) =
            let apply (args: DatabaseArgs) =
                args.ElasticPoolId <- input elasticPoolId
                args

            ()
            name, List.Cons(apply, args)

        member _.ElasticPoolId((name, args), elasticPoolId) =
            let apply (args: DatabaseArgs) =
                args.ElasticPoolId <- io elasticPoolId
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: DatabaseArgs) =
                   args.ExtendedAuditingPolicy <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("licenseType")>]
        member _.LicenseType((name, args), licenseType) =
            let apply (args: DatabaseArgs) =
                args.LicenseType <- input licenseType
                args

            ()
            name, List.Cons(apply, args)

        member _.LicenseType((name, args), licenseType) =
            let apply (args: DatabaseArgs) =
                args.LicenseType <- io licenseType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("maxSizeGb")>]
        member _.MaxSizeGb((name, args), maxSizeGb) =
            let apply (args: DatabaseArgs) =
                args.MaxSizeGb <- input maxSizeGb
                args

            ()
            name, List.Cons(apply, args)

        member _.MaxSizeGb((name, args), maxSizeGb) =
            let apply (args: DatabaseArgs) =
                args.MaxSizeGb <- io maxSizeGb
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("minCapacity")>]
        member _.MinCapacity((name, args), minCapacity) =
            let apply (args: DatabaseArgs) =
                args.MinCapacity <- input minCapacity
                args

            ()
            name, List.Cons(apply, args)

        member _.MinCapacity((name, args), minCapacity) =
            let apply (args: DatabaseArgs) =
                args.MinCapacity <- io minCapacity
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: DatabaseArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: DatabaseArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("readReplicaCount")>]
        member _.ReadReplicaCount((name, args), readReplicaCount) =
            let apply (args: DatabaseArgs) =
                args.ReadReplicaCount <- input readReplicaCount
                args

            ()
            name, List.Cons(apply, args)

        member _.ReadReplicaCount((name, args), readReplicaCount) =
            let apply (args: DatabaseArgs) =
                args.ReadReplicaCount <- io readReplicaCount
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("readScale")>]
        member _.ReadScale((name, args), readScale) =
            let apply (args: DatabaseArgs) =
                args.ReadScale <- input readScale
                args

            ()
            name, List.Cons(apply, args)

        member _.ReadScale((name, args), readScale) =
            let apply (args: DatabaseArgs) =
                args.ReadScale <- io readScale
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("restorePointInTime")>]
        member _.RestorePointInTime((name, args), restorePointInTime) =
            let apply (args: DatabaseArgs) =
                args.RestorePointInTime <- input restorePointInTime
                args

            ()
            name, List.Cons(apply, args)

        member _.RestorePointInTime((name, args), restorePointInTime) =
            let apply (args: DatabaseArgs) =
                args.RestorePointInTime <- io restorePointInTime
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sampleName")>]
        member _.SampleName((name, args), sampleName) =
            let apply (args: DatabaseArgs) =
                args.SampleName <- input sampleName
                args

            ()
            name, List.Cons(apply, args)

        member _.SampleName((name, args), sampleName) =
            let apply (args: DatabaseArgs) =
                args.SampleName <- io sampleName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serverId")>]
        member _.ServerId((name, args), serverId) =
            let apply (args: DatabaseArgs) =
                args.ServerId <- input serverId
                args

            ()
            name, List.Cons(apply, args)

        member _.ServerId((name, args), serverId) =
            let apply (args: DatabaseArgs) =
                args.ServerId <- io serverId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("skuName")>]
        member _.SkuName((name, args), skuName) =
            let apply (args: DatabaseArgs) =
                args.SkuName <- input skuName
                args

            ()
            name, List.Cons(apply, args)

        member _.SkuName((name, args), skuName) =
            let apply (args: DatabaseArgs) =
                args.SkuName <- io skuName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: DatabaseArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: DatabaseArgs) =
                   args.ThreatDetectionPolicy <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("zoneRedundant")>]
        member _.ZoneRedundant((name, args), zoneRedundant) =
            let apply (args: DatabaseArgs) =
                args.ZoneRedundant <- input zoneRedundant
                args

            ()
            name, List.Cons(apply, args)

        member _.ZoneRedundant((name, args), zoneRedundant) =
            let apply (args: DatabaseArgs) =
                args.ZoneRedundant <- io zoneRedundant
                args

            ()
            name, List.Cons(apply, args)

    let database = DatabaseBuilder()

    type DatabaseVulnerabilityAssessmentRuleBaselineBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            DatabaseVulnerabilityAssessmentRuleBaseline
                (name, (List.fold func (DatabaseVulnerabilityAssessmentRuleBaselineArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("baselineName")>]
        member _.BaselineName((name, args), baselineName) =
            let apply (args: DatabaseVulnerabilityAssessmentRuleBaselineArgs) =
                args.BaselineName <- input baselineName
                args

            ()
            name, List.Cons(apply, args)

        member _.BaselineName((name, args), baselineName) =
            let apply (args: DatabaseVulnerabilityAssessmentRuleBaselineArgs) =
                args.BaselineName <- io baselineName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("baselineResults")>]
        member _.BaselineResults((name, args), baselineResults) =
            let apply (args: DatabaseVulnerabilityAssessmentRuleBaselineArgs) =
                args.BaselineResults <- inputList baselineResults
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("databaseName")>]
        member _.DatabaseName((name, args), databaseName) =
            let apply (args: DatabaseVulnerabilityAssessmentRuleBaselineArgs) =
                args.DatabaseName <- input databaseName
                args

            ()
            name, List.Cons(apply, args)

        member _.DatabaseName((name, args), databaseName) =
            let apply (args: DatabaseVulnerabilityAssessmentRuleBaselineArgs) =
                args.DatabaseName <- io databaseName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("ruleId")>]
        member _.RuleId((name, args), ruleId) =
            let apply (args: DatabaseVulnerabilityAssessmentRuleBaselineArgs) =
                args.RuleId <- input ruleId
                args

            ()
            name, List.Cons(apply, args)

        member _.RuleId((name, args), ruleId) =
            let apply (args: DatabaseVulnerabilityAssessmentRuleBaselineArgs) =
                args.RuleId <- io ruleId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serverVulnerabilityAssessmentId")>]
        member _.ServerVulnerabilityAssessmentId((name, args), serverVulnerabilityAssessmentId) =
            let apply (args: DatabaseVulnerabilityAssessmentRuleBaselineArgs) =
                args.ServerVulnerabilityAssessmentId <- input serverVulnerabilityAssessmentId
                args

            ()
            name, List.Cons(apply, args)

        member _.ServerVulnerabilityAssessmentId((name, args), serverVulnerabilityAssessmentId) =
            let apply (args: DatabaseVulnerabilityAssessmentRuleBaselineArgs) =
                args.ServerVulnerabilityAssessmentId <- io serverVulnerabilityAssessmentId
                args

            ()
            name, List.Cons(apply, args)

    let databaseVulnerabilityAssessmentRuleBaseline =
        DatabaseVulnerabilityAssessmentRuleBaselineBuilder()

    type ElasticPoolBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ElasticPool(name, (List.fold func (ElasticPoolArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("licenseType")>]
        member _.LicenseType((name, args), licenseType) =
            let apply (args: ElasticPoolArgs) =
                args.LicenseType <- input licenseType
                args

            ()
            name, List.Cons(apply, args)

        member _.LicenseType((name, args), licenseType) =
            let apply (args: ElasticPoolArgs) =
                args.LicenseType <- io licenseType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ElasticPoolArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ElasticPoolArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("maxSizeBytes")>]
        member _.MaxSizeBytes((name, args), maxSizeBytes) =
            let apply (args: ElasticPoolArgs) =
                args.MaxSizeBytes <- input maxSizeBytes
                args

            ()
            name, List.Cons(apply, args)

        member _.MaxSizeBytes((name, args), maxSizeBytes) =
            let apply (args: ElasticPoolArgs) =
                args.MaxSizeBytes <- io maxSizeBytes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("maxSizeGb")>]
        member _.MaxSizeGb((name, args), maxSizeGb) =
            let apply (args: ElasticPoolArgs) =
                args.MaxSizeGb <- input maxSizeGb
                args

            ()
            name, List.Cons(apply, args)

        member _.MaxSizeGb((name, args), maxSizeGb) =
            let apply (args: ElasticPoolArgs) =
                args.MaxSizeGb <- io maxSizeGb
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ElasticPoolArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ElasticPoolArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ElasticPoolArgs) =
                   args.PerDatabaseSettings <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ElasticPoolArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ElasticPoolArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serverName")>]
        member _.ServerName((name, args), serverName) =
            let apply (args: ElasticPoolArgs) =
                args.ServerName <- input serverName
                args

            ()
            name, List.Cons(apply, args)

        member _.ServerName((name, args), serverName) =
            let apply (args: ElasticPoolArgs) =
                args.ServerName <- io serverName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ElasticPoolArgs) =
                   args.Sku <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ElasticPoolArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zoneRedundant")>]
        member _.ZoneRedundant((name, args), zoneRedundant) =
            let apply (args: ElasticPoolArgs) =
                args.ZoneRedundant <- input zoneRedundant
                args

            ()
            name, List.Cons(apply, args)

        member _.ZoneRedundant((name, args), zoneRedundant) =
            let apply (args: ElasticPoolArgs) =
                args.ZoneRedundant <- io zoneRedundant
                args

            ()
            name, List.Cons(apply, args)

    let elasticPool = ElasticPoolBuilder()

    type ServerBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Server(name, (List.fold func (ServerArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("administratorLogin")>]
        member _.AdministratorLogin((name, args), administratorLogin) =
            let apply (args: ServerArgs) =
                args.AdministratorLogin <- input administratorLogin
                args

            ()
            name, List.Cons(apply, args)

        member _.AdministratorLogin((name, args), administratorLogin) =
            let apply (args: ServerArgs) =
                args.AdministratorLogin <- io administratorLogin
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("administratorLoginPassword")>]
        member _.AdministratorLoginPassword((name, args), administratorLoginPassword) =
            let apply (args: ServerArgs) =
                args.AdministratorLoginPassword <- input administratorLoginPassword
                args

            ()
            name, List.Cons(apply, args)

        member _.AdministratorLoginPassword((name, args), administratorLoginPassword) =
            let apply (args: ServerArgs) =
                args.AdministratorLoginPassword <- io administratorLoginPassword
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ServerArgs) =
                   args.AzureadAdministrator <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("connectionPolicy")>]
        member _.ConnectionPolicy((name, args), connectionPolicy) =
            let apply (args: ServerArgs) =
                args.ConnectionPolicy <- input connectionPolicy
                args

            ()
            name, List.Cons(apply, args)

        member _.ConnectionPolicy((name, args), connectionPolicy) =
            let apply (args: ServerArgs) =
                args.ConnectionPolicy <- io connectionPolicy
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ServerArgs) =
                   args.ExtendedAuditingPolicy <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: ServerArgs) =
                   args.Identity <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ServerArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ServerArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ServerArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ServerArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("publicNetworkAccessEnabled")>]
        member _.PublicNetworkAccessEnabled((name, args), publicNetworkAccessEnabled) =
            let apply (args: ServerArgs) =
                args.PublicNetworkAccessEnabled <- input publicNetworkAccessEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.PublicNetworkAccessEnabled((name, args), publicNetworkAccessEnabled) =
            let apply (args: ServerArgs) =
                args.PublicNetworkAccessEnabled <- io publicNetworkAccessEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ServerArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ServerArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ServerArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("version")>]
        member _.Version((name, args), version) =
            let apply (args: ServerArgs) =
                args.Version <- input version
                args

            ()
            name, List.Cons(apply, args)

        member _.Version((name, args), version) =
            let apply (args: ServerArgs) =
                args.Version <- io version
                args

            ()
            name, List.Cons(apply, args)

    let server = ServerBuilder()

    type ServerSecurityAlertPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ServerSecurityAlertPolicy(name, (List.fold func (ServerSecurityAlertPolicyArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("disabledAlerts")>]
        member _.DisabledAlerts((name, args), disabledAlerts) =
            let apply (args: ServerSecurityAlertPolicyArgs) =
                args.DisabledAlerts <- inputList disabledAlerts
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("emailAccountAdmins")>]
        member _.EmailAccountAdmins((name, args), emailAccountAdmins) =
            let apply (args: ServerSecurityAlertPolicyArgs) =
                args.EmailAccountAdmins <- input emailAccountAdmins
                args

            ()
            name, List.Cons(apply, args)

        member _.EmailAccountAdmins((name, args), emailAccountAdmins) =
            let apply (args: ServerSecurityAlertPolicyArgs) =
                args.EmailAccountAdmins <- io emailAccountAdmins
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("emailAddresses")>]
        member _.EmailAddresses((name, args), emailAddresses) =
            let apply (args: ServerSecurityAlertPolicyArgs) =
                args.EmailAddresses <- inputList emailAddresses
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ServerSecurityAlertPolicyArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ServerSecurityAlertPolicyArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("retentionDays")>]
        member _.RetentionDays((name, args), retentionDays) =
            let apply (args: ServerSecurityAlertPolicyArgs) =
                args.RetentionDays <- input retentionDays
                args

            ()
            name, List.Cons(apply, args)

        member _.RetentionDays((name, args), retentionDays) =
            let apply (args: ServerSecurityAlertPolicyArgs) =
                args.RetentionDays <- io retentionDays
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serverName")>]
        member _.ServerName((name, args), serverName) =
            let apply (args: ServerSecurityAlertPolicyArgs) =
                args.ServerName <- input serverName
                args

            ()
            name, List.Cons(apply, args)

        member _.ServerName((name, args), serverName) =
            let apply (args: ServerSecurityAlertPolicyArgs) =
                args.ServerName <- io serverName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("state")>]
        member _.State((name, args), state) =
            let apply (args: ServerSecurityAlertPolicyArgs) =
                args.State <- input state
                args

            ()
            name, List.Cons(apply, args)

        member _.State((name, args), state) =
            let apply (args: ServerSecurityAlertPolicyArgs) =
                args.State <- io state
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageAccountAccessKey")>]
        member _.StorageAccountAccessKey((name, args), storageAccountAccessKey) =
            let apply (args: ServerSecurityAlertPolicyArgs) =
                args.StorageAccountAccessKey <- input storageAccountAccessKey
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageAccountAccessKey((name, args), storageAccountAccessKey) =
            let apply (args: ServerSecurityAlertPolicyArgs) =
                args.StorageAccountAccessKey <- io storageAccountAccessKey
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageEndpoint")>]
        member _.StorageEndpoint((name, args), storageEndpoint) =
            let apply (args: ServerSecurityAlertPolicyArgs) =
                args.StorageEndpoint <- input storageEndpoint
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageEndpoint((name, args), storageEndpoint) =
            let apply (args: ServerSecurityAlertPolicyArgs) =
                args.StorageEndpoint <- io storageEndpoint
                args

            ()
            name, List.Cons(apply, args)

    let serverSecurityAlertPolicy = ServerSecurityAlertPolicyBuilder()

    type ServerVulnerabilityAssessmentBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ServerVulnerabilityAssessment(name, (List.fold func (ServerVulnerabilityAssessmentArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: ServerVulnerabilityAssessmentArgs) =
                   args.RecurringScans <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("serverSecurityAlertPolicyId")>]
        member _.ServerSecurityAlertPolicyId((name, args), serverSecurityAlertPolicyId) =
            let apply (args: ServerVulnerabilityAssessmentArgs) =
                args.ServerSecurityAlertPolicyId <- input serverSecurityAlertPolicyId
                args

            ()
            name, List.Cons(apply, args)

        member _.ServerSecurityAlertPolicyId((name, args), serverSecurityAlertPolicyId) =
            let apply (args: ServerVulnerabilityAssessmentArgs) =
                args.ServerSecurityAlertPolicyId <- io serverSecurityAlertPolicyId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageAccountAccessKey")>]
        member _.StorageAccountAccessKey((name, args), storageAccountAccessKey) =
            let apply (args: ServerVulnerabilityAssessmentArgs) =
                args.StorageAccountAccessKey <- input storageAccountAccessKey
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageAccountAccessKey((name, args), storageAccountAccessKey) =
            let apply (args: ServerVulnerabilityAssessmentArgs) =
                args.StorageAccountAccessKey <- io storageAccountAccessKey
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageContainerPath")>]
        member _.StorageContainerPath((name, args), storageContainerPath) =
            let apply (args: ServerVulnerabilityAssessmentArgs) =
                args.StorageContainerPath <- input storageContainerPath
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageContainerPath((name, args), storageContainerPath) =
            let apply (args: ServerVulnerabilityAssessmentArgs) =
                args.StorageContainerPath <- io storageContainerPath
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageContainerSasKey")>]
        member _.StorageContainerSasKey((name, args), storageContainerSasKey) =
            let apply (args: ServerVulnerabilityAssessmentArgs) =
                args.StorageContainerSasKey <- input storageContainerSasKey
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageContainerSasKey((name, args), storageContainerSasKey) =
            let apply (args: ServerVulnerabilityAssessmentArgs) =
                args.StorageContainerSasKey <- io storageContainerSasKey
                args

            ()
            name, List.Cons(apply, args)

    let serverVulnerabilityAssessment = ServerVulnerabilityAssessmentBuilder()

    type VirtualMachineBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            VirtualMachine(name, (List.fold func (VirtualMachineArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: VirtualMachineArgs) =
                   args.AutoPatching <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: VirtualMachineArgs) =
                   args.KeyVaultCredential <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("rServicesEnabled")>]
        member _.RServicesEnabled((name, args), rServicesEnabled) =
            let apply (args: VirtualMachineArgs) =
                args.RServicesEnabled <- input rServicesEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.RServicesEnabled((name, args), rServicesEnabled) =
            let apply (args: VirtualMachineArgs) =
                args.RServicesEnabled <- io rServicesEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sqlConnectivityPort")>]
        member _.SqlConnectivityPort((name, args), sqlConnectivityPort) =
            let apply (args: VirtualMachineArgs) =
                args.SqlConnectivityPort <- input sqlConnectivityPort
                args

            ()
            name, List.Cons(apply, args)

        member _.SqlConnectivityPort((name, args), sqlConnectivityPort) =
            let apply (args: VirtualMachineArgs) =
                args.SqlConnectivityPort <- io sqlConnectivityPort
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sqlConnectivityType")>]
        member _.SqlConnectivityType((name, args), sqlConnectivityType) =
            let apply (args: VirtualMachineArgs) =
                args.SqlConnectivityType <- input sqlConnectivityType
                args

            ()
            name, List.Cons(apply, args)

        member _.SqlConnectivityType((name, args), sqlConnectivityType) =
            let apply (args: VirtualMachineArgs) =
                args.SqlConnectivityType <- io sqlConnectivityType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sqlConnectivityUpdatePassword")>]
        member _.SqlConnectivityUpdatePassword((name, args), sqlConnectivityUpdatePassword) =
            let apply (args: VirtualMachineArgs) =
                args.SqlConnectivityUpdatePassword <- input sqlConnectivityUpdatePassword
                args

            ()
            name, List.Cons(apply, args)

        member _.SqlConnectivityUpdatePassword((name, args), sqlConnectivityUpdatePassword) =
            let apply (args: VirtualMachineArgs) =
                args.SqlConnectivityUpdatePassword <- io sqlConnectivityUpdatePassword
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sqlConnectivityUpdateUsername")>]
        member _.SqlConnectivityUpdateUsername((name, args), sqlConnectivityUpdateUsername) =
            let apply (args: VirtualMachineArgs) =
                args.SqlConnectivityUpdateUsername <- input sqlConnectivityUpdateUsername
                args

            ()
            name, List.Cons(apply, args)

        member _.SqlConnectivityUpdateUsername((name, args), sqlConnectivityUpdateUsername) =
            let apply (args: VirtualMachineArgs) =
                args.SqlConnectivityUpdateUsername <- io sqlConnectivityUpdateUsername
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sqlLicenseType")>]
        member _.SqlLicenseType((name, args), sqlLicenseType) =
            let apply (args: VirtualMachineArgs) =
                args.SqlLicenseType <- input sqlLicenseType
                args

            ()
            name, List.Cons(apply, args)

        member _.SqlLicenseType((name, args), sqlLicenseType) =
            let apply (args: VirtualMachineArgs) =
                args.SqlLicenseType <- io sqlLicenseType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: VirtualMachineArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("virtualMachineId")>]
        member _.VirtualMachineId((name, args), virtualMachineId) =
            let apply (args: VirtualMachineArgs) =
                args.VirtualMachineId <- input virtualMachineId
                args

            ()
            name, List.Cons(apply, args)

        member _.VirtualMachineId((name, args), virtualMachineId) =
            let apply (args: VirtualMachineArgs) =
                args.VirtualMachineId <- io virtualMachineId
                args

            ()
            name, List.Cons(apply, args)

    let virtualMachine = VirtualMachineBuilder()

module MySql =
    open Pulumi.Azure.MySql
    open Pulumi.Azure.MySql.Inputs

    type ServerStorageProfileBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ServerStorageProfileArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("autoGrow")>]
        member _.AutoGrow((n, args), autoGrow) =
            let apply (args: ServerStorageProfileArgs) =
                args.AutoGrow <- input autoGrow
                args

            ()
            n, List.Cons(apply, args)

        member _.AutoGrow((n, args), autoGrow) =
            let apply (args: ServerStorageProfileArgs) =
                args.AutoGrow <- io autoGrow
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("backupRetentionDays")>]
        member _.BackupRetentionDays((n, args), backupRetentionDays) =
            let apply (args: ServerStorageProfileArgs) =
                args.BackupRetentionDays <- input backupRetentionDays
                args

            ()
            n, List.Cons(apply, args)

        member _.BackupRetentionDays((n, args), backupRetentionDays) =
            let apply (args: ServerStorageProfileArgs) =
                args.BackupRetentionDays <- io backupRetentionDays
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("geoRedundantBackup")>]
        member _.GeoRedundantBackup((n, args), geoRedundantBackup) =
            let apply (args: ServerStorageProfileArgs) =
                args.GeoRedundantBackup <- input geoRedundantBackup
                args

            ()
            n, List.Cons(apply, args)

        member _.GeoRedundantBackup((n, args), geoRedundantBackup) =
            let apply (args: ServerStorageProfileArgs) =
                args.GeoRedundantBackup <- io geoRedundantBackup
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageMb")>]
        member _.StorageMb((n, args), storageMb) =
            let apply (args: ServerStorageProfileArgs) =
                args.StorageMb <- input storageMb
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageMb((n, args), storageMb) =
            let apply (args: ServerStorageProfileArgs) =
                args.StorageMb <- io storageMb
                args

            ()
            n, List.Cons(apply, args)

    let serverStorageProfile = ServerStorageProfileBuilder()

    type ConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Configuration(name, (List.fold func (ConfigurationArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ConfigurationArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ConfigurationArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ConfigurationArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ConfigurationArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serverName")>]
        member _.ServerName((name, args), serverName) =
            let apply (args: ConfigurationArgs) =
                args.ServerName <- input serverName
                args

            ()
            name, List.Cons(apply, args)

        member _.ServerName((name, args), serverName) =
            let apply (args: ConfigurationArgs) =
                args.ServerName <- io serverName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((name, args), value) =
            let apply (args: ConfigurationArgs) =
                args.Value <- input value
                args

            ()
            name, List.Cons(apply, args)

        member _.Value((name, args), value) =
            let apply (args: ConfigurationArgs) =
                args.Value <- io value
                args

            ()
            name, List.Cons(apply, args)

    let configuration = ConfigurationBuilder()

    type DatabaseBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Database(name, (List.fold func (DatabaseArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("charset")>]
        member _.Charset((name, args), charset) =
            let apply (args: DatabaseArgs) =
                args.Charset <- input charset
                args

            ()
            name, List.Cons(apply, args)

        member _.Charset((name, args), charset) =
            let apply (args: DatabaseArgs) =
                args.Charset <- io charset
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("collation")>]
        member _.Collation((name, args), collation) =
            let apply (args: DatabaseArgs) =
                args.Collation <- input collation
                args

            ()
            name, List.Cons(apply, args)

        member _.Collation((name, args), collation) =
            let apply (args: DatabaseArgs) =
                args.Collation <- io collation
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: DatabaseArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: DatabaseArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DatabaseArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DatabaseArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serverName")>]
        member _.ServerName((name, args), serverName) =
            let apply (args: DatabaseArgs) =
                args.ServerName <- input serverName
                args

            ()
            name, List.Cons(apply, args)

        member _.ServerName((name, args), serverName) =
            let apply (args: DatabaseArgs) =
                args.ServerName <- io serverName
                args

            ()
            name, List.Cons(apply, args)

    let database = DatabaseBuilder()

    type FirewallRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            FirewallRule(name, (List.fold func (FirewallRuleArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("endIpAddress")>]
        member _.EndIpAddress((name, args), endIpAddress) =
            let apply (args: FirewallRuleArgs) =
                args.EndIpAddress <- input endIpAddress
                args

            ()
            name, List.Cons(apply, args)

        member _.EndIpAddress((name, args), endIpAddress) =
            let apply (args: FirewallRuleArgs) =
                args.EndIpAddress <- io endIpAddress
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: FirewallRuleArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: FirewallRuleArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FirewallRuleArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FirewallRuleArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serverName")>]
        member _.ServerName((name, args), serverName) =
            let apply (args: FirewallRuleArgs) =
                args.ServerName <- input serverName
                args

            ()
            name, List.Cons(apply, args)

        member _.ServerName((name, args), serverName) =
            let apply (args: FirewallRuleArgs) =
                args.ServerName <- io serverName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("startIpAddress")>]
        member _.StartIpAddress((name, args), startIpAddress) =
            let apply (args: FirewallRuleArgs) =
                args.StartIpAddress <- input startIpAddress
                args

            ()
            name, List.Cons(apply, args)

        member _.StartIpAddress((name, args), startIpAddress) =
            let apply (args: FirewallRuleArgs) =
                args.StartIpAddress <- io startIpAddress
                args

            ()
            name, List.Cons(apply, args)

    let firewallRule = FirewallRuleBuilder()

    type ServerBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Server(name, (List.fold func (ServerArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("administratorLogin")>]
        member _.AdministratorLogin((name, args), administratorLogin) =
            let apply (args: ServerArgs) =
                args.AdministratorLogin <- input administratorLogin
                args

            ()
            name, List.Cons(apply, args)

        member _.AdministratorLogin((name, args), administratorLogin) =
            let apply (args: ServerArgs) =
                args.AdministratorLogin <- io administratorLogin
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("administratorLoginPassword")>]
        member _.AdministratorLoginPassword((name, args), administratorLoginPassword) =
            let apply (args: ServerArgs) =
                args.AdministratorLoginPassword <- input administratorLoginPassword
                args

            ()
            name, List.Cons(apply, args)

        member _.AdministratorLoginPassword((name, args), administratorLoginPassword) =
            let apply (args: ServerArgs) =
                args.AdministratorLoginPassword <- io administratorLoginPassword
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("autoGrowEnabled")>]
        member _.AutoGrowEnabled((name, args), autoGrowEnabled) =
            let apply (args: ServerArgs) =
                args.AutoGrowEnabled <- input autoGrowEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.AutoGrowEnabled((name, args), autoGrowEnabled) =
            let apply (args: ServerArgs) =
                args.AutoGrowEnabled <- io autoGrowEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("backupRetentionDays")>]
        member _.BackupRetentionDays((name, args), backupRetentionDays) =
            let apply (args: ServerArgs) =
                args.BackupRetentionDays <- input backupRetentionDays
                args

            ()
            name, List.Cons(apply, args)

        member _.BackupRetentionDays((name, args), backupRetentionDays) =
            let apply (args: ServerArgs) =
                args.BackupRetentionDays <- io backupRetentionDays
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("createMode")>]
        member _.CreateMode((name, args), createMode) =
            let apply (args: ServerArgs) =
                args.CreateMode <- input createMode
                args

            ()
            name, List.Cons(apply, args)

        member _.CreateMode((name, args), createMode) =
            let apply (args: ServerArgs) =
                args.CreateMode <- io createMode
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("creationSourceServerId")>]
        member _.CreationSourceServerId((name, args), creationSourceServerId) =
            let apply (args: ServerArgs) =
                args.CreationSourceServerId <- input creationSourceServerId
                args

            ()
            name, List.Cons(apply, args)

        member _.CreationSourceServerId((name, args), creationSourceServerId) =
            let apply (args: ServerArgs) =
                args.CreationSourceServerId <- io creationSourceServerId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("geoRedundantBackupEnabled")>]
        member _.GeoRedundantBackupEnabled((name, args), geoRedundantBackupEnabled) =
            let apply (args: ServerArgs) =
                args.GeoRedundantBackupEnabled <- input geoRedundantBackupEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.GeoRedundantBackupEnabled((name, args), geoRedundantBackupEnabled) =
            let apply (args: ServerArgs) =
                args.GeoRedundantBackupEnabled <- io geoRedundantBackupEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("infrastructureEncryptionEnabled")>]
        member _.InfrastructureEncryptionEnabled((name, args), infrastructureEncryptionEnabled) =
            let apply (args: ServerArgs) =
                args.InfrastructureEncryptionEnabled <- input infrastructureEncryptionEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.InfrastructureEncryptionEnabled((name, args), infrastructureEncryptionEnabled) =
            let apply (args: ServerArgs) =
                args.InfrastructureEncryptionEnabled <- io infrastructureEncryptionEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ServerArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ServerArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ServerArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ServerArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("publicNetworkAccessEnabled")>]
        member _.PublicNetworkAccessEnabled((name, args), publicNetworkAccessEnabled) =
            let apply (args: ServerArgs) =
                args.PublicNetworkAccessEnabled <- input publicNetworkAccessEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.PublicNetworkAccessEnabled((name, args), publicNetworkAccessEnabled) =
            let apply (args: ServerArgs) =
                args.PublicNetworkAccessEnabled <- io publicNetworkAccessEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ServerArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ServerArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("restorePointInTime")>]
        member _.RestorePointInTime((name, args), restorePointInTime) =
            let apply (args: ServerArgs) =
                args.RestorePointInTime <- input restorePointInTime
                args

            ()
            name, List.Cons(apply, args)

        member _.RestorePointInTime((name, args), restorePointInTime) =
            let apply (args: ServerArgs) =
                args.RestorePointInTime <- io restorePointInTime
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("skuName")>]
        member _.SkuName((name, args), skuName) =
            let apply (args: ServerArgs) =
                args.SkuName <- input skuName
                args

            ()
            name, List.Cons(apply, args)

        member _.SkuName((name, args), skuName) =
            let apply (args: ServerArgs) =
                args.SkuName <- io skuName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sslEnforcement")>]
        member _.SslEnforcement((name, args), sslEnforcement) =
            let apply (args: ServerArgs) =
                args.SslEnforcement <- input sslEnforcement
                args

            ()
            name, List.Cons(apply, args)

        member _.SslEnforcement((name, args), sslEnforcement) =
            let apply (args: ServerArgs) =
                args.SslEnforcement <- io sslEnforcement
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sslEnforcementEnabled")>]
        member _.SslEnforcementEnabled((name, args), sslEnforcementEnabled) =
            let apply (args: ServerArgs) =
                args.SslEnforcementEnabled <- input sslEnforcementEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.SslEnforcementEnabled((name, args), sslEnforcementEnabled) =
            let apply (args: ServerArgs) =
                args.SslEnforcementEnabled <- io sslEnforcementEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sslMinimalTlsVersionEnforced")>]
        member _.SslMinimalTlsVersionEnforced((name, args), sslMinimalTlsVersionEnforced) =
            let apply (args: ServerArgs) =
                args.SslMinimalTlsVersionEnforced <- input sslMinimalTlsVersionEnforced
                args

            ()
            name, List.Cons(apply, args)

        member _.SslMinimalTlsVersionEnforced((name, args), sslMinimalTlsVersionEnforced) =
            let apply (args: ServerArgs) =
                args.SslMinimalTlsVersionEnforced <- io sslMinimalTlsVersionEnforced
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageMb")>]
        member _.StorageMb((name, args), storageMb) =
            let apply (args: ServerArgs) =
                args.StorageMb <- input storageMb
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageMb((name, args), storageMb) =
            let apply (args: ServerArgs) =
                args.StorageMb <- io storageMb
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ServerArgs) =
                   args.StorageProfile <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ServerArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("version")>]
        member _.Version((name, args), version) =
            let apply (args: ServerArgs) =
                args.Version <- input version
                args

            ()
            name, List.Cons(apply, args)

        member _.Version((name, args), version) =
            let apply (args: ServerArgs) =
                args.Version <- io version
                args

            ()
            name, List.Cons(apply, args)

    let server = ServerBuilder()

    type VirtualNetworkRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            VirtualNetworkRule(name, (List.fold func (VirtualNetworkRuleArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serverName")>]
        member _.ServerName((name, args), serverName) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.ServerName <- input serverName
                args

            ()
            name, List.Cons(apply, args)

        member _.ServerName((name, args), serverName) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.ServerName <- io serverName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((name, args), subnetId) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            name, List.Cons(apply, args)

        member _.SubnetId((name, args), subnetId) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            name, List.Cons(apply, args)

    let virtualNetworkRule = VirtualNetworkRuleBuilder()

module NetApp =
    open Pulumi.Azure.NetApp
    open Pulumi.Azure.NetApp.Inputs

    type AccountActiveDirectoryBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AccountActiveDirectoryArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("dnsServers")>]
        member _.DnsServers((n, args), dnsServers) =
            let apply (args: AccountActiveDirectoryArgs) =
                args.DnsServers <- inputList dnsServers
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("domain")>]
        member _.Domain((n, args), domain) =
            let apply (args: AccountActiveDirectoryArgs) =
                args.Domain <- input domain
                args

            ()
            n, List.Cons(apply, args)

        member _.Domain((n, args), domain) =
            let apply (args: AccountActiveDirectoryArgs) =
                args.Domain <- io domain
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("organizationalUnit")>]
        member _.OrganizationalUnit((n, args), organizationalUnit) =
            let apply (args: AccountActiveDirectoryArgs) =
                args.OrganizationalUnit <- input organizationalUnit
                args

            ()
            n, List.Cons(apply, args)

        member _.OrganizationalUnit((n, args), organizationalUnit) =
            let apply (args: AccountActiveDirectoryArgs) =
                args.OrganizationalUnit <- io organizationalUnit
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: AccountActiveDirectoryArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: AccountActiveDirectoryArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("smbServerName")>]
        member _.SmbServerName((n, args), smbServerName) =
            let apply (args: AccountActiveDirectoryArgs) =
                args.SmbServerName <- input smbServerName
                args

            ()
            n, List.Cons(apply, args)

        member _.SmbServerName((n, args), smbServerName) =
            let apply (args: AccountActiveDirectoryArgs) =
                args.SmbServerName <- io smbServerName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("username")>]
        member _.Username((n, args), username) =
            let apply (args: AccountActiveDirectoryArgs) =
                args.Username <- input username
                args

            ()
            n, List.Cons(apply, args)

        member _.Username((n, args), username) =
            let apply (args: AccountActiveDirectoryArgs) =
                args.Username <- io username
                args

            ()
            n, List.Cons(apply, args)

    let accountActiveDirectory = AccountActiveDirectoryBuilder()

    type VolumeExportPolicyRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VolumeExportPolicyRuleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("allowedClients")>]
        member _.AllowedClients((n, args), allowedClients) =
            let apply (args: VolumeExportPolicyRuleArgs) =
                args.AllowedClients <- inputList allowedClients
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("cifsEnabled")>]
        member _.CifsEnabled((n, args), cifsEnabled) =
            let apply (args: VolumeExportPolicyRuleArgs) =
                args.CifsEnabled <- input cifsEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.CifsEnabled((n, args), cifsEnabled) =
            let apply (args: VolumeExportPolicyRuleArgs) =
                args.CifsEnabled <- io cifsEnabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("nfsv3Enabled")>]
        member _.Nfsv3Enabled((n, args), nfsv3Enabled) =
            let apply (args: VolumeExportPolicyRuleArgs) =
                args.Nfsv3Enabled <- input nfsv3Enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Nfsv3Enabled((n, args), nfsv3Enabled) =
            let apply (args: VolumeExportPolicyRuleArgs) =
                args.Nfsv3Enabled <- io nfsv3Enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("nfsv4Enabled")>]
        member _.Nfsv4Enabled((n, args), nfsv4Enabled) =
            let apply (args: VolumeExportPolicyRuleArgs) =
                args.Nfsv4Enabled <- input nfsv4Enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Nfsv4Enabled((n, args), nfsv4Enabled) =
            let apply (args: VolumeExportPolicyRuleArgs) =
                args.Nfsv4Enabled <- io nfsv4Enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("protocolsEnabled")>]
        member _.ProtocolsEnabled((n, args), protocolsEnabled) =
            let apply (args: VolumeExportPolicyRuleArgs) =
                args.ProtocolsEnabled <- input protocolsEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.ProtocolsEnabled((n, args), protocolsEnabled) =
            let apply (args: VolumeExportPolicyRuleArgs) =
                args.ProtocolsEnabled <- io protocolsEnabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ruleIndex")>]
        member _.RuleIndex((n, args), ruleIndex) =
            let apply (args: VolumeExportPolicyRuleArgs) =
                args.RuleIndex <- input ruleIndex
                args

            ()
            n, List.Cons(apply, args)

        member _.RuleIndex((n, args), ruleIndex) =
            let apply (args: VolumeExportPolicyRuleArgs) =
                args.RuleIndex <- io ruleIndex
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("unixReadOnly")>]
        member _.UnixReadOnly((n, args), unixReadOnly) =
            let apply (args: VolumeExportPolicyRuleArgs) =
                args.UnixReadOnly <- input unixReadOnly
                args

            ()
            n, List.Cons(apply, args)

        member _.UnixReadOnly((n, args), unixReadOnly) =
            let apply (args: VolumeExportPolicyRuleArgs) =
                args.UnixReadOnly <- io unixReadOnly
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("unixReadWrite")>]
        member _.UnixReadWrite((n, args), unixReadWrite) =
            let apply (args: VolumeExportPolicyRuleArgs) =
                args.UnixReadWrite <- input unixReadWrite
                args

            ()
            n, List.Cons(apply, args)

        member _.UnixReadWrite((n, args), unixReadWrite) =
            let apply (args: VolumeExportPolicyRuleArgs) =
                args.UnixReadWrite <- io unixReadWrite
                args

            ()
            n, List.Cons(apply, args)

    let volumeExportPolicyRule = VolumeExportPolicyRuleBuilder()

    type AccountBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Account(name, (List.fold func (AccountArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: AccountArgs) =
                   args.ActiveDirectory <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: AccountArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: AccountArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: AccountArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: AccountArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AccountArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AccountArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: AccountArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let account = AccountBuilder()

    type PoolBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Pool(name, (List.fold func (PoolArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("accountName")>]
        member _.AccountName((name, args), accountName) =
            let apply (args: PoolArgs) =
                args.AccountName <- input accountName
                args

            ()
            name, List.Cons(apply, args)

        member _.AccountName((name, args), accountName) =
            let apply (args: PoolArgs) =
                args.AccountName <- io accountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: PoolArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: PoolArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: PoolArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: PoolArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: PoolArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: PoolArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serviceLevel")>]
        member _.ServiceLevel((name, args), serviceLevel) =
            let apply (args: PoolArgs) =
                args.ServiceLevel <- input serviceLevel
                args

            ()
            name, List.Cons(apply, args)

        member _.ServiceLevel((name, args), serviceLevel) =
            let apply (args: PoolArgs) =
                args.ServiceLevel <- io serviceLevel
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sizeInTb")>]
        member _.SizeInTb((name, args), sizeInTb) =
            let apply (args: PoolArgs) =
                args.SizeInTb <- input sizeInTb
                args

            ()
            name, List.Cons(apply, args)

        member _.SizeInTb((name, args), sizeInTb) =
            let apply (args: PoolArgs) =
                args.SizeInTb <- io sizeInTb
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: PoolArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let pool = PoolBuilder()

    type SnapshotBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Snapshot(name, (List.fold func (SnapshotArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("accountName")>]
        member _.AccountName((name, args), accountName) =
            let apply (args: SnapshotArgs) =
                args.AccountName <- input accountName
                args

            ()
            name, List.Cons(apply, args)

        member _.AccountName((name, args), accountName) =
            let apply (args: SnapshotArgs) =
                args.AccountName <- io accountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: SnapshotArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: SnapshotArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: SnapshotArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: SnapshotArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("poolName")>]
        member _.PoolName((name, args), poolName) =
            let apply (args: SnapshotArgs) =
                args.PoolName <- input poolName
                args

            ()
            name, List.Cons(apply, args)

        member _.PoolName((name, args), poolName) =
            let apply (args: SnapshotArgs) =
                args.PoolName <- io poolName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SnapshotArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SnapshotArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: SnapshotArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("volumeName")>]
        member _.VolumeName((name, args), volumeName) =
            let apply (args: SnapshotArgs) =
                args.VolumeName <- input volumeName
                args

            ()
            name, List.Cons(apply, args)

        member _.VolumeName((name, args), volumeName) =
            let apply (args: SnapshotArgs) =
                args.VolumeName <- io volumeName
                args

            ()
            name, List.Cons(apply, args)

    let snapshot = SnapshotBuilder()

    type VolumeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Volume(name, (List.fold func (VolumeArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("accountName")>]
        member _.AccountName((name, args), accountName) =
            let apply (args: VolumeArgs) =
                args.AccountName <- input accountName
                args

            ()
            name, List.Cons(apply, args)

        member _.AccountName((name, args), accountName) =
            let apply (args: VolumeArgs) =
                args.AccountName <- io accountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("exportPolicyRules")>]
        member _.ExportPolicyRules((name, args), exportPolicyRules) =
            let apply (args: VolumeArgs) =
                args.ExportPolicyRules <- inputList exportPolicyRules
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: VolumeArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: VolumeArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: VolumeArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: VolumeArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("poolName")>]
        member _.PoolName((name, args), poolName) =
            let apply (args: VolumeArgs) =
                args.PoolName <- input poolName
                args

            ()
            name, List.Cons(apply, args)

        member _.PoolName((name, args), poolName) =
            let apply (args: VolumeArgs) =
                args.PoolName <- io poolName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("protocols")>]
        member _.Protocols((name, args), protocols) =
            let apply (args: VolumeArgs) =
                args.Protocols <- inputList protocols
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: VolumeArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: VolumeArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serviceLevel")>]
        member _.ServiceLevel((name, args), serviceLevel) =
            let apply (args: VolumeArgs) =
                args.ServiceLevel <- input serviceLevel
                args

            ()
            name, List.Cons(apply, args)

        member _.ServiceLevel((name, args), serviceLevel) =
            let apply (args: VolumeArgs) =
                args.ServiceLevel <- io serviceLevel
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageQuotaInGb")>]
        member _.StorageQuotaInGb((name, args), storageQuotaInGb) =
            let apply (args: VolumeArgs) =
                args.StorageQuotaInGb <- input storageQuotaInGb
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageQuotaInGb((name, args), storageQuotaInGb) =
            let apply (args: VolumeArgs) =
                args.StorageQuotaInGb <- io storageQuotaInGb
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((name, args), subnetId) =
            let apply (args: VolumeArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            name, List.Cons(apply, args)

        member _.SubnetId((name, args), subnetId) =
            let apply (args: VolumeArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: VolumeArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("volumePath")>]
        member _.VolumePath((name, args), volumePath) =
            let apply (args: VolumeArgs) =
                args.VolumePath <- input volumePath
                args

            ()
            name, List.Cons(apply, args)

        member _.VolumePath((name, args), volumePath) =
            let apply (args: VolumeArgs) =
                args.VolumePath <- io volumePath
                args

            ()
            name, List.Cons(apply, args)

    let volume = VolumeBuilder()

module Network =
    open Pulumi.Azure.Network
    open Pulumi.Azure.Network.Inputs

    type ApplicationGatewayAuthenticationCertificateBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApplicationGatewayAuthenticationCertificateArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("data")>]
        member _.Data((n, args), data) =
            let apply (args: ApplicationGatewayAuthenticationCertificateArgs) =
                args.Data <- input data
                args

            ()
            n, List.Cons(apply, args)

        member _.Data((n, args), data) =
            let apply (args: ApplicationGatewayAuthenticationCertificateArgs) =
                args.Data <- io data
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewayAuthenticationCertificateArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewayAuthenticationCertificateArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewayAuthenticationCertificateArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewayAuthenticationCertificateArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

    let applicationGatewayAuthenticationCertificate =
        ApplicationGatewayAuthenticationCertificateBuilder()

    type ApplicationGatewayAutoscaleConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApplicationGatewayAutoscaleConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("maxCapacity")>]
        member _.MaxCapacity((n, args), maxCapacity) =
            let apply (args: ApplicationGatewayAutoscaleConfigurationArgs) =
                args.MaxCapacity <- input maxCapacity
                args

            ()
            n, List.Cons(apply, args)

        member _.MaxCapacity((n, args), maxCapacity) =
            let apply (args: ApplicationGatewayAutoscaleConfigurationArgs) =
                args.MaxCapacity <- io maxCapacity
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("minCapacity")>]
        member _.MinCapacity((n, args), minCapacity) =
            let apply (args: ApplicationGatewayAutoscaleConfigurationArgs) =
                args.MinCapacity <- input minCapacity
                args

            ()
            n, List.Cons(apply, args)

        member _.MinCapacity((n, args), minCapacity) =
            let apply (args: ApplicationGatewayAutoscaleConfigurationArgs) =
                args.MinCapacity <- io minCapacity
                args

            ()
            n, List.Cons(apply, args)

    let applicationGatewayAutoscaleConfiguration =
        ApplicationGatewayAutoscaleConfigurationBuilder()

    type ApplicationGatewayBackendAddressPoolBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApplicationGatewayBackendAddressPoolArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("fqdns")>]
        member _.Fqdns((n, args), fqdns) =
            let apply (args: ApplicationGatewayBackendAddressPoolArgs) =
                args.Fqdns <- inputList fqdns
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewayBackendAddressPoolArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewayBackendAddressPoolArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ipAddresses")>]
        member _.IpAddresses((n, args), ipAddresses) =
            let apply (args: ApplicationGatewayBackendAddressPoolArgs) =
                args.IpAddresses <- inputList ipAddresses
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewayBackendAddressPoolArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewayBackendAddressPoolArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

    let applicationGatewayBackendAddressPool =
        ApplicationGatewayBackendAddressPoolBuilder()

    type ApplicationGatewayBackendHttpSettingBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApplicationGatewayBackendHttpSettingArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("affinityCookieName")>]
        member _.AffinityCookieName((n, args), affinityCookieName) =
            let apply (args: ApplicationGatewayBackendHttpSettingArgs) =
                args.AffinityCookieName <- input affinityCookieName
                args

            ()
            n, List.Cons(apply, args)

        member _.AffinityCookieName((n, args), affinityCookieName) =
            let apply (args: ApplicationGatewayBackendHttpSettingArgs) =
                args.AffinityCookieName <- io affinityCookieName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("authenticationCertificates")>]
        member _.AuthenticationCertificates((n, args), authenticationCertificates) =
            let apply (args: ApplicationGatewayBackendHttpSettingArgs) =
                args.AuthenticationCertificates <- inputList authenticationCertificates
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ApplicationGatewayBackendHttpSettingArgs) =
                   args.ConnectionDraining <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("cookieBasedAffinity")>]
        member _.CookieBasedAffinity((n, args), cookieBasedAffinity) =
            let apply (args: ApplicationGatewayBackendHttpSettingArgs) =
                args.CookieBasedAffinity <- input cookieBasedAffinity
                args

            ()
            n, List.Cons(apply, args)

        member _.CookieBasedAffinity((n, args), cookieBasedAffinity) =
            let apply (args: ApplicationGatewayBackendHttpSettingArgs) =
                args.CookieBasedAffinity <- io cookieBasedAffinity
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("hostName")>]
        member _.HostName((n, args), hostName) =
            let apply (args: ApplicationGatewayBackendHttpSettingArgs) =
                args.HostName <- input hostName
                args

            ()
            n, List.Cons(apply, args)

        member _.HostName((n, args), hostName) =
            let apply (args: ApplicationGatewayBackendHttpSettingArgs) =
                args.HostName <- io hostName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewayBackendHttpSettingArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewayBackendHttpSettingArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewayBackendHttpSettingArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewayBackendHttpSettingArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("path")>]
        member _.Path((n, args), path) =
            let apply (args: ApplicationGatewayBackendHttpSettingArgs) =
                args.Path <- input path
                args

            ()
            n, List.Cons(apply, args)

        member _.Path((n, args), path) =
            let apply (args: ApplicationGatewayBackendHttpSettingArgs) =
                args.Path <- io path
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("pickHostNameFromBackendAddress")>]
        member _.PickHostNameFromBackendAddress((n, args), pickHostNameFromBackendAddress) =
            let apply (args: ApplicationGatewayBackendHttpSettingArgs) =
                args.PickHostNameFromBackendAddress <- input pickHostNameFromBackendAddress
                args

            ()
            n, List.Cons(apply, args)

        member _.PickHostNameFromBackendAddress((n, args), pickHostNameFromBackendAddress) =
            let apply (args: ApplicationGatewayBackendHttpSettingArgs) =
                args.PickHostNameFromBackendAddress <- io pickHostNameFromBackendAddress
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("port")>]
        member _.Port((n, args), port) =
            let apply (args: ApplicationGatewayBackendHttpSettingArgs) =
                args.Port <- input port
                args

            ()
            n, List.Cons(apply, args)

        member _.Port((n, args), port) =
            let apply (args: ApplicationGatewayBackendHttpSettingArgs) =
                args.Port <- io port
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("probeId")>]
        member _.ProbeId((n, args), probeId) =
            let apply (args: ApplicationGatewayBackendHttpSettingArgs) =
                args.ProbeId <- input probeId
                args

            ()
            n, List.Cons(apply, args)

        member _.ProbeId((n, args), probeId) =
            let apply (args: ApplicationGatewayBackendHttpSettingArgs) =
                args.ProbeId <- io probeId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("probeName")>]
        member _.ProbeName((n, args), probeName) =
            let apply (args: ApplicationGatewayBackendHttpSettingArgs) =
                args.ProbeName <- input probeName
                args

            ()
            n, List.Cons(apply, args)

        member _.ProbeName((n, args), probeName) =
            let apply (args: ApplicationGatewayBackendHttpSettingArgs) =
                args.ProbeName <- io probeName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("protocol")>]
        member _.Protocol((n, args), protocol) =
            let apply (args: ApplicationGatewayBackendHttpSettingArgs) =
                args.Protocol <- input protocol
                args

            ()
            n, List.Cons(apply, args)

        member _.Protocol((n, args), protocol) =
            let apply (args: ApplicationGatewayBackendHttpSettingArgs) =
                args.Protocol <- io protocol
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("requestTimeout")>]
        member _.RequestTimeout((n, args), requestTimeout) =
            let apply (args: ApplicationGatewayBackendHttpSettingArgs) =
                args.RequestTimeout <- input requestTimeout
                args

            ()
            n, List.Cons(apply, args)

        member _.RequestTimeout((n, args), requestTimeout) =
            let apply (args: ApplicationGatewayBackendHttpSettingArgs) =
                args.RequestTimeout <- io requestTimeout
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("trustedRootCertificateNames")>]
        member _.TrustedRootCertificateNames((n, args), trustedRootCertificateNames) =
            let apply (args: ApplicationGatewayBackendHttpSettingArgs) =
                args.TrustedRootCertificateNames <- inputList trustedRootCertificateNames
                args

            ()
            n, List.Cons(apply, args)

    let applicationGatewayBackendHttpSetting =
        ApplicationGatewayBackendHttpSettingBuilder()

    type ApplicationGatewayBackendHttpSettingAuthenticationCertificateBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApplicationGatewayBackendHttpSettingAuthenticationCertificateArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewayBackendHttpSettingAuthenticationCertificateArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewayBackendHttpSettingAuthenticationCertificateArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewayBackendHttpSettingAuthenticationCertificateArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewayBackendHttpSettingAuthenticationCertificateArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

    let applicationGatewayBackendHttpSettingAuthenticationCertificate =
        ApplicationGatewayBackendHttpSettingAuthenticationCertificateBuilder()

    type ApplicationGatewayBackendHttpSettingConnectionDrainingBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApplicationGatewayBackendHttpSettingConnectionDrainingArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("drainTimeoutSec")>]
        member _.DrainTimeoutSec((n, args), drainTimeoutSec) =
            let apply (args: ApplicationGatewayBackendHttpSettingConnectionDrainingArgs) =
                args.DrainTimeoutSec <- input drainTimeoutSec
                args

            ()
            n, List.Cons(apply, args)

        member _.DrainTimeoutSec((n, args), drainTimeoutSec) =
            let apply (args: ApplicationGatewayBackendHttpSettingConnectionDrainingArgs) =
                args.DrainTimeoutSec <- io drainTimeoutSec
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: ApplicationGatewayBackendHttpSettingConnectionDrainingArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: ApplicationGatewayBackendHttpSettingConnectionDrainingArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

    let applicationGatewayBackendHttpSettingConnectionDraining =
        ApplicationGatewayBackendHttpSettingConnectionDrainingBuilder()

    type ApplicationGatewayCustomErrorConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApplicationGatewayCustomErrorConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("customErrorPageUrl")>]
        member _.CustomErrorPageUrl((n, args), customErrorPageUrl) =
            let apply (args: ApplicationGatewayCustomErrorConfigurationArgs) =
                args.CustomErrorPageUrl <- input customErrorPageUrl
                args

            ()
            n, List.Cons(apply, args)

        member _.CustomErrorPageUrl((n, args), customErrorPageUrl) =
            let apply (args: ApplicationGatewayCustomErrorConfigurationArgs) =
                args.CustomErrorPageUrl <- io customErrorPageUrl
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewayCustomErrorConfigurationArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewayCustomErrorConfigurationArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("statusCode")>]
        member _.StatusCode((n, args), statusCode) =
            let apply (args: ApplicationGatewayCustomErrorConfigurationArgs) =
                args.StatusCode <- input statusCode
                args

            ()
            n, List.Cons(apply, args)

        member _.StatusCode((n, args), statusCode) =
            let apply (args: ApplicationGatewayCustomErrorConfigurationArgs) =
                args.StatusCode <- io statusCode
                args

            ()
            n, List.Cons(apply, args)

    let applicationGatewayCustomErrorConfiguration =
        ApplicationGatewayCustomErrorConfigurationBuilder()

    type ApplicationGatewayFrontendIpConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApplicationGatewayFrontendIpConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewayFrontendIpConfigurationArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewayFrontendIpConfigurationArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewayFrontendIpConfigurationArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewayFrontendIpConfigurationArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("privateIpAddress")>]
        member _.PrivateIpAddress((n, args), privateIpAddress) =
            let apply (args: ApplicationGatewayFrontendIpConfigurationArgs) =
                args.PrivateIpAddress <- input privateIpAddress
                args

            ()
            n, List.Cons(apply, args)

        member _.PrivateIpAddress((n, args), privateIpAddress) =
            let apply (args: ApplicationGatewayFrontendIpConfigurationArgs) =
                args.PrivateIpAddress <- io privateIpAddress
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("privateIpAddressAllocation")>]
        member _.PrivateIpAddressAllocation((n, args), privateIpAddressAllocation) =
            let apply (args: ApplicationGatewayFrontendIpConfigurationArgs) =
                args.PrivateIpAddressAllocation <- input privateIpAddressAllocation
                args

            ()
            n, List.Cons(apply, args)

        member _.PrivateIpAddressAllocation((n, args), privateIpAddressAllocation) =
            let apply (args: ApplicationGatewayFrontendIpConfigurationArgs) =
                args.PrivateIpAddressAllocation <- io privateIpAddressAllocation
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publicIpAddressId")>]
        member _.PublicIpAddressId((n, args), publicIpAddressId) =
            let apply (args: ApplicationGatewayFrontendIpConfigurationArgs) =
                args.PublicIpAddressId <- input publicIpAddressId
                args

            ()
            n, List.Cons(apply, args)

        member _.PublicIpAddressId((n, args), publicIpAddressId) =
            let apply (args: ApplicationGatewayFrontendIpConfigurationArgs) =
                args.PublicIpAddressId <- io publicIpAddressId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: ApplicationGatewayFrontendIpConfigurationArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: ApplicationGatewayFrontendIpConfigurationArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

    let applicationGatewayFrontendIpConfiguration =
        ApplicationGatewayFrontendIpConfigurationBuilder()

    type ApplicationGatewayFrontendPortBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApplicationGatewayFrontendPortArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewayFrontendPortArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewayFrontendPortArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewayFrontendPortArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewayFrontendPortArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("port")>]
        member _.Port((n, args), port) =
            let apply (args: ApplicationGatewayFrontendPortArgs) =
                args.Port <- input port
                args

            ()
            n, List.Cons(apply, args)

        member _.Port((n, args), port) =
            let apply (args: ApplicationGatewayFrontendPortArgs) =
                args.Port <- io port
                args

            ()
            n, List.Cons(apply, args)

    let applicationGatewayFrontendPort = ApplicationGatewayFrontendPortBuilder()

    type ApplicationGatewayGatewayIpConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApplicationGatewayGatewayIpConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewayGatewayIpConfigurationArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewayGatewayIpConfigurationArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewayGatewayIpConfigurationArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewayGatewayIpConfigurationArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: ApplicationGatewayGatewayIpConfigurationArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: ApplicationGatewayGatewayIpConfigurationArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

    let applicationGatewayGatewayIpConfiguration =
        ApplicationGatewayGatewayIpConfigurationBuilder()

    type ApplicationGatewayHttpListenerBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApplicationGatewayHttpListenerArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("customErrorConfigurations")>]
        member _.CustomErrorConfigurations((n, args), customErrorConfigurations) =
            let apply (args: ApplicationGatewayHttpListenerArgs) =
                args.CustomErrorConfigurations <- inputList customErrorConfigurations
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("frontendIpConfigurationId")>]
        member _.FrontendIpConfigurationId((n, args), frontendIpConfigurationId) =
            let apply (args: ApplicationGatewayHttpListenerArgs) =
                args.FrontendIpConfigurationId <- input frontendIpConfigurationId
                args

            ()
            n, List.Cons(apply, args)

        member _.FrontendIpConfigurationId((n, args), frontendIpConfigurationId) =
            let apply (args: ApplicationGatewayHttpListenerArgs) =
                args.FrontendIpConfigurationId <- io frontendIpConfigurationId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("frontendIpConfigurationName")>]
        member _.FrontendIpConfigurationName((n, args), frontendIpConfigurationName) =
            let apply (args: ApplicationGatewayHttpListenerArgs) =
                args.FrontendIpConfigurationName <- input frontendIpConfigurationName
                args

            ()
            n, List.Cons(apply, args)

        member _.FrontendIpConfigurationName((n, args), frontendIpConfigurationName) =
            let apply (args: ApplicationGatewayHttpListenerArgs) =
                args.FrontendIpConfigurationName <- io frontendIpConfigurationName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("frontendPortId")>]
        member _.FrontendPortId((n, args), frontendPortId) =
            let apply (args: ApplicationGatewayHttpListenerArgs) =
                args.FrontendPortId <- input frontendPortId
                args

            ()
            n, List.Cons(apply, args)

        member _.FrontendPortId((n, args), frontendPortId) =
            let apply (args: ApplicationGatewayHttpListenerArgs) =
                args.FrontendPortId <- io frontendPortId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("frontendPortName")>]
        member _.FrontendPortName((n, args), frontendPortName) =
            let apply (args: ApplicationGatewayHttpListenerArgs) =
                args.FrontendPortName <- input frontendPortName
                args

            ()
            n, List.Cons(apply, args)

        member _.FrontendPortName((n, args), frontendPortName) =
            let apply (args: ApplicationGatewayHttpListenerArgs) =
                args.FrontendPortName <- io frontendPortName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("hostName")>]
        member _.HostName((n, args), hostName) =
            let apply (args: ApplicationGatewayHttpListenerArgs) =
                args.HostName <- input hostName
                args

            ()
            n, List.Cons(apply, args)

        member _.HostName((n, args), hostName) =
            let apply (args: ApplicationGatewayHttpListenerArgs) =
                args.HostName <- io hostName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("hostNames")>]
        member _.HostNames((n, args), hostNames) =
            let apply (args: ApplicationGatewayHttpListenerArgs) =
                args.HostNames <- inputList hostNames
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewayHttpListenerArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewayHttpListenerArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewayHttpListenerArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewayHttpListenerArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("protocol")>]
        member _.Protocol((n, args), protocol) =
            let apply (args: ApplicationGatewayHttpListenerArgs) =
                args.Protocol <- input protocol
                args

            ()
            n, List.Cons(apply, args)

        member _.Protocol((n, args), protocol) =
            let apply (args: ApplicationGatewayHttpListenerArgs) =
                args.Protocol <- io protocol
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("requireSni")>]
        member _.RequireSni((n, args), requireSni) =
            let apply (args: ApplicationGatewayHttpListenerArgs) =
                args.RequireSni <- input requireSni
                args

            ()
            n, List.Cons(apply, args)

        member _.RequireSni((n, args), requireSni) =
            let apply (args: ApplicationGatewayHttpListenerArgs) =
                args.RequireSni <- io requireSni
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sslCertificateId")>]
        member _.SslCertificateId((n, args), sslCertificateId) =
            let apply (args: ApplicationGatewayHttpListenerArgs) =
                args.SslCertificateId <- input sslCertificateId
                args

            ()
            n, List.Cons(apply, args)

        member _.SslCertificateId((n, args), sslCertificateId) =
            let apply (args: ApplicationGatewayHttpListenerArgs) =
                args.SslCertificateId <- io sslCertificateId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sslCertificateName")>]
        member _.SslCertificateName((n, args), sslCertificateName) =
            let apply (args: ApplicationGatewayHttpListenerArgs) =
                args.SslCertificateName <- input sslCertificateName
                args

            ()
            n, List.Cons(apply, args)

        member _.SslCertificateName((n, args), sslCertificateName) =
            let apply (args: ApplicationGatewayHttpListenerArgs) =
                args.SslCertificateName <- io sslCertificateName
                args

            ()
            n, List.Cons(apply, args)

    let applicationGatewayHttpListener = ApplicationGatewayHttpListenerBuilder()

    type ApplicationGatewayHttpListenerCustomErrorConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApplicationGatewayHttpListenerCustomErrorConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("customErrorPageUrl")>]
        member _.CustomErrorPageUrl((n, args), customErrorPageUrl) =
            let apply (args: ApplicationGatewayHttpListenerCustomErrorConfigurationArgs) =
                args.CustomErrorPageUrl <- input customErrorPageUrl
                args

            ()
            n, List.Cons(apply, args)

        member _.CustomErrorPageUrl((n, args), customErrorPageUrl) =
            let apply (args: ApplicationGatewayHttpListenerCustomErrorConfigurationArgs) =
                args.CustomErrorPageUrl <- io customErrorPageUrl
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewayHttpListenerCustomErrorConfigurationArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewayHttpListenerCustomErrorConfigurationArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("statusCode")>]
        member _.StatusCode((n, args), statusCode) =
            let apply (args: ApplicationGatewayHttpListenerCustomErrorConfigurationArgs) =
                args.StatusCode <- input statusCode
                args

            ()
            n, List.Cons(apply, args)

        member _.StatusCode((n, args), statusCode) =
            let apply (args: ApplicationGatewayHttpListenerCustomErrorConfigurationArgs) =
                args.StatusCode <- io statusCode
                args

            ()
            n, List.Cons(apply, args)

    let applicationGatewayHttpListenerCustomErrorConfiguration =
        ApplicationGatewayHttpListenerCustomErrorConfigurationBuilder()

    type ApplicationGatewayIdentityBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApplicationGatewayIdentityArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("identityIds")>]
        member _.IdentityIds((n, args), identityIds) =
            let apply (args: ApplicationGatewayIdentityArgs) =
                args.IdentityIds <- input identityIds
                args

            ()
            n, List.Cons(apply, args)

        member _.IdentityIds((n, args), identityIds) =
            let apply (args: ApplicationGatewayIdentityArgs) =
                args.IdentityIds <- io identityIds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: ApplicationGatewayIdentityArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: ApplicationGatewayIdentityArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let applicationGatewayIdentity = ApplicationGatewayIdentityBuilder()

    type ApplicationGatewayProbeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApplicationGatewayProbeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("host")>]
        member _.Host((n, args), host) =
            let apply (args: ApplicationGatewayProbeArgs) =
                args.Host <- input host
                args

            ()
            n, List.Cons(apply, args)

        member _.Host((n, args), host) =
            let apply (args: ApplicationGatewayProbeArgs) =
                args.Host <- io host
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewayProbeArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewayProbeArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("interval")>]
        member _.Interval((n, args), interval) =
            let apply (args: ApplicationGatewayProbeArgs) =
                args.Interval <- input interval
                args

            ()
            n, List.Cons(apply, args)

        member _.Interval((n, args), interval) =
            let apply (args: ApplicationGatewayProbeArgs) =
                args.Interval <- io interval
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ApplicationGatewayProbeArgs) =
                   args.Match <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("minimumServers")>]
        member _.MinimumServers((n, args), minimumServers) =
            let apply (args: ApplicationGatewayProbeArgs) =
                args.MinimumServers <- input minimumServers
                args

            ()
            n, List.Cons(apply, args)

        member _.MinimumServers((n, args), minimumServers) =
            let apply (args: ApplicationGatewayProbeArgs) =
                args.MinimumServers <- io minimumServers
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewayProbeArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewayProbeArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("path")>]
        member _.Path((n, args), path) =
            let apply (args: ApplicationGatewayProbeArgs) =
                args.Path <- input path
                args

            ()
            n, List.Cons(apply, args)

        member _.Path((n, args), path) =
            let apply (args: ApplicationGatewayProbeArgs) =
                args.Path <- io path
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("pickHostNameFromBackendHttpSettings")>]
        member _.PickHostNameFromBackendHttpSettings((n, args), pickHostNameFromBackendHttpSettings) =
            let apply (args: ApplicationGatewayProbeArgs) =
                args.PickHostNameFromBackendHttpSettings <- input pickHostNameFromBackendHttpSettings
                args

            ()
            n, List.Cons(apply, args)

        member _.PickHostNameFromBackendHttpSettings((n, args), pickHostNameFromBackendHttpSettings) =
            let apply (args: ApplicationGatewayProbeArgs) =
                args.PickHostNameFromBackendHttpSettings <- io pickHostNameFromBackendHttpSettings
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("protocol")>]
        member _.Protocol((n, args), protocol) =
            let apply (args: ApplicationGatewayProbeArgs) =
                args.Protocol <- input protocol
                args

            ()
            n, List.Cons(apply, args)

        member _.Protocol((n, args), protocol) =
            let apply (args: ApplicationGatewayProbeArgs) =
                args.Protocol <- io protocol
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("timeout")>]
        member _.Timeout((n, args), timeout) =
            let apply (args: ApplicationGatewayProbeArgs) =
                args.Timeout <- input timeout
                args

            ()
            n, List.Cons(apply, args)

        member _.Timeout((n, args), timeout) =
            let apply (args: ApplicationGatewayProbeArgs) =
                args.Timeout <- io timeout
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("unhealthyThreshold")>]
        member _.UnhealthyThreshold((n, args), unhealthyThreshold) =
            let apply (args: ApplicationGatewayProbeArgs) =
                args.UnhealthyThreshold <- input unhealthyThreshold
                args

            ()
            n, List.Cons(apply, args)

        member _.UnhealthyThreshold((n, args), unhealthyThreshold) =
            let apply (args: ApplicationGatewayProbeArgs) =
                args.UnhealthyThreshold <- io unhealthyThreshold
                args

            ()
            n, List.Cons(apply, args)

    let applicationGatewayProbe = ApplicationGatewayProbeBuilder()

    type ApplicationGatewayProbeMatchBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApplicationGatewayProbeMatchArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("body")>]
        member _.Body((n, args), body) =
            let apply (args: ApplicationGatewayProbeMatchArgs) =
                args.Body <- input body
                args

            ()
            n, List.Cons(apply, args)

        member _.Body((n, args), body) =
            let apply (args: ApplicationGatewayProbeMatchArgs) =
                args.Body <- io body
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("statusCodes")>]
        member _.StatusCodes((n, args), statusCodes) =
            let apply (args: ApplicationGatewayProbeMatchArgs) =
                args.StatusCodes <- inputList statusCodes
                args

            ()
            n, List.Cons(apply, args)

    let applicationGatewayProbeMatch = ApplicationGatewayProbeMatchBuilder()

    type ApplicationGatewayRedirectConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApplicationGatewayRedirectConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewayRedirectConfigurationArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewayRedirectConfigurationArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("includePath")>]
        member _.IncludePath((n, args), includePath) =
            let apply (args: ApplicationGatewayRedirectConfigurationArgs) =
                args.IncludePath <- input includePath
                args

            ()
            n, List.Cons(apply, args)

        member _.IncludePath((n, args), includePath) =
            let apply (args: ApplicationGatewayRedirectConfigurationArgs) =
                args.IncludePath <- io includePath
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("includeQueryString")>]
        member _.IncludeQueryString((n, args), includeQueryString) =
            let apply (args: ApplicationGatewayRedirectConfigurationArgs) =
                args.IncludeQueryString <- input includeQueryString
                args

            ()
            n, List.Cons(apply, args)

        member _.IncludeQueryString((n, args), includeQueryString) =
            let apply (args: ApplicationGatewayRedirectConfigurationArgs) =
                args.IncludeQueryString <- io includeQueryString
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewayRedirectConfigurationArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewayRedirectConfigurationArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("redirectType")>]
        member _.RedirectType((n, args), redirectType) =
            let apply (args: ApplicationGatewayRedirectConfigurationArgs) =
                args.RedirectType <- input redirectType
                args

            ()
            n, List.Cons(apply, args)

        member _.RedirectType((n, args), redirectType) =
            let apply (args: ApplicationGatewayRedirectConfigurationArgs) =
                args.RedirectType <- io redirectType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("targetListenerId")>]
        member _.TargetListenerId((n, args), targetListenerId) =
            let apply (args: ApplicationGatewayRedirectConfigurationArgs) =
                args.TargetListenerId <- input targetListenerId
                args

            ()
            n, List.Cons(apply, args)

        member _.TargetListenerId((n, args), targetListenerId) =
            let apply (args: ApplicationGatewayRedirectConfigurationArgs) =
                args.TargetListenerId <- io targetListenerId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("targetListenerName")>]
        member _.TargetListenerName((n, args), targetListenerName) =
            let apply (args: ApplicationGatewayRedirectConfigurationArgs) =
                args.TargetListenerName <- input targetListenerName
                args

            ()
            n, List.Cons(apply, args)

        member _.TargetListenerName((n, args), targetListenerName) =
            let apply (args: ApplicationGatewayRedirectConfigurationArgs) =
                args.TargetListenerName <- io targetListenerName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("targetUrl")>]
        member _.TargetUrl((n, args), targetUrl) =
            let apply (args: ApplicationGatewayRedirectConfigurationArgs) =
                args.TargetUrl <- input targetUrl
                args

            ()
            n, List.Cons(apply, args)

        member _.TargetUrl((n, args), targetUrl) =
            let apply (args: ApplicationGatewayRedirectConfigurationArgs) =
                args.TargetUrl <- io targetUrl
                args

            ()
            n, List.Cons(apply, args)

    let applicationGatewayRedirectConfiguration =
        ApplicationGatewayRedirectConfigurationBuilder()

    type ApplicationGatewayRequestRoutingRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApplicationGatewayRequestRoutingRuleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("backendAddressPoolId")>]
        member _.BackendAddressPoolId((n, args), backendAddressPoolId) =
            let apply (args: ApplicationGatewayRequestRoutingRuleArgs) =
                args.BackendAddressPoolId <- input backendAddressPoolId
                args

            ()
            n, List.Cons(apply, args)

        member _.BackendAddressPoolId((n, args), backendAddressPoolId) =
            let apply (args: ApplicationGatewayRequestRoutingRuleArgs) =
                args.BackendAddressPoolId <- io backendAddressPoolId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("backendAddressPoolName")>]
        member _.BackendAddressPoolName((n, args), backendAddressPoolName) =
            let apply (args: ApplicationGatewayRequestRoutingRuleArgs) =
                args.BackendAddressPoolName <- input backendAddressPoolName
                args

            ()
            n, List.Cons(apply, args)

        member _.BackendAddressPoolName((n, args), backendAddressPoolName) =
            let apply (args: ApplicationGatewayRequestRoutingRuleArgs) =
                args.BackendAddressPoolName <- io backendAddressPoolName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("backendHttpSettingsId")>]
        member _.BackendHttpSettingsId((n, args), backendHttpSettingsId) =
            let apply (args: ApplicationGatewayRequestRoutingRuleArgs) =
                args.BackendHttpSettingsId <- input backendHttpSettingsId
                args

            ()
            n, List.Cons(apply, args)

        member _.BackendHttpSettingsId((n, args), backendHttpSettingsId) =
            let apply (args: ApplicationGatewayRequestRoutingRuleArgs) =
                args.BackendHttpSettingsId <- io backendHttpSettingsId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("backendHttpSettingsName")>]
        member _.BackendHttpSettingsName((n, args), backendHttpSettingsName) =
            let apply (args: ApplicationGatewayRequestRoutingRuleArgs) =
                args.BackendHttpSettingsName <- input backendHttpSettingsName
                args

            ()
            n, List.Cons(apply, args)

        member _.BackendHttpSettingsName((n, args), backendHttpSettingsName) =
            let apply (args: ApplicationGatewayRequestRoutingRuleArgs) =
                args.BackendHttpSettingsName <- io backendHttpSettingsName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("httpListenerId")>]
        member _.HttpListenerId((n, args), httpListenerId) =
            let apply (args: ApplicationGatewayRequestRoutingRuleArgs) =
                args.HttpListenerId <- input httpListenerId
                args

            ()
            n, List.Cons(apply, args)

        member _.HttpListenerId((n, args), httpListenerId) =
            let apply (args: ApplicationGatewayRequestRoutingRuleArgs) =
                args.HttpListenerId <- io httpListenerId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("httpListenerName")>]
        member _.HttpListenerName((n, args), httpListenerName) =
            let apply (args: ApplicationGatewayRequestRoutingRuleArgs) =
                args.HttpListenerName <- input httpListenerName
                args

            ()
            n, List.Cons(apply, args)

        member _.HttpListenerName((n, args), httpListenerName) =
            let apply (args: ApplicationGatewayRequestRoutingRuleArgs) =
                args.HttpListenerName <- io httpListenerName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewayRequestRoutingRuleArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewayRequestRoutingRuleArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewayRequestRoutingRuleArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewayRequestRoutingRuleArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("redirectConfigurationId")>]
        member _.RedirectConfigurationId((n, args), redirectConfigurationId) =
            let apply (args: ApplicationGatewayRequestRoutingRuleArgs) =
                args.RedirectConfigurationId <- input redirectConfigurationId
                args

            ()
            n, List.Cons(apply, args)

        member _.RedirectConfigurationId((n, args), redirectConfigurationId) =
            let apply (args: ApplicationGatewayRequestRoutingRuleArgs) =
                args.RedirectConfigurationId <- io redirectConfigurationId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("redirectConfigurationName")>]
        member _.RedirectConfigurationName((n, args), redirectConfigurationName) =
            let apply (args: ApplicationGatewayRequestRoutingRuleArgs) =
                args.RedirectConfigurationName <- input redirectConfigurationName
                args

            ()
            n, List.Cons(apply, args)

        member _.RedirectConfigurationName((n, args), redirectConfigurationName) =
            let apply (args: ApplicationGatewayRequestRoutingRuleArgs) =
                args.RedirectConfigurationName <- io redirectConfigurationName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("rewriteRuleSetId")>]
        member _.RewriteRuleSetId((n, args), rewriteRuleSetId) =
            let apply (args: ApplicationGatewayRequestRoutingRuleArgs) =
                args.RewriteRuleSetId <- input rewriteRuleSetId
                args

            ()
            n, List.Cons(apply, args)

        member _.RewriteRuleSetId((n, args), rewriteRuleSetId) =
            let apply (args: ApplicationGatewayRequestRoutingRuleArgs) =
                args.RewriteRuleSetId <- io rewriteRuleSetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("rewriteRuleSetName")>]
        member _.RewriteRuleSetName((n, args), rewriteRuleSetName) =
            let apply (args: ApplicationGatewayRequestRoutingRuleArgs) =
                args.RewriteRuleSetName <- input rewriteRuleSetName
                args

            ()
            n, List.Cons(apply, args)

        member _.RewriteRuleSetName((n, args), rewriteRuleSetName) =
            let apply (args: ApplicationGatewayRequestRoutingRuleArgs) =
                args.RewriteRuleSetName <- io rewriteRuleSetName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ruleType")>]
        member _.RuleType((n, args), ruleType) =
            let apply (args: ApplicationGatewayRequestRoutingRuleArgs) =
                args.RuleType <- input ruleType
                args

            ()
            n, List.Cons(apply, args)

        member _.RuleType((n, args), ruleType) =
            let apply (args: ApplicationGatewayRequestRoutingRuleArgs) =
                args.RuleType <- io ruleType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("urlPathMapId")>]
        member _.UrlPathMapId((n, args), urlPathMapId) =
            let apply (args: ApplicationGatewayRequestRoutingRuleArgs) =
                args.UrlPathMapId <- input urlPathMapId
                args

            ()
            n, List.Cons(apply, args)

        member _.UrlPathMapId((n, args), urlPathMapId) =
            let apply (args: ApplicationGatewayRequestRoutingRuleArgs) =
                args.UrlPathMapId <- io urlPathMapId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("urlPathMapName")>]
        member _.UrlPathMapName((n, args), urlPathMapName) =
            let apply (args: ApplicationGatewayRequestRoutingRuleArgs) =
                args.UrlPathMapName <- input urlPathMapName
                args

            ()
            n, List.Cons(apply, args)

        member _.UrlPathMapName((n, args), urlPathMapName) =
            let apply (args: ApplicationGatewayRequestRoutingRuleArgs) =
                args.UrlPathMapName <- io urlPathMapName
                args

            ()
            n, List.Cons(apply, args)

    let applicationGatewayRequestRoutingRule =
        ApplicationGatewayRequestRoutingRuleBuilder()

    type ApplicationGatewayRewriteRuleSetBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApplicationGatewayRewriteRuleSetArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewayRewriteRuleSetArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewayRewriteRuleSetArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewayRewriteRuleSetArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewayRewriteRuleSetArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("rewriteRules")>]
        member _.RewriteRules((n, args), rewriteRules) =
            let apply (args: ApplicationGatewayRewriteRuleSetArgs) =
                args.RewriteRules <- inputList rewriteRules
                args

            ()
            n, List.Cons(apply, args)

    let applicationGatewayRewriteRuleSet =
        ApplicationGatewayRewriteRuleSetBuilder()

    type ApplicationGatewayRewriteRuleSetRewriteRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApplicationGatewayRewriteRuleSetRewriteRuleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("conditions")>]
        member _.Conditions((n, args), conditions) =
            let apply (args: ApplicationGatewayRewriteRuleSetRewriteRuleArgs) =
                args.Conditions <- inputList conditions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewayRewriteRuleSetRewriteRuleArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewayRewriteRuleSetRewriteRuleArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("requestHeaderConfigurations")>]
        member _.RequestHeaderConfigurations((n, args), requestHeaderConfigurations) =
            let apply (args: ApplicationGatewayRewriteRuleSetRewriteRuleArgs) =
                args.RequestHeaderConfigurations <- inputList requestHeaderConfigurations
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("responseHeaderConfigurations")>]
        member _.ResponseHeaderConfigurations((n, args), responseHeaderConfigurations) =
            let apply (args: ApplicationGatewayRewriteRuleSetRewriteRuleArgs) =
                args.ResponseHeaderConfigurations <- inputList responseHeaderConfigurations
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ruleSequence")>]
        member _.RuleSequence((n, args), ruleSequence) =
            let apply (args: ApplicationGatewayRewriteRuleSetRewriteRuleArgs) =
                args.RuleSequence <- input ruleSequence
                args

            ()
            n, List.Cons(apply, args)

        member _.RuleSequence((n, args), ruleSequence) =
            let apply (args: ApplicationGatewayRewriteRuleSetRewriteRuleArgs) =
                args.RuleSequence <- io ruleSequence
                args

            ()
            n, List.Cons(apply, args)

    let applicationGatewayRewriteRuleSetRewriteRule =
        ApplicationGatewayRewriteRuleSetRewriteRuleBuilder()

    type ApplicationGatewayRewriteRuleSetRewriteRuleConditionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApplicationGatewayRewriteRuleSetRewriteRuleConditionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("ignoreCase")>]
        member _.IgnoreCase((n, args), ignoreCase) =
            let apply (args: ApplicationGatewayRewriteRuleSetRewriteRuleConditionArgs) =
                args.IgnoreCase <- input ignoreCase
                args

            ()
            n, List.Cons(apply, args)

        member _.IgnoreCase((n, args), ignoreCase) =
            let apply (args: ApplicationGatewayRewriteRuleSetRewriteRuleConditionArgs) =
                args.IgnoreCase <- io ignoreCase
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("negate")>]
        member _.Negate((n, args), negate) =
            let apply (args: ApplicationGatewayRewriteRuleSetRewriteRuleConditionArgs) =
                args.Negate <- input negate
                args

            ()
            n, List.Cons(apply, args)

        member _.Negate((n, args), negate) =
            let apply (args: ApplicationGatewayRewriteRuleSetRewriteRuleConditionArgs) =
                args.Negate <- io negate
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("pattern")>]
        member _.Pattern((n, args), pattern) =
            let apply (args: ApplicationGatewayRewriteRuleSetRewriteRuleConditionArgs) =
                args.Pattern <- input pattern
                args

            ()
            n, List.Cons(apply, args)

        member _.Pattern((n, args), pattern) =
            let apply (args: ApplicationGatewayRewriteRuleSetRewriteRuleConditionArgs) =
                args.Pattern <- io pattern
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("variable")>]
        member _.Variable((n, args), variable) =
            let apply (args: ApplicationGatewayRewriteRuleSetRewriteRuleConditionArgs) =
                args.Variable <- input variable
                args

            ()
            n, List.Cons(apply, args)

        member _.Variable((n, args), variable) =
            let apply (args: ApplicationGatewayRewriteRuleSetRewriteRuleConditionArgs) =
                args.Variable <- io variable
                args

            ()
            n, List.Cons(apply, args)

    let applicationGatewayRewriteRuleSetRewriteRuleCondition =
        ApplicationGatewayRewriteRuleSetRewriteRuleConditionBuilder()

    type ApplicationGatewayRewriteRuleSetRewriteRuleRequestHeaderConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApplicationGatewayRewriteRuleSetRewriteRuleRequestHeaderConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("headerName")>]
        member _.HeaderName((n, args), headerName) =
            let apply (args: ApplicationGatewayRewriteRuleSetRewriteRuleRequestHeaderConfigurationArgs) =
                args.HeaderName <- input headerName
                args

            ()
            n, List.Cons(apply, args)

        member _.HeaderName((n, args), headerName) =
            let apply (args: ApplicationGatewayRewriteRuleSetRewriteRuleRequestHeaderConfigurationArgs) =
                args.HeaderName <- io headerName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("headerValue")>]
        member _.HeaderValue((n, args), headerValue) =
            let apply (args: ApplicationGatewayRewriteRuleSetRewriteRuleRequestHeaderConfigurationArgs) =
                args.HeaderValue <- input headerValue
                args

            ()
            n, List.Cons(apply, args)

        member _.HeaderValue((n, args), headerValue) =
            let apply (args: ApplicationGatewayRewriteRuleSetRewriteRuleRequestHeaderConfigurationArgs) =
                args.HeaderValue <- io headerValue
                args

            ()
            n, List.Cons(apply, args)

    let applicationGatewayRewriteRuleSetRewriteRuleRequestHeaderConfiguration =
        ApplicationGatewayRewriteRuleSetRewriteRuleRequestHeaderConfigurationBuilder()

    type ApplicationGatewayRewriteRuleSetRewriteRuleResponseHeaderConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApplicationGatewayRewriteRuleSetRewriteRuleResponseHeaderConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("headerName")>]
        member _.HeaderName((n, args), headerName) =
            let apply (args: ApplicationGatewayRewriteRuleSetRewriteRuleResponseHeaderConfigurationArgs) =
                args.HeaderName <- input headerName
                args

            ()
            n, List.Cons(apply, args)

        member _.HeaderName((n, args), headerName) =
            let apply (args: ApplicationGatewayRewriteRuleSetRewriteRuleResponseHeaderConfigurationArgs) =
                args.HeaderName <- io headerName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("headerValue")>]
        member _.HeaderValue((n, args), headerValue) =
            let apply (args: ApplicationGatewayRewriteRuleSetRewriteRuleResponseHeaderConfigurationArgs) =
                args.HeaderValue <- input headerValue
                args

            ()
            n, List.Cons(apply, args)

        member _.HeaderValue((n, args), headerValue) =
            let apply (args: ApplicationGatewayRewriteRuleSetRewriteRuleResponseHeaderConfigurationArgs) =
                args.HeaderValue <- io headerValue
                args

            ()
            n, List.Cons(apply, args)

    let applicationGatewayRewriteRuleSetRewriteRuleResponseHeaderConfiguration =
        ApplicationGatewayRewriteRuleSetRewriteRuleResponseHeaderConfigurationBuilder()

    type ApplicationGatewaySkuBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApplicationGatewaySkuArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("capacity")>]
        member _.Capacity((n, args), capacity) =
            let apply (args: ApplicationGatewaySkuArgs) =
                args.Capacity <- input capacity
                args

            ()
            n, List.Cons(apply, args)

        member _.Capacity((n, args), capacity) =
            let apply (args: ApplicationGatewaySkuArgs) =
                args.Capacity <- io capacity
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewaySkuArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewaySkuArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tier")>]
        member _.Tier((n, args), tier) =
            let apply (args: ApplicationGatewaySkuArgs) =
                args.Tier <- input tier
                args

            ()
            n, List.Cons(apply, args)

        member _.Tier((n, args), tier) =
            let apply (args: ApplicationGatewaySkuArgs) =
                args.Tier <- io tier
                args

            ()
            n, List.Cons(apply, args)

    let applicationGatewaySku = ApplicationGatewaySkuBuilder()

    type ApplicationGatewaySslCertificateBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApplicationGatewaySslCertificateArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("data")>]
        member _.Data((n, args), data) =
            let apply (args: ApplicationGatewaySslCertificateArgs) =
                args.Data <- input data
                args

            ()
            n, List.Cons(apply, args)

        member _.Data((n, args), data) =
            let apply (args: ApplicationGatewaySslCertificateArgs) =
                args.Data <- io data
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewaySslCertificateArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewaySslCertificateArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("keyVaultSecretId")>]
        member _.KeyVaultSecretId((n, args), keyVaultSecretId) =
            let apply (args: ApplicationGatewaySslCertificateArgs) =
                args.KeyVaultSecretId <- input keyVaultSecretId
                args

            ()
            n, List.Cons(apply, args)

        member _.KeyVaultSecretId((n, args), keyVaultSecretId) =
            let apply (args: ApplicationGatewaySslCertificateArgs) =
                args.KeyVaultSecretId <- io keyVaultSecretId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewaySslCertificateArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewaySslCertificateArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("password")>]
        member _.Password((n, args), password) =
            let apply (args: ApplicationGatewaySslCertificateArgs) =
                args.Password <- input password
                args

            ()
            n, List.Cons(apply, args)

        member _.Password((n, args), password) =
            let apply (args: ApplicationGatewaySslCertificateArgs) =
                args.Password <- io password
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publicCertData")>]
        member _.PublicCertData((n, args), publicCertData) =
            let apply (args: ApplicationGatewaySslCertificateArgs) =
                args.PublicCertData <- input publicCertData
                args

            ()
            n, List.Cons(apply, args)

        member _.PublicCertData((n, args), publicCertData) =
            let apply (args: ApplicationGatewaySslCertificateArgs) =
                args.PublicCertData <- io publicCertData
                args

            ()
            n, List.Cons(apply, args)

    let applicationGatewaySslCertificate =
        ApplicationGatewaySslCertificateBuilder()

    type ApplicationGatewaySslPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApplicationGatewaySslPolicyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("cipherSuites")>]
        member _.CipherSuites((n, args), cipherSuites) =
            let apply (args: ApplicationGatewaySslPolicyArgs) =
                args.CipherSuites <- inputList cipherSuites
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("disabledProtocols")>]
        member _.DisabledProtocols((n, args), disabledProtocols) =
            let apply (args: ApplicationGatewaySslPolicyArgs) =
                args.DisabledProtocols <- inputList disabledProtocols
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("minProtocolVersion")>]
        member _.MinProtocolVersion((n, args), minProtocolVersion) =
            let apply (args: ApplicationGatewaySslPolicyArgs) =
                args.MinProtocolVersion <- input minProtocolVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.MinProtocolVersion((n, args), minProtocolVersion) =
            let apply (args: ApplicationGatewaySslPolicyArgs) =
                args.MinProtocolVersion <- io minProtocolVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("policyName")>]
        member _.PolicyName((n, args), policyName) =
            let apply (args: ApplicationGatewaySslPolicyArgs) =
                args.PolicyName <- input policyName
                args

            ()
            n, List.Cons(apply, args)

        member _.PolicyName((n, args), policyName) =
            let apply (args: ApplicationGatewaySslPolicyArgs) =
                args.PolicyName <- io policyName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("policyType")>]
        member _.PolicyType((n, args), policyType) =
            let apply (args: ApplicationGatewaySslPolicyArgs) =
                args.PolicyType <- input policyType
                args

            ()
            n, List.Cons(apply, args)

        member _.PolicyType((n, args), policyType) =
            let apply (args: ApplicationGatewaySslPolicyArgs) =
                args.PolicyType <- io policyType
                args

            ()
            n, List.Cons(apply, args)

    let applicationGatewaySslPolicy = ApplicationGatewaySslPolicyBuilder()

    type ApplicationGatewayTrustedRootCertificateBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApplicationGatewayTrustedRootCertificateArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("data")>]
        member _.Data((n, args), data) =
            let apply (args: ApplicationGatewayTrustedRootCertificateArgs) =
                args.Data <- input data
                args

            ()
            n, List.Cons(apply, args)

        member _.Data((n, args), data) =
            let apply (args: ApplicationGatewayTrustedRootCertificateArgs) =
                args.Data <- io data
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewayTrustedRootCertificateArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewayTrustedRootCertificateArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewayTrustedRootCertificateArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewayTrustedRootCertificateArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

    let applicationGatewayTrustedRootCertificate =
        ApplicationGatewayTrustedRootCertificateBuilder()

    type ApplicationGatewayUrlPathMapBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApplicationGatewayUrlPathMapArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("defaultBackendAddressPoolId")>]
        member _.DefaultBackendAddressPoolId((n, args), defaultBackendAddressPoolId) =
            let apply (args: ApplicationGatewayUrlPathMapArgs) =
                args.DefaultBackendAddressPoolId <- input defaultBackendAddressPoolId
                args

            ()
            n, List.Cons(apply, args)

        member _.DefaultBackendAddressPoolId((n, args), defaultBackendAddressPoolId) =
            let apply (args: ApplicationGatewayUrlPathMapArgs) =
                args.DefaultBackendAddressPoolId <- io defaultBackendAddressPoolId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("defaultBackendAddressPoolName")>]
        member _.DefaultBackendAddressPoolName((n, args), defaultBackendAddressPoolName) =
            let apply (args: ApplicationGatewayUrlPathMapArgs) =
                args.DefaultBackendAddressPoolName <- input defaultBackendAddressPoolName
                args

            ()
            n, List.Cons(apply, args)

        member _.DefaultBackendAddressPoolName((n, args), defaultBackendAddressPoolName) =
            let apply (args: ApplicationGatewayUrlPathMapArgs) =
                args.DefaultBackendAddressPoolName <- io defaultBackendAddressPoolName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("defaultBackendHttpSettingsId")>]
        member _.DefaultBackendHttpSettingsId((n, args), defaultBackendHttpSettingsId) =
            let apply (args: ApplicationGatewayUrlPathMapArgs) =
                args.DefaultBackendHttpSettingsId <- input defaultBackendHttpSettingsId
                args

            ()
            n, List.Cons(apply, args)

        member _.DefaultBackendHttpSettingsId((n, args), defaultBackendHttpSettingsId) =
            let apply (args: ApplicationGatewayUrlPathMapArgs) =
                args.DefaultBackendHttpSettingsId <- io defaultBackendHttpSettingsId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("defaultBackendHttpSettingsName")>]
        member _.DefaultBackendHttpSettingsName((n, args), defaultBackendHttpSettingsName) =
            let apply (args: ApplicationGatewayUrlPathMapArgs) =
                args.DefaultBackendHttpSettingsName <- input defaultBackendHttpSettingsName
                args

            ()
            n, List.Cons(apply, args)

        member _.DefaultBackendHttpSettingsName((n, args), defaultBackendHttpSettingsName) =
            let apply (args: ApplicationGatewayUrlPathMapArgs) =
                args.DefaultBackendHttpSettingsName <- io defaultBackendHttpSettingsName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("defaultRedirectConfigurationId")>]
        member _.DefaultRedirectConfigurationId((n, args), defaultRedirectConfigurationId) =
            let apply (args: ApplicationGatewayUrlPathMapArgs) =
                args.DefaultRedirectConfigurationId <- input defaultRedirectConfigurationId
                args

            ()
            n, List.Cons(apply, args)

        member _.DefaultRedirectConfigurationId((n, args), defaultRedirectConfigurationId) =
            let apply (args: ApplicationGatewayUrlPathMapArgs) =
                args.DefaultRedirectConfigurationId <- io defaultRedirectConfigurationId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("defaultRedirectConfigurationName")>]
        member _.DefaultRedirectConfigurationName((n, args), defaultRedirectConfigurationName) =
            let apply (args: ApplicationGatewayUrlPathMapArgs) =
                args.DefaultRedirectConfigurationName <- input defaultRedirectConfigurationName
                args

            ()
            n, List.Cons(apply, args)

        member _.DefaultRedirectConfigurationName((n, args), defaultRedirectConfigurationName) =
            let apply (args: ApplicationGatewayUrlPathMapArgs) =
                args.DefaultRedirectConfigurationName <- io defaultRedirectConfigurationName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("defaultRewriteRuleSetId")>]
        member _.DefaultRewriteRuleSetId((n, args), defaultRewriteRuleSetId) =
            let apply (args: ApplicationGatewayUrlPathMapArgs) =
                args.DefaultRewriteRuleSetId <- input defaultRewriteRuleSetId
                args

            ()
            n, List.Cons(apply, args)

        member _.DefaultRewriteRuleSetId((n, args), defaultRewriteRuleSetId) =
            let apply (args: ApplicationGatewayUrlPathMapArgs) =
                args.DefaultRewriteRuleSetId <- io defaultRewriteRuleSetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("defaultRewriteRuleSetName")>]
        member _.DefaultRewriteRuleSetName((n, args), defaultRewriteRuleSetName) =
            let apply (args: ApplicationGatewayUrlPathMapArgs) =
                args.DefaultRewriteRuleSetName <- input defaultRewriteRuleSetName
                args

            ()
            n, List.Cons(apply, args)

        member _.DefaultRewriteRuleSetName((n, args), defaultRewriteRuleSetName) =
            let apply (args: ApplicationGatewayUrlPathMapArgs) =
                args.DefaultRewriteRuleSetName <- io defaultRewriteRuleSetName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewayUrlPathMapArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewayUrlPathMapArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewayUrlPathMapArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewayUrlPathMapArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("pathRules")>]
        member _.PathRules((n, args), pathRules) =
            let apply (args: ApplicationGatewayUrlPathMapArgs) =
                args.PathRules <- inputList pathRules
                args

            ()
            n, List.Cons(apply, args)

    let applicationGatewayUrlPathMap = ApplicationGatewayUrlPathMapBuilder()

    type ApplicationGatewayUrlPathMapPathRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApplicationGatewayUrlPathMapPathRuleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("backendAddressPoolId")>]
        member _.BackendAddressPoolId((n, args), backendAddressPoolId) =
            let apply (args: ApplicationGatewayUrlPathMapPathRuleArgs) =
                args.BackendAddressPoolId <- input backendAddressPoolId
                args

            ()
            n, List.Cons(apply, args)

        member _.BackendAddressPoolId((n, args), backendAddressPoolId) =
            let apply (args: ApplicationGatewayUrlPathMapPathRuleArgs) =
                args.BackendAddressPoolId <- io backendAddressPoolId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("backendAddressPoolName")>]
        member _.BackendAddressPoolName((n, args), backendAddressPoolName) =
            let apply (args: ApplicationGatewayUrlPathMapPathRuleArgs) =
                args.BackendAddressPoolName <- input backendAddressPoolName
                args

            ()
            n, List.Cons(apply, args)

        member _.BackendAddressPoolName((n, args), backendAddressPoolName) =
            let apply (args: ApplicationGatewayUrlPathMapPathRuleArgs) =
                args.BackendAddressPoolName <- io backendAddressPoolName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("backendHttpSettingsId")>]
        member _.BackendHttpSettingsId((n, args), backendHttpSettingsId) =
            let apply (args: ApplicationGatewayUrlPathMapPathRuleArgs) =
                args.BackendHttpSettingsId <- input backendHttpSettingsId
                args

            ()
            n, List.Cons(apply, args)

        member _.BackendHttpSettingsId((n, args), backendHttpSettingsId) =
            let apply (args: ApplicationGatewayUrlPathMapPathRuleArgs) =
                args.BackendHttpSettingsId <- io backendHttpSettingsId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("backendHttpSettingsName")>]
        member _.BackendHttpSettingsName((n, args), backendHttpSettingsName) =
            let apply (args: ApplicationGatewayUrlPathMapPathRuleArgs) =
                args.BackendHttpSettingsName <- input backendHttpSettingsName
                args

            ()
            n, List.Cons(apply, args)

        member _.BackendHttpSettingsName((n, args), backendHttpSettingsName) =
            let apply (args: ApplicationGatewayUrlPathMapPathRuleArgs) =
                args.BackendHttpSettingsName <- io backendHttpSettingsName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewayUrlPathMapPathRuleArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: ApplicationGatewayUrlPathMapPathRuleArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewayUrlPathMapPathRuleArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ApplicationGatewayUrlPathMapPathRuleArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("paths")>]
        member _.Paths((n, args), paths) =
            let apply (args: ApplicationGatewayUrlPathMapPathRuleArgs) =
                args.Paths <- inputList paths
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("redirectConfigurationId")>]
        member _.RedirectConfigurationId((n, args), redirectConfigurationId) =
            let apply (args: ApplicationGatewayUrlPathMapPathRuleArgs) =
                args.RedirectConfigurationId <- input redirectConfigurationId
                args

            ()
            n, List.Cons(apply, args)

        member _.RedirectConfigurationId((n, args), redirectConfigurationId) =
            let apply (args: ApplicationGatewayUrlPathMapPathRuleArgs) =
                args.RedirectConfigurationId <- io redirectConfigurationId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("redirectConfigurationName")>]
        member _.RedirectConfigurationName((n, args), redirectConfigurationName) =
            let apply (args: ApplicationGatewayUrlPathMapPathRuleArgs) =
                args.RedirectConfigurationName <- input redirectConfigurationName
                args

            ()
            n, List.Cons(apply, args)

        member _.RedirectConfigurationName((n, args), redirectConfigurationName) =
            let apply (args: ApplicationGatewayUrlPathMapPathRuleArgs) =
                args.RedirectConfigurationName <- io redirectConfigurationName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("rewriteRuleSetId")>]
        member _.RewriteRuleSetId((n, args), rewriteRuleSetId) =
            let apply (args: ApplicationGatewayUrlPathMapPathRuleArgs) =
                args.RewriteRuleSetId <- input rewriteRuleSetId
                args

            ()
            n, List.Cons(apply, args)

        member _.RewriteRuleSetId((n, args), rewriteRuleSetId) =
            let apply (args: ApplicationGatewayUrlPathMapPathRuleArgs) =
                args.RewriteRuleSetId <- io rewriteRuleSetId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("rewriteRuleSetName")>]
        member _.RewriteRuleSetName((n, args), rewriteRuleSetName) =
            let apply (args: ApplicationGatewayUrlPathMapPathRuleArgs) =
                args.RewriteRuleSetName <- input rewriteRuleSetName
                args

            ()
            n, List.Cons(apply, args)

        member _.RewriteRuleSetName((n, args), rewriteRuleSetName) =
            let apply (args: ApplicationGatewayUrlPathMapPathRuleArgs) =
                args.RewriteRuleSetName <- io rewriteRuleSetName
                args

            ()
            n, List.Cons(apply, args)

    let applicationGatewayUrlPathMapPathRule =
        ApplicationGatewayUrlPathMapPathRuleBuilder()

    type ApplicationGatewayWafConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApplicationGatewayWafConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("disabledRuleGroups")>]
        member _.DisabledRuleGroups((n, args), disabledRuleGroups) =
            let apply (args: ApplicationGatewayWafConfigurationArgs) =
                args.DisabledRuleGroups <- inputList disabledRuleGroups
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: ApplicationGatewayWafConfigurationArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: ApplicationGatewayWafConfigurationArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("exclusions")>]
        member _.Exclusions((n, args), exclusions) =
            let apply (args: ApplicationGatewayWafConfigurationArgs) =
                args.Exclusions <- inputList exclusions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("fileUploadLimitMb")>]
        member _.FileUploadLimitMb((n, args), fileUploadLimitMb) =
            let apply (args: ApplicationGatewayWafConfigurationArgs) =
                args.FileUploadLimitMb <- input fileUploadLimitMb
                args

            ()
            n, List.Cons(apply, args)

        member _.FileUploadLimitMb((n, args), fileUploadLimitMb) =
            let apply (args: ApplicationGatewayWafConfigurationArgs) =
                args.FileUploadLimitMb <- io fileUploadLimitMb
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("firewallMode")>]
        member _.FirewallMode((n, args), firewallMode) =
            let apply (args: ApplicationGatewayWafConfigurationArgs) =
                args.FirewallMode <- input firewallMode
                args

            ()
            n, List.Cons(apply, args)

        member _.FirewallMode((n, args), firewallMode) =
            let apply (args: ApplicationGatewayWafConfigurationArgs) =
                args.FirewallMode <- io firewallMode
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("maxRequestBodySizeKb")>]
        member _.MaxRequestBodySizeKb((n, args), maxRequestBodySizeKb) =
            let apply (args: ApplicationGatewayWafConfigurationArgs) =
                args.MaxRequestBodySizeKb <- input maxRequestBodySizeKb
                args

            ()
            n, List.Cons(apply, args)

        member _.MaxRequestBodySizeKb((n, args), maxRequestBodySizeKb) =
            let apply (args: ApplicationGatewayWafConfigurationArgs) =
                args.MaxRequestBodySizeKb <- io maxRequestBodySizeKb
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("requestBodyCheck")>]
        member _.RequestBodyCheck((n, args), requestBodyCheck) =
            let apply (args: ApplicationGatewayWafConfigurationArgs) =
                args.RequestBodyCheck <- input requestBodyCheck
                args

            ()
            n, List.Cons(apply, args)

        member _.RequestBodyCheck((n, args), requestBodyCheck) =
            let apply (args: ApplicationGatewayWafConfigurationArgs) =
                args.RequestBodyCheck <- io requestBodyCheck
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ruleSetType")>]
        member _.RuleSetType((n, args), ruleSetType) =
            let apply (args: ApplicationGatewayWafConfigurationArgs) =
                args.RuleSetType <- input ruleSetType
                args

            ()
            n, List.Cons(apply, args)

        member _.RuleSetType((n, args), ruleSetType) =
            let apply (args: ApplicationGatewayWafConfigurationArgs) =
                args.RuleSetType <- io ruleSetType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ruleSetVersion")>]
        member _.RuleSetVersion((n, args), ruleSetVersion) =
            let apply (args: ApplicationGatewayWafConfigurationArgs) =
                args.RuleSetVersion <- input ruleSetVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.RuleSetVersion((n, args), ruleSetVersion) =
            let apply (args: ApplicationGatewayWafConfigurationArgs) =
                args.RuleSetVersion <- io ruleSetVersion
                args

            ()
            n, List.Cons(apply, args)

    let applicationGatewayWafConfiguration =
        ApplicationGatewayWafConfigurationBuilder()

    type ApplicationGatewayWafConfigurationDisabledRuleGroupBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApplicationGatewayWafConfigurationDisabledRuleGroupArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("ruleGroupName")>]
        member _.RuleGroupName((n, args), ruleGroupName) =
            let apply (args: ApplicationGatewayWafConfigurationDisabledRuleGroupArgs) =
                args.RuleGroupName <- input ruleGroupName
                args

            ()
            n, List.Cons(apply, args)

        member _.RuleGroupName((n, args), ruleGroupName) =
            let apply (args: ApplicationGatewayWafConfigurationDisabledRuleGroupArgs) =
                args.RuleGroupName <- io ruleGroupName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("rules")>]
        member _.Rules((n, args), rules) =
            let apply (args: ApplicationGatewayWafConfigurationDisabledRuleGroupArgs) =
                args.Rules <- inputList rules
                args

            ()
            n, List.Cons(apply, args)

    let applicationGatewayWafConfigurationDisabledRuleGroup =
        ApplicationGatewayWafConfigurationDisabledRuleGroupBuilder()

    type ApplicationGatewayWafConfigurationExclusionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ApplicationGatewayWafConfigurationExclusionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("matchVariable")>]
        member _.MatchVariable((n, args), matchVariable) =
            let apply (args: ApplicationGatewayWafConfigurationExclusionArgs) =
                args.MatchVariable <- input matchVariable
                args

            ()
            n, List.Cons(apply, args)

        member _.MatchVariable((n, args), matchVariable) =
            let apply (args: ApplicationGatewayWafConfigurationExclusionArgs) =
                args.MatchVariable <- io matchVariable
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("selector")>]
        member _.Selector((n, args), selector) =
            let apply (args: ApplicationGatewayWafConfigurationExclusionArgs) =
                args.Selector <- input selector
                args

            ()
            n, List.Cons(apply, args)

        member _.Selector((n, args), selector) =
            let apply (args: ApplicationGatewayWafConfigurationExclusionArgs) =
                args.Selector <- io selector
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("selectorMatchOperator")>]
        member _.SelectorMatchOperator((n, args), selectorMatchOperator) =
            let apply (args: ApplicationGatewayWafConfigurationExclusionArgs) =
                args.SelectorMatchOperator <- input selectorMatchOperator
                args

            ()
            n, List.Cons(apply, args)

        member _.SelectorMatchOperator((n, args), selectorMatchOperator) =
            let apply (args: ApplicationGatewayWafConfigurationExclusionArgs) =
                args.SelectorMatchOperator <- io selectorMatchOperator
                args

            ()
            n, List.Cons(apply, args)

    let applicationGatewayWafConfigurationExclusion =
        ApplicationGatewayWafConfigurationExclusionBuilder()

    type ExpressRouteCircuitPeeringMicrosoftPeeringConfigBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ExpressRouteCircuitPeeringMicrosoftPeeringConfigArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("advertisedPublicPrefixes")>]
        member _.AdvertisedPublicPrefixes((n, args), advertisedPublicPrefixes) =
            let apply (args: ExpressRouteCircuitPeeringMicrosoftPeeringConfigArgs) =
                args.AdvertisedPublicPrefixes <- inputList advertisedPublicPrefixes
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("customerAsn")>]
        member _.CustomerAsn((n, args), customerAsn) =
            let apply (args: ExpressRouteCircuitPeeringMicrosoftPeeringConfigArgs) =
                args.CustomerAsn <- input customerAsn
                args

            ()
            n, List.Cons(apply, args)

        member _.CustomerAsn((n, args), customerAsn) =
            let apply (args: ExpressRouteCircuitPeeringMicrosoftPeeringConfigArgs) =
                args.CustomerAsn <- io customerAsn
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("routingRegistryName")>]
        member _.RoutingRegistryName((n, args), routingRegistryName) =
            let apply (args: ExpressRouteCircuitPeeringMicrosoftPeeringConfigArgs) =
                args.RoutingRegistryName <- input routingRegistryName
                args

            ()
            n, List.Cons(apply, args)

        member _.RoutingRegistryName((n, args), routingRegistryName) =
            let apply (args: ExpressRouteCircuitPeeringMicrosoftPeeringConfigArgs) =
                args.RoutingRegistryName <- io routingRegistryName
                args

            ()
            n, List.Cons(apply, args)

    let expressRouteCircuitPeeringMicrosoftPeeringConfig =
        ExpressRouteCircuitPeeringMicrosoftPeeringConfigBuilder()

    type ExpressRouteCircuitSkuBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ExpressRouteCircuitSkuArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("family")>]
        member _.Family((n, args), family) =
            let apply (args: ExpressRouteCircuitSkuArgs) =
                args.Family <- input family
                args

            ()
            n, List.Cons(apply, args)

        member _.Family((n, args), family) =
            let apply (args: ExpressRouteCircuitSkuArgs) =
                args.Family <- io family
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tier")>]
        member _.Tier((n, args), tier) =
            let apply (args: ExpressRouteCircuitSkuArgs) =
                args.Tier <- input tier
                args

            ()
            n, List.Cons(apply, args)

        member _.Tier((n, args), tier) =
            let apply (args: ExpressRouteCircuitSkuArgs) =
                args.Tier <- io tier
                args

            ()
            n, List.Cons(apply, args)

    let expressRouteCircuitSku = ExpressRouteCircuitSkuBuilder()

    type FirewallApplicationRuleCollectionRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FirewallApplicationRuleCollectionRuleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("description")>]
        member _.Description((n, args), description) =
            let apply (args: FirewallApplicationRuleCollectionRuleArgs) =
                args.Description <- input description
                args

            ()
            n, List.Cons(apply, args)

        member _.Description((n, args), description) =
            let apply (args: FirewallApplicationRuleCollectionRuleArgs) =
                args.Description <- io description
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("fqdnTags")>]
        member _.FqdnTags((n, args), fqdnTags) =
            let apply (args: FirewallApplicationRuleCollectionRuleArgs) =
                args.FqdnTags <- inputList fqdnTags
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: FirewallApplicationRuleCollectionRuleArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: FirewallApplicationRuleCollectionRuleArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("protocols")>]
        member _.Protocols((n, args), protocols) =
            let apply (args: FirewallApplicationRuleCollectionRuleArgs) =
                args.Protocols <- inputList protocols
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sourceAddresses")>]
        member _.SourceAddresses((n, args), sourceAddresses) =
            let apply (args: FirewallApplicationRuleCollectionRuleArgs) =
                args.SourceAddresses <- inputList sourceAddresses
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("targetFqdns")>]
        member _.TargetFqdns((n, args), targetFqdns) =
            let apply (args: FirewallApplicationRuleCollectionRuleArgs) =
                args.TargetFqdns <- inputList targetFqdns
                args

            ()
            n, List.Cons(apply, args)

    let firewallApplicationRuleCollectionRule =
        FirewallApplicationRuleCollectionRuleBuilder()

    type FirewallApplicationRuleCollectionRuleProtocolBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FirewallApplicationRuleCollectionRuleProtocolArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("port")>]
        member _.Port((n, args), port) =
            let apply (args: FirewallApplicationRuleCollectionRuleProtocolArgs) =
                args.Port <- input port
                args

            ()
            n, List.Cons(apply, args)

        member _.Port((n, args), port) =
            let apply (args: FirewallApplicationRuleCollectionRuleProtocolArgs) =
                args.Port <- io port
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: FirewallApplicationRuleCollectionRuleProtocolArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: FirewallApplicationRuleCollectionRuleProtocolArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let firewallApplicationRuleCollectionRuleProtocol =
        FirewallApplicationRuleCollectionRuleProtocolBuilder()

    type FirewallIpConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FirewallIpConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: FirewallIpConfigurationArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: FirewallIpConfigurationArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("privateIpAddress")>]
        member _.PrivateIpAddress((n, args), privateIpAddress) =
            let apply (args: FirewallIpConfigurationArgs) =
                args.PrivateIpAddress <- input privateIpAddress
                args

            ()
            n, List.Cons(apply, args)

        member _.PrivateIpAddress((n, args), privateIpAddress) =
            let apply (args: FirewallIpConfigurationArgs) =
                args.PrivateIpAddress <- io privateIpAddress
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publicIpAddressId")>]
        member _.PublicIpAddressId((n, args), publicIpAddressId) =
            let apply (args: FirewallIpConfigurationArgs) =
                args.PublicIpAddressId <- input publicIpAddressId
                args

            ()
            n, List.Cons(apply, args)

        member _.PublicIpAddressId((n, args), publicIpAddressId) =
            let apply (args: FirewallIpConfigurationArgs) =
                args.PublicIpAddressId <- io publicIpAddressId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: FirewallIpConfigurationArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: FirewallIpConfigurationArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

    let firewallIpConfiguration = FirewallIpConfigurationBuilder()

    type FirewallNatRuleCollectionRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FirewallNatRuleCollectionRuleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("description")>]
        member _.Description((n, args), description) =
            let apply (args: FirewallNatRuleCollectionRuleArgs) =
                args.Description <- input description
                args

            ()
            n, List.Cons(apply, args)

        member _.Description((n, args), description) =
            let apply (args: FirewallNatRuleCollectionRuleArgs) =
                args.Description <- io description
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("destinationAddresses")>]
        member _.DestinationAddresses((n, args), destinationAddresses) =
            let apply (args: FirewallNatRuleCollectionRuleArgs) =
                args.DestinationAddresses <- inputList destinationAddresses
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("destinationPorts")>]
        member _.DestinationPorts((n, args), destinationPorts) =
            let apply (args: FirewallNatRuleCollectionRuleArgs) =
                args.DestinationPorts <- inputList destinationPorts
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: FirewallNatRuleCollectionRuleArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: FirewallNatRuleCollectionRuleArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("protocols")>]
        member _.Protocols((n, args), protocols) =
            let apply (args: FirewallNatRuleCollectionRuleArgs) =
                args.Protocols <- inputList protocols
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sourceAddresses")>]
        member _.SourceAddresses((n, args), sourceAddresses) =
            let apply (args: FirewallNatRuleCollectionRuleArgs) =
                args.SourceAddresses <- inputList sourceAddresses
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("translatedAddress")>]
        member _.TranslatedAddress((n, args), translatedAddress) =
            let apply (args: FirewallNatRuleCollectionRuleArgs) =
                args.TranslatedAddress <- input translatedAddress
                args

            ()
            n, List.Cons(apply, args)

        member _.TranslatedAddress((n, args), translatedAddress) =
            let apply (args: FirewallNatRuleCollectionRuleArgs) =
                args.TranslatedAddress <- io translatedAddress
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("translatedPort")>]
        member _.TranslatedPort((n, args), translatedPort) =
            let apply (args: FirewallNatRuleCollectionRuleArgs) =
                args.TranslatedPort <- input translatedPort
                args

            ()
            n, List.Cons(apply, args)

        member _.TranslatedPort((n, args), translatedPort) =
            let apply (args: FirewallNatRuleCollectionRuleArgs) =
                args.TranslatedPort <- io translatedPort
                args

            ()
            n, List.Cons(apply, args)

    let firewallNatRuleCollectionRule = FirewallNatRuleCollectionRuleBuilder()

    type FirewallNetworkRuleCollectionRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FirewallNetworkRuleCollectionRuleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("description")>]
        member _.Description((n, args), description) =
            let apply (args: FirewallNetworkRuleCollectionRuleArgs) =
                args.Description <- input description
                args

            ()
            n, List.Cons(apply, args)

        member _.Description((n, args), description) =
            let apply (args: FirewallNetworkRuleCollectionRuleArgs) =
                args.Description <- io description
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("destinationAddresses")>]
        member _.DestinationAddresses((n, args), destinationAddresses) =
            let apply (args: FirewallNetworkRuleCollectionRuleArgs) =
                args.DestinationAddresses <- inputList destinationAddresses
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("destinationPorts")>]
        member _.DestinationPorts((n, args), destinationPorts) =
            let apply (args: FirewallNetworkRuleCollectionRuleArgs) =
                args.DestinationPorts <- inputList destinationPorts
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: FirewallNetworkRuleCollectionRuleArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: FirewallNetworkRuleCollectionRuleArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("protocols")>]
        member _.Protocols((n, args), protocols) =
            let apply (args: FirewallNetworkRuleCollectionRuleArgs) =
                args.Protocols <- inputList protocols
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sourceAddresses")>]
        member _.SourceAddresses((n, args), sourceAddresses) =
            let apply (args: FirewallNetworkRuleCollectionRuleArgs) =
                args.SourceAddresses <- inputList sourceAddresses
                args

            ()
            n, List.Cons(apply, args)

    let firewallNetworkRuleCollectionRule =
        FirewallNetworkRuleCollectionRuleBuilder()

    type LocalNetworkGatewayBgpSettingsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LocalNetworkGatewayBgpSettingsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("asn")>]
        member _.Asn((n, args), asn) =
            let apply (args: LocalNetworkGatewayBgpSettingsArgs) =
                args.Asn <- input asn
                args

            ()
            n, List.Cons(apply, args)

        member _.Asn((n, args), asn) =
            let apply (args: LocalNetworkGatewayBgpSettingsArgs) =
                args.Asn <- io asn
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("bgpPeeringAddress")>]
        member _.BgpPeeringAddress((n, args), bgpPeeringAddress) =
            let apply (args: LocalNetworkGatewayBgpSettingsArgs) =
                args.BgpPeeringAddress <- input bgpPeeringAddress
                args

            ()
            n, List.Cons(apply, args)

        member _.BgpPeeringAddress((n, args), bgpPeeringAddress) =
            let apply (args: LocalNetworkGatewayBgpSettingsArgs) =
                args.BgpPeeringAddress <- io bgpPeeringAddress
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("peerWeight")>]
        member _.PeerWeight((n, args), peerWeight) =
            let apply (args: LocalNetworkGatewayBgpSettingsArgs) =
                args.PeerWeight <- input peerWeight
                args

            ()
            n, List.Cons(apply, args)

        member _.PeerWeight((n, args), peerWeight) =
            let apply (args: LocalNetworkGatewayBgpSettingsArgs) =
                args.PeerWeight <- io peerWeight
                args

            ()
            n, List.Cons(apply, args)

    let localNetworkGatewayBgpSettings = LocalNetworkGatewayBgpSettingsBuilder()

    type NetworkConnectionMonitorDestinationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (NetworkConnectionMonitorDestinationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("address")>]
        member _.Address((n, args), address) =
            let apply (args: NetworkConnectionMonitorDestinationArgs) =
                args.Address <- input address
                args

            ()
            n, List.Cons(apply, args)

        member _.Address((n, args), address) =
            let apply (args: NetworkConnectionMonitorDestinationArgs) =
                args.Address <- io address
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("port")>]
        member _.Port((n, args), port) =
            let apply (args: NetworkConnectionMonitorDestinationArgs) =
                args.Port <- input port
                args

            ()
            n, List.Cons(apply, args)

        member _.Port((n, args), port) =
            let apply (args: NetworkConnectionMonitorDestinationArgs) =
                args.Port <- io port
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualMachineId")>]
        member _.VirtualMachineId((n, args), virtualMachineId) =
            let apply (args: NetworkConnectionMonitorDestinationArgs) =
                args.VirtualMachineId <- input virtualMachineId
                args

            ()
            n, List.Cons(apply, args)

        member _.VirtualMachineId((n, args), virtualMachineId) =
            let apply (args: NetworkConnectionMonitorDestinationArgs) =
                args.VirtualMachineId <- io virtualMachineId
                args

            ()
            n, List.Cons(apply, args)

    let networkConnectionMonitorDestination =
        NetworkConnectionMonitorDestinationBuilder()

    type NetworkConnectionMonitorSourceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (NetworkConnectionMonitorSourceArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("port")>]
        member _.Port((n, args), port) =
            let apply (args: NetworkConnectionMonitorSourceArgs) =
                args.Port <- input port
                args

            ()
            n, List.Cons(apply, args)

        member _.Port((n, args), port) =
            let apply (args: NetworkConnectionMonitorSourceArgs) =
                args.Port <- io port
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("virtualMachineId")>]
        member _.VirtualMachineId((n, args), virtualMachineId) =
            let apply (args: NetworkConnectionMonitorSourceArgs) =
                args.VirtualMachineId <- input virtualMachineId
                args

            ()
            n, List.Cons(apply, args)

        member _.VirtualMachineId((n, args), virtualMachineId) =
            let apply (args: NetworkConnectionMonitorSourceArgs) =
                args.VirtualMachineId <- io virtualMachineId
                args

            ()
            n, List.Cons(apply, args)

    let networkConnectionMonitorSource = NetworkConnectionMonitorSourceBuilder()

    type NetworkInterfaceIpConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (NetworkInterfaceIpConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: NetworkInterfaceIpConfigurationArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: NetworkInterfaceIpConfigurationArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("primary")>]
        member _.Primary((n, args), primary) =
            let apply (args: NetworkInterfaceIpConfigurationArgs) =
                args.Primary <- input primary
                args

            ()
            n, List.Cons(apply, args)

        member _.Primary((n, args), primary) =
            let apply (args: NetworkInterfaceIpConfigurationArgs) =
                args.Primary <- io primary
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("privateIpAddress")>]
        member _.PrivateIpAddress((n, args), privateIpAddress) =
            let apply (args: NetworkInterfaceIpConfigurationArgs) =
                args.PrivateIpAddress <- input privateIpAddress
                args

            ()
            n, List.Cons(apply, args)

        member _.PrivateIpAddress((n, args), privateIpAddress) =
            let apply (args: NetworkInterfaceIpConfigurationArgs) =
                args.PrivateIpAddress <- io privateIpAddress
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("privateIpAddressAllocation")>]
        member _.PrivateIpAddressAllocation((n, args), privateIpAddressAllocation) =
            let apply (args: NetworkInterfaceIpConfigurationArgs) =
                args.PrivateIpAddressAllocation <- input privateIpAddressAllocation
                args

            ()
            n, List.Cons(apply, args)

        member _.PrivateIpAddressAllocation((n, args), privateIpAddressAllocation) =
            let apply (args: NetworkInterfaceIpConfigurationArgs) =
                args.PrivateIpAddressAllocation <- io privateIpAddressAllocation
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("privateIpAddressVersion")>]
        member _.PrivateIpAddressVersion((n, args), privateIpAddressVersion) =
            let apply (args: NetworkInterfaceIpConfigurationArgs) =
                args.PrivateIpAddressVersion <- input privateIpAddressVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.PrivateIpAddressVersion((n, args), privateIpAddressVersion) =
            let apply (args: NetworkInterfaceIpConfigurationArgs) =
                args.PrivateIpAddressVersion <- io privateIpAddressVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publicIpAddressId")>]
        member _.PublicIpAddressId((n, args), publicIpAddressId) =
            let apply (args: NetworkInterfaceIpConfigurationArgs) =
                args.PublicIpAddressId <- input publicIpAddressId
                args

            ()
            n, List.Cons(apply, args)

        member _.PublicIpAddressId((n, args), publicIpAddressId) =
            let apply (args: NetworkInterfaceIpConfigurationArgs) =
                args.PublicIpAddressId <- io publicIpAddressId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: NetworkInterfaceIpConfigurationArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: NetworkInterfaceIpConfigurationArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

    let networkInterfaceIpConfiguration = NetworkInterfaceIpConfigurationBuilder()

    type NetworkPacketCaptureFilterBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (NetworkPacketCaptureFilterArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("localIpAddress")>]
        member _.LocalIpAddress((n, args), localIpAddress) =
            let apply (args: NetworkPacketCaptureFilterArgs) =
                args.LocalIpAddress <- input localIpAddress
                args

            ()
            n, List.Cons(apply, args)

        member _.LocalIpAddress((n, args), localIpAddress) =
            let apply (args: NetworkPacketCaptureFilterArgs) =
                args.LocalIpAddress <- io localIpAddress
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("localPort")>]
        member _.LocalPort((n, args), localPort) =
            let apply (args: NetworkPacketCaptureFilterArgs) =
                args.LocalPort <- input localPort
                args

            ()
            n, List.Cons(apply, args)

        member _.LocalPort((n, args), localPort) =
            let apply (args: NetworkPacketCaptureFilterArgs) =
                args.LocalPort <- io localPort
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("protocol")>]
        member _.Protocol((n, args), protocol) =
            let apply (args: NetworkPacketCaptureFilterArgs) =
                args.Protocol <- input protocol
                args

            ()
            n, List.Cons(apply, args)

        member _.Protocol((n, args), protocol) =
            let apply (args: NetworkPacketCaptureFilterArgs) =
                args.Protocol <- io protocol
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("remoteIpAddress")>]
        member _.RemoteIpAddress((n, args), remoteIpAddress) =
            let apply (args: NetworkPacketCaptureFilterArgs) =
                args.RemoteIpAddress <- input remoteIpAddress
                args

            ()
            n, List.Cons(apply, args)

        member _.RemoteIpAddress((n, args), remoteIpAddress) =
            let apply (args: NetworkPacketCaptureFilterArgs) =
                args.RemoteIpAddress <- io remoteIpAddress
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("remotePort")>]
        member _.RemotePort((n, args), remotePort) =
            let apply (args: NetworkPacketCaptureFilterArgs) =
                args.RemotePort <- input remotePort
                args

            ()
            n, List.Cons(apply, args)

        member _.RemotePort((n, args), remotePort) =
            let apply (args: NetworkPacketCaptureFilterArgs) =
                args.RemotePort <- io remotePort
                args

            ()
            n, List.Cons(apply, args)

    let networkPacketCaptureFilter = NetworkPacketCaptureFilterBuilder()

    type NetworkPacketCaptureStorageLocationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (NetworkPacketCaptureStorageLocationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("filePath")>]
        member _.FilePath((n, args), filePath) =
            let apply (args: NetworkPacketCaptureStorageLocationArgs) =
                args.FilePath <- input filePath
                args

            ()
            n, List.Cons(apply, args)

        member _.FilePath((n, args), filePath) =
            let apply (args: NetworkPacketCaptureStorageLocationArgs) =
                args.FilePath <- io filePath
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageAccountId")>]
        member _.StorageAccountId((n, args), storageAccountId) =
            let apply (args: NetworkPacketCaptureStorageLocationArgs) =
                args.StorageAccountId <- input storageAccountId
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountId((n, args), storageAccountId) =
            let apply (args: NetworkPacketCaptureStorageLocationArgs) =
                args.StorageAccountId <- io storageAccountId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storagePath")>]
        member _.StoragePath((n, args), storagePath) =
            let apply (args: NetworkPacketCaptureStorageLocationArgs) =
                args.StoragePath <- input storagePath
                args

            ()
            n, List.Cons(apply, args)

        member _.StoragePath((n, args), storagePath) =
            let apply (args: NetworkPacketCaptureStorageLocationArgs) =
                args.StoragePath <- io storagePath
                args

            ()
            n, List.Cons(apply, args)

    let networkPacketCaptureStorageLocation =
        NetworkPacketCaptureStorageLocationBuilder()

    type NetworkSecurityGroupSecurityRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (NetworkSecurityGroupSecurityRuleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("access")>]
        member _.Access((n, args), access) =
            let apply (args: NetworkSecurityGroupSecurityRuleArgs) =
                args.Access <- input access
                args

            ()
            n, List.Cons(apply, args)

        member _.Access((n, args), access) =
            let apply (args: NetworkSecurityGroupSecurityRuleArgs) =
                args.Access <- io access
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((n, args), description) =
            let apply (args: NetworkSecurityGroupSecurityRuleArgs) =
                args.Description <- input description
                args

            ()
            n, List.Cons(apply, args)

        member _.Description((n, args), description) =
            let apply (args: NetworkSecurityGroupSecurityRuleArgs) =
                args.Description <- io description
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("destinationAddressPrefix")>]
        member _.DestinationAddressPrefix((n, args), destinationAddressPrefix) =
            let apply (args: NetworkSecurityGroupSecurityRuleArgs) =
                args.DestinationAddressPrefix <- input destinationAddressPrefix
                args

            ()
            n, List.Cons(apply, args)

        member _.DestinationAddressPrefix((n, args), destinationAddressPrefix) =
            let apply (args: NetworkSecurityGroupSecurityRuleArgs) =
                args.DestinationAddressPrefix <- io destinationAddressPrefix
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("destinationAddressPrefixes")>]
        member _.DestinationAddressPrefixes((n, args), destinationAddressPrefixes) =
            let apply (args: NetworkSecurityGroupSecurityRuleArgs) =
                args.DestinationAddressPrefixes <- inputList destinationAddressPrefixes
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("destinationApplicationSecurityGroupIds")>]
        member _.DestinationApplicationSecurityGroupIds((n, args), destinationApplicationSecurityGroupIds) =
            let apply (args: NetworkSecurityGroupSecurityRuleArgs) =
                args.DestinationApplicationSecurityGroupIds <- inputList destinationApplicationSecurityGroupIds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("destinationPortRange")>]
        member _.DestinationPortRange((n, args), destinationPortRange) =
            let apply (args: NetworkSecurityGroupSecurityRuleArgs) =
                args.DestinationPortRange <- input destinationPortRange
                args

            ()
            n, List.Cons(apply, args)

        member _.DestinationPortRange((n, args), destinationPortRange) =
            let apply (args: NetworkSecurityGroupSecurityRuleArgs) =
                args.DestinationPortRange <- io destinationPortRange
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("destinationPortRanges")>]
        member _.DestinationPortRanges((n, args), destinationPortRanges) =
            let apply (args: NetworkSecurityGroupSecurityRuleArgs) =
                args.DestinationPortRanges <- inputList destinationPortRanges
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("direction")>]
        member _.Direction((n, args), direction) =
            let apply (args: NetworkSecurityGroupSecurityRuleArgs) =
                args.Direction <- input direction
                args

            ()
            n, List.Cons(apply, args)

        member _.Direction((n, args), direction) =
            let apply (args: NetworkSecurityGroupSecurityRuleArgs) =
                args.Direction <- io direction
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: NetworkSecurityGroupSecurityRuleArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: NetworkSecurityGroupSecurityRuleArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("priority")>]
        member _.Priority((n, args), priority) =
            let apply (args: NetworkSecurityGroupSecurityRuleArgs) =
                args.Priority <- input priority
                args

            ()
            n, List.Cons(apply, args)

        member _.Priority((n, args), priority) =
            let apply (args: NetworkSecurityGroupSecurityRuleArgs) =
                args.Priority <- io priority
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("protocol")>]
        member _.Protocol((n, args), protocol) =
            let apply (args: NetworkSecurityGroupSecurityRuleArgs) =
                args.Protocol <- input protocol
                args

            ()
            n, List.Cons(apply, args)

        member _.Protocol((n, args), protocol) =
            let apply (args: NetworkSecurityGroupSecurityRuleArgs) =
                args.Protocol <- io protocol
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sourceAddressPrefix")>]
        member _.SourceAddressPrefix((n, args), sourceAddressPrefix) =
            let apply (args: NetworkSecurityGroupSecurityRuleArgs) =
                args.SourceAddressPrefix <- input sourceAddressPrefix
                args

            ()
            n, List.Cons(apply, args)

        member _.SourceAddressPrefix((n, args), sourceAddressPrefix) =
            let apply (args: NetworkSecurityGroupSecurityRuleArgs) =
                args.SourceAddressPrefix <- io sourceAddressPrefix
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sourceAddressPrefixes")>]
        member _.SourceAddressPrefixes((n, args), sourceAddressPrefixes) =
            let apply (args: NetworkSecurityGroupSecurityRuleArgs) =
                args.SourceAddressPrefixes <- inputList sourceAddressPrefixes
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sourceApplicationSecurityGroupIds")>]
        member _.SourceApplicationSecurityGroupIds((n, args), sourceApplicationSecurityGroupIds) =
            let apply (args: NetworkSecurityGroupSecurityRuleArgs) =
                args.SourceApplicationSecurityGroupIds <- inputList sourceApplicationSecurityGroupIds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sourcePortRange")>]
        member _.SourcePortRange((n, args), sourcePortRange) =
            let apply (args: NetworkSecurityGroupSecurityRuleArgs) =
                args.SourcePortRange <- input sourcePortRange
                args

            ()
            n, List.Cons(apply, args)

        member _.SourcePortRange((n, args), sourcePortRange) =
            let apply (args: NetworkSecurityGroupSecurityRuleArgs) =
                args.SourcePortRange <- io sourcePortRange
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sourcePortRanges")>]
        member _.SourcePortRanges((n, args), sourcePortRanges) =
            let apply (args: NetworkSecurityGroupSecurityRuleArgs) =
                args.SourcePortRanges <- inputList sourcePortRanges
                args

            ()
            n, List.Cons(apply, args)

    let networkSecurityGroupSecurityRule =
        NetworkSecurityGroupSecurityRuleBuilder()

    type NetworkWatcherFlowLogRetentionPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (NetworkWatcherFlowLogRetentionPolicyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("days")>]
        member _.Days((n, args), days) =
            let apply (args: NetworkWatcherFlowLogRetentionPolicyArgs) =
                args.Days <- input days
                args

            ()
            n, List.Cons(apply, args)

        member _.Days((n, args), days) =
            let apply (args: NetworkWatcherFlowLogRetentionPolicyArgs) =
                args.Days <- io days
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: NetworkWatcherFlowLogRetentionPolicyArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: NetworkWatcherFlowLogRetentionPolicyArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

    let networkWatcherFlowLogRetentionPolicy =
        NetworkWatcherFlowLogRetentionPolicyBuilder()

    type NetworkWatcherFlowLogTrafficAnalyticsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (NetworkWatcherFlowLogTrafficAnalyticsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: NetworkWatcherFlowLogTrafficAnalyticsArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: NetworkWatcherFlowLogTrafficAnalyticsArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("intervalInMinutes")>]
        member _.IntervalInMinutes((n, args), intervalInMinutes) =
            let apply (args: NetworkWatcherFlowLogTrafficAnalyticsArgs) =
                args.IntervalInMinutes <- input intervalInMinutes
                args

            ()
            n, List.Cons(apply, args)

        member _.IntervalInMinutes((n, args), intervalInMinutes) =
            let apply (args: NetworkWatcherFlowLogTrafficAnalyticsArgs) =
                args.IntervalInMinutes <- io intervalInMinutes
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("workspaceId")>]
        member _.WorkspaceId((n, args), workspaceId) =
            let apply (args: NetworkWatcherFlowLogTrafficAnalyticsArgs) =
                args.WorkspaceId <- input workspaceId
                args

            ()
            n, List.Cons(apply, args)

        member _.WorkspaceId((n, args), workspaceId) =
            let apply (args: NetworkWatcherFlowLogTrafficAnalyticsArgs) =
                args.WorkspaceId <- io workspaceId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("workspaceRegion")>]
        member _.WorkspaceRegion((n, args), workspaceRegion) =
            let apply (args: NetworkWatcherFlowLogTrafficAnalyticsArgs) =
                args.WorkspaceRegion <- input workspaceRegion
                args

            ()
            n, List.Cons(apply, args)

        member _.WorkspaceRegion((n, args), workspaceRegion) =
            let apply (args: NetworkWatcherFlowLogTrafficAnalyticsArgs) =
                args.WorkspaceRegion <- io workspaceRegion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("workspaceResourceId")>]
        member _.WorkspaceResourceId((n, args), workspaceResourceId) =
            let apply (args: NetworkWatcherFlowLogTrafficAnalyticsArgs) =
                args.WorkspaceResourceId <- input workspaceResourceId
                args

            ()
            n, List.Cons(apply, args)

        member _.WorkspaceResourceId((n, args), workspaceResourceId) =
            let apply (args: NetworkWatcherFlowLogTrafficAnalyticsArgs) =
                args.WorkspaceResourceId <- io workspaceResourceId
                args

            ()
            n, List.Cons(apply, args)

    let networkWatcherFlowLogTrafficAnalytics =
        NetworkWatcherFlowLogTrafficAnalyticsBuilder()

    type PacketCaptureFilterBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (PacketCaptureFilterArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("localIpAddress")>]
        member _.LocalIpAddress((n, args), localIpAddress) =
            let apply (args: PacketCaptureFilterArgs) =
                args.LocalIpAddress <- input localIpAddress
                args

            ()
            n, List.Cons(apply, args)

        member _.LocalIpAddress((n, args), localIpAddress) =
            let apply (args: PacketCaptureFilterArgs) =
                args.LocalIpAddress <- io localIpAddress
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("localPort")>]
        member _.LocalPort((n, args), localPort) =
            let apply (args: PacketCaptureFilterArgs) =
                args.LocalPort <- input localPort
                args

            ()
            n, List.Cons(apply, args)

        member _.LocalPort((n, args), localPort) =
            let apply (args: PacketCaptureFilterArgs) =
                args.LocalPort <- io localPort
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("protocol")>]
        member _.Protocol((n, args), protocol) =
            let apply (args: PacketCaptureFilterArgs) =
                args.Protocol <- input protocol
                args

            ()
            n, List.Cons(apply, args)

        member _.Protocol((n, args), protocol) =
            let apply (args: PacketCaptureFilterArgs) =
                args.Protocol <- io protocol
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("remoteIpAddress")>]
        member _.RemoteIpAddress((n, args), remoteIpAddress) =
            let apply (args: PacketCaptureFilterArgs) =
                args.RemoteIpAddress <- input remoteIpAddress
                args

            ()
            n, List.Cons(apply, args)

        member _.RemoteIpAddress((n, args), remoteIpAddress) =
            let apply (args: PacketCaptureFilterArgs) =
                args.RemoteIpAddress <- io remoteIpAddress
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("remotePort")>]
        member _.RemotePort((n, args), remotePort) =
            let apply (args: PacketCaptureFilterArgs) =
                args.RemotePort <- input remotePort
                args

            ()
            n, List.Cons(apply, args)

        member _.RemotePort((n, args), remotePort) =
            let apply (args: PacketCaptureFilterArgs) =
                args.RemotePort <- io remotePort
                args

            ()
            n, List.Cons(apply, args)

    let packetCaptureFilter = PacketCaptureFilterBuilder()

    type PacketCaptureStorageLocationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (PacketCaptureStorageLocationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("filePath")>]
        member _.FilePath((n, args), filePath) =
            let apply (args: PacketCaptureStorageLocationArgs) =
                args.FilePath <- input filePath
                args

            ()
            n, List.Cons(apply, args)

        member _.FilePath((n, args), filePath) =
            let apply (args: PacketCaptureStorageLocationArgs) =
                args.FilePath <- io filePath
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageAccountId")>]
        member _.StorageAccountId((n, args), storageAccountId) =
            let apply (args: PacketCaptureStorageLocationArgs) =
                args.StorageAccountId <- input storageAccountId
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountId((n, args), storageAccountId) =
            let apply (args: PacketCaptureStorageLocationArgs) =
                args.StorageAccountId <- io storageAccountId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storagePath")>]
        member _.StoragePath((n, args), storagePath) =
            let apply (args: PacketCaptureStorageLocationArgs) =
                args.StoragePath <- input storagePath
                args

            ()
            n, List.Cons(apply, args)

        member _.StoragePath((n, args), storagePath) =
            let apply (args: PacketCaptureStorageLocationArgs) =
                args.StoragePath <- io storagePath
                args

            ()
            n, List.Cons(apply, args)

    let packetCaptureStorageLocation = PacketCaptureStorageLocationBuilder()

    type PointToPointVpnGatewayConnectionConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (PointToPointVpnGatewayConnectionConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: PointToPointVpnGatewayConnectionConfigurationArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: PointToPointVpnGatewayConnectionConfigurationArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: PointToPointVpnGatewayConnectionConfigurationArgs) =
                   args.VpnClientAddressPool <- input arg
                   args

               ()
               func) ]

    let pointToPointVpnGatewayConnectionConfiguration =
        PointToPointVpnGatewayConnectionConfigurationBuilder()

    type PointToPointVpnGatewayConnectionConfigurationVpnClientAddressPoolBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (PointToPointVpnGatewayConnectionConfigurationVpnClientAddressPoolArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("addressPrefixes")>]
        member _.AddressPrefixes((n, args), addressPrefixes) =
            let apply (args: PointToPointVpnGatewayConnectionConfigurationVpnClientAddressPoolArgs) =
                args.AddressPrefixes <- inputList addressPrefixes
                args

            ()
            n, List.Cons(apply, args)

    let pointToPointVpnGatewayConnectionConfigurationVpnClientAddressPool =
        PointToPointVpnGatewayConnectionConfigurationVpnClientAddressPoolBuilder()

    type ProfileContainerNetworkInterfaceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ProfileContainerNetworkInterfaceArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("ipConfigurations")>]
        member _.IpConfigurations((n, args), ipConfigurations) =
            let apply (args: ProfileContainerNetworkInterfaceArgs) =
                args.IpConfigurations <- inputList ipConfigurations
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ProfileContainerNetworkInterfaceArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ProfileContainerNetworkInterfaceArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

    let profileContainerNetworkInterface =
        ProfileContainerNetworkInterfaceBuilder()

    type ProfileContainerNetworkInterfaceIpConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ProfileContainerNetworkInterfaceIpConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ProfileContainerNetworkInterfaceIpConfigurationArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ProfileContainerNetworkInterfaceIpConfigurationArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: ProfileContainerNetworkInterfaceIpConfigurationArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: ProfileContainerNetworkInterfaceIpConfigurationArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

    let profileContainerNetworkInterfaceIpConfiguration =
        ProfileContainerNetworkInterfaceIpConfigurationBuilder()

    type RouteTableRouteBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (RouteTableRouteArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("addressPrefix")>]
        member _.AddressPrefix((n, args), addressPrefix) =
            let apply (args: RouteTableRouteArgs) =
                args.AddressPrefix <- input addressPrefix
                args

            ()
            n, List.Cons(apply, args)

        member _.AddressPrefix((n, args), addressPrefix) =
            let apply (args: RouteTableRouteArgs) =
                args.AddressPrefix <- io addressPrefix
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: RouteTableRouteArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: RouteTableRouteArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("nextHopInIpAddress")>]
        member _.NextHopInIpAddress((n, args), nextHopInIpAddress) =
            let apply (args: RouteTableRouteArgs) =
                args.NextHopInIpAddress <- input nextHopInIpAddress
                args

            ()
            n, List.Cons(apply, args)

        member _.NextHopInIpAddress((n, args), nextHopInIpAddress) =
            let apply (args: RouteTableRouteArgs) =
                args.NextHopInIpAddress <- io nextHopInIpAddress
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("nextHopType")>]
        member _.NextHopType((n, args), nextHopType) =
            let apply (args: RouteTableRouteArgs) =
                args.NextHopType <- input nextHopType
                args

            ()
            n, List.Cons(apply, args)

        member _.NextHopType((n, args), nextHopType) =
            let apply (args: RouteTableRouteArgs) =
                args.NextHopType <- io nextHopType
                args

            ()
            n, List.Cons(apply, args)

    let routeTableRoute = RouteTableRouteBuilder()

    type SubnetDelegationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SubnetDelegationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: SubnetDelegationArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: SubnetDelegationArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: SubnetDelegationArgs) =
                   args.ServiceDelegation <- input arg
                   args

               ()
               func) ]

    let subnetDelegation = SubnetDelegationBuilder()

    type SubnetDelegationServiceDelegationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SubnetDelegationServiceDelegationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("actions")>]
        member _.Actions((n, args), actions) =
            let apply (args: SubnetDelegationServiceDelegationArgs) =
                args.Actions <- inputList actions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: SubnetDelegationServiceDelegationArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: SubnetDelegationServiceDelegationArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

    let subnetDelegationServiceDelegation =
        SubnetDelegationServiceDelegationBuilder()

    type TrafficManagerEndpointCustomHeaderBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (TrafficManagerEndpointCustomHeaderArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: TrafficManagerEndpointCustomHeaderArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: TrafficManagerEndpointCustomHeaderArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((n, args), value) =
            let apply (args: TrafficManagerEndpointCustomHeaderArgs) =
                args.Value <- input value
                args

            ()
            n, List.Cons(apply, args)

        member _.Value((n, args), value) =
            let apply (args: TrafficManagerEndpointCustomHeaderArgs) =
                args.Value <- io value
                args

            ()
            n, List.Cons(apply, args)

    let trafficManagerEndpointCustomHeader =
        TrafficManagerEndpointCustomHeaderBuilder()

    type TrafficManagerEndpointSubnetBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (TrafficManagerEndpointSubnetArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("first")>]
        member _.First((n, args), first) =
            let apply (args: TrafficManagerEndpointSubnetArgs) =
                args.First <- input first
                args

            ()
            n, List.Cons(apply, args)

        member _.First((n, args), first) =
            let apply (args: TrafficManagerEndpointSubnetArgs) =
                args.First <- io first
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("last")>]
        member _.Last((n, args), last) =
            let apply (args: TrafficManagerEndpointSubnetArgs) =
                args.Last <- input last
                args

            ()
            n, List.Cons(apply, args)

        member _.Last((n, args), last) =
            let apply (args: TrafficManagerEndpointSubnetArgs) =
                args.Last <- io last
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("scope")>]
        member _.Scope((n, args), scope) =
            let apply (args: TrafficManagerEndpointSubnetArgs) =
                args.Scope <- input scope
                args

            ()
            n, List.Cons(apply, args)

        member _.Scope((n, args), scope) =
            let apply (args: TrafficManagerEndpointSubnetArgs) =
                args.Scope <- io scope
                args

            ()
            n, List.Cons(apply, args)

    let trafficManagerEndpointSubnet = TrafficManagerEndpointSubnetBuilder()

    type TrafficManagerProfileDnsConfigBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (TrafficManagerProfileDnsConfigArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("relativeName")>]
        member _.RelativeName((n, args), relativeName) =
            let apply (args: TrafficManagerProfileDnsConfigArgs) =
                args.RelativeName <- input relativeName
                args

            ()
            n, List.Cons(apply, args)

        member _.RelativeName((n, args), relativeName) =
            let apply (args: TrafficManagerProfileDnsConfigArgs) =
                args.RelativeName <- io relativeName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ttl")>]
        member _.Ttl((n, args), ttl) =
            let apply (args: TrafficManagerProfileDnsConfigArgs) =
                args.Ttl <- input ttl
                args

            ()
            n, List.Cons(apply, args)

        member _.Ttl((n, args), ttl) =
            let apply (args: TrafficManagerProfileDnsConfigArgs) =
                args.Ttl <- io ttl
                args

            ()
            n, List.Cons(apply, args)

    let trafficManagerProfileDnsConfig = TrafficManagerProfileDnsConfigBuilder()

    type TrafficManagerProfileMonitorConfigBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (TrafficManagerProfileMonitorConfigArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("customHeaders")>]
        member _.CustomHeaders((n, args), customHeaders) =
            let apply (args: TrafficManagerProfileMonitorConfigArgs) =
                args.CustomHeaders <- inputList customHeaders
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("expectedStatusCodeRanges")>]
        member _.ExpectedStatusCodeRanges((n, args), expectedStatusCodeRanges) =
            let apply (args: TrafficManagerProfileMonitorConfigArgs) =
                args.ExpectedStatusCodeRanges <- inputList expectedStatusCodeRanges
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("intervalInSeconds")>]
        member _.IntervalInSeconds((n, args), intervalInSeconds) =
            let apply (args: TrafficManagerProfileMonitorConfigArgs) =
                args.IntervalInSeconds <- input intervalInSeconds
                args

            ()
            n, List.Cons(apply, args)

        member _.IntervalInSeconds((n, args), intervalInSeconds) =
            let apply (args: TrafficManagerProfileMonitorConfigArgs) =
                args.IntervalInSeconds <- io intervalInSeconds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("path")>]
        member _.Path((n, args), path) =
            let apply (args: TrafficManagerProfileMonitorConfigArgs) =
                args.Path <- input path
                args

            ()
            n, List.Cons(apply, args)

        member _.Path((n, args), path) =
            let apply (args: TrafficManagerProfileMonitorConfigArgs) =
                args.Path <- io path
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("port")>]
        member _.Port((n, args), port) =
            let apply (args: TrafficManagerProfileMonitorConfigArgs) =
                args.Port <- input port
                args

            ()
            n, List.Cons(apply, args)

        member _.Port((n, args), port) =
            let apply (args: TrafficManagerProfileMonitorConfigArgs) =
                args.Port <- io port
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("protocol")>]
        member _.Protocol((n, args), protocol) =
            let apply (args: TrafficManagerProfileMonitorConfigArgs) =
                args.Protocol <- input protocol
                args

            ()
            n, List.Cons(apply, args)

        member _.Protocol((n, args), protocol) =
            let apply (args: TrafficManagerProfileMonitorConfigArgs) =
                args.Protocol <- io protocol
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("timeoutInSeconds")>]
        member _.TimeoutInSeconds((n, args), timeoutInSeconds) =
            let apply (args: TrafficManagerProfileMonitorConfigArgs) =
                args.TimeoutInSeconds <- input timeoutInSeconds
                args

            ()
            n, List.Cons(apply, args)

        member _.TimeoutInSeconds((n, args), timeoutInSeconds) =
            let apply (args: TrafficManagerProfileMonitorConfigArgs) =
                args.TimeoutInSeconds <- io timeoutInSeconds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("toleratedNumberOfFailures")>]
        member _.ToleratedNumberOfFailures((n, args), toleratedNumberOfFailures) =
            let apply (args: TrafficManagerProfileMonitorConfigArgs) =
                args.ToleratedNumberOfFailures <- input toleratedNumberOfFailures
                args

            ()
            n, List.Cons(apply, args)

        member _.ToleratedNumberOfFailures((n, args), toleratedNumberOfFailures) =
            let apply (args: TrafficManagerProfileMonitorConfigArgs) =
                args.ToleratedNumberOfFailures <- io toleratedNumberOfFailures
                args

            ()
            n, List.Cons(apply, args)

    let trafficManagerProfileMonitorConfig =
        TrafficManagerProfileMonitorConfigBuilder()

    type TrafficManagerProfileMonitorConfigCustomHeaderBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (TrafficManagerProfileMonitorConfigCustomHeaderArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: TrafficManagerProfileMonitorConfigCustomHeaderArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: TrafficManagerProfileMonitorConfigCustomHeaderArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((n, args), value) =
            let apply (args: TrafficManagerProfileMonitorConfigCustomHeaderArgs) =
                args.Value <- input value
                args

            ()
            n, List.Cons(apply, args)

        member _.Value((n, args), value) =
            let apply (args: TrafficManagerProfileMonitorConfigCustomHeaderArgs) =
                args.Value <- io value
                args

            ()
            n, List.Cons(apply, args)

    let trafficManagerProfileMonitorConfigCustomHeader =
        TrafficManagerProfileMonitorConfigCustomHeaderBuilder()

    type VirtualHubRouteBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VirtualHubRouteArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("addressPrefixes")>]
        member _.AddressPrefixes((n, args), addressPrefixes) =
            let apply (args: VirtualHubRouteArgs) =
                args.AddressPrefixes <- inputList addressPrefixes
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("nextHopIpAddress")>]
        member _.NextHopIpAddress((n, args), nextHopIpAddress) =
            let apply (args: VirtualHubRouteArgs) =
                args.NextHopIpAddress <- input nextHopIpAddress
                args

            ()
            n, List.Cons(apply, args)

        member _.NextHopIpAddress((n, args), nextHopIpAddress) =
            let apply (args: VirtualHubRouteArgs) =
                args.NextHopIpAddress <- io nextHopIpAddress
                args

            ()
            n, List.Cons(apply, args)

    let virtualHubRoute = VirtualHubRouteBuilder()

    type VirtualNetworkDdosProtectionPlanBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VirtualNetworkDdosProtectionPlanArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("enable")>]
        member _.Enable((n, args), enable) =
            let apply (args: VirtualNetworkDdosProtectionPlanArgs) =
                args.Enable <- input enable
                args

            ()
            n, List.Cons(apply, args)

        member _.Enable((n, args), enable) =
            let apply (args: VirtualNetworkDdosProtectionPlanArgs) =
                args.Enable <- io enable
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: VirtualNetworkDdosProtectionPlanArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: VirtualNetworkDdosProtectionPlanArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

    let virtualNetworkDdosProtectionPlan =
        VirtualNetworkDdosProtectionPlanBuilder()

    type VirtualNetworkGatewayBgpSettingsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VirtualNetworkGatewayBgpSettingsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("asn")>]
        member _.Asn((n, args), asn) =
            let apply (args: VirtualNetworkGatewayBgpSettingsArgs) =
                args.Asn <- input asn
                args

            ()
            n, List.Cons(apply, args)

        member _.Asn((n, args), asn) =
            let apply (args: VirtualNetworkGatewayBgpSettingsArgs) =
                args.Asn <- io asn
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("peerWeight")>]
        member _.PeerWeight((n, args), peerWeight) =
            let apply (args: VirtualNetworkGatewayBgpSettingsArgs) =
                args.PeerWeight <- input peerWeight
                args

            ()
            n, List.Cons(apply, args)

        member _.PeerWeight((n, args), peerWeight) =
            let apply (args: VirtualNetworkGatewayBgpSettingsArgs) =
                args.PeerWeight <- io peerWeight
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("peeringAddress")>]
        member _.PeeringAddress((n, args), peeringAddress) =
            let apply (args: VirtualNetworkGatewayBgpSettingsArgs) =
                args.PeeringAddress <- input peeringAddress
                args

            ()
            n, List.Cons(apply, args)

        member _.PeeringAddress((n, args), peeringAddress) =
            let apply (args: VirtualNetworkGatewayBgpSettingsArgs) =
                args.PeeringAddress <- io peeringAddress
                args

            ()
            n, List.Cons(apply, args)

    let virtualNetworkGatewayBgpSettings =
        VirtualNetworkGatewayBgpSettingsBuilder()

    type VirtualNetworkGatewayConnectionIpsecPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VirtualNetworkGatewayConnectionIpsecPolicyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("dhGroup")>]
        member _.DhGroup((n, args), dhGroup) =
            let apply (args: VirtualNetworkGatewayConnectionIpsecPolicyArgs) =
                args.DhGroup <- input dhGroup
                args

            ()
            n, List.Cons(apply, args)

        member _.DhGroup((n, args), dhGroup) =
            let apply (args: VirtualNetworkGatewayConnectionIpsecPolicyArgs) =
                args.DhGroup <- io dhGroup
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ikeEncryption")>]
        member _.IkeEncryption((n, args), ikeEncryption) =
            let apply (args: VirtualNetworkGatewayConnectionIpsecPolicyArgs) =
                args.IkeEncryption <- input ikeEncryption
                args

            ()
            n, List.Cons(apply, args)

        member _.IkeEncryption((n, args), ikeEncryption) =
            let apply (args: VirtualNetworkGatewayConnectionIpsecPolicyArgs) =
                args.IkeEncryption <- io ikeEncryption
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ikeIntegrity")>]
        member _.IkeIntegrity((n, args), ikeIntegrity) =
            let apply (args: VirtualNetworkGatewayConnectionIpsecPolicyArgs) =
                args.IkeIntegrity <- input ikeIntegrity
                args

            ()
            n, List.Cons(apply, args)

        member _.IkeIntegrity((n, args), ikeIntegrity) =
            let apply (args: VirtualNetworkGatewayConnectionIpsecPolicyArgs) =
                args.IkeIntegrity <- io ikeIntegrity
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ipsecEncryption")>]
        member _.IpsecEncryption((n, args), ipsecEncryption) =
            let apply (args: VirtualNetworkGatewayConnectionIpsecPolicyArgs) =
                args.IpsecEncryption <- input ipsecEncryption
                args

            ()
            n, List.Cons(apply, args)

        member _.IpsecEncryption((n, args), ipsecEncryption) =
            let apply (args: VirtualNetworkGatewayConnectionIpsecPolicyArgs) =
                args.IpsecEncryption <- io ipsecEncryption
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ipsecIntegrity")>]
        member _.IpsecIntegrity((n, args), ipsecIntegrity) =
            let apply (args: VirtualNetworkGatewayConnectionIpsecPolicyArgs) =
                args.IpsecIntegrity <- input ipsecIntegrity
                args

            ()
            n, List.Cons(apply, args)

        member _.IpsecIntegrity((n, args), ipsecIntegrity) =
            let apply (args: VirtualNetworkGatewayConnectionIpsecPolicyArgs) =
                args.IpsecIntegrity <- io ipsecIntegrity
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("pfsGroup")>]
        member _.PfsGroup((n, args), pfsGroup) =
            let apply (args: VirtualNetworkGatewayConnectionIpsecPolicyArgs) =
                args.PfsGroup <- input pfsGroup
                args

            ()
            n, List.Cons(apply, args)

        member _.PfsGroup((n, args), pfsGroup) =
            let apply (args: VirtualNetworkGatewayConnectionIpsecPolicyArgs) =
                args.PfsGroup <- io pfsGroup
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("saDatasize")>]
        member _.SaDatasize((n, args), saDatasize) =
            let apply (args: VirtualNetworkGatewayConnectionIpsecPolicyArgs) =
                args.SaDatasize <- input saDatasize
                args

            ()
            n, List.Cons(apply, args)

        member _.SaDatasize((n, args), saDatasize) =
            let apply (args: VirtualNetworkGatewayConnectionIpsecPolicyArgs) =
                args.SaDatasize <- io saDatasize
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("saLifetime")>]
        member _.SaLifetime((n, args), saLifetime) =
            let apply (args: VirtualNetworkGatewayConnectionIpsecPolicyArgs) =
                args.SaLifetime <- input saLifetime
                args

            ()
            n, List.Cons(apply, args)

        member _.SaLifetime((n, args), saLifetime) =
            let apply (args: VirtualNetworkGatewayConnectionIpsecPolicyArgs) =
                args.SaLifetime <- io saLifetime
                args

            ()
            n, List.Cons(apply, args)

    let virtualNetworkGatewayConnectionIpsecPolicy =
        VirtualNetworkGatewayConnectionIpsecPolicyBuilder()

    type VirtualNetworkGatewayIpConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VirtualNetworkGatewayIpConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: VirtualNetworkGatewayIpConfigurationArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: VirtualNetworkGatewayIpConfigurationArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("privateIpAddressAllocation")>]
        member _.PrivateIpAddressAllocation((n, args), privateIpAddressAllocation) =
            let apply (args: VirtualNetworkGatewayIpConfigurationArgs) =
                args.PrivateIpAddressAllocation <- input privateIpAddressAllocation
                args

            ()
            n, List.Cons(apply, args)

        member _.PrivateIpAddressAllocation((n, args), privateIpAddressAllocation) =
            let apply (args: VirtualNetworkGatewayIpConfigurationArgs) =
                args.PrivateIpAddressAllocation <- io privateIpAddressAllocation
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publicIpAddressId")>]
        member _.PublicIpAddressId((n, args), publicIpAddressId) =
            let apply (args: VirtualNetworkGatewayIpConfigurationArgs) =
                args.PublicIpAddressId <- input publicIpAddressId
                args

            ()
            n, List.Cons(apply, args)

        member _.PublicIpAddressId((n, args), publicIpAddressId) =
            let apply (args: VirtualNetworkGatewayIpConfigurationArgs) =
                args.PublicIpAddressId <- io publicIpAddressId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: VirtualNetworkGatewayIpConfigurationArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: VirtualNetworkGatewayIpConfigurationArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

    let virtualNetworkGatewayIpConfiguration =
        VirtualNetworkGatewayIpConfigurationBuilder()

    type VirtualNetworkGatewayVpnClientConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VirtualNetworkGatewayVpnClientConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("addressSpaces")>]
        member _.AddressSpaces((n, args), addressSpaces) =
            let apply (args: VirtualNetworkGatewayVpnClientConfigurationArgs) =
                args.AddressSpaces <- inputList addressSpaces
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("radiusServerAddress")>]
        member _.RadiusServerAddress((n, args), radiusServerAddress) =
            let apply (args: VirtualNetworkGatewayVpnClientConfigurationArgs) =
                args.RadiusServerAddress <- input radiusServerAddress
                args

            ()
            n, List.Cons(apply, args)

        member _.RadiusServerAddress((n, args), radiusServerAddress) =
            let apply (args: VirtualNetworkGatewayVpnClientConfigurationArgs) =
                args.RadiusServerAddress <- io radiusServerAddress
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("radiusServerSecret")>]
        member _.RadiusServerSecret((n, args), radiusServerSecret) =
            let apply (args: VirtualNetworkGatewayVpnClientConfigurationArgs) =
                args.RadiusServerSecret <- input radiusServerSecret
                args

            ()
            n, List.Cons(apply, args)

        member _.RadiusServerSecret((n, args), radiusServerSecret) =
            let apply (args: VirtualNetworkGatewayVpnClientConfigurationArgs) =
                args.RadiusServerSecret <- io radiusServerSecret
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("revokedCertificates")>]
        member _.RevokedCertificates((n, args), revokedCertificates) =
            let apply (args: VirtualNetworkGatewayVpnClientConfigurationArgs) =
                args.RevokedCertificates <- inputList revokedCertificates
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("rootCertificates")>]
        member _.RootCertificates((n, args), rootCertificates) =
            let apply (args: VirtualNetworkGatewayVpnClientConfigurationArgs) =
                args.RootCertificates <- inputList rootCertificates
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("vpnClientProtocols")>]
        member _.VpnClientProtocols((n, args), vpnClientProtocols) =
            let apply (args: VirtualNetworkGatewayVpnClientConfigurationArgs) =
                args.VpnClientProtocols <- inputList vpnClientProtocols
                args

            ()
            n, List.Cons(apply, args)

    let virtualNetworkGatewayVpnClientConfiguration =
        VirtualNetworkGatewayVpnClientConfigurationBuilder()

    type VirtualNetworkGatewayVpnClientConfigurationRevokedCertificateBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VirtualNetworkGatewayVpnClientConfigurationRevokedCertificateArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: VirtualNetworkGatewayVpnClientConfigurationRevokedCertificateArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: VirtualNetworkGatewayVpnClientConfigurationRevokedCertificateArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("thumbprint")>]
        member _.Thumbprint((n, args), thumbprint) =
            let apply (args: VirtualNetworkGatewayVpnClientConfigurationRevokedCertificateArgs) =
                args.Thumbprint <- input thumbprint
                args

            ()
            n, List.Cons(apply, args)

        member _.Thumbprint((n, args), thumbprint) =
            let apply (args: VirtualNetworkGatewayVpnClientConfigurationRevokedCertificateArgs) =
                args.Thumbprint <- io thumbprint
                args

            ()
            n, List.Cons(apply, args)

    let virtualNetworkGatewayVpnClientConfigurationRevokedCertificate =
        VirtualNetworkGatewayVpnClientConfigurationRevokedCertificateBuilder()

    type VirtualNetworkGatewayVpnClientConfigurationRootCertificateBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VirtualNetworkGatewayVpnClientConfigurationRootCertificateArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: VirtualNetworkGatewayVpnClientConfigurationRootCertificateArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: VirtualNetworkGatewayVpnClientConfigurationRootCertificateArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publicCertData")>]
        member _.PublicCertData((n, args), publicCertData) =
            let apply (args: VirtualNetworkGatewayVpnClientConfigurationRootCertificateArgs) =
                args.PublicCertData <- input publicCertData
                args

            ()
            n, List.Cons(apply, args)

        member _.PublicCertData((n, args), publicCertData) =
            let apply (args: VirtualNetworkGatewayVpnClientConfigurationRootCertificateArgs) =
                args.PublicCertData <- io publicCertData
                args

            ()
            n, List.Cons(apply, args)

    let virtualNetworkGatewayVpnClientConfigurationRootCertificate =
        VirtualNetworkGatewayVpnClientConfigurationRootCertificateBuilder()

    type VirtualNetworkSubnetBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VirtualNetworkSubnetArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("addressPrefix")>]
        member _.AddressPrefix((n, args), addressPrefix) =
            let apply (args: VirtualNetworkSubnetArgs) =
                args.AddressPrefix <- input addressPrefix
                args

            ()
            n, List.Cons(apply, args)

        member _.AddressPrefix((n, args), addressPrefix) =
            let apply (args: VirtualNetworkSubnetArgs) =
                args.AddressPrefix <- io addressPrefix
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: VirtualNetworkSubnetArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: VirtualNetworkSubnetArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: VirtualNetworkSubnetArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: VirtualNetworkSubnetArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("securityGroup")>]
        member _.SecurityGroup((n, args), securityGroup) =
            let apply (args: VirtualNetworkSubnetArgs) =
                args.SecurityGroup <- input securityGroup
                args

            ()
            n, List.Cons(apply, args)

        member _.SecurityGroup((n, args), securityGroup) =
            let apply (args: VirtualNetworkSubnetArgs) =
                args.SecurityGroup <- io securityGroup
                args

            ()
            n, List.Cons(apply, args)

    let virtualNetworkSubnet = VirtualNetworkSubnetBuilder()

    type VpnGatewayBgpSettingBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VpnGatewayBgpSettingArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("asn")>]
        member _.Asn((n, args), asn) =
            let apply (args: VpnGatewayBgpSettingArgs) =
                args.Asn <- input asn
                args

            ()
            n, List.Cons(apply, args)

        member _.Asn((n, args), asn) =
            let apply (args: VpnGatewayBgpSettingArgs) =
                args.Asn <- io asn
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("bgpPeeringAddress")>]
        member _.BgpPeeringAddress((n, args), bgpPeeringAddress) =
            let apply (args: VpnGatewayBgpSettingArgs) =
                args.BgpPeeringAddress <- input bgpPeeringAddress
                args

            ()
            n, List.Cons(apply, args)

        member _.BgpPeeringAddress((n, args), bgpPeeringAddress) =
            let apply (args: VpnGatewayBgpSettingArgs) =
                args.BgpPeeringAddress <- io bgpPeeringAddress
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("peerWeight")>]
        member _.PeerWeight((n, args), peerWeight) =
            let apply (args: VpnGatewayBgpSettingArgs) =
                args.PeerWeight <- input peerWeight
                args

            ()
            n, List.Cons(apply, args)

        member _.PeerWeight((n, args), peerWeight) =
            let apply (args: VpnGatewayBgpSettingArgs) =
                args.PeerWeight <- io peerWeight
                args

            ()
            n, List.Cons(apply, args)

    let vpnGatewayBgpSetting = VpnGatewayBgpSettingBuilder()

    type VpnServerConfigurationAzureActiveDirectoryAuthenticationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VpnServerConfigurationAzureActiveDirectoryAuthenticationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("audience")>]
        member _.Audience((n, args), audience) =
            let apply (args: VpnServerConfigurationAzureActiveDirectoryAuthenticationArgs) =
                args.Audience <- input audience
                args

            ()
            n, List.Cons(apply, args)

        member _.Audience((n, args), audience) =
            let apply (args: VpnServerConfigurationAzureActiveDirectoryAuthenticationArgs) =
                args.Audience <- io audience
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("issuer")>]
        member _.Issuer((n, args), issuer) =
            let apply (args: VpnServerConfigurationAzureActiveDirectoryAuthenticationArgs) =
                args.Issuer <- input issuer
                args

            ()
            n, List.Cons(apply, args)

        member _.Issuer((n, args), issuer) =
            let apply (args: VpnServerConfigurationAzureActiveDirectoryAuthenticationArgs) =
                args.Issuer <- io issuer
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tenant")>]
        member _.Tenant((n, args), tenant) =
            let apply (args: VpnServerConfigurationAzureActiveDirectoryAuthenticationArgs) =
                args.Tenant <- input tenant
                args

            ()
            n, List.Cons(apply, args)

        member _.Tenant((n, args), tenant) =
            let apply (args: VpnServerConfigurationAzureActiveDirectoryAuthenticationArgs) =
                args.Tenant <- io tenant
                args

            ()
            n, List.Cons(apply, args)

    let vpnServerConfigurationAzureActiveDirectoryAuthentication =
        VpnServerConfigurationAzureActiveDirectoryAuthenticationBuilder()

    type VpnServerConfigurationClientRevokedCertificateBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VpnServerConfigurationClientRevokedCertificateArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: VpnServerConfigurationClientRevokedCertificateArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: VpnServerConfigurationClientRevokedCertificateArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("thumbprint")>]
        member _.Thumbprint((n, args), thumbprint) =
            let apply (args: VpnServerConfigurationClientRevokedCertificateArgs) =
                args.Thumbprint <- input thumbprint
                args

            ()
            n, List.Cons(apply, args)

        member _.Thumbprint((n, args), thumbprint) =
            let apply (args: VpnServerConfigurationClientRevokedCertificateArgs) =
                args.Thumbprint <- io thumbprint
                args

            ()
            n, List.Cons(apply, args)

    let vpnServerConfigurationClientRevokedCertificate =
        VpnServerConfigurationClientRevokedCertificateBuilder()

    type VpnServerConfigurationClientRootCertificateBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VpnServerConfigurationClientRootCertificateArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: VpnServerConfigurationClientRootCertificateArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: VpnServerConfigurationClientRootCertificateArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publicCertData")>]
        member _.PublicCertData((n, args), publicCertData) =
            let apply (args: VpnServerConfigurationClientRootCertificateArgs) =
                args.PublicCertData <- input publicCertData
                args

            ()
            n, List.Cons(apply, args)

        member _.PublicCertData((n, args), publicCertData) =
            let apply (args: VpnServerConfigurationClientRootCertificateArgs) =
                args.PublicCertData <- io publicCertData
                args

            ()
            n, List.Cons(apply, args)

    let vpnServerConfigurationClientRootCertificate =
        VpnServerConfigurationClientRootCertificateBuilder()

    type VpnServerConfigurationIpsecPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VpnServerConfigurationIpsecPolicyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("dhGroup")>]
        member _.DhGroup((n, args), dhGroup) =
            let apply (args: VpnServerConfigurationIpsecPolicyArgs) =
                args.DhGroup <- input dhGroup
                args

            ()
            n, List.Cons(apply, args)

        member _.DhGroup((n, args), dhGroup) =
            let apply (args: VpnServerConfigurationIpsecPolicyArgs) =
                args.DhGroup <- io dhGroup
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ikeEncryption")>]
        member _.IkeEncryption((n, args), ikeEncryption) =
            let apply (args: VpnServerConfigurationIpsecPolicyArgs) =
                args.IkeEncryption <- input ikeEncryption
                args

            ()
            n, List.Cons(apply, args)

        member _.IkeEncryption((n, args), ikeEncryption) =
            let apply (args: VpnServerConfigurationIpsecPolicyArgs) =
                args.IkeEncryption <- io ikeEncryption
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ikeIntegrity")>]
        member _.IkeIntegrity((n, args), ikeIntegrity) =
            let apply (args: VpnServerConfigurationIpsecPolicyArgs) =
                args.IkeIntegrity <- input ikeIntegrity
                args

            ()
            n, List.Cons(apply, args)

        member _.IkeIntegrity((n, args), ikeIntegrity) =
            let apply (args: VpnServerConfigurationIpsecPolicyArgs) =
                args.IkeIntegrity <- io ikeIntegrity
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ipsecEncryption")>]
        member _.IpsecEncryption((n, args), ipsecEncryption) =
            let apply (args: VpnServerConfigurationIpsecPolicyArgs) =
                args.IpsecEncryption <- input ipsecEncryption
                args

            ()
            n, List.Cons(apply, args)

        member _.IpsecEncryption((n, args), ipsecEncryption) =
            let apply (args: VpnServerConfigurationIpsecPolicyArgs) =
                args.IpsecEncryption <- io ipsecEncryption
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ipsecIntegrity")>]
        member _.IpsecIntegrity((n, args), ipsecIntegrity) =
            let apply (args: VpnServerConfigurationIpsecPolicyArgs) =
                args.IpsecIntegrity <- input ipsecIntegrity
                args

            ()
            n, List.Cons(apply, args)

        member _.IpsecIntegrity((n, args), ipsecIntegrity) =
            let apply (args: VpnServerConfigurationIpsecPolicyArgs) =
                args.IpsecIntegrity <- io ipsecIntegrity
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("pfsGroup")>]
        member _.PfsGroup((n, args), pfsGroup) =
            let apply (args: VpnServerConfigurationIpsecPolicyArgs) =
                args.PfsGroup <- input pfsGroup
                args

            ()
            n, List.Cons(apply, args)

        member _.PfsGroup((n, args), pfsGroup) =
            let apply (args: VpnServerConfigurationIpsecPolicyArgs) =
                args.PfsGroup <- io pfsGroup
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("saDataSizeKilobytes")>]
        member _.SaDataSizeKilobytes((n, args), saDataSizeKilobytes) =
            let apply (args: VpnServerConfigurationIpsecPolicyArgs) =
                args.SaDataSizeKilobytes <- input saDataSizeKilobytes
                args

            ()
            n, List.Cons(apply, args)

        member _.SaDataSizeKilobytes((n, args), saDataSizeKilobytes) =
            let apply (args: VpnServerConfigurationIpsecPolicyArgs) =
                args.SaDataSizeKilobytes <- io saDataSizeKilobytes
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("saLifetimeSeconds")>]
        member _.SaLifetimeSeconds((n, args), saLifetimeSeconds) =
            let apply (args: VpnServerConfigurationIpsecPolicyArgs) =
                args.SaLifetimeSeconds <- input saLifetimeSeconds
                args

            ()
            n, List.Cons(apply, args)

        member _.SaLifetimeSeconds((n, args), saLifetimeSeconds) =
            let apply (args: VpnServerConfigurationIpsecPolicyArgs) =
                args.SaLifetimeSeconds <- io saLifetimeSeconds
                args

            ()
            n, List.Cons(apply, args)

    let vpnServerConfigurationIpsecPolicy =
        VpnServerConfigurationIpsecPolicyBuilder()

    type VpnServerConfigurationRadiusServerBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VpnServerConfigurationRadiusServerArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("address")>]
        member _.Address((n, args), address) =
            let apply (args: VpnServerConfigurationRadiusServerArgs) =
                args.Address <- input address
                args

            ()
            n, List.Cons(apply, args)

        member _.Address((n, args), address) =
            let apply (args: VpnServerConfigurationRadiusServerArgs) =
                args.Address <- io address
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("clientRootCertificates")>]
        member _.ClientRootCertificates((n, args), clientRootCertificates) =
            let apply (args: VpnServerConfigurationRadiusServerArgs) =
                args.ClientRootCertificates <- inputList clientRootCertificates
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("secret")>]
        member _.Secret((n, args), secret) =
            let apply (args: VpnServerConfigurationRadiusServerArgs) =
                args.Secret <- input secret
                args

            ()
            n, List.Cons(apply, args)

        member _.Secret((n, args), secret) =
            let apply (args: VpnServerConfigurationRadiusServerArgs) =
                args.Secret <- io secret
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("serverRootCertificates")>]
        member _.ServerRootCertificates((n, args), serverRootCertificates) =
            let apply (args: VpnServerConfigurationRadiusServerArgs) =
                args.ServerRootCertificates <- inputList serverRootCertificates
                args

            ()
            n, List.Cons(apply, args)

    let vpnServerConfigurationRadiusServer =
        VpnServerConfigurationRadiusServerBuilder()

    type VpnServerConfigurationRadiusServerClientRootCertificateBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VpnServerConfigurationRadiusServerClientRootCertificateArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: VpnServerConfigurationRadiusServerClientRootCertificateArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: VpnServerConfigurationRadiusServerClientRootCertificateArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("thumbprint")>]
        member _.Thumbprint((n, args), thumbprint) =
            let apply (args: VpnServerConfigurationRadiusServerClientRootCertificateArgs) =
                args.Thumbprint <- input thumbprint
                args

            ()
            n, List.Cons(apply, args)

        member _.Thumbprint((n, args), thumbprint) =
            let apply (args: VpnServerConfigurationRadiusServerClientRootCertificateArgs) =
                args.Thumbprint <- io thumbprint
                args

            ()
            n, List.Cons(apply, args)

    let vpnServerConfigurationRadiusServerClientRootCertificate =
        VpnServerConfigurationRadiusServerClientRootCertificateBuilder()

    type VpnServerConfigurationRadiusServerServerRootCertificateBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (VpnServerConfigurationRadiusServerServerRootCertificateArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: VpnServerConfigurationRadiusServerServerRootCertificateArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: VpnServerConfigurationRadiusServerServerRootCertificateArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publicCertData")>]
        member _.PublicCertData((n, args), publicCertData) =
            let apply (args: VpnServerConfigurationRadiusServerServerRootCertificateArgs) =
                args.PublicCertData <- input publicCertData
                args

            ()
            n, List.Cons(apply, args)

        member _.PublicCertData((n, args), publicCertData) =
            let apply (args: VpnServerConfigurationRadiusServerServerRootCertificateArgs) =
                args.PublicCertData <- io publicCertData
                args

            ()
            n, List.Cons(apply, args)

    let vpnServerConfigurationRadiusServerServerRootCertificate =
        VpnServerConfigurationRadiusServerServerRootCertificateBuilder()

    type ApplicationGatewayBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ApplicationGateway(name, (List.fold func (ApplicationGatewayArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("authenticationCertificates")>]
        member _.AuthenticationCertificates((name, args), authenticationCertificates) =
            let apply (args: ApplicationGatewayArgs) =
                args.AuthenticationCertificates <- inputList authenticationCertificates
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ApplicationGatewayArgs) =
                   args.AutoscaleConfiguration <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("backendAddressPools")>]
        member _.BackendAddressPools((name, args), backendAddressPools) =
            let apply (args: ApplicationGatewayArgs) =
                args.BackendAddressPools <- inputList backendAddressPools
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("backendHttpSettings")>]
        member _.BackendHttpSettings((name, args), backendHttpSettings) =
            let apply (args: ApplicationGatewayArgs) =
                args.BackendHttpSettings <- inputList backendHttpSettings
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("customErrorConfigurations")>]
        member _.CustomErrorConfigurations((name, args), customErrorConfigurations) =
            let apply (args: ApplicationGatewayArgs) =
                args.CustomErrorConfigurations <- inputList customErrorConfigurations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enableHttp2")>]
        member _.EnableHttp2((name, args), enableHttp2) =
            let apply (args: ApplicationGatewayArgs) =
                args.EnableHttp2 <- input enableHttp2
                args

            ()
            name, List.Cons(apply, args)

        member _.EnableHttp2((name, args), enableHttp2) =
            let apply (args: ApplicationGatewayArgs) =
                args.EnableHttp2 <- io enableHttp2
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("firewallPolicyId")>]
        member _.FirewallPolicyId((name, args), firewallPolicyId) =
            let apply (args: ApplicationGatewayArgs) =
                args.FirewallPolicyId <- input firewallPolicyId
                args

            ()
            name, List.Cons(apply, args)

        member _.FirewallPolicyId((name, args), firewallPolicyId) =
            let apply (args: ApplicationGatewayArgs) =
                args.FirewallPolicyId <- io firewallPolicyId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("frontendIpConfigurations")>]
        member _.FrontendIpConfigurations((name, args), frontendIpConfigurations) =
            let apply (args: ApplicationGatewayArgs) =
                args.FrontendIpConfigurations <- inputList frontendIpConfigurations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("frontendPorts")>]
        member _.FrontendPorts((name, args), frontendPorts) =
            let apply (args: ApplicationGatewayArgs) =
                args.FrontendPorts <- inputList frontendPorts
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("gatewayIpConfigurations")>]
        member _.GatewayIpConfigurations((name, args), gatewayIpConfigurations) =
            let apply (args: ApplicationGatewayArgs) =
                args.GatewayIpConfigurations <- inputList gatewayIpConfigurations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("httpListeners")>]
        member _.HttpListeners((name, args), httpListeners) =
            let apply (args: ApplicationGatewayArgs) =
                args.HttpListeners <- inputList httpListeners
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ApplicationGatewayArgs) =
                   args.Identity <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ApplicationGatewayArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ApplicationGatewayArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ApplicationGatewayArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ApplicationGatewayArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("probes")>]
        member _.Probes((name, args), probes) =
            let apply (args: ApplicationGatewayArgs) =
                args.Probes <- inputList probes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("redirectConfigurations")>]
        member _.RedirectConfigurations((name, args), redirectConfigurations) =
            let apply (args: ApplicationGatewayArgs) =
                args.RedirectConfigurations <- inputList redirectConfigurations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("requestRoutingRules")>]
        member _.RequestRoutingRules((name, args), requestRoutingRules) =
            let apply (args: ApplicationGatewayArgs) =
                args.RequestRoutingRules <- inputList requestRoutingRules
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ApplicationGatewayArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ApplicationGatewayArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("rewriteRuleSets")>]
        member _.RewriteRuleSets((name, args), rewriteRuleSets) =
            let apply (args: ApplicationGatewayArgs) =
                args.RewriteRuleSets <- inputList rewriteRuleSets
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ApplicationGatewayArgs) =
                   args.Sku <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("sslCertificates")>]
        member _.SslCertificates((name, args), sslCertificates) =
            let apply (args: ApplicationGatewayArgs) =
                args.SslCertificates <- inputList sslCertificates
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sslPolicies")>]
        member _.SslPolicies((name, args), sslPolicies) =
            let apply (args: ApplicationGatewayArgs) =
                args.SslPolicies <- inputList sslPolicies
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ApplicationGatewayArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("trustedRootCertificates")>]
        member _.TrustedRootCertificates((name, args), trustedRootCertificates) =
            let apply (args: ApplicationGatewayArgs) =
                args.TrustedRootCertificates <- inputList trustedRootCertificates
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("urlPathMaps")>]
        member _.UrlPathMaps((name, args), urlPathMaps) =
            let apply (args: ApplicationGatewayArgs) =
                args.UrlPathMaps <- inputList urlPathMaps
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ApplicationGatewayArgs) =
                   args.WafConfiguration <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("zones")>]
        member _.Zones((name, args), zones) =
            let apply (args: ApplicationGatewayArgs) =
                args.Zones <- inputList zones
                args

            ()
            name, List.Cons(apply, args)

    let applicationGateway = ApplicationGatewayBuilder()

    type ApplicationSecurityGroupBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ApplicationSecurityGroup(name, (List.fold func (ApplicationSecurityGroupArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ApplicationSecurityGroupArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ApplicationSecurityGroupArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ApplicationSecurityGroupArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ApplicationSecurityGroupArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ApplicationSecurityGroupArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ApplicationSecurityGroupArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ApplicationSecurityGroupArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let applicationSecurityGroup = ApplicationSecurityGroupBuilder()

    type DdosProtectionPlanBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            DdosProtectionPlan(name, (List.fold func (DdosProtectionPlanArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: DdosProtectionPlanArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: DdosProtectionPlanArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: DdosProtectionPlanArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: DdosProtectionPlanArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DdosProtectionPlanArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DdosProtectionPlanArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: DdosProtectionPlanArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let ddosProtectionPlan = DdosProtectionPlanBuilder()

    type ExpressRouteCircuitBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ExpressRouteCircuit(name, (List.fold func (ExpressRouteCircuitArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("allowClassicOperations")>]
        member _.AllowClassicOperations((name, args), allowClassicOperations) =
            let apply (args: ExpressRouteCircuitArgs) =
                args.AllowClassicOperations <- input allowClassicOperations
                args

            ()
            name, List.Cons(apply, args)

        member _.AllowClassicOperations((name, args), allowClassicOperations) =
            let apply (args: ExpressRouteCircuitArgs) =
                args.AllowClassicOperations <- io allowClassicOperations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("bandwidthInMbps")>]
        member _.BandwidthInMbps((name, args), bandwidthInMbps) =
            let apply (args: ExpressRouteCircuitArgs) =
                args.BandwidthInMbps <- input bandwidthInMbps
                args

            ()
            name, List.Cons(apply, args)

        member _.BandwidthInMbps((name, args), bandwidthInMbps) =
            let apply (args: ExpressRouteCircuitArgs) =
                args.BandwidthInMbps <- io bandwidthInMbps
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ExpressRouteCircuitArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ExpressRouteCircuitArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ExpressRouteCircuitArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ExpressRouteCircuitArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("peeringLocation")>]
        member _.PeeringLocation((name, args), peeringLocation) =
            let apply (args: ExpressRouteCircuitArgs) =
                args.PeeringLocation <- input peeringLocation
                args

            ()
            name, List.Cons(apply, args)

        member _.PeeringLocation((name, args), peeringLocation) =
            let apply (args: ExpressRouteCircuitArgs) =
                args.PeeringLocation <- io peeringLocation
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ExpressRouteCircuitArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ExpressRouteCircuitArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serviceProviderName")>]
        member _.ServiceProviderName((name, args), serviceProviderName) =
            let apply (args: ExpressRouteCircuitArgs) =
                args.ServiceProviderName <- input serviceProviderName
                args

            ()
            name, List.Cons(apply, args)

        member _.ServiceProviderName((name, args), serviceProviderName) =
            let apply (args: ExpressRouteCircuitArgs) =
                args.ServiceProviderName <- io serviceProviderName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ExpressRouteCircuitArgs) =
                   args.Sku <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ExpressRouteCircuitArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let expressRouteCircuit = ExpressRouteCircuitBuilder()

    type ExpressRouteCircuitAuthorizationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ExpressRouteCircuitAuthorization(name, (List.fold func (ExpressRouteCircuitAuthorizationArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("expressRouteCircuitName")>]
        member _.ExpressRouteCircuitName((name, args), expressRouteCircuitName) =
            let apply (args: ExpressRouteCircuitAuthorizationArgs) =
                args.ExpressRouteCircuitName <- input expressRouteCircuitName
                args

            ()
            name, List.Cons(apply, args)

        member _.ExpressRouteCircuitName((name, args), expressRouteCircuitName) =
            let apply (args: ExpressRouteCircuitAuthorizationArgs) =
                args.ExpressRouteCircuitName <- io expressRouteCircuitName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ExpressRouteCircuitAuthorizationArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ExpressRouteCircuitAuthorizationArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ExpressRouteCircuitAuthorizationArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ExpressRouteCircuitAuthorizationArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let expressRouteCircuitAuthorization =
        ExpressRouteCircuitAuthorizationBuilder()

    type ExpressRouteCircuitPeeringBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ExpressRouteCircuitPeering(name, (List.fold func (ExpressRouteCircuitPeeringArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("expressRouteCircuitName")>]
        member _.ExpressRouteCircuitName((name, args), expressRouteCircuitName) =
            let apply (args: ExpressRouteCircuitPeeringArgs) =
                args.ExpressRouteCircuitName <- input expressRouteCircuitName
                args

            ()
            name, List.Cons(apply, args)

        member _.ExpressRouteCircuitName((name, args), expressRouteCircuitName) =
            let apply (args: ExpressRouteCircuitPeeringArgs) =
                args.ExpressRouteCircuitName <- io expressRouteCircuitName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ExpressRouteCircuitPeeringArgs) =
                   args.MicrosoftPeeringConfig <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("peerAsn")>]
        member _.PeerAsn((name, args), peerAsn) =
            let apply (args: ExpressRouteCircuitPeeringArgs) =
                args.PeerAsn <- input peerAsn
                args

            ()
            name, List.Cons(apply, args)

        member _.PeerAsn((name, args), peerAsn) =
            let apply (args: ExpressRouteCircuitPeeringArgs) =
                args.PeerAsn <- io peerAsn
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("peeringType")>]
        member _.PeeringType((name, args), peeringType) =
            let apply (args: ExpressRouteCircuitPeeringArgs) =
                args.PeeringType <- input peeringType
                args

            ()
            name, List.Cons(apply, args)

        member _.PeeringType((name, args), peeringType) =
            let apply (args: ExpressRouteCircuitPeeringArgs) =
                args.PeeringType <- io peeringType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("primaryPeerAddressPrefix")>]
        member _.PrimaryPeerAddressPrefix((name, args), primaryPeerAddressPrefix) =
            let apply (args: ExpressRouteCircuitPeeringArgs) =
                args.PrimaryPeerAddressPrefix <- input primaryPeerAddressPrefix
                args

            ()
            name, List.Cons(apply, args)

        member _.PrimaryPeerAddressPrefix((name, args), primaryPeerAddressPrefix) =
            let apply (args: ExpressRouteCircuitPeeringArgs) =
                args.PrimaryPeerAddressPrefix <- io primaryPeerAddressPrefix
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ExpressRouteCircuitPeeringArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ExpressRouteCircuitPeeringArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("secondaryPeerAddressPrefix")>]
        member _.SecondaryPeerAddressPrefix((name, args), secondaryPeerAddressPrefix) =
            let apply (args: ExpressRouteCircuitPeeringArgs) =
                args.SecondaryPeerAddressPrefix <- input secondaryPeerAddressPrefix
                args

            ()
            name, List.Cons(apply, args)

        member _.SecondaryPeerAddressPrefix((name, args), secondaryPeerAddressPrefix) =
            let apply (args: ExpressRouteCircuitPeeringArgs) =
                args.SecondaryPeerAddressPrefix <- io secondaryPeerAddressPrefix
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sharedKey")>]
        member _.SharedKey((name, args), sharedKey) =
            let apply (args: ExpressRouteCircuitPeeringArgs) =
                args.SharedKey <- input sharedKey
                args

            ()
            name, List.Cons(apply, args)

        member _.SharedKey((name, args), sharedKey) =
            let apply (args: ExpressRouteCircuitPeeringArgs) =
                args.SharedKey <- io sharedKey
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("vlanId")>]
        member _.VlanId((name, args), vlanId) =
            let apply (args: ExpressRouteCircuitPeeringArgs) =
                args.VlanId <- input vlanId
                args

            ()
            name, List.Cons(apply, args)

        member _.VlanId((name, args), vlanId) =
            let apply (args: ExpressRouteCircuitPeeringArgs) =
                args.VlanId <- io vlanId
                args

            ()
            name, List.Cons(apply, args)

    let expressRouteCircuitPeering = ExpressRouteCircuitPeeringBuilder()

    type ExpressRouteGatewayBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ExpressRouteGateway(name, (List.fold func (ExpressRouteGatewayArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ExpressRouteGatewayArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ExpressRouteGatewayArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ExpressRouteGatewayArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ExpressRouteGatewayArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ExpressRouteGatewayArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ExpressRouteGatewayArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("scaleUnits")>]
        member _.ScaleUnits((name, args), scaleUnits) =
            let apply (args: ExpressRouteGatewayArgs) =
                args.ScaleUnits <- input scaleUnits
                args

            ()
            name, List.Cons(apply, args)

        member _.ScaleUnits((name, args), scaleUnits) =
            let apply (args: ExpressRouteGatewayArgs) =
                args.ScaleUnits <- io scaleUnits
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ExpressRouteGatewayArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("virtualHubId")>]
        member _.VirtualHubId((name, args), virtualHubId) =
            let apply (args: ExpressRouteGatewayArgs) =
                args.VirtualHubId <- input virtualHubId
                args

            ()
            name, List.Cons(apply, args)

        member _.VirtualHubId((name, args), virtualHubId) =
            let apply (args: ExpressRouteGatewayArgs) =
                args.VirtualHubId <- io virtualHubId
                args

            ()
            name, List.Cons(apply, args)

    let expressRouteGateway = ExpressRouteGatewayBuilder()

    type FirewallBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Firewall(name, (List.fold func (FirewallArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("ipConfigurations")>]
        member _.IpConfigurations((name, args), ipConfigurations) =
            let apply (args: FirewallArgs) =
                args.IpConfigurations <- inputList ipConfigurations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: FirewallArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: FirewallArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: FirewallArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: FirewallArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FirewallArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FirewallArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: FirewallArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("threatIntelMode")>]
        member _.ThreatIntelMode((name, args), threatIntelMode) =
            let apply (args: FirewallArgs) =
                args.ThreatIntelMode <- input threatIntelMode
                args

            ()
            name, List.Cons(apply, args)

        member _.ThreatIntelMode((name, args), threatIntelMode) =
            let apply (args: FirewallArgs) =
                args.ThreatIntelMode <- io threatIntelMode
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zones")>]
        member _.Zones((name, args), zones) =
            let apply (args: FirewallArgs) =
                args.Zones <- inputList zones
                args

            ()
            name, List.Cons(apply, args)

    let firewall = FirewallBuilder()

    type FirewallApplicationRuleCollectionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            FirewallApplicationRuleCollection(name, (List.fold func (FirewallApplicationRuleCollectionArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("action")>]
        member _.Action((name, args), action) =
            let apply (args: FirewallApplicationRuleCollectionArgs) =
                args.Action <- input action
                args

            ()
            name, List.Cons(apply, args)

        member _.Action((name, args), action) =
            let apply (args: FirewallApplicationRuleCollectionArgs) =
                args.Action <- io action
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("azureFirewallName")>]
        member _.AzureFirewallName((name, args), azureFirewallName) =
            let apply (args: FirewallApplicationRuleCollectionArgs) =
                args.AzureFirewallName <- input azureFirewallName
                args

            ()
            name, List.Cons(apply, args)

        member _.AzureFirewallName((name, args), azureFirewallName) =
            let apply (args: FirewallApplicationRuleCollectionArgs) =
                args.AzureFirewallName <- io azureFirewallName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: FirewallApplicationRuleCollectionArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: FirewallApplicationRuleCollectionArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("priority")>]
        member _.Priority((name, args), priority) =
            let apply (args: FirewallApplicationRuleCollectionArgs) =
                args.Priority <- input priority
                args

            ()
            name, List.Cons(apply, args)

        member _.Priority((name, args), priority) =
            let apply (args: FirewallApplicationRuleCollectionArgs) =
                args.Priority <- io priority
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FirewallApplicationRuleCollectionArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FirewallApplicationRuleCollectionArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("rules")>]
        member _.Rules((name, args), rules) =
            let apply (args: FirewallApplicationRuleCollectionArgs) =
                args.Rules <- inputList rules
                args

            ()
            name, List.Cons(apply, args)

    let firewallApplicationRuleCollection =
        FirewallApplicationRuleCollectionBuilder()

    type FirewallNatRuleCollectionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            FirewallNatRuleCollection(name, (List.fold func (FirewallNatRuleCollectionArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("action")>]
        member _.Action((name, args), action) =
            let apply (args: FirewallNatRuleCollectionArgs) =
                args.Action <- input action
                args

            ()
            name, List.Cons(apply, args)

        member _.Action((name, args), action) =
            let apply (args: FirewallNatRuleCollectionArgs) =
                args.Action <- io action
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("azureFirewallName")>]
        member _.AzureFirewallName((name, args), azureFirewallName) =
            let apply (args: FirewallNatRuleCollectionArgs) =
                args.AzureFirewallName <- input azureFirewallName
                args

            ()
            name, List.Cons(apply, args)

        member _.AzureFirewallName((name, args), azureFirewallName) =
            let apply (args: FirewallNatRuleCollectionArgs) =
                args.AzureFirewallName <- io azureFirewallName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: FirewallNatRuleCollectionArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: FirewallNatRuleCollectionArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("priority")>]
        member _.Priority((name, args), priority) =
            let apply (args: FirewallNatRuleCollectionArgs) =
                args.Priority <- input priority
                args

            ()
            name, List.Cons(apply, args)

        member _.Priority((name, args), priority) =
            let apply (args: FirewallNatRuleCollectionArgs) =
                args.Priority <- io priority
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FirewallNatRuleCollectionArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FirewallNatRuleCollectionArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("rules")>]
        member _.Rules((name, args), rules) =
            let apply (args: FirewallNatRuleCollectionArgs) =
                args.Rules <- inputList rules
                args

            ()
            name, List.Cons(apply, args)

    let firewallNatRuleCollection = FirewallNatRuleCollectionBuilder()

    type FirewallNetworkRuleCollectionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            FirewallNetworkRuleCollection(name, (List.fold func (FirewallNetworkRuleCollectionArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("action")>]
        member _.Action((name, args), action) =
            let apply (args: FirewallNetworkRuleCollectionArgs) =
                args.Action <- input action
                args

            ()
            name, List.Cons(apply, args)

        member _.Action((name, args), action) =
            let apply (args: FirewallNetworkRuleCollectionArgs) =
                args.Action <- io action
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("azureFirewallName")>]
        member _.AzureFirewallName((name, args), azureFirewallName) =
            let apply (args: FirewallNetworkRuleCollectionArgs) =
                args.AzureFirewallName <- input azureFirewallName
                args

            ()
            name, List.Cons(apply, args)

        member _.AzureFirewallName((name, args), azureFirewallName) =
            let apply (args: FirewallNetworkRuleCollectionArgs) =
                args.AzureFirewallName <- io azureFirewallName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: FirewallNetworkRuleCollectionArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: FirewallNetworkRuleCollectionArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("priority")>]
        member _.Priority((name, args), priority) =
            let apply (args: FirewallNetworkRuleCollectionArgs) =
                args.Priority <- input priority
                args

            ()
            name, List.Cons(apply, args)

        member _.Priority((name, args), priority) =
            let apply (args: FirewallNetworkRuleCollectionArgs) =
                args.Priority <- io priority
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FirewallNetworkRuleCollectionArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FirewallNetworkRuleCollectionArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("rules")>]
        member _.Rules((name, args), rules) =
            let apply (args: FirewallNetworkRuleCollectionArgs) =
                args.Rules <- inputList rules
                args

            ()
            name, List.Cons(apply, args)

    let firewallNetworkRuleCollection = FirewallNetworkRuleCollectionBuilder()

    type LocalNetworkGatewayBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            LocalNetworkGateway(name, (List.fold func (LocalNetworkGatewayArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("addressSpaces")>]
        member _.AddressSpaces((name, args), addressSpaces) =
            let apply (args: LocalNetworkGatewayArgs) =
                args.AddressSpaces <- inputList addressSpaces
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: LocalNetworkGatewayArgs) =
                   args.BgpSettings <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("gatewayAddress")>]
        member _.GatewayAddress((name, args), gatewayAddress) =
            let apply (args: LocalNetworkGatewayArgs) =
                args.GatewayAddress <- input gatewayAddress
                args

            ()
            name, List.Cons(apply, args)

        member _.GatewayAddress((name, args), gatewayAddress) =
            let apply (args: LocalNetworkGatewayArgs) =
                args.GatewayAddress <- io gatewayAddress
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: LocalNetworkGatewayArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: LocalNetworkGatewayArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: LocalNetworkGatewayArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: LocalNetworkGatewayArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: LocalNetworkGatewayArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: LocalNetworkGatewayArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: LocalNetworkGatewayArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let localNetworkGateway = LocalNetworkGatewayBuilder()

    type NatGatewayBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            NatGateway(name, (List.fold func (NatGatewayArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("idleTimeoutInMinutes")>]
        member _.IdleTimeoutInMinutes((name, args), idleTimeoutInMinutes) =
            let apply (args: NatGatewayArgs) =
                args.IdleTimeoutInMinutes <- input idleTimeoutInMinutes
                args

            ()
            name, List.Cons(apply, args)

        member _.IdleTimeoutInMinutes((name, args), idleTimeoutInMinutes) =
            let apply (args: NatGatewayArgs) =
                args.IdleTimeoutInMinutes <- io idleTimeoutInMinutes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: NatGatewayArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: NatGatewayArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: NatGatewayArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: NatGatewayArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("publicIpAddressIds")>]
        member _.PublicIpAddressIds((name, args), publicIpAddressIds) =
            let apply (args: NatGatewayArgs) =
                args.PublicIpAddressIds <- inputList publicIpAddressIds
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("publicIpPrefixIds")>]
        member _.PublicIpPrefixIds((name, args), publicIpPrefixIds) =
            let apply (args: NatGatewayArgs) =
                args.PublicIpPrefixIds <- inputList publicIpPrefixIds
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NatGatewayArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NatGatewayArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("skuName")>]
        member _.SkuName((name, args), skuName) =
            let apply (args: NatGatewayArgs) =
                args.SkuName <- input skuName
                args

            ()
            name, List.Cons(apply, args)

        member _.SkuName((name, args), skuName) =
            let apply (args: NatGatewayArgs) =
                args.SkuName <- io skuName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: NatGatewayArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zones")>]
        member _.Zones((name, args), zones) =
            let apply (args: NatGatewayArgs) =
                args.Zones <- inputList zones
                args

            ()
            name, List.Cons(apply, args)

    let natGateway = NatGatewayBuilder()

    type NatGatewayPublicIpAssociationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            NatGatewayPublicIpAssociation(name, (List.fold func (NatGatewayPublicIpAssociationArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("natGatewayId")>]
        member _.NatGatewayId((name, args), natGatewayId) =
            let apply (args: NatGatewayPublicIpAssociationArgs) =
                args.NatGatewayId <- input natGatewayId
                args

            ()
            name, List.Cons(apply, args)

        member _.NatGatewayId((name, args), natGatewayId) =
            let apply (args: NatGatewayPublicIpAssociationArgs) =
                args.NatGatewayId <- io natGatewayId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("publicIpAddressId")>]
        member _.PublicIpAddressId((name, args), publicIpAddressId) =
            let apply (args: NatGatewayPublicIpAssociationArgs) =
                args.PublicIpAddressId <- input publicIpAddressId
                args

            ()
            name, List.Cons(apply, args)

        member _.PublicIpAddressId((name, args), publicIpAddressId) =
            let apply (args: NatGatewayPublicIpAssociationArgs) =
                args.PublicIpAddressId <- io publicIpAddressId
                args

            ()
            name, List.Cons(apply, args)

    let natGatewayPublicIpAssociation = NatGatewayPublicIpAssociationBuilder()

    type NetworkConnectionMonitorBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            NetworkConnectionMonitor(name, (List.fold func (NetworkConnectionMonitorArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("autoStart")>]
        member _.AutoStart((name, args), autoStart) =
            let apply (args: NetworkConnectionMonitorArgs) =
                args.AutoStart <- input autoStart
                args

            ()
            name, List.Cons(apply, args)

        member _.AutoStart((name, args), autoStart) =
            let apply (args: NetworkConnectionMonitorArgs) =
                args.AutoStart <- io autoStart
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: NetworkConnectionMonitorArgs) =
                   args.Destination <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("intervalInSeconds")>]
        member _.IntervalInSeconds((name, args), intervalInSeconds) =
            let apply (args: NetworkConnectionMonitorArgs) =
                args.IntervalInSeconds <- input intervalInSeconds
                args

            ()
            name, List.Cons(apply, args)

        member _.IntervalInSeconds((name, args), intervalInSeconds) =
            let apply (args: NetworkConnectionMonitorArgs) =
                args.IntervalInSeconds <- io intervalInSeconds
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: NetworkConnectionMonitorArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: NetworkConnectionMonitorArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: NetworkConnectionMonitorArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: NetworkConnectionMonitorArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("networkWatcherName")>]
        member _.NetworkWatcherName((name, args), networkWatcherName) =
            let apply (args: NetworkConnectionMonitorArgs) =
                args.NetworkWatcherName <- input networkWatcherName
                args

            ()
            name, List.Cons(apply, args)

        member _.NetworkWatcherName((name, args), networkWatcherName) =
            let apply (args: NetworkConnectionMonitorArgs) =
                args.NetworkWatcherName <- io networkWatcherName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NetworkConnectionMonitorArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NetworkConnectionMonitorArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: NetworkConnectionMonitorArgs) =
                   args.Source <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: NetworkConnectionMonitorArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let networkConnectionMonitor = NetworkConnectionMonitorBuilder()

    type NetworkInterfaceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            NetworkInterface(name, (List.fold func (NetworkInterfaceArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("dnsServers")>]
        member _.DnsServers((name, args), dnsServers) =
            let apply (args: NetworkInterfaceArgs) =
                args.DnsServers <- inputList dnsServers
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enableAcceleratedNetworking")>]
        member _.EnableAcceleratedNetworking((name, args), enableAcceleratedNetworking) =
            let apply (args: NetworkInterfaceArgs) =
                args.EnableAcceleratedNetworking <- input enableAcceleratedNetworking
                args

            ()
            name, List.Cons(apply, args)

        member _.EnableAcceleratedNetworking((name, args), enableAcceleratedNetworking) =
            let apply (args: NetworkInterfaceArgs) =
                args.EnableAcceleratedNetworking <- io enableAcceleratedNetworking
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enableIpForwarding")>]
        member _.EnableIpForwarding((name, args), enableIpForwarding) =
            let apply (args: NetworkInterfaceArgs) =
                args.EnableIpForwarding <- input enableIpForwarding
                args

            ()
            name, List.Cons(apply, args)

        member _.EnableIpForwarding((name, args), enableIpForwarding) =
            let apply (args: NetworkInterfaceArgs) =
                args.EnableIpForwarding <- io enableIpForwarding
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("internalDnsNameLabel")>]
        member _.InternalDnsNameLabel((name, args), internalDnsNameLabel) =
            let apply (args: NetworkInterfaceArgs) =
                args.InternalDnsNameLabel <- input internalDnsNameLabel
                args

            ()
            name, List.Cons(apply, args)

        member _.InternalDnsNameLabel((name, args), internalDnsNameLabel) =
            let apply (args: NetworkInterfaceArgs) =
                args.InternalDnsNameLabel <- io internalDnsNameLabel
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("ipConfigurations")>]
        member _.IpConfigurations((name, args), ipConfigurations) =
            let apply (args: NetworkInterfaceArgs) =
                args.IpConfigurations <- inputList ipConfigurations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: NetworkInterfaceArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: NetworkInterfaceArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: NetworkInterfaceArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: NetworkInterfaceArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NetworkInterfaceArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NetworkInterfaceArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: NetworkInterfaceArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let networkInterface = NetworkInterfaceBuilder()

    type NetworkInterfaceApplicationGatewayBackendAddressPoolAssociationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            NetworkInterfaceApplicationGatewayBackendAddressPoolAssociation
                (name, (List.fold func (NetworkInterfaceApplicationGatewayBackendAddressPoolAssociationArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("backendAddressPoolId")>]
        member _.BackendAddressPoolId((name, args), backendAddressPoolId) =
            let apply (args: NetworkInterfaceApplicationGatewayBackendAddressPoolAssociationArgs) =
                args.BackendAddressPoolId <- input backendAddressPoolId
                args

            ()
            name, List.Cons(apply, args)

        member _.BackendAddressPoolId((name, args), backendAddressPoolId) =
            let apply (args: NetworkInterfaceApplicationGatewayBackendAddressPoolAssociationArgs) =
                args.BackendAddressPoolId <- io backendAddressPoolId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("ipConfigurationName")>]
        member _.IpConfigurationName((name, args), ipConfigurationName) =
            let apply (args: NetworkInterfaceApplicationGatewayBackendAddressPoolAssociationArgs) =
                args.IpConfigurationName <- input ipConfigurationName
                args

            ()
            name, List.Cons(apply, args)

        member _.IpConfigurationName((name, args), ipConfigurationName) =
            let apply (args: NetworkInterfaceApplicationGatewayBackendAddressPoolAssociationArgs) =
                args.IpConfigurationName <- io ipConfigurationName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("networkInterfaceId")>]
        member _.NetworkInterfaceId((name, args), networkInterfaceId) =
            let apply (args: NetworkInterfaceApplicationGatewayBackendAddressPoolAssociationArgs) =
                args.NetworkInterfaceId <- input networkInterfaceId
                args

            ()
            name, List.Cons(apply, args)

        member _.NetworkInterfaceId((name, args), networkInterfaceId) =
            let apply (args: NetworkInterfaceApplicationGatewayBackendAddressPoolAssociationArgs) =
                args.NetworkInterfaceId <- io networkInterfaceId
                args

            ()
            name, List.Cons(apply, args)

    let networkInterfaceApplicationGatewayBackendAddressPoolAssociation =
        NetworkInterfaceApplicationGatewayBackendAddressPoolAssociationBuilder()

    type NetworkInterfaceApplicationSecurityGroupAssociationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            NetworkInterfaceApplicationSecurityGroupAssociation
                (name, (List.fold func (NetworkInterfaceApplicationSecurityGroupAssociationArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("applicationSecurityGroupId")>]
        member _.ApplicationSecurityGroupId((name, args), applicationSecurityGroupId) =
            let apply (args: NetworkInterfaceApplicationSecurityGroupAssociationArgs) =
                args.ApplicationSecurityGroupId <- input applicationSecurityGroupId
                args

            ()
            name, List.Cons(apply, args)

        member _.ApplicationSecurityGroupId((name, args), applicationSecurityGroupId) =
            let apply (args: NetworkInterfaceApplicationSecurityGroupAssociationArgs) =
                args.ApplicationSecurityGroupId <- io applicationSecurityGroupId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("networkInterfaceId")>]
        member _.NetworkInterfaceId((name, args), networkInterfaceId) =
            let apply (args: NetworkInterfaceApplicationSecurityGroupAssociationArgs) =
                args.NetworkInterfaceId <- input networkInterfaceId
                args

            ()
            name, List.Cons(apply, args)

        member _.NetworkInterfaceId((name, args), networkInterfaceId) =
            let apply (args: NetworkInterfaceApplicationSecurityGroupAssociationArgs) =
                args.NetworkInterfaceId <- io networkInterfaceId
                args

            ()
            name, List.Cons(apply, args)

    let networkInterfaceApplicationSecurityGroupAssociation =
        NetworkInterfaceApplicationSecurityGroupAssociationBuilder()

    type NetworkInterfaceBackendAddressPoolAssociationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            NetworkInterfaceBackendAddressPoolAssociation
                (name, (List.fold func (NetworkInterfaceBackendAddressPoolAssociationArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("backendAddressPoolId")>]
        member _.BackendAddressPoolId((name, args), backendAddressPoolId) =
            let apply (args: NetworkInterfaceBackendAddressPoolAssociationArgs) =
                args.BackendAddressPoolId <- input backendAddressPoolId
                args

            ()
            name, List.Cons(apply, args)

        member _.BackendAddressPoolId((name, args), backendAddressPoolId) =
            let apply (args: NetworkInterfaceBackendAddressPoolAssociationArgs) =
                args.BackendAddressPoolId <- io backendAddressPoolId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("ipConfigurationName")>]
        member _.IpConfigurationName((name, args), ipConfigurationName) =
            let apply (args: NetworkInterfaceBackendAddressPoolAssociationArgs) =
                args.IpConfigurationName <- input ipConfigurationName
                args

            ()
            name, List.Cons(apply, args)

        member _.IpConfigurationName((name, args), ipConfigurationName) =
            let apply (args: NetworkInterfaceBackendAddressPoolAssociationArgs) =
                args.IpConfigurationName <- io ipConfigurationName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("networkInterfaceId")>]
        member _.NetworkInterfaceId((name, args), networkInterfaceId) =
            let apply (args: NetworkInterfaceBackendAddressPoolAssociationArgs) =
                args.NetworkInterfaceId <- input networkInterfaceId
                args

            ()
            name, List.Cons(apply, args)

        member _.NetworkInterfaceId((name, args), networkInterfaceId) =
            let apply (args: NetworkInterfaceBackendAddressPoolAssociationArgs) =
                args.NetworkInterfaceId <- io networkInterfaceId
                args

            ()
            name, List.Cons(apply, args)

    let networkInterfaceBackendAddressPoolAssociation =
        NetworkInterfaceBackendAddressPoolAssociationBuilder()

    type NetworkInterfaceNatRuleAssociationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            NetworkInterfaceNatRuleAssociation(name, (List.fold func (NetworkInterfaceNatRuleAssociationArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("ipConfigurationName")>]
        member _.IpConfigurationName((name, args), ipConfigurationName) =
            let apply (args: NetworkInterfaceNatRuleAssociationArgs) =
                args.IpConfigurationName <- input ipConfigurationName
                args

            ()
            name, List.Cons(apply, args)

        member _.IpConfigurationName((name, args), ipConfigurationName) =
            let apply (args: NetworkInterfaceNatRuleAssociationArgs) =
                args.IpConfigurationName <- io ipConfigurationName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("natRuleId")>]
        member _.NatRuleId((name, args), natRuleId) =
            let apply (args: NetworkInterfaceNatRuleAssociationArgs) =
                args.NatRuleId <- input natRuleId
                args

            ()
            name, List.Cons(apply, args)

        member _.NatRuleId((name, args), natRuleId) =
            let apply (args: NetworkInterfaceNatRuleAssociationArgs) =
                args.NatRuleId <- io natRuleId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("networkInterfaceId")>]
        member _.NetworkInterfaceId((name, args), networkInterfaceId) =
            let apply (args: NetworkInterfaceNatRuleAssociationArgs) =
                args.NetworkInterfaceId <- input networkInterfaceId
                args

            ()
            name, List.Cons(apply, args)

        member _.NetworkInterfaceId((name, args), networkInterfaceId) =
            let apply (args: NetworkInterfaceNatRuleAssociationArgs) =
                args.NetworkInterfaceId <- io networkInterfaceId
                args

            ()
            name, List.Cons(apply, args)

    let networkInterfaceNatRuleAssociation =
        NetworkInterfaceNatRuleAssociationBuilder()

    type NetworkInterfaceSecurityGroupAssociationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            NetworkInterfaceSecurityGroupAssociation
                (name, (List.fold func (NetworkInterfaceSecurityGroupAssociationArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("networkInterfaceId")>]
        member _.NetworkInterfaceId((name, args), networkInterfaceId) =
            let apply (args: NetworkInterfaceSecurityGroupAssociationArgs) =
                args.NetworkInterfaceId <- input networkInterfaceId
                args

            ()
            name, List.Cons(apply, args)

        member _.NetworkInterfaceId((name, args), networkInterfaceId) =
            let apply (args: NetworkInterfaceSecurityGroupAssociationArgs) =
                args.NetworkInterfaceId <- io networkInterfaceId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("networkSecurityGroupId")>]
        member _.NetworkSecurityGroupId((name, args), networkSecurityGroupId) =
            let apply (args: NetworkInterfaceSecurityGroupAssociationArgs) =
                args.NetworkSecurityGroupId <- input networkSecurityGroupId
                args

            ()
            name, List.Cons(apply, args)

        member _.NetworkSecurityGroupId((name, args), networkSecurityGroupId) =
            let apply (args: NetworkInterfaceSecurityGroupAssociationArgs) =
                args.NetworkSecurityGroupId <- io networkSecurityGroupId
                args

            ()
            name, List.Cons(apply, args)

    let networkInterfaceSecurityGroupAssociation =
        NetworkInterfaceSecurityGroupAssociationBuilder()

    type NetworkPacketCaptureBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            NetworkPacketCapture(name, (List.fold func (NetworkPacketCaptureArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("filters")>]
        member _.Filters((name, args), filters) =
            let apply (args: NetworkPacketCaptureArgs) =
                args.Filters <- inputList filters
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("maximumBytesPerPacket")>]
        member _.MaximumBytesPerPacket((name, args), maximumBytesPerPacket) =
            let apply (args: NetworkPacketCaptureArgs) =
                args.MaximumBytesPerPacket <- input maximumBytesPerPacket
                args

            ()
            name, List.Cons(apply, args)

        member _.MaximumBytesPerPacket((name, args), maximumBytesPerPacket) =
            let apply (args: NetworkPacketCaptureArgs) =
                args.MaximumBytesPerPacket <- io maximumBytesPerPacket
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("maximumBytesPerSession")>]
        member _.MaximumBytesPerSession((name, args), maximumBytesPerSession) =
            let apply (args: NetworkPacketCaptureArgs) =
                args.MaximumBytesPerSession <- input maximumBytesPerSession
                args

            ()
            name, List.Cons(apply, args)

        member _.MaximumBytesPerSession((name, args), maximumBytesPerSession) =
            let apply (args: NetworkPacketCaptureArgs) =
                args.MaximumBytesPerSession <- io maximumBytesPerSession
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("maximumCaptureDuration")>]
        member _.MaximumCaptureDuration((name, args), maximumCaptureDuration) =
            let apply (args: NetworkPacketCaptureArgs) =
                args.MaximumCaptureDuration <- input maximumCaptureDuration
                args

            ()
            name, List.Cons(apply, args)

        member _.MaximumCaptureDuration((name, args), maximumCaptureDuration) =
            let apply (args: NetworkPacketCaptureArgs) =
                args.MaximumCaptureDuration <- io maximumCaptureDuration
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: NetworkPacketCaptureArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: NetworkPacketCaptureArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("networkWatcherName")>]
        member _.NetworkWatcherName((name, args), networkWatcherName) =
            let apply (args: NetworkPacketCaptureArgs) =
                args.NetworkWatcherName <- input networkWatcherName
                args

            ()
            name, List.Cons(apply, args)

        member _.NetworkWatcherName((name, args), networkWatcherName) =
            let apply (args: NetworkPacketCaptureArgs) =
                args.NetworkWatcherName <- io networkWatcherName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NetworkPacketCaptureArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NetworkPacketCaptureArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: NetworkPacketCaptureArgs) =
                   args.StorageLocation <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("targetResourceId")>]
        member _.TargetResourceId((name, args), targetResourceId) =
            let apply (args: NetworkPacketCaptureArgs) =
                args.TargetResourceId <- input targetResourceId
                args

            ()
            name, List.Cons(apply, args)

        member _.TargetResourceId((name, args), targetResourceId) =
            let apply (args: NetworkPacketCaptureArgs) =
                args.TargetResourceId <- io targetResourceId
                args

            ()
            name, List.Cons(apply, args)

    let networkPacketCapture = NetworkPacketCaptureBuilder()

    type NetworkSecurityGroupBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            NetworkSecurityGroup(name, (List.fold func (NetworkSecurityGroupArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: NetworkSecurityGroupArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: NetworkSecurityGroupArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: NetworkSecurityGroupArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: NetworkSecurityGroupArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NetworkSecurityGroupArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NetworkSecurityGroupArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("securityRules")>]
        member _.SecurityRules((name, args), securityRules) =
            let apply (args: NetworkSecurityGroupArgs) =
                args.SecurityRules <- inputList securityRules
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: NetworkSecurityGroupArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let networkSecurityGroup = NetworkSecurityGroupBuilder()

    type NetworkSecurityRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            NetworkSecurityRule(name, (List.fold func (NetworkSecurityRuleArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("access")>]
        member _.Access((name, args), access) =
            let apply (args: NetworkSecurityRuleArgs) =
                args.Access <- input access
                args

            ()
            name, List.Cons(apply, args)

        member _.Access((name, args), access) =
            let apply (args: NetworkSecurityRuleArgs) =
                args.Access <- io access
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: NetworkSecurityRuleArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: NetworkSecurityRuleArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("destinationAddressPrefix")>]
        member _.DestinationAddressPrefix((name, args), destinationAddressPrefix) =
            let apply (args: NetworkSecurityRuleArgs) =
                args.DestinationAddressPrefix <- input destinationAddressPrefix
                args

            ()
            name, List.Cons(apply, args)

        member _.DestinationAddressPrefix((name, args), destinationAddressPrefix) =
            let apply (args: NetworkSecurityRuleArgs) =
                args.DestinationAddressPrefix <- io destinationAddressPrefix
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("destinationAddressPrefixes")>]
        member _.DestinationAddressPrefixes((name, args), destinationAddressPrefixes) =
            let apply (args: NetworkSecurityRuleArgs) =
                args.DestinationAddressPrefixes <- inputList destinationAddressPrefixes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("destinationApplicationSecurityGroupIds")>]
        member _.DestinationApplicationSecurityGroupIds((name, args), destinationApplicationSecurityGroupIds) =
            let apply (args: NetworkSecurityRuleArgs) =
                args.DestinationApplicationSecurityGroupIds <- input destinationApplicationSecurityGroupIds
                args

            ()
            name, List.Cons(apply, args)

        member _.DestinationApplicationSecurityGroupIds((name, args), destinationApplicationSecurityGroupIds) =
            let apply (args: NetworkSecurityRuleArgs) =
                args.DestinationApplicationSecurityGroupIds <- io destinationApplicationSecurityGroupIds
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("destinationPortRange")>]
        member _.DestinationPortRange((name, args), destinationPortRange) =
            let apply (args: NetworkSecurityRuleArgs) =
                args.DestinationPortRange <- input destinationPortRange
                args

            ()
            name, List.Cons(apply, args)

        member _.DestinationPortRange((name, args), destinationPortRange) =
            let apply (args: NetworkSecurityRuleArgs) =
                args.DestinationPortRange <- io destinationPortRange
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("destinationPortRanges")>]
        member _.DestinationPortRanges((name, args), destinationPortRanges) =
            let apply (args: NetworkSecurityRuleArgs) =
                args.DestinationPortRanges <- inputList destinationPortRanges
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("direction")>]
        member _.Direction((name, args), direction) =
            let apply (args: NetworkSecurityRuleArgs) =
                args.Direction <- input direction
                args

            ()
            name, List.Cons(apply, args)

        member _.Direction((name, args), direction) =
            let apply (args: NetworkSecurityRuleArgs) =
                args.Direction <- io direction
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: NetworkSecurityRuleArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: NetworkSecurityRuleArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("networkSecurityGroupName")>]
        member _.NetworkSecurityGroupName((name, args), networkSecurityGroupName) =
            let apply (args: NetworkSecurityRuleArgs) =
                args.NetworkSecurityGroupName <- input networkSecurityGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.NetworkSecurityGroupName((name, args), networkSecurityGroupName) =
            let apply (args: NetworkSecurityRuleArgs) =
                args.NetworkSecurityGroupName <- io networkSecurityGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("priority")>]
        member _.Priority((name, args), priority) =
            let apply (args: NetworkSecurityRuleArgs) =
                args.Priority <- input priority
                args

            ()
            name, List.Cons(apply, args)

        member _.Priority((name, args), priority) =
            let apply (args: NetworkSecurityRuleArgs) =
                args.Priority <- io priority
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("protocol")>]
        member _.Protocol((name, args), protocol) =
            let apply (args: NetworkSecurityRuleArgs) =
                args.Protocol <- input protocol
                args

            ()
            name, List.Cons(apply, args)

        member _.Protocol((name, args), protocol) =
            let apply (args: NetworkSecurityRuleArgs) =
                args.Protocol <- io protocol
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NetworkSecurityRuleArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NetworkSecurityRuleArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sourceAddressPrefix")>]
        member _.SourceAddressPrefix((name, args), sourceAddressPrefix) =
            let apply (args: NetworkSecurityRuleArgs) =
                args.SourceAddressPrefix <- input sourceAddressPrefix
                args

            ()
            name, List.Cons(apply, args)

        member _.SourceAddressPrefix((name, args), sourceAddressPrefix) =
            let apply (args: NetworkSecurityRuleArgs) =
                args.SourceAddressPrefix <- io sourceAddressPrefix
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sourceAddressPrefixes")>]
        member _.SourceAddressPrefixes((name, args), sourceAddressPrefixes) =
            let apply (args: NetworkSecurityRuleArgs) =
                args.SourceAddressPrefixes <- inputList sourceAddressPrefixes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sourceApplicationSecurityGroupIds")>]
        member _.SourceApplicationSecurityGroupIds((name, args), sourceApplicationSecurityGroupIds) =
            let apply (args: NetworkSecurityRuleArgs) =
                args.SourceApplicationSecurityGroupIds <- input sourceApplicationSecurityGroupIds
                args

            ()
            name, List.Cons(apply, args)

        member _.SourceApplicationSecurityGroupIds((name, args), sourceApplicationSecurityGroupIds) =
            let apply (args: NetworkSecurityRuleArgs) =
                args.SourceApplicationSecurityGroupIds <- io sourceApplicationSecurityGroupIds
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sourcePortRange")>]
        member _.SourcePortRange((name, args), sourcePortRange) =
            let apply (args: NetworkSecurityRuleArgs) =
                args.SourcePortRange <- input sourcePortRange
                args

            ()
            name, List.Cons(apply, args)

        member _.SourcePortRange((name, args), sourcePortRange) =
            let apply (args: NetworkSecurityRuleArgs) =
                args.SourcePortRange <- io sourcePortRange
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sourcePortRanges")>]
        member _.SourcePortRanges((name, args), sourcePortRanges) =
            let apply (args: NetworkSecurityRuleArgs) =
                args.SourcePortRanges <- inputList sourcePortRanges
                args

            ()
            name, List.Cons(apply, args)

    let networkSecurityRule = NetworkSecurityRuleBuilder()

    type NetworkWatcherBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            NetworkWatcher(name, (List.fold func (NetworkWatcherArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: NetworkWatcherArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: NetworkWatcherArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: NetworkWatcherArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: NetworkWatcherArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NetworkWatcherArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NetworkWatcherArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: NetworkWatcherArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let networkWatcher = NetworkWatcherBuilder()

    type NetworkWatcherFlowLogBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            NetworkWatcherFlowLog(name, (List.fold func (NetworkWatcherFlowLogArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("enabled")>]
        member _.Enabled((name, args), enabled) =
            let apply (args: NetworkWatcherFlowLogArgs) =
                args.Enabled <- input enabled
                args

            ()
            name, List.Cons(apply, args)

        member _.Enabled((name, args), enabled) =
            let apply (args: NetworkWatcherFlowLogArgs) =
                args.Enabled <- io enabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("networkSecurityGroupId")>]
        member _.NetworkSecurityGroupId((name, args), networkSecurityGroupId) =
            let apply (args: NetworkWatcherFlowLogArgs) =
                args.NetworkSecurityGroupId <- input networkSecurityGroupId
                args

            ()
            name, List.Cons(apply, args)

        member _.NetworkSecurityGroupId((name, args), networkSecurityGroupId) =
            let apply (args: NetworkWatcherFlowLogArgs) =
                args.NetworkSecurityGroupId <- io networkSecurityGroupId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("networkWatcherName")>]
        member _.NetworkWatcherName((name, args), networkWatcherName) =
            let apply (args: NetworkWatcherFlowLogArgs) =
                args.NetworkWatcherName <- input networkWatcherName
                args

            ()
            name, List.Cons(apply, args)

        member _.NetworkWatcherName((name, args), networkWatcherName) =
            let apply (args: NetworkWatcherFlowLogArgs) =
                args.NetworkWatcherName <- io networkWatcherName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NetworkWatcherFlowLogArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NetworkWatcherFlowLogArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: NetworkWatcherFlowLogArgs) =
                   args.RetentionPolicy <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("storageAccountId")>]
        member _.StorageAccountId((name, args), storageAccountId) =
            let apply (args: NetworkWatcherFlowLogArgs) =
                args.StorageAccountId <- input storageAccountId
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageAccountId((name, args), storageAccountId) =
            let apply (args: NetworkWatcherFlowLogArgs) =
                args.StorageAccountId <- io storageAccountId
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: NetworkWatcherFlowLogArgs) =
                   args.TrafficAnalytics <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("version")>]
        member _.Version((name, args), version) =
            let apply (args: NetworkWatcherFlowLogArgs) =
                args.Version <- input version
                args

            ()
            name, List.Cons(apply, args)

        member _.Version((name, args), version) =
            let apply (args: NetworkWatcherFlowLogArgs) =
                args.Version <- io version
                args

            ()
            name, List.Cons(apply, args)

    let networkWatcherFlowLog = NetworkWatcherFlowLogBuilder()

    type PacketCaptureBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            PacketCapture(name, (List.fold func (PacketCaptureArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("filters")>]
        member _.Filters((name, args), filters) =
            let apply (args: PacketCaptureArgs) =
                args.Filters <- inputList filters
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("maximumBytesPerPacket")>]
        member _.MaximumBytesPerPacket((name, args), maximumBytesPerPacket) =
            let apply (args: PacketCaptureArgs) =
                args.MaximumBytesPerPacket <- input maximumBytesPerPacket
                args

            ()
            name, List.Cons(apply, args)

        member _.MaximumBytesPerPacket((name, args), maximumBytesPerPacket) =
            let apply (args: PacketCaptureArgs) =
                args.MaximumBytesPerPacket <- io maximumBytesPerPacket
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("maximumBytesPerSession")>]
        member _.MaximumBytesPerSession((name, args), maximumBytesPerSession) =
            let apply (args: PacketCaptureArgs) =
                args.MaximumBytesPerSession <- input maximumBytesPerSession
                args

            ()
            name, List.Cons(apply, args)

        member _.MaximumBytesPerSession((name, args), maximumBytesPerSession) =
            let apply (args: PacketCaptureArgs) =
                args.MaximumBytesPerSession <- io maximumBytesPerSession
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("maximumCaptureDuration")>]
        member _.MaximumCaptureDuration((name, args), maximumCaptureDuration) =
            let apply (args: PacketCaptureArgs) =
                args.MaximumCaptureDuration <- input maximumCaptureDuration
                args

            ()
            name, List.Cons(apply, args)

        member _.MaximumCaptureDuration((name, args), maximumCaptureDuration) =
            let apply (args: PacketCaptureArgs) =
                args.MaximumCaptureDuration <- io maximumCaptureDuration
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: PacketCaptureArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: PacketCaptureArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("networkWatcherName")>]
        member _.NetworkWatcherName((name, args), networkWatcherName) =
            let apply (args: PacketCaptureArgs) =
                args.NetworkWatcherName <- input networkWatcherName
                args

            ()
            name, List.Cons(apply, args)

        member _.NetworkWatcherName((name, args), networkWatcherName) =
            let apply (args: PacketCaptureArgs) =
                args.NetworkWatcherName <- io networkWatcherName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: PacketCaptureArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: PacketCaptureArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: PacketCaptureArgs) =
                   args.StorageLocation <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("targetResourceId")>]
        member _.TargetResourceId((name, args), targetResourceId) =
            let apply (args: PacketCaptureArgs) =
                args.TargetResourceId <- input targetResourceId
                args

            ()
            name, List.Cons(apply, args)

        member _.TargetResourceId((name, args), targetResourceId) =
            let apply (args: PacketCaptureArgs) =
                args.TargetResourceId <- io targetResourceId
                args

            ()
            name, List.Cons(apply, args)

    let packetCapture = PacketCaptureBuilder()

    type PointToPointVpnGatewayBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            PointToPointVpnGateway(name, (List.fold func (PointToPointVpnGatewayArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: PointToPointVpnGatewayArgs) =
                   args.ConnectionConfiguration <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: PointToPointVpnGatewayArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: PointToPointVpnGatewayArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: PointToPointVpnGatewayArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: PointToPointVpnGatewayArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: PointToPointVpnGatewayArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: PointToPointVpnGatewayArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("scaleUnit")>]
        member _.ScaleUnit((name, args), scaleUnit) =
            let apply (args: PointToPointVpnGatewayArgs) =
                args.ScaleUnit <- input scaleUnit
                args

            ()
            name, List.Cons(apply, args)

        member _.ScaleUnit((name, args), scaleUnit) =
            let apply (args: PointToPointVpnGatewayArgs) =
                args.ScaleUnit <- io scaleUnit
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: PointToPointVpnGatewayArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("virtualHubId")>]
        member _.VirtualHubId((name, args), virtualHubId) =
            let apply (args: PointToPointVpnGatewayArgs) =
                args.VirtualHubId <- input virtualHubId
                args

            ()
            name, List.Cons(apply, args)

        member _.VirtualHubId((name, args), virtualHubId) =
            let apply (args: PointToPointVpnGatewayArgs) =
                args.VirtualHubId <- io virtualHubId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("vpnServerConfigurationId")>]
        member _.VpnServerConfigurationId((name, args), vpnServerConfigurationId) =
            let apply (args: PointToPointVpnGatewayArgs) =
                args.VpnServerConfigurationId <- input vpnServerConfigurationId
                args

            ()
            name, List.Cons(apply, args)

        member _.VpnServerConfigurationId((name, args), vpnServerConfigurationId) =
            let apply (args: PointToPointVpnGatewayArgs) =
                args.VpnServerConfigurationId <- io vpnServerConfigurationId
                args

            ()
            name, List.Cons(apply, args)

    let pointToPointVpnGateway = PointToPointVpnGatewayBuilder()

    type ProfileBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Profile(name, (List.fold func (ProfileArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: ProfileArgs) =
                   args.ContainerNetworkInterface <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ProfileArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ProfileArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ProfileArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ProfileArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ProfileArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ProfileArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ProfileArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let profile = ProfileBuilder()

    type PublicIpBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            PublicIp(name, (List.fold func (PublicIpArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("allocationMethod")>]
        member _.AllocationMethod((name, args), allocationMethod) =
            let apply (args: PublicIpArgs) =
                args.AllocationMethod <- input allocationMethod
                args

            ()
            name, List.Cons(apply, args)

        member _.AllocationMethod((name, args), allocationMethod) =
            let apply (args: PublicIpArgs) =
                args.AllocationMethod <- io allocationMethod
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("domainNameLabel")>]
        member _.DomainNameLabel((name, args), domainNameLabel) =
            let apply (args: PublicIpArgs) =
                args.DomainNameLabel <- input domainNameLabel
                args

            ()
            name, List.Cons(apply, args)

        member _.DomainNameLabel((name, args), domainNameLabel) =
            let apply (args: PublicIpArgs) =
                args.DomainNameLabel <- io domainNameLabel
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("idleTimeoutInMinutes")>]
        member _.IdleTimeoutInMinutes((name, args), idleTimeoutInMinutes) =
            let apply (args: PublicIpArgs) =
                args.IdleTimeoutInMinutes <- input idleTimeoutInMinutes
                args

            ()
            name, List.Cons(apply, args)

        member _.IdleTimeoutInMinutes((name, args), idleTimeoutInMinutes) =
            let apply (args: PublicIpArgs) =
                args.IdleTimeoutInMinutes <- io idleTimeoutInMinutes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("ipVersion")>]
        member _.IpVersion((name, args), ipVersion) =
            let apply (args: PublicIpArgs) =
                args.IpVersion <- input ipVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.IpVersion((name, args), ipVersion) =
            let apply (args: PublicIpArgs) =
                args.IpVersion <- io ipVersion
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: PublicIpArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: PublicIpArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: PublicIpArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: PublicIpArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("publicIpPrefixId")>]
        member _.PublicIpPrefixId((name, args), publicIpPrefixId) =
            let apply (args: PublicIpArgs) =
                args.PublicIpPrefixId <- input publicIpPrefixId
                args

            ()
            name, List.Cons(apply, args)

        member _.PublicIpPrefixId((name, args), publicIpPrefixId) =
            let apply (args: PublicIpArgs) =
                args.PublicIpPrefixId <- io publicIpPrefixId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: PublicIpArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: PublicIpArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("reverseFqdn")>]
        member _.ReverseFqdn((name, args), reverseFqdn) =
            let apply (args: PublicIpArgs) =
                args.ReverseFqdn <- input reverseFqdn
                args

            ()
            name, List.Cons(apply, args)

        member _.ReverseFqdn((name, args), reverseFqdn) =
            let apply (args: PublicIpArgs) =
                args.ReverseFqdn <- io reverseFqdn
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sku")>]
        member _.Sku((name, args), sku) =
            let apply (args: PublicIpArgs) =
                args.Sku <- input sku
                args

            ()
            name, List.Cons(apply, args)

        member _.Sku((name, args), sku) =
            let apply (args: PublicIpArgs) =
                args.Sku <- io sku
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: PublicIpArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zones")>]
        member _.Zones((name, args), zones) =
            let apply (args: PublicIpArgs) =
                args.Zones <- input zones
                args

            ()
            name, List.Cons(apply, args)

        member _.Zones((name, args), zones) =
            let apply (args: PublicIpArgs) =
                args.Zones <- io zones
                args

            ()
            name, List.Cons(apply, args)

    let publicIp = PublicIpBuilder()

    type PublicIpPrefixBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            PublicIpPrefix(name, (List.fold func (PublicIpPrefixArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: PublicIpPrefixArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: PublicIpPrefixArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: PublicIpPrefixArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: PublicIpPrefixArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("prefixLength")>]
        member _.PrefixLength((name, args), prefixLength) =
            let apply (args: PublicIpPrefixArgs) =
                args.PrefixLength <- input prefixLength
                args

            ()
            name, List.Cons(apply, args)

        member _.PrefixLength((name, args), prefixLength) =
            let apply (args: PublicIpPrefixArgs) =
                args.PrefixLength <- io prefixLength
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: PublicIpPrefixArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: PublicIpPrefixArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sku")>]
        member _.Sku((name, args), sku) =
            let apply (args: PublicIpPrefixArgs) =
                args.Sku <- input sku
                args

            ()
            name, List.Cons(apply, args)

        member _.Sku((name, args), sku) =
            let apply (args: PublicIpPrefixArgs) =
                args.Sku <- io sku
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: PublicIpPrefixArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zones")>]
        member _.Zones((name, args), zones) =
            let apply (args: PublicIpPrefixArgs) =
                args.Zones <- input zones
                args

            ()
            name, List.Cons(apply, args)

        member _.Zones((name, args), zones) =
            let apply (args: PublicIpPrefixArgs) =
                args.Zones <- io zones
                args

            ()
            name, List.Cons(apply, args)

    let publicIpPrefix = PublicIpPrefixBuilder()

    type RouteBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Route(name, (List.fold func (RouteArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("addressPrefix")>]
        member _.AddressPrefix((name, args), addressPrefix) =
            let apply (args: RouteArgs) =
                args.AddressPrefix <- input addressPrefix
                args

            ()
            name, List.Cons(apply, args)

        member _.AddressPrefix((name, args), addressPrefix) =
            let apply (args: RouteArgs) =
                args.AddressPrefix <- io addressPrefix
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: RouteArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: RouteArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("nextHopInIpAddress")>]
        member _.NextHopInIpAddress((name, args), nextHopInIpAddress) =
            let apply (args: RouteArgs) =
                args.NextHopInIpAddress <- input nextHopInIpAddress
                args

            ()
            name, List.Cons(apply, args)

        member _.NextHopInIpAddress((name, args), nextHopInIpAddress) =
            let apply (args: RouteArgs) =
                args.NextHopInIpAddress <- io nextHopInIpAddress
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("nextHopType")>]
        member _.NextHopType((name, args), nextHopType) =
            let apply (args: RouteArgs) =
                args.NextHopType <- input nextHopType
                args

            ()
            name, List.Cons(apply, args)

        member _.NextHopType((name, args), nextHopType) =
            let apply (args: RouteArgs) =
                args.NextHopType <- io nextHopType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: RouteArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: RouteArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("routeTableName")>]
        member _.RouteTableName((name, args), routeTableName) =
            let apply (args: RouteArgs) =
                args.RouteTableName <- input routeTableName
                args

            ()
            name, List.Cons(apply, args)

        member _.RouteTableName((name, args), routeTableName) =
            let apply (args: RouteArgs) =
                args.RouteTableName <- io routeTableName
                args

            ()
            name, List.Cons(apply, args)

    let route = RouteBuilder()

    type RouteTableBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            RouteTable(name, (List.fold func (RouteTableArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("disableBgpRoutePropagation")>]
        member _.DisableBgpRoutePropagation((name, args), disableBgpRoutePropagation) =
            let apply (args: RouteTableArgs) =
                args.DisableBgpRoutePropagation <- input disableBgpRoutePropagation
                args

            ()
            name, List.Cons(apply, args)

        member _.DisableBgpRoutePropagation((name, args), disableBgpRoutePropagation) =
            let apply (args: RouteTableArgs) =
                args.DisableBgpRoutePropagation <- io disableBgpRoutePropagation
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: RouteTableArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: RouteTableArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: RouteTableArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: RouteTableArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: RouteTableArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: RouteTableArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("routes")>]
        member _.Routes((name, args), routes) =
            let apply (args: RouteTableArgs) =
                args.Routes <- inputList routes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: RouteTableArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let routeTable = RouteTableBuilder()

    type SubnetBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Subnet(name, (List.fold func (SubnetArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("addressPrefix")>]
        member _.AddressPrefix((name, args), addressPrefix) =
            let apply (args: SubnetArgs) =
                args.AddressPrefix <- input addressPrefix
                args

            ()
            name, List.Cons(apply, args)

        member _.AddressPrefix((name, args), addressPrefix) =
            let apply (args: SubnetArgs) =
                args.AddressPrefix <- io addressPrefix
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("addressPrefixes")>]
        member _.AddressPrefixes((name, args), addressPrefixes) =
            let apply (args: SubnetArgs) =
                args.AddressPrefixes <- inputList addressPrefixes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("delegations")>]
        member _.Delegations((name, args), delegations) =
            let apply (args: SubnetArgs) =
                args.Delegations <- inputList delegations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enforcePrivateLinkEndpointNetworkPolicies")>]
        member _.EnforcePrivateLinkEndpointNetworkPolicies((name, args), enforcePrivateLinkEndpointNetworkPolicies) =
            let apply (args: SubnetArgs) =
                args.EnforcePrivateLinkEndpointNetworkPolicies <- input enforcePrivateLinkEndpointNetworkPolicies
                args

            ()
            name, List.Cons(apply, args)

        member _.EnforcePrivateLinkEndpointNetworkPolicies((name, args), enforcePrivateLinkEndpointNetworkPolicies) =
            let apply (args: SubnetArgs) =
                args.EnforcePrivateLinkEndpointNetworkPolicies <- io enforcePrivateLinkEndpointNetworkPolicies
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enforcePrivateLinkServiceNetworkPolicies")>]
        member _.EnforcePrivateLinkServiceNetworkPolicies((name, args), enforcePrivateLinkServiceNetworkPolicies) =
            let apply (args: SubnetArgs) =
                args.EnforcePrivateLinkServiceNetworkPolicies <- input enforcePrivateLinkServiceNetworkPolicies
                args

            ()
            name, List.Cons(apply, args)

        member _.EnforcePrivateLinkServiceNetworkPolicies((name, args), enforcePrivateLinkServiceNetworkPolicies) =
            let apply (args: SubnetArgs) =
                args.EnforcePrivateLinkServiceNetworkPolicies <- io enforcePrivateLinkServiceNetworkPolicies
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: SubnetArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: SubnetArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SubnetArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SubnetArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serviceEndpoints")>]
        member _.ServiceEndpoints((name, args), serviceEndpoints) =
            let apply (args: SubnetArgs) =
                args.ServiceEndpoints <- inputList serviceEndpoints
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkName")>]
        member _.VirtualNetworkName((name, args), virtualNetworkName) =
            let apply (args: SubnetArgs) =
                args.VirtualNetworkName <- input virtualNetworkName
                args

            ()
            name, List.Cons(apply, args)

        member _.VirtualNetworkName((name, args), virtualNetworkName) =
            let apply (args: SubnetArgs) =
                args.VirtualNetworkName <- io virtualNetworkName
                args

            ()
            name, List.Cons(apply, args)

    let subnet = SubnetBuilder()

    type SubnetNatGatewayAssociationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            SubnetNatGatewayAssociation(name, (List.fold func (SubnetNatGatewayAssociationArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("natGatewayId")>]
        member _.NatGatewayId((name, args), natGatewayId) =
            let apply (args: SubnetNatGatewayAssociationArgs) =
                args.NatGatewayId <- input natGatewayId
                args

            ()
            name, List.Cons(apply, args)

        member _.NatGatewayId((name, args), natGatewayId) =
            let apply (args: SubnetNatGatewayAssociationArgs) =
                args.NatGatewayId <- io natGatewayId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((name, args), subnetId) =
            let apply (args: SubnetNatGatewayAssociationArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            name, List.Cons(apply, args)

        member _.SubnetId((name, args), subnetId) =
            let apply (args: SubnetNatGatewayAssociationArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            name, List.Cons(apply, args)

    let subnetNatGatewayAssociation = SubnetNatGatewayAssociationBuilder()

    type SubnetNetworkSecurityGroupAssociationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            SubnetNetworkSecurityGroupAssociation
                (name, (List.fold func (SubnetNetworkSecurityGroupAssociationArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("networkSecurityGroupId")>]
        member _.NetworkSecurityGroupId((name, args), networkSecurityGroupId) =
            let apply (args: SubnetNetworkSecurityGroupAssociationArgs) =
                args.NetworkSecurityGroupId <- input networkSecurityGroupId
                args

            ()
            name, List.Cons(apply, args)

        member _.NetworkSecurityGroupId((name, args), networkSecurityGroupId) =
            let apply (args: SubnetNetworkSecurityGroupAssociationArgs) =
                args.NetworkSecurityGroupId <- io networkSecurityGroupId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((name, args), subnetId) =
            let apply (args: SubnetNetworkSecurityGroupAssociationArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            name, List.Cons(apply, args)

        member _.SubnetId((name, args), subnetId) =
            let apply (args: SubnetNetworkSecurityGroupAssociationArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            name, List.Cons(apply, args)

    let subnetNetworkSecurityGroupAssociation =
        SubnetNetworkSecurityGroupAssociationBuilder()

    type SubnetRouteTableAssociationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            SubnetRouteTableAssociation(name, (List.fold func (SubnetRouteTableAssociationArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("routeTableId")>]
        member _.RouteTableId((name, args), routeTableId) =
            let apply (args: SubnetRouteTableAssociationArgs) =
                args.RouteTableId <- input routeTableId
                args

            ()
            name, List.Cons(apply, args)

        member _.RouteTableId((name, args), routeTableId) =
            let apply (args: SubnetRouteTableAssociationArgs) =
                args.RouteTableId <- io routeTableId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((name, args), subnetId) =
            let apply (args: SubnetRouteTableAssociationArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            name, List.Cons(apply, args)

        member _.SubnetId((name, args), subnetId) =
            let apply (args: SubnetRouteTableAssociationArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            name, List.Cons(apply, args)

    let subnetRouteTableAssociation = SubnetRouteTableAssociationBuilder()

    type TrafficManagerEndpointBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            TrafficManagerEndpoint(name, (List.fold func (TrafficManagerEndpointArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("customHeaders")>]
        member _.CustomHeaders((name, args), customHeaders) =
            let apply (args: TrafficManagerEndpointArgs) =
                args.CustomHeaders <- inputList customHeaders
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("endpointLocation")>]
        member _.EndpointLocation((name, args), endpointLocation) =
            let apply (args: TrafficManagerEndpointArgs) =
                args.EndpointLocation <- input endpointLocation
                args

            ()
            name, List.Cons(apply, args)

        member _.EndpointLocation((name, args), endpointLocation) =
            let apply (args: TrafficManagerEndpointArgs) =
                args.EndpointLocation <- io endpointLocation
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("endpointStatus")>]
        member _.EndpointStatus((name, args), endpointStatus) =
            let apply (args: TrafficManagerEndpointArgs) =
                args.EndpointStatus <- input endpointStatus
                args

            ()
            name, List.Cons(apply, args)

        member _.EndpointStatus((name, args), endpointStatus) =
            let apply (args: TrafficManagerEndpointArgs) =
                args.EndpointStatus <- io endpointStatus
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("geoMappings")>]
        member _.GeoMappings((name, args), geoMappings) =
            let apply (args: TrafficManagerEndpointArgs) =
                args.GeoMappings <- inputList geoMappings
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("minChildEndpoints")>]
        member _.MinChildEndpoints((name, args), minChildEndpoints) =
            let apply (args: TrafficManagerEndpointArgs) =
                args.MinChildEndpoints <- input minChildEndpoints
                args

            ()
            name, List.Cons(apply, args)

        member _.MinChildEndpoints((name, args), minChildEndpoints) =
            let apply (args: TrafficManagerEndpointArgs) =
                args.MinChildEndpoints <- io minChildEndpoints
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: TrafficManagerEndpointArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: TrafficManagerEndpointArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("priority")>]
        member _.Priority((name, args), priority) =
            let apply (args: TrafficManagerEndpointArgs) =
                args.Priority <- input priority
                args

            ()
            name, List.Cons(apply, args)

        member _.Priority((name, args), priority) =
            let apply (args: TrafficManagerEndpointArgs) =
                args.Priority <- io priority
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("profileName")>]
        member _.ProfileName((name, args), profileName) =
            let apply (args: TrafficManagerEndpointArgs) =
                args.ProfileName <- input profileName
                args

            ()
            name, List.Cons(apply, args)

        member _.ProfileName((name, args), profileName) =
            let apply (args: TrafficManagerEndpointArgs) =
                args.ProfileName <- io profileName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: TrafficManagerEndpointArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: TrafficManagerEndpointArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("subnets")>]
        member _.Subnets((name, args), subnets) =
            let apply (args: TrafficManagerEndpointArgs) =
                args.Subnets <- inputList subnets
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("target")>]
        member _.Target((name, args), target) =
            let apply (args: TrafficManagerEndpointArgs) =
                args.Target <- input target
                args

            ()
            name, List.Cons(apply, args)

        member _.Target((name, args), target) =
            let apply (args: TrafficManagerEndpointArgs) =
                args.Target <- io target
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("targetResourceId")>]
        member _.TargetResourceId((name, args), targetResourceId) =
            let apply (args: TrafficManagerEndpointArgs) =
                args.TargetResourceId <- input targetResourceId
                args

            ()
            name, List.Cons(apply, args)

        member _.TargetResourceId((name, args), targetResourceId) =
            let apply (args: TrafficManagerEndpointArgs) =
                args.TargetResourceId <- io targetResourceId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((name, args), ``type``) =
            let apply (args: TrafficManagerEndpointArgs) =
                args.Type <- input ``type``
                args

            ()
            name, List.Cons(apply, args)

        member _.Type((name, args), ``type``) =
            let apply (args: TrafficManagerEndpointArgs) =
                args.Type <- io ``type``
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("weight")>]
        member _.Weight((name, args), weight) =
            let apply (args: TrafficManagerEndpointArgs) =
                args.Weight <- input weight
                args

            ()
            name, List.Cons(apply, args)

        member _.Weight((name, args), weight) =
            let apply (args: TrafficManagerEndpointArgs) =
                args.Weight <- io weight
                args

            ()
            name, List.Cons(apply, args)

    let trafficManagerEndpoint = TrafficManagerEndpointBuilder()

    type TrafficManagerProfileBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            TrafficManagerProfile(name, (List.fold func (TrafficManagerProfileArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: TrafficManagerProfileArgs) =
                   args.DnsConfig <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: TrafficManagerProfileArgs) =
                   args.MonitorConfig <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: TrafficManagerProfileArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: TrafficManagerProfileArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("profileStatus")>]
        member _.ProfileStatus((name, args), profileStatus) =
            let apply (args: TrafficManagerProfileArgs) =
                args.ProfileStatus <- input profileStatus
                args

            ()
            name, List.Cons(apply, args)

        member _.ProfileStatus((name, args), profileStatus) =
            let apply (args: TrafficManagerProfileArgs) =
                args.ProfileStatus <- io profileStatus
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: TrafficManagerProfileArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: TrafficManagerProfileArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: TrafficManagerProfileArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("trafficRoutingMethod")>]
        member _.TrafficRoutingMethod((name, args), trafficRoutingMethod) =
            let apply (args: TrafficManagerProfileArgs) =
                args.TrafficRoutingMethod <- input trafficRoutingMethod
                args

            ()
            name, List.Cons(apply, args)

        member _.TrafficRoutingMethod((name, args), trafficRoutingMethod) =
            let apply (args: TrafficManagerProfileArgs) =
                args.TrafficRoutingMethod <- io trafficRoutingMethod
                args

            ()
            name, List.Cons(apply, args)

    let trafficManagerProfile = TrafficManagerProfileBuilder()

    type VirtualHubBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            VirtualHub(name, (List.fold func (VirtualHubArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("addressPrefix")>]
        member _.AddressPrefix((name, args), addressPrefix) =
            let apply (args: VirtualHubArgs) =
                args.AddressPrefix <- input addressPrefix
                args

            ()
            name, List.Cons(apply, args)

        member _.AddressPrefix((name, args), addressPrefix) =
            let apply (args: VirtualHubArgs) =
                args.AddressPrefix <- io addressPrefix
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: VirtualHubArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: VirtualHubArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: VirtualHubArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: VirtualHubArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: VirtualHubArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: VirtualHubArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("routes")>]
        member _.Routes((name, args), routes) =
            let apply (args: VirtualHubArgs) =
                args.Routes <- inputList routes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: VirtualHubArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("virtualWanId")>]
        member _.VirtualWanId((name, args), virtualWanId) =
            let apply (args: VirtualHubArgs) =
                args.VirtualWanId <- input virtualWanId
                args

            ()
            name, List.Cons(apply, args)

        member _.VirtualWanId((name, args), virtualWanId) =
            let apply (args: VirtualHubArgs) =
                args.VirtualWanId <- io virtualWanId
                args

            ()
            name, List.Cons(apply, args)

    let virtualHub = VirtualHubBuilder()

    type VirtualHubConnectionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            VirtualHubConnection(name, (List.fold func (VirtualHubConnectionArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("hubToVitualNetworkTrafficAllowed")>]
        member _.HubToVitualNetworkTrafficAllowed((name, args), hubToVitualNetworkTrafficAllowed) =
            let apply (args: VirtualHubConnectionArgs) =
                args.HubToVitualNetworkTrafficAllowed <- input hubToVitualNetworkTrafficAllowed
                args

            ()
            name, List.Cons(apply, args)

        member _.HubToVitualNetworkTrafficAllowed((name, args), hubToVitualNetworkTrafficAllowed) =
            let apply (args: VirtualHubConnectionArgs) =
                args.HubToVitualNetworkTrafficAllowed <- io hubToVitualNetworkTrafficAllowed
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("internetSecurityEnabled")>]
        member _.InternetSecurityEnabled((name, args), internetSecurityEnabled) =
            let apply (args: VirtualHubConnectionArgs) =
                args.InternetSecurityEnabled <- input internetSecurityEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.InternetSecurityEnabled((name, args), internetSecurityEnabled) =
            let apply (args: VirtualHubConnectionArgs) =
                args.InternetSecurityEnabled <- io internetSecurityEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: VirtualHubConnectionArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: VirtualHubConnectionArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("remoteVirtualNetworkId")>]
        member _.RemoteVirtualNetworkId((name, args), remoteVirtualNetworkId) =
            let apply (args: VirtualHubConnectionArgs) =
                args.RemoteVirtualNetworkId <- input remoteVirtualNetworkId
                args

            ()
            name, List.Cons(apply, args)

        member _.RemoteVirtualNetworkId((name, args), remoteVirtualNetworkId) =
            let apply (args: VirtualHubConnectionArgs) =
                args.RemoteVirtualNetworkId <- io remoteVirtualNetworkId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("virtualHubId")>]
        member _.VirtualHubId((name, args), virtualHubId) =
            let apply (args: VirtualHubConnectionArgs) =
                args.VirtualHubId <- input virtualHubId
                args

            ()
            name, List.Cons(apply, args)

        member _.VirtualHubId((name, args), virtualHubId) =
            let apply (args: VirtualHubConnectionArgs) =
                args.VirtualHubId <- io virtualHubId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("vitualNetworkToHubGatewaysTrafficAllowed")>]
        member _.VitualNetworkToHubGatewaysTrafficAllowed((name, args), vitualNetworkToHubGatewaysTrafficAllowed) =
            let apply (args: VirtualHubConnectionArgs) =
                args.VitualNetworkToHubGatewaysTrafficAllowed <- input vitualNetworkToHubGatewaysTrafficAllowed
                args

            ()
            name, List.Cons(apply, args)

        member _.VitualNetworkToHubGatewaysTrafficAllowed((name, args), vitualNetworkToHubGatewaysTrafficAllowed) =
            let apply (args: VirtualHubConnectionArgs) =
                args.VitualNetworkToHubGatewaysTrafficAllowed <- io vitualNetworkToHubGatewaysTrafficAllowed
                args

            ()
            name, List.Cons(apply, args)

    let virtualHubConnection = VirtualHubConnectionBuilder()

    type VirtualNetworkBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            VirtualNetwork(name, (List.fold func (VirtualNetworkArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("addressSpaces")>]
        member _.AddressSpaces((name, args), addressSpaces) =
            let apply (args: VirtualNetworkArgs) =
                args.AddressSpaces <- inputList addressSpaces
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: VirtualNetworkArgs) =
                   args.DdosProtectionPlan <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("dnsServers")>]
        member _.DnsServers((name, args), dnsServers) =
            let apply (args: VirtualNetworkArgs) =
                args.DnsServers <- inputList dnsServers
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: VirtualNetworkArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: VirtualNetworkArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: VirtualNetworkArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: VirtualNetworkArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: VirtualNetworkArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: VirtualNetworkArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("subnets")>]
        member _.Subnets((name, args), subnets) =
            let apply (args: VirtualNetworkArgs) =
                args.Subnets <- inputList subnets
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: VirtualNetworkArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let virtualNetwork = VirtualNetworkBuilder()

    type VirtualNetworkGatewayBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            VirtualNetworkGateway(name, (List.fold func (VirtualNetworkGatewayArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("activeActive")>]
        member _.ActiveActive((name, args), activeActive) =
            let apply (args: VirtualNetworkGatewayArgs) =
                args.ActiveActive <- input activeActive
                args

            ()
            name, List.Cons(apply, args)

        member _.ActiveActive((name, args), activeActive) =
            let apply (args: VirtualNetworkGatewayArgs) =
                args.ActiveActive <- io activeActive
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: VirtualNetworkGatewayArgs) =
                   args.BgpSettings <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("defaultLocalNetworkGatewayId")>]
        member _.DefaultLocalNetworkGatewayId((name, args), defaultLocalNetworkGatewayId) =
            let apply (args: VirtualNetworkGatewayArgs) =
                args.DefaultLocalNetworkGatewayId <- input defaultLocalNetworkGatewayId
                args

            ()
            name, List.Cons(apply, args)

        member _.DefaultLocalNetworkGatewayId((name, args), defaultLocalNetworkGatewayId) =
            let apply (args: VirtualNetworkGatewayArgs) =
                args.DefaultLocalNetworkGatewayId <- io defaultLocalNetworkGatewayId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enableBgp")>]
        member _.EnableBgp((name, args), enableBgp) =
            let apply (args: VirtualNetworkGatewayArgs) =
                args.EnableBgp <- input enableBgp
                args

            ()
            name, List.Cons(apply, args)

        member _.EnableBgp((name, args), enableBgp) =
            let apply (args: VirtualNetworkGatewayArgs) =
                args.EnableBgp <- io enableBgp
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("generation")>]
        member _.Generation((name, args), generation) =
            let apply (args: VirtualNetworkGatewayArgs) =
                args.Generation <- input generation
                args

            ()
            name, List.Cons(apply, args)

        member _.Generation((name, args), generation) =
            let apply (args: VirtualNetworkGatewayArgs) =
                args.Generation <- io generation
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("ipConfigurations")>]
        member _.IpConfigurations((name, args), ipConfigurations) =
            let apply (args: VirtualNetworkGatewayArgs) =
                args.IpConfigurations <- inputList ipConfigurations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: VirtualNetworkGatewayArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: VirtualNetworkGatewayArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: VirtualNetworkGatewayArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: VirtualNetworkGatewayArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: VirtualNetworkGatewayArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: VirtualNetworkGatewayArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sku")>]
        member _.Sku((name, args), sku) =
            let apply (args: VirtualNetworkGatewayArgs) =
                args.Sku <- input sku
                args

            ()
            name, List.Cons(apply, args)

        member _.Sku((name, args), sku) =
            let apply (args: VirtualNetworkGatewayArgs) =
                args.Sku <- io sku
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: VirtualNetworkGatewayArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((name, args), ``type``) =
            let apply (args: VirtualNetworkGatewayArgs) =
                args.Type <- input ``type``
                args

            ()
            name, List.Cons(apply, args)

        member _.Type((name, args), ``type``) =
            let apply (args: VirtualNetworkGatewayArgs) =
                args.Type <- io ``type``
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: VirtualNetworkGatewayArgs) =
                   args.VpnClientConfiguration <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("vpnType")>]
        member _.VpnType((name, args), vpnType) =
            let apply (args: VirtualNetworkGatewayArgs) =
                args.VpnType <- input vpnType
                args

            ()
            name, List.Cons(apply, args)

        member _.VpnType((name, args), vpnType) =
            let apply (args: VirtualNetworkGatewayArgs) =
                args.VpnType <- io vpnType
                args

            ()
            name, List.Cons(apply, args)

    let virtualNetworkGateway = VirtualNetworkGatewayBuilder()

    type VirtualNetworkGatewayConnectionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            VirtualNetworkGatewayConnection(name, (List.fold func (VirtualNetworkGatewayConnectionArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("authorizationKey")>]
        member _.AuthorizationKey((name, args), authorizationKey) =
            let apply (args: VirtualNetworkGatewayConnectionArgs) =
                args.AuthorizationKey <- input authorizationKey
                args

            ()
            name, List.Cons(apply, args)

        member _.AuthorizationKey((name, args), authorizationKey) =
            let apply (args: VirtualNetworkGatewayConnectionArgs) =
                args.AuthorizationKey <- io authorizationKey
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("connectionProtocol")>]
        member _.ConnectionProtocol((name, args), connectionProtocol) =
            let apply (args: VirtualNetworkGatewayConnectionArgs) =
                args.ConnectionProtocol <- input connectionProtocol
                args

            ()
            name, List.Cons(apply, args)

        member _.ConnectionProtocol((name, args), connectionProtocol) =
            let apply (args: VirtualNetworkGatewayConnectionArgs) =
                args.ConnectionProtocol <- io connectionProtocol
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enableBgp")>]
        member _.EnableBgp((name, args), enableBgp) =
            let apply (args: VirtualNetworkGatewayConnectionArgs) =
                args.EnableBgp <- input enableBgp
                args

            ()
            name, List.Cons(apply, args)

        member _.EnableBgp((name, args), enableBgp) =
            let apply (args: VirtualNetworkGatewayConnectionArgs) =
                args.EnableBgp <- io enableBgp
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("expressRouteCircuitId")>]
        member _.ExpressRouteCircuitId((name, args), expressRouteCircuitId) =
            let apply (args: VirtualNetworkGatewayConnectionArgs) =
                args.ExpressRouteCircuitId <- input expressRouteCircuitId
                args

            ()
            name, List.Cons(apply, args)

        member _.ExpressRouteCircuitId((name, args), expressRouteCircuitId) =
            let apply (args: VirtualNetworkGatewayConnectionArgs) =
                args.ExpressRouteCircuitId <- io expressRouteCircuitId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("expressRouteGatewayBypass")>]
        member _.ExpressRouteGatewayBypass((name, args), expressRouteGatewayBypass) =
            let apply (args: VirtualNetworkGatewayConnectionArgs) =
                args.ExpressRouteGatewayBypass <- input expressRouteGatewayBypass
                args

            ()
            name, List.Cons(apply, args)

        member _.ExpressRouteGatewayBypass((name, args), expressRouteGatewayBypass) =
            let apply (args: VirtualNetworkGatewayConnectionArgs) =
                args.ExpressRouteGatewayBypass <- io expressRouteGatewayBypass
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: VirtualNetworkGatewayConnectionArgs) =
                   args.IpsecPolicy <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("localNetworkGatewayId")>]
        member _.LocalNetworkGatewayId((name, args), localNetworkGatewayId) =
            let apply (args: VirtualNetworkGatewayConnectionArgs) =
                args.LocalNetworkGatewayId <- input localNetworkGatewayId
                args

            ()
            name, List.Cons(apply, args)

        member _.LocalNetworkGatewayId((name, args), localNetworkGatewayId) =
            let apply (args: VirtualNetworkGatewayConnectionArgs) =
                args.LocalNetworkGatewayId <- io localNetworkGatewayId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: VirtualNetworkGatewayConnectionArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: VirtualNetworkGatewayConnectionArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: VirtualNetworkGatewayConnectionArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: VirtualNetworkGatewayConnectionArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("peerVirtualNetworkGatewayId")>]
        member _.PeerVirtualNetworkGatewayId((name, args), peerVirtualNetworkGatewayId) =
            let apply (args: VirtualNetworkGatewayConnectionArgs) =
                args.PeerVirtualNetworkGatewayId <- input peerVirtualNetworkGatewayId
                args

            ()
            name, List.Cons(apply, args)

        member _.PeerVirtualNetworkGatewayId((name, args), peerVirtualNetworkGatewayId) =
            let apply (args: VirtualNetworkGatewayConnectionArgs) =
                args.PeerVirtualNetworkGatewayId <- io peerVirtualNetworkGatewayId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: VirtualNetworkGatewayConnectionArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: VirtualNetworkGatewayConnectionArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("routingWeight")>]
        member _.RoutingWeight((name, args), routingWeight) =
            let apply (args: VirtualNetworkGatewayConnectionArgs) =
                args.RoutingWeight <- input routingWeight
                args

            ()
            name, List.Cons(apply, args)

        member _.RoutingWeight((name, args), routingWeight) =
            let apply (args: VirtualNetworkGatewayConnectionArgs) =
                args.RoutingWeight <- io routingWeight
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sharedKey")>]
        member _.SharedKey((name, args), sharedKey) =
            let apply (args: VirtualNetworkGatewayConnectionArgs) =
                args.SharedKey <- input sharedKey
                args

            ()
            name, List.Cons(apply, args)

        member _.SharedKey((name, args), sharedKey) =
            let apply (args: VirtualNetworkGatewayConnectionArgs) =
                args.SharedKey <- io sharedKey
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: VirtualNetworkGatewayConnectionArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((name, args), ``type``) =
            let apply (args: VirtualNetworkGatewayConnectionArgs) =
                args.Type <- input ``type``
                args

            ()
            name, List.Cons(apply, args)

        member _.Type((name, args), ``type``) =
            let apply (args: VirtualNetworkGatewayConnectionArgs) =
                args.Type <- io ``type``
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("usePolicyBasedTrafficSelectors")>]
        member _.UsePolicyBasedTrafficSelectors((name, args), usePolicyBasedTrafficSelectors) =
            let apply (args: VirtualNetworkGatewayConnectionArgs) =
                args.UsePolicyBasedTrafficSelectors <- input usePolicyBasedTrafficSelectors
                args

            ()
            name, List.Cons(apply, args)

        member _.UsePolicyBasedTrafficSelectors((name, args), usePolicyBasedTrafficSelectors) =
            let apply (args: VirtualNetworkGatewayConnectionArgs) =
                args.UsePolicyBasedTrafficSelectors <- io usePolicyBasedTrafficSelectors
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkGatewayId")>]
        member _.VirtualNetworkGatewayId((name, args), virtualNetworkGatewayId) =
            let apply (args: VirtualNetworkGatewayConnectionArgs) =
                args.VirtualNetworkGatewayId <- input virtualNetworkGatewayId
                args

            ()
            name, List.Cons(apply, args)

        member _.VirtualNetworkGatewayId((name, args), virtualNetworkGatewayId) =
            let apply (args: VirtualNetworkGatewayConnectionArgs) =
                args.VirtualNetworkGatewayId <- io virtualNetworkGatewayId
                args

            ()
            name, List.Cons(apply, args)

    let virtualNetworkGatewayConnection = VirtualNetworkGatewayConnectionBuilder()

    type VirtualNetworkPeeringBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            VirtualNetworkPeering(name, (List.fold func (VirtualNetworkPeeringArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("allowForwardedTraffic")>]
        member _.AllowForwardedTraffic((name, args), allowForwardedTraffic) =
            let apply (args: VirtualNetworkPeeringArgs) =
                args.AllowForwardedTraffic <- input allowForwardedTraffic
                args

            ()
            name, List.Cons(apply, args)

        member _.AllowForwardedTraffic((name, args), allowForwardedTraffic) =
            let apply (args: VirtualNetworkPeeringArgs) =
                args.AllowForwardedTraffic <- io allowForwardedTraffic
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("allowGatewayTransit")>]
        member _.AllowGatewayTransit((name, args), allowGatewayTransit) =
            let apply (args: VirtualNetworkPeeringArgs) =
                args.AllowGatewayTransit <- input allowGatewayTransit
                args

            ()
            name, List.Cons(apply, args)

        member _.AllowGatewayTransit((name, args), allowGatewayTransit) =
            let apply (args: VirtualNetworkPeeringArgs) =
                args.AllowGatewayTransit <- io allowGatewayTransit
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("allowVirtualNetworkAccess")>]
        member _.AllowVirtualNetworkAccess((name, args), allowVirtualNetworkAccess) =
            let apply (args: VirtualNetworkPeeringArgs) =
                args.AllowVirtualNetworkAccess <- input allowVirtualNetworkAccess
                args

            ()
            name, List.Cons(apply, args)

        member _.AllowVirtualNetworkAccess((name, args), allowVirtualNetworkAccess) =
            let apply (args: VirtualNetworkPeeringArgs) =
                args.AllowVirtualNetworkAccess <- io allowVirtualNetworkAccess
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: VirtualNetworkPeeringArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: VirtualNetworkPeeringArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("remoteVirtualNetworkId")>]
        member _.RemoteVirtualNetworkId((name, args), remoteVirtualNetworkId) =
            let apply (args: VirtualNetworkPeeringArgs) =
                args.RemoteVirtualNetworkId <- input remoteVirtualNetworkId
                args

            ()
            name, List.Cons(apply, args)

        member _.RemoteVirtualNetworkId((name, args), remoteVirtualNetworkId) =
            let apply (args: VirtualNetworkPeeringArgs) =
                args.RemoteVirtualNetworkId <- io remoteVirtualNetworkId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: VirtualNetworkPeeringArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: VirtualNetworkPeeringArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("useRemoteGateways")>]
        member _.UseRemoteGateways((name, args), useRemoteGateways) =
            let apply (args: VirtualNetworkPeeringArgs) =
                args.UseRemoteGateways <- input useRemoteGateways
                args

            ()
            name, List.Cons(apply, args)

        member _.UseRemoteGateways((name, args), useRemoteGateways) =
            let apply (args: VirtualNetworkPeeringArgs) =
                args.UseRemoteGateways <- io useRemoteGateways
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkName")>]
        member _.VirtualNetworkName((name, args), virtualNetworkName) =
            let apply (args: VirtualNetworkPeeringArgs) =
                args.VirtualNetworkName <- input virtualNetworkName
                args

            ()
            name, List.Cons(apply, args)

        member _.VirtualNetworkName((name, args), virtualNetworkName) =
            let apply (args: VirtualNetworkPeeringArgs) =
                args.VirtualNetworkName <- io virtualNetworkName
                args

            ()
            name, List.Cons(apply, args)

    let virtualNetworkPeering = VirtualNetworkPeeringBuilder()

    type VirtualWanBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            VirtualWan(name, (List.fold func (VirtualWanArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("allowBranchToBranchTraffic")>]
        member _.AllowBranchToBranchTraffic((name, args), allowBranchToBranchTraffic) =
            let apply (args: VirtualWanArgs) =
                args.AllowBranchToBranchTraffic <- input allowBranchToBranchTraffic
                args

            ()
            name, List.Cons(apply, args)

        member _.AllowBranchToBranchTraffic((name, args), allowBranchToBranchTraffic) =
            let apply (args: VirtualWanArgs) =
                args.AllowBranchToBranchTraffic <- io allowBranchToBranchTraffic
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("allowVnetToVnetTraffic")>]
        member _.AllowVnetToVnetTraffic((name, args), allowVnetToVnetTraffic) =
            let apply (args: VirtualWanArgs) =
                args.AllowVnetToVnetTraffic <- input allowVnetToVnetTraffic
                args

            ()
            name, List.Cons(apply, args)

        member _.AllowVnetToVnetTraffic((name, args), allowVnetToVnetTraffic) =
            let apply (args: VirtualWanArgs) =
                args.AllowVnetToVnetTraffic <- io allowVnetToVnetTraffic
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("disableVpnEncryption")>]
        member _.DisableVpnEncryption((name, args), disableVpnEncryption) =
            let apply (args: VirtualWanArgs) =
                args.DisableVpnEncryption <- input disableVpnEncryption
                args

            ()
            name, List.Cons(apply, args)

        member _.DisableVpnEncryption((name, args), disableVpnEncryption) =
            let apply (args: VirtualWanArgs) =
                args.DisableVpnEncryption <- io disableVpnEncryption
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: VirtualWanArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: VirtualWanArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: VirtualWanArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: VirtualWanArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("office365LocalBreakoutCategory")>]
        member _.Office365LocalBreakoutCategory((name, args), office365LocalBreakoutCategory) =
            let apply (args: VirtualWanArgs) =
                args.Office365LocalBreakoutCategory <- input office365LocalBreakoutCategory
                args

            ()
            name, List.Cons(apply, args)

        member _.Office365LocalBreakoutCategory((name, args), office365LocalBreakoutCategory) =
            let apply (args: VirtualWanArgs) =
                args.Office365LocalBreakoutCategory <- io office365LocalBreakoutCategory
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: VirtualWanArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: VirtualWanArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: VirtualWanArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((name, args), ``type``) =
            let apply (args: VirtualWanArgs) =
                args.Type <- input ``type``
                args

            ()
            name, List.Cons(apply, args)

        member _.Type((name, args), ``type``) =
            let apply (args: VirtualWanArgs) =
                args.Type <- io ``type``
                args

            ()
            name, List.Cons(apply, args)

    let virtualWan = VirtualWanBuilder()

    type VpnGatewayBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            VpnGateway(name, (List.fold func (VpnGatewayArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("bgpSettings")>]
        member _.BgpSettings((name, args), bgpSettings) =
            let apply (args: VpnGatewayArgs) =
                args.BgpSettings <- inputList bgpSettings
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: VpnGatewayArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: VpnGatewayArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: VpnGatewayArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: VpnGatewayArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: VpnGatewayArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: VpnGatewayArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("scaleUnit")>]
        member _.ScaleUnit((name, args), scaleUnit) =
            let apply (args: VpnGatewayArgs) =
                args.ScaleUnit <- input scaleUnit
                args

            ()
            name, List.Cons(apply, args)

        member _.ScaleUnit((name, args), scaleUnit) =
            let apply (args: VpnGatewayArgs) =
                args.ScaleUnit <- io scaleUnit
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: VpnGatewayArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("virtualHubId")>]
        member _.VirtualHubId((name, args), virtualHubId) =
            let apply (args: VpnGatewayArgs) =
                args.VirtualHubId <- input virtualHubId
                args

            ()
            name, List.Cons(apply, args)

        member _.VirtualHubId((name, args), virtualHubId) =
            let apply (args: VpnGatewayArgs) =
                args.VirtualHubId <- io virtualHubId
                args

            ()
            name, List.Cons(apply, args)

    let vpnGateway = VpnGatewayBuilder()

    type VpnServerConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            VpnServerConfiguration(name, (List.fold func (VpnServerConfigurationArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("azureActiveDirectoryAuthentications")>]
        member _.AzureActiveDirectoryAuthentications((name, args), azureActiveDirectoryAuthentications) =
            let apply (args: VpnServerConfigurationArgs) =
                args.AzureActiveDirectoryAuthentications <- inputList azureActiveDirectoryAuthentications
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("clientRevokedCertificates")>]
        member _.ClientRevokedCertificates((name, args), clientRevokedCertificates) =
            let apply (args: VpnServerConfigurationArgs) =
                args.ClientRevokedCertificates <- inputList clientRevokedCertificates
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("clientRootCertificates")>]
        member _.ClientRootCertificates((name, args), clientRootCertificates) =
            let apply (args: VpnServerConfigurationArgs) =
                args.ClientRootCertificates <- inputList clientRootCertificates
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: VpnServerConfigurationArgs) =
                   args.IpsecPolicy <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: VpnServerConfigurationArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: VpnServerConfigurationArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: VpnServerConfigurationArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: VpnServerConfigurationArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: VpnServerConfigurationArgs) =
                   args.RadiusServer <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: VpnServerConfigurationArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: VpnServerConfigurationArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: VpnServerConfigurationArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("vpnAuthenticationTypes")>]
        member _.VpnAuthenticationTypes((name, args), vpnAuthenticationTypes) =
            let apply (args: VpnServerConfigurationArgs) =
                args.VpnAuthenticationTypes <- input vpnAuthenticationTypes
                args

            ()
            name, List.Cons(apply, args)

        member _.VpnAuthenticationTypes((name, args), vpnAuthenticationTypes) =
            let apply (args: VpnServerConfigurationArgs) =
                args.VpnAuthenticationTypes <- io vpnAuthenticationTypes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("vpnProtocols")>]
        member _.VpnProtocols((name, args), vpnProtocols) =
            let apply (args: VpnServerConfigurationArgs) =
                args.VpnProtocols <- inputList vpnProtocols
                args

            ()
            name, List.Cons(apply, args)

    let vpnServerConfiguration = VpnServerConfigurationBuilder()

module NotificationHub =
    open Pulumi.Azure.NotificationHub
    open Pulumi.Azure.NotificationHub.Inputs

    type HubApnsCredentialBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (HubApnsCredentialArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("applicationMode")>]
        member _.ApplicationMode((n, args), applicationMode) =
            let apply (args: HubApnsCredentialArgs) =
                args.ApplicationMode <- input applicationMode
                args

            ()
            n, List.Cons(apply, args)

        member _.ApplicationMode((n, args), applicationMode) =
            let apply (args: HubApnsCredentialArgs) =
                args.ApplicationMode <- io applicationMode
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("bundleId")>]
        member _.BundleId((n, args), bundleId) =
            let apply (args: HubApnsCredentialArgs) =
                args.BundleId <- input bundleId
                args

            ()
            n, List.Cons(apply, args)

        member _.BundleId((n, args), bundleId) =
            let apply (args: HubApnsCredentialArgs) =
                args.BundleId <- io bundleId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("keyId")>]
        member _.KeyId((n, args), keyId) =
            let apply (args: HubApnsCredentialArgs) =
                args.KeyId <- input keyId
                args

            ()
            n, List.Cons(apply, args)

        member _.KeyId((n, args), keyId) =
            let apply (args: HubApnsCredentialArgs) =
                args.KeyId <- io keyId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("teamId")>]
        member _.TeamId((n, args), teamId) =
            let apply (args: HubApnsCredentialArgs) =
                args.TeamId <- input teamId
                args

            ()
            n, List.Cons(apply, args)

        member _.TeamId((n, args), teamId) =
            let apply (args: HubApnsCredentialArgs) =
                args.TeamId <- io teamId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("token")>]
        member _.Token((n, args), token) =
            let apply (args: HubApnsCredentialArgs) =
                args.Token <- input token
                args

            ()
            n, List.Cons(apply, args)

        member _.Token((n, args), token) =
            let apply (args: HubApnsCredentialArgs) =
                args.Token <- io token
                args

            ()
            n, List.Cons(apply, args)

    let hubApnsCredential = HubApnsCredentialBuilder()

    type HubGcmCredentialBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (HubGcmCredentialArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("apiKey")>]
        member _.ApiKey((n, args), apiKey) =
            let apply (args: HubGcmCredentialArgs) =
                args.ApiKey <- input apiKey
                args

            ()
            n, List.Cons(apply, args)

        member _.ApiKey((n, args), apiKey) =
            let apply (args: HubGcmCredentialArgs) =
                args.ApiKey <- io apiKey
                args

            ()
            n, List.Cons(apply, args)

    let hubGcmCredential = HubGcmCredentialBuilder()

    type AuthorizationRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            AuthorizationRule(name, (List.fold func (AuthorizationRuleArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("listen")>]
        member _.Listen((name, args), listen) =
            let apply (args: AuthorizationRuleArgs) =
                args.Listen <- input listen
                args

            ()
            name, List.Cons(apply, args)

        member _.Listen((name, args), listen) =
            let apply (args: AuthorizationRuleArgs) =
                args.Listen <- io listen
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("manage")>]
        member _.Manage((name, args), manage) =
            let apply (args: AuthorizationRuleArgs) =
                args.Manage <- input manage
                args

            ()
            name, List.Cons(apply, args)

        member _.Manage((name, args), manage) =
            let apply (args: AuthorizationRuleArgs) =
                args.Manage <- io manage
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: AuthorizationRuleArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: AuthorizationRuleArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("namespaceName")>]
        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: AuthorizationRuleArgs) =
                args.NamespaceName <- input namespaceName
                args

            ()
            name, List.Cons(apply, args)

        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: AuthorizationRuleArgs) =
                args.NamespaceName <- io namespaceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("notificationHubName")>]
        member _.NotificationHubName((name, args), notificationHubName) =
            let apply (args: AuthorizationRuleArgs) =
                args.NotificationHubName <- input notificationHubName
                args

            ()
            name, List.Cons(apply, args)

        member _.NotificationHubName((name, args), notificationHubName) =
            let apply (args: AuthorizationRuleArgs) =
                args.NotificationHubName <- io notificationHubName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AuthorizationRuleArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AuthorizationRuleArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("send")>]
        member _.Send((name, args), send) =
            let apply (args: AuthorizationRuleArgs) =
                args.Send <- input send
                args

            ()
            name, List.Cons(apply, args)

        member _.Send((name, args), send) =
            let apply (args: AuthorizationRuleArgs) =
                args.Send <- io send
                args

            ()
            name, List.Cons(apply, args)

    let authorizationRule = AuthorizationRuleBuilder()

    type HubBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Hub(name, (List.fold func (HubArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: HubArgs) =
                   args.ApnsCredential <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: HubArgs) =
                   args.GcmCredential <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: HubArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: HubArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: HubArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: HubArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("namespaceName")>]
        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: HubArgs) =
                args.NamespaceName <- input namespaceName
                args

            ()
            name, List.Cons(apply, args)

        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: HubArgs) =
                args.NamespaceName <- io namespaceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: HubArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: HubArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: HubArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let hub = HubBuilder()

    type NamespaceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Namespace(name, (List.fold func (NamespaceArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("enabled")>]
        member _.Enabled((name, args), enabled) =
            let apply (args: NamespaceArgs) =
                args.Enabled <- input enabled
                args

            ()
            name, List.Cons(apply, args)

        member _.Enabled((name, args), enabled) =
            let apply (args: NamespaceArgs) =
                args.Enabled <- io enabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: NamespaceArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: NamespaceArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: NamespaceArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: NamespaceArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("namespaceType")>]
        member _.NamespaceType((name, args), namespaceType) =
            let apply (args: NamespaceArgs) =
                args.NamespaceType <- input namespaceType
                args

            ()
            name, List.Cons(apply, args)

        member _.NamespaceType((name, args), namespaceType) =
            let apply (args: NamespaceArgs) =
                args.NamespaceType <- io namespaceType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NamespaceArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NamespaceArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("skuName")>]
        member _.SkuName((name, args), skuName) =
            let apply (args: NamespaceArgs) =
                args.SkuName <- input skuName
                args

            ()
            name, List.Cons(apply, args)

        member _.SkuName((name, args), skuName) =
            let apply (args: NamespaceArgs) =
                args.SkuName <- io skuName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: NamespaceArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let ``namespace`` = NamespaceBuilder()

module OperationalInsights =
    open Pulumi.Azure.OperationalInsights
    open Pulumi.Azure.OperationalInsights.Inputs

    type AnalyticsSolutionPlanBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AnalyticsSolutionPlanArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: AnalyticsSolutionPlanArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: AnalyticsSolutionPlanArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("product")>]
        member _.Product((n, args), product) =
            let apply (args: AnalyticsSolutionPlanArgs) =
                args.Product <- input product
                args

            ()
            n, List.Cons(apply, args)

        member _.Product((n, args), product) =
            let apply (args: AnalyticsSolutionPlanArgs) =
                args.Product <- io product
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("promotionCode")>]
        member _.PromotionCode((n, args), promotionCode) =
            let apply (args: AnalyticsSolutionPlanArgs) =
                args.PromotionCode <- input promotionCode
                args

            ()
            n, List.Cons(apply, args)

        member _.PromotionCode((n, args), promotionCode) =
            let apply (args: AnalyticsSolutionPlanArgs) =
                args.PromotionCode <- io promotionCode
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("publisher")>]
        member _.Publisher((n, args), publisher) =
            let apply (args: AnalyticsSolutionPlanArgs) =
                args.Publisher <- input publisher
                args

            ()
            n, List.Cons(apply, args)

        member _.Publisher((n, args), publisher) =
            let apply (args: AnalyticsSolutionPlanArgs) =
                args.Publisher <- io publisher
                args

            ()
            n, List.Cons(apply, args)

    let analyticsSolutionPlan = AnalyticsSolutionPlanBuilder()

    type AnalyticsSolutionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            AnalyticsSolution(name, (List.fold func (AnalyticsSolutionArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: AnalyticsSolutionArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: AnalyticsSolutionArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: AnalyticsSolutionArgs) =
                   args.Plan <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AnalyticsSolutionArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AnalyticsSolutionArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("solutionName")>]
        member _.SolutionName((name, args), solutionName) =
            let apply (args: AnalyticsSolutionArgs) =
                args.SolutionName <- input solutionName
                args

            ()
            name, List.Cons(apply, args)

        member _.SolutionName((name, args), solutionName) =
            let apply (args: AnalyticsSolutionArgs) =
                args.SolutionName <- io solutionName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("workspaceName")>]
        member _.WorkspaceName((name, args), workspaceName) =
            let apply (args: AnalyticsSolutionArgs) =
                args.WorkspaceName <- input workspaceName
                args

            ()
            name, List.Cons(apply, args)

        member _.WorkspaceName((name, args), workspaceName) =
            let apply (args: AnalyticsSolutionArgs) =
                args.WorkspaceName <- io workspaceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("workspaceResourceId")>]
        member _.WorkspaceResourceId((name, args), workspaceResourceId) =
            let apply (args: AnalyticsSolutionArgs) =
                args.WorkspaceResourceId <- input workspaceResourceId
                args

            ()
            name, List.Cons(apply, args)

        member _.WorkspaceResourceId((name, args), workspaceResourceId) =
            let apply (args: AnalyticsSolutionArgs) =
                args.WorkspaceResourceId <- io workspaceResourceId
                args

            ()
            name, List.Cons(apply, args)

    let analyticsSolution = AnalyticsSolutionBuilder()

    type AnalyticsWorkspaceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            AnalyticsWorkspace(name, (List.fold func (AnalyticsWorkspaceArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: AnalyticsWorkspaceArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: AnalyticsWorkspaceArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: AnalyticsWorkspaceArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: AnalyticsWorkspaceArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AnalyticsWorkspaceArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AnalyticsWorkspaceArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("retentionInDays")>]
        member _.RetentionInDays((name, args), retentionInDays) =
            let apply (args: AnalyticsWorkspaceArgs) =
                args.RetentionInDays <- input retentionInDays
                args

            ()
            name, List.Cons(apply, args)

        member _.RetentionInDays((name, args), retentionInDays) =
            let apply (args: AnalyticsWorkspaceArgs) =
                args.RetentionInDays <- io retentionInDays
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sku")>]
        member _.Sku((name, args), sku) =
            let apply (args: AnalyticsWorkspaceArgs) =
                args.Sku <- input sku
                args

            ()
            name, List.Cons(apply, args)

        member _.Sku((name, args), sku) =
            let apply (args: AnalyticsWorkspaceArgs) =
                args.Sku <- io sku
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: AnalyticsWorkspaceArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let analyticsWorkspace = AnalyticsWorkspaceBuilder()

module Policy =
    open Pulumi.Azure.Policy
    open Pulumi.Azure.Policy.Inputs

    type AssignmentIdentityBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AssignmentIdentityArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("principalId")>]
        member _.PrincipalId((n, args), principalId) =
            let apply (args: AssignmentIdentityArgs) =
                args.PrincipalId <- input principalId
                args

            ()
            n, List.Cons(apply, args)

        member _.PrincipalId((n, args), principalId) =
            let apply (args: AssignmentIdentityArgs) =
                args.PrincipalId <- io principalId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tenantId")>]
        member _.TenantId((n, args), tenantId) =
            let apply (args: AssignmentIdentityArgs) =
                args.TenantId <- input tenantId
                args

            ()
            n, List.Cons(apply, args)

        member _.TenantId((n, args), tenantId) =
            let apply (args: AssignmentIdentityArgs) =
                args.TenantId <- io tenantId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: AssignmentIdentityArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: AssignmentIdentityArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let assignmentIdentity = AssignmentIdentityBuilder()

    type AssignmentBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Assignment(name, (List.fold func (AssignmentArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: AssignmentArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: AssignmentArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("displayName")>]
        member _.DisplayName((name, args), displayName) =
            let apply (args: AssignmentArgs) =
                args.DisplayName <- input displayName
                args

            ()
            name, List.Cons(apply, args)

        member _.DisplayName((name, args), displayName) =
            let apply (args: AssignmentArgs) =
                args.DisplayName <- io displayName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enforcementMode")>]
        member _.EnforcementMode((name, args), enforcementMode) =
            let apply (args: AssignmentArgs) =
                args.EnforcementMode <- input enforcementMode
                args

            ()
            name, List.Cons(apply, args)

        member _.EnforcementMode((name, args), enforcementMode) =
            let apply (args: AssignmentArgs) =
                args.EnforcementMode <- io enforcementMode
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: AssignmentArgs) =
                   args.Identity <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: AssignmentArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: AssignmentArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: AssignmentArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: AssignmentArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("notScopes")>]
        member _.NotScopes((name, args), notScopes) =
            let apply (args: AssignmentArgs) =
                args.NotScopes <- inputList notScopes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("parameters")>]
        member _.Parameters((name, args), parameters) =
            let apply (args: AssignmentArgs) =
                args.Parameters <- input parameters
                args

            ()
            name, List.Cons(apply, args)

        member _.Parameters((name, args), parameters) =
            let apply (args: AssignmentArgs) =
                args.Parameters <- io parameters
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("policyDefinitionId")>]
        member _.PolicyDefinitionId((name, args), policyDefinitionId) =
            let apply (args: AssignmentArgs) =
                args.PolicyDefinitionId <- input policyDefinitionId
                args

            ()
            name, List.Cons(apply, args)

        member _.PolicyDefinitionId((name, args), policyDefinitionId) =
            let apply (args: AssignmentArgs) =
                args.PolicyDefinitionId <- io policyDefinitionId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("scope")>]
        member _.Scope((name, args), scope) =
            let apply (args: AssignmentArgs) =
                args.Scope <- input scope
                args

            ()
            name, List.Cons(apply, args)

        member _.Scope((name, args), scope) =
            let apply (args: AssignmentArgs) =
                args.Scope <- io scope
                args

            ()
            name, List.Cons(apply, args)

    let assignment = AssignmentBuilder()

    type DefinitionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Definition(name, (List.fold func (DefinitionArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: DefinitionArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: DefinitionArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("displayName")>]
        member _.DisplayName((name, args), displayName) =
            let apply (args: DefinitionArgs) =
                args.DisplayName <- input displayName
                args

            ()
            name, List.Cons(apply, args)

        member _.DisplayName((name, args), displayName) =
            let apply (args: DefinitionArgs) =
                args.DisplayName <- io displayName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("managementGroupId")>]
        member _.ManagementGroupId((name, args), managementGroupId) =
            let apply (args: DefinitionArgs) =
                args.ManagementGroupId <- input managementGroupId
                args

            ()
            name, List.Cons(apply, args)

        member _.ManagementGroupId((name, args), managementGroupId) =
            let apply (args: DefinitionArgs) =
                args.ManagementGroupId <- io managementGroupId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("managementGroupName")>]
        member _.ManagementGroupName((name, args), managementGroupName) =
            let apply (args: DefinitionArgs) =
                args.ManagementGroupName <- input managementGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ManagementGroupName((name, args), managementGroupName) =
            let apply (args: DefinitionArgs) =
                args.ManagementGroupName <- io managementGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("metadata")>]
        member _.Metadata((name, args), metadata) =
            let apply (args: DefinitionArgs) =
                args.Metadata <- input metadata
                args

            ()
            name, List.Cons(apply, args)

        member _.Metadata((name, args), metadata) =
            let apply (args: DefinitionArgs) =
                args.Metadata <- io metadata
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("mode")>]
        member _.Mode((name, args), mode) =
            let apply (args: DefinitionArgs) =
                args.Mode <- input mode
                args

            ()
            name, List.Cons(apply, args)

        member _.Mode((name, args), mode) =
            let apply (args: DefinitionArgs) =
                args.Mode <- io mode
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: DefinitionArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: DefinitionArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("parameters")>]
        member _.Parameters((name, args), parameters) =
            let apply (args: DefinitionArgs) =
                args.Parameters <- input parameters
                args

            ()
            name, List.Cons(apply, args)

        member _.Parameters((name, args), parameters) =
            let apply (args: DefinitionArgs) =
                args.Parameters <- io parameters
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("policyRule")>]
        member _.PolicyRule((name, args), policyRule) =
            let apply (args: DefinitionArgs) =
                args.PolicyRule <- input policyRule
                args

            ()
            name, List.Cons(apply, args)

        member _.PolicyRule((name, args), policyRule) =
            let apply (args: DefinitionArgs) =
                args.PolicyRule <- io policyRule
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("policyType")>]
        member _.PolicyType((name, args), policyType) =
            let apply (args: DefinitionArgs) =
                args.PolicyType <- input policyType
                args

            ()
            name, List.Cons(apply, args)

        member _.PolicyType((name, args), policyType) =
            let apply (args: DefinitionArgs) =
                args.PolicyType <- io policyType
                args

            ()
            name, List.Cons(apply, args)

    let definition = DefinitionBuilder()

    type PolicySetDefinitionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            PolicySetDefinition(name, (List.fold func (PolicySetDefinitionArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: PolicySetDefinitionArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: PolicySetDefinitionArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("displayName")>]
        member _.DisplayName((name, args), displayName) =
            let apply (args: PolicySetDefinitionArgs) =
                args.DisplayName <- input displayName
                args

            ()
            name, List.Cons(apply, args)

        member _.DisplayName((name, args), displayName) =
            let apply (args: PolicySetDefinitionArgs) =
                args.DisplayName <- io displayName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("managementGroupId")>]
        member _.ManagementGroupId((name, args), managementGroupId) =
            let apply (args: PolicySetDefinitionArgs) =
                args.ManagementGroupId <- input managementGroupId
                args

            ()
            name, List.Cons(apply, args)

        member _.ManagementGroupId((name, args), managementGroupId) =
            let apply (args: PolicySetDefinitionArgs) =
                args.ManagementGroupId <- io managementGroupId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("metadata")>]
        member _.Metadata((name, args), metadata) =
            let apply (args: PolicySetDefinitionArgs) =
                args.Metadata <- input metadata
                args

            ()
            name, List.Cons(apply, args)

        member _.Metadata((name, args), metadata) =
            let apply (args: PolicySetDefinitionArgs) =
                args.Metadata <- io metadata
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: PolicySetDefinitionArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: PolicySetDefinitionArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("parameters")>]
        member _.Parameters((name, args), parameters) =
            let apply (args: PolicySetDefinitionArgs) =
                args.Parameters <- input parameters
                args

            ()
            name, List.Cons(apply, args)

        member _.Parameters((name, args), parameters) =
            let apply (args: PolicySetDefinitionArgs) =
                args.Parameters <- io parameters
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("policyDefinitions")>]
        member _.PolicyDefinitions((name, args), policyDefinitions) =
            let apply (args: PolicySetDefinitionArgs) =
                args.PolicyDefinitions <- input policyDefinitions
                args

            ()
            name, List.Cons(apply, args)

        member _.PolicyDefinitions((name, args), policyDefinitions) =
            let apply (args: PolicySetDefinitionArgs) =
                args.PolicyDefinitions <- io policyDefinitions
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("policyType")>]
        member _.PolicyType((name, args), policyType) =
            let apply (args: PolicySetDefinitionArgs) =
                args.PolicyType <- input policyType
                args

            ()
            name, List.Cons(apply, args)

        member _.PolicyType((name, args), policyType) =
            let apply (args: PolicySetDefinitionArgs) =
                args.PolicyType <- io policyType
                args

            ()
            name, List.Cons(apply, args)

    let policySetDefinition = PolicySetDefinitionBuilder()

    type RemediationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Remediation(name, (List.fold func (RemediationArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("locationFilters")>]
        member _.LocationFilters((name, args), locationFilters) =
            let apply (args: RemediationArgs) =
                args.LocationFilters <- inputList locationFilters
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: RemediationArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: RemediationArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("policyAssignmentId")>]
        member _.PolicyAssignmentId((name, args), policyAssignmentId) =
            let apply (args: RemediationArgs) =
                args.PolicyAssignmentId <- input policyAssignmentId
                args

            ()
            name, List.Cons(apply, args)

        member _.PolicyAssignmentId((name, args), policyAssignmentId) =
            let apply (args: RemediationArgs) =
                args.PolicyAssignmentId <- io policyAssignmentId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("policyDefinitionReferenceId")>]
        member _.PolicyDefinitionReferenceId((name, args), policyDefinitionReferenceId) =
            let apply (args: RemediationArgs) =
                args.PolicyDefinitionReferenceId <- input policyDefinitionReferenceId
                args

            ()
            name, List.Cons(apply, args)

        member _.PolicyDefinitionReferenceId((name, args), policyDefinitionReferenceId) =
            let apply (args: RemediationArgs) =
                args.PolicyDefinitionReferenceId <- io policyDefinitionReferenceId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("scope")>]
        member _.Scope((name, args), scope) =
            let apply (args: RemediationArgs) =
                args.Scope <- input scope
                args

            ()
            name, List.Cons(apply, args)

        member _.Scope((name, args), scope) =
            let apply (args: RemediationArgs) =
                args.Scope <- io scope
                args

            ()
            name, List.Cons(apply, args)

    let remediation = RemediationBuilder()

module PostgreSql =
    open Pulumi.Azure.PostgreSql
    open Pulumi.Azure.PostgreSql.Inputs

    type ServerStorageProfileBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ServerStorageProfileArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("autoGrow")>]
        member _.AutoGrow((n, args), autoGrow) =
            let apply (args: ServerStorageProfileArgs) =
                args.AutoGrow <- input autoGrow
                args

            ()
            n, List.Cons(apply, args)

        member _.AutoGrow((n, args), autoGrow) =
            let apply (args: ServerStorageProfileArgs) =
                args.AutoGrow <- io autoGrow
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("backupRetentionDays")>]
        member _.BackupRetentionDays((n, args), backupRetentionDays) =
            let apply (args: ServerStorageProfileArgs) =
                args.BackupRetentionDays <- input backupRetentionDays
                args

            ()
            n, List.Cons(apply, args)

        member _.BackupRetentionDays((n, args), backupRetentionDays) =
            let apply (args: ServerStorageProfileArgs) =
                args.BackupRetentionDays <- io backupRetentionDays
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("geoRedundantBackup")>]
        member _.GeoRedundantBackup((n, args), geoRedundantBackup) =
            let apply (args: ServerStorageProfileArgs) =
                args.GeoRedundantBackup <- input geoRedundantBackup
                args

            ()
            n, List.Cons(apply, args)

        member _.GeoRedundantBackup((n, args), geoRedundantBackup) =
            let apply (args: ServerStorageProfileArgs) =
                args.GeoRedundantBackup <- io geoRedundantBackup
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageMb")>]
        member _.StorageMb((n, args), storageMb) =
            let apply (args: ServerStorageProfileArgs) =
                args.StorageMb <- input storageMb
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageMb((n, args), storageMb) =
            let apply (args: ServerStorageProfileArgs) =
                args.StorageMb <- io storageMb
                args

            ()
            n, List.Cons(apply, args)

    let serverStorageProfile = ServerStorageProfileBuilder()

    type ServerThreatDetectionPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ServerThreatDetectionPolicyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("disabledAlerts")>]
        member _.DisabledAlerts((n, args), disabledAlerts) =
            let apply (args: ServerThreatDetectionPolicyArgs) =
                args.DisabledAlerts <- inputList disabledAlerts
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("emailAccountAdmins")>]
        member _.EmailAccountAdmins((n, args), emailAccountAdmins) =
            let apply (args: ServerThreatDetectionPolicyArgs) =
                args.EmailAccountAdmins <- input emailAccountAdmins
                args

            ()
            n, List.Cons(apply, args)

        member _.EmailAccountAdmins((n, args), emailAccountAdmins) =
            let apply (args: ServerThreatDetectionPolicyArgs) =
                args.EmailAccountAdmins <- io emailAccountAdmins
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("emailAddresses")>]
        member _.EmailAddresses((n, args), emailAddresses) =
            let apply (args: ServerThreatDetectionPolicyArgs) =
                args.EmailAddresses <- inputList emailAddresses
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: ServerThreatDetectionPolicyArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: ServerThreatDetectionPolicyArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("retentionDays")>]
        member _.RetentionDays((n, args), retentionDays) =
            let apply (args: ServerThreatDetectionPolicyArgs) =
                args.RetentionDays <- input retentionDays
                args

            ()
            n, List.Cons(apply, args)

        member _.RetentionDays((n, args), retentionDays) =
            let apply (args: ServerThreatDetectionPolicyArgs) =
                args.RetentionDays <- io retentionDays
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageAccountAccessKey")>]
        member _.StorageAccountAccessKey((n, args), storageAccountAccessKey) =
            let apply (args: ServerThreatDetectionPolicyArgs) =
                args.StorageAccountAccessKey <- input storageAccountAccessKey
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountAccessKey((n, args), storageAccountAccessKey) =
            let apply (args: ServerThreatDetectionPolicyArgs) =
                args.StorageAccountAccessKey <- io storageAccountAccessKey
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageEndpoint")>]
        member _.StorageEndpoint((n, args), storageEndpoint) =
            let apply (args: ServerThreatDetectionPolicyArgs) =
                args.StorageEndpoint <- input storageEndpoint
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageEndpoint((n, args), storageEndpoint) =
            let apply (args: ServerThreatDetectionPolicyArgs) =
                args.StorageEndpoint <- io storageEndpoint
                args

            ()
            n, List.Cons(apply, args)

    let serverThreatDetectionPolicy = ServerThreatDetectionPolicyBuilder()

    type ActiveDirectoryAdministratorBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ActiveDirectoryAdministrator(name, (List.fold func (ActiveDirectoryAdministratorArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("login")>]
        member _.Login((name, args), login) =
            let apply (args: ActiveDirectoryAdministratorArgs) =
                args.Login <- input login
                args

            ()
            name, List.Cons(apply, args)

        member _.Login((name, args), login) =
            let apply (args: ActiveDirectoryAdministratorArgs) =
                args.Login <- io login
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("objectId")>]
        member _.ObjectId((name, args), objectId) =
            let apply (args: ActiveDirectoryAdministratorArgs) =
                args.ObjectId <- input objectId
                args

            ()
            name, List.Cons(apply, args)

        member _.ObjectId((name, args), objectId) =
            let apply (args: ActiveDirectoryAdministratorArgs) =
                args.ObjectId <- io objectId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ActiveDirectoryAdministratorArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ActiveDirectoryAdministratorArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serverName")>]
        member _.ServerName((name, args), serverName) =
            let apply (args: ActiveDirectoryAdministratorArgs) =
                args.ServerName <- input serverName
                args

            ()
            name, List.Cons(apply, args)

        member _.ServerName((name, args), serverName) =
            let apply (args: ActiveDirectoryAdministratorArgs) =
                args.ServerName <- io serverName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tenantId")>]
        member _.TenantId((name, args), tenantId) =
            let apply (args: ActiveDirectoryAdministratorArgs) =
                args.TenantId <- input tenantId
                args

            ()
            name, List.Cons(apply, args)

        member _.TenantId((name, args), tenantId) =
            let apply (args: ActiveDirectoryAdministratorArgs) =
                args.TenantId <- io tenantId
                args

            ()
            name, List.Cons(apply, args)

    let activeDirectoryAdministrator = ActiveDirectoryAdministratorBuilder()

    type ConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Configuration(name, (List.fold func (ConfigurationArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ConfigurationArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ConfigurationArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ConfigurationArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ConfigurationArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serverName")>]
        member _.ServerName((name, args), serverName) =
            let apply (args: ConfigurationArgs) =
                args.ServerName <- input serverName
                args

            ()
            name, List.Cons(apply, args)

        member _.ServerName((name, args), serverName) =
            let apply (args: ConfigurationArgs) =
                args.ServerName <- io serverName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((name, args), value) =
            let apply (args: ConfigurationArgs) =
                args.Value <- input value
                args

            ()
            name, List.Cons(apply, args)

        member _.Value((name, args), value) =
            let apply (args: ConfigurationArgs) =
                args.Value <- io value
                args

            ()
            name, List.Cons(apply, args)

    let configuration = ConfigurationBuilder()

    type DatabaseBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Database(name, (List.fold func (DatabaseArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("charset")>]
        member _.Charset((name, args), charset) =
            let apply (args: DatabaseArgs) =
                args.Charset <- input charset
                args

            ()
            name, List.Cons(apply, args)

        member _.Charset((name, args), charset) =
            let apply (args: DatabaseArgs) =
                args.Charset <- io charset
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("collation")>]
        member _.Collation((name, args), collation) =
            let apply (args: DatabaseArgs) =
                args.Collation <- input collation
                args

            ()
            name, List.Cons(apply, args)

        member _.Collation((name, args), collation) =
            let apply (args: DatabaseArgs) =
                args.Collation <- io collation
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: DatabaseArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: DatabaseArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DatabaseArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DatabaseArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serverName")>]
        member _.ServerName((name, args), serverName) =
            let apply (args: DatabaseArgs) =
                args.ServerName <- input serverName
                args

            ()
            name, List.Cons(apply, args)

        member _.ServerName((name, args), serverName) =
            let apply (args: DatabaseArgs) =
                args.ServerName <- io serverName
                args

            ()
            name, List.Cons(apply, args)

    let database = DatabaseBuilder()

    type FirewallRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            FirewallRule(name, (List.fold func (FirewallRuleArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("endIpAddress")>]
        member _.EndIpAddress((name, args), endIpAddress) =
            let apply (args: FirewallRuleArgs) =
                args.EndIpAddress <- input endIpAddress
                args

            ()
            name, List.Cons(apply, args)

        member _.EndIpAddress((name, args), endIpAddress) =
            let apply (args: FirewallRuleArgs) =
                args.EndIpAddress <- io endIpAddress
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: FirewallRuleArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: FirewallRuleArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FirewallRuleArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FirewallRuleArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serverName")>]
        member _.ServerName((name, args), serverName) =
            let apply (args: FirewallRuleArgs) =
                args.ServerName <- input serverName
                args

            ()
            name, List.Cons(apply, args)

        member _.ServerName((name, args), serverName) =
            let apply (args: FirewallRuleArgs) =
                args.ServerName <- io serverName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("startIpAddress")>]
        member _.StartIpAddress((name, args), startIpAddress) =
            let apply (args: FirewallRuleArgs) =
                args.StartIpAddress <- input startIpAddress
                args

            ()
            name, List.Cons(apply, args)

        member _.StartIpAddress((name, args), startIpAddress) =
            let apply (args: FirewallRuleArgs) =
                args.StartIpAddress <- io startIpAddress
                args

            ()
            name, List.Cons(apply, args)

    let firewallRule = FirewallRuleBuilder()

    type ServerBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Server(name, (List.fold func (ServerArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("administratorLogin")>]
        member _.AdministratorLogin((name, args), administratorLogin) =
            let apply (args: ServerArgs) =
                args.AdministratorLogin <- input administratorLogin
                args

            ()
            name, List.Cons(apply, args)

        member _.AdministratorLogin((name, args), administratorLogin) =
            let apply (args: ServerArgs) =
                args.AdministratorLogin <- io administratorLogin
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("administratorLoginPassword")>]
        member _.AdministratorLoginPassword((name, args), administratorLoginPassword) =
            let apply (args: ServerArgs) =
                args.AdministratorLoginPassword <- input administratorLoginPassword
                args

            ()
            name, List.Cons(apply, args)

        member _.AdministratorLoginPassword((name, args), administratorLoginPassword) =
            let apply (args: ServerArgs) =
                args.AdministratorLoginPassword <- io administratorLoginPassword
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("autoGrowEnabled")>]
        member _.AutoGrowEnabled((name, args), autoGrowEnabled) =
            let apply (args: ServerArgs) =
                args.AutoGrowEnabled <- input autoGrowEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.AutoGrowEnabled((name, args), autoGrowEnabled) =
            let apply (args: ServerArgs) =
                args.AutoGrowEnabled <- io autoGrowEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("backupRetentionDays")>]
        member _.BackupRetentionDays((name, args), backupRetentionDays) =
            let apply (args: ServerArgs) =
                args.BackupRetentionDays <- input backupRetentionDays
                args

            ()
            name, List.Cons(apply, args)

        member _.BackupRetentionDays((name, args), backupRetentionDays) =
            let apply (args: ServerArgs) =
                args.BackupRetentionDays <- io backupRetentionDays
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("createMode")>]
        member _.CreateMode((name, args), createMode) =
            let apply (args: ServerArgs) =
                args.CreateMode <- input createMode
                args

            ()
            name, List.Cons(apply, args)

        member _.CreateMode((name, args), createMode) =
            let apply (args: ServerArgs) =
                args.CreateMode <- io createMode
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("creationSourceServerId")>]
        member _.CreationSourceServerId((name, args), creationSourceServerId) =
            let apply (args: ServerArgs) =
                args.CreationSourceServerId <- input creationSourceServerId
                args

            ()
            name, List.Cons(apply, args)

        member _.CreationSourceServerId((name, args), creationSourceServerId) =
            let apply (args: ServerArgs) =
                args.CreationSourceServerId <- io creationSourceServerId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("geoRedundantBackupEnabled")>]
        member _.GeoRedundantBackupEnabled((name, args), geoRedundantBackupEnabled) =
            let apply (args: ServerArgs) =
                args.GeoRedundantBackupEnabled <- input geoRedundantBackupEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.GeoRedundantBackupEnabled((name, args), geoRedundantBackupEnabled) =
            let apply (args: ServerArgs) =
                args.GeoRedundantBackupEnabled <- io geoRedundantBackupEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("infrastructureEncryptionEnabled")>]
        member _.InfrastructureEncryptionEnabled((name, args), infrastructureEncryptionEnabled) =
            let apply (args: ServerArgs) =
                args.InfrastructureEncryptionEnabled <- input infrastructureEncryptionEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.InfrastructureEncryptionEnabled((name, args), infrastructureEncryptionEnabled) =
            let apply (args: ServerArgs) =
                args.InfrastructureEncryptionEnabled <- io infrastructureEncryptionEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ServerArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ServerArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ServerArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ServerArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("publicNetworkAccessEnabled")>]
        member _.PublicNetworkAccessEnabled((name, args), publicNetworkAccessEnabled) =
            let apply (args: ServerArgs) =
                args.PublicNetworkAccessEnabled <- input publicNetworkAccessEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.PublicNetworkAccessEnabled((name, args), publicNetworkAccessEnabled) =
            let apply (args: ServerArgs) =
                args.PublicNetworkAccessEnabled <- io publicNetworkAccessEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ServerArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ServerArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("restorePointInTime")>]
        member _.RestorePointInTime((name, args), restorePointInTime) =
            let apply (args: ServerArgs) =
                args.RestorePointInTime <- input restorePointInTime
                args

            ()
            name, List.Cons(apply, args)

        member _.RestorePointInTime((name, args), restorePointInTime) =
            let apply (args: ServerArgs) =
                args.RestorePointInTime <- io restorePointInTime
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("skuName")>]
        member _.SkuName((name, args), skuName) =
            let apply (args: ServerArgs) =
                args.SkuName <- input skuName
                args

            ()
            name, List.Cons(apply, args)

        member _.SkuName((name, args), skuName) =
            let apply (args: ServerArgs) =
                args.SkuName <- io skuName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sslEnforcement")>]
        member _.SslEnforcement((name, args), sslEnforcement) =
            let apply (args: ServerArgs) =
                args.SslEnforcement <- input sslEnforcement
                args

            ()
            name, List.Cons(apply, args)

        member _.SslEnforcement((name, args), sslEnforcement) =
            let apply (args: ServerArgs) =
                args.SslEnforcement <- io sslEnforcement
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sslEnforcementEnabled")>]
        member _.SslEnforcementEnabled((name, args), sslEnforcementEnabled) =
            let apply (args: ServerArgs) =
                args.SslEnforcementEnabled <- input sslEnforcementEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.SslEnforcementEnabled((name, args), sslEnforcementEnabled) =
            let apply (args: ServerArgs) =
                args.SslEnforcementEnabled <- io sslEnforcementEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sslMinimalTlsVersionEnforced")>]
        member _.SslMinimalTlsVersionEnforced((name, args), sslMinimalTlsVersionEnforced) =
            let apply (args: ServerArgs) =
                args.SslMinimalTlsVersionEnforced <- input sslMinimalTlsVersionEnforced
                args

            ()
            name, List.Cons(apply, args)

        member _.SslMinimalTlsVersionEnforced((name, args), sslMinimalTlsVersionEnforced) =
            let apply (args: ServerArgs) =
                args.SslMinimalTlsVersionEnforced <- io sslMinimalTlsVersionEnforced
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageMb")>]
        member _.StorageMb((name, args), storageMb) =
            let apply (args: ServerArgs) =
                args.StorageMb <- input storageMb
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageMb((name, args), storageMb) =
            let apply (args: ServerArgs) =
                args.StorageMb <- io storageMb
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ServerArgs) =
                   args.StorageProfile <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ServerArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ServerArgs) =
                   args.ThreatDetectionPolicy <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("version")>]
        member _.Version((name, args), version) =
            let apply (args: ServerArgs) =
                args.Version <- input version
                args

            ()
            name, List.Cons(apply, args)

        member _.Version((name, args), version) =
            let apply (args: ServerArgs) =
                args.Version <- io version
                args

            ()
            name, List.Cons(apply, args)

    let server = ServerBuilder()

    type VirtualNetworkRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            VirtualNetworkRule(name, (List.fold func (VirtualNetworkRuleArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("ignoreMissingVnetServiceEndpoint")>]
        member _.IgnoreMissingVnetServiceEndpoint((name, args), ignoreMissingVnetServiceEndpoint) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.IgnoreMissingVnetServiceEndpoint <- input ignoreMissingVnetServiceEndpoint
                args

            ()
            name, List.Cons(apply, args)

        member _.IgnoreMissingVnetServiceEndpoint((name, args), ignoreMissingVnetServiceEndpoint) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.IgnoreMissingVnetServiceEndpoint <- io ignoreMissingVnetServiceEndpoint
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serverName")>]
        member _.ServerName((name, args), serverName) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.ServerName <- input serverName
                args

            ()
            name, List.Cons(apply, args)

        member _.ServerName((name, args), serverName) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.ServerName <- io serverName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((name, args), subnetId) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            name, List.Cons(apply, args)

        member _.SubnetId((name, args), subnetId) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            name, List.Cons(apply, args)

    let virtualNetworkRule = VirtualNetworkRuleBuilder()

module PrivateDns =
    open Pulumi.Azure.PrivateDns
    open Pulumi.Azure.PrivateDns.Inputs

    type LinkServiceNatIpConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (LinkServiceNatIpConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: LinkServiceNatIpConfigurationArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: LinkServiceNatIpConfigurationArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("primary")>]
        member _.Primary((n, args), primary) =
            let apply (args: LinkServiceNatIpConfigurationArgs) =
                args.Primary <- input primary
                args

            ()
            n, List.Cons(apply, args)

        member _.Primary((n, args), primary) =
            let apply (args: LinkServiceNatIpConfigurationArgs) =
                args.Primary <- io primary
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("privateIpAddress")>]
        member _.PrivateIpAddress((n, args), privateIpAddress) =
            let apply (args: LinkServiceNatIpConfigurationArgs) =
                args.PrivateIpAddress <- input privateIpAddress
                args

            ()
            n, List.Cons(apply, args)

        member _.PrivateIpAddress((n, args), privateIpAddress) =
            let apply (args: LinkServiceNatIpConfigurationArgs) =
                args.PrivateIpAddress <- io privateIpAddress
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("privateIpAddressVersion")>]
        member _.PrivateIpAddressVersion((n, args), privateIpAddressVersion) =
            let apply (args: LinkServiceNatIpConfigurationArgs) =
                args.PrivateIpAddressVersion <- input privateIpAddressVersion
                args

            ()
            n, List.Cons(apply, args)

        member _.PrivateIpAddressVersion((n, args), privateIpAddressVersion) =
            let apply (args: LinkServiceNatIpConfigurationArgs) =
                args.PrivateIpAddressVersion <- io privateIpAddressVersion
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: LinkServiceNatIpConfigurationArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: LinkServiceNatIpConfigurationArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

    let linkServiceNatIpConfiguration = LinkServiceNatIpConfigurationBuilder()

    type MxRecordRecordBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (MxRecordRecordArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("exchange")>]
        member _.Exchange((n, args), exchange) =
            let apply (args: MxRecordRecordArgs) =
                args.Exchange <- input exchange
                args

            ()
            n, List.Cons(apply, args)

        member _.Exchange((n, args), exchange) =
            let apply (args: MxRecordRecordArgs) =
                args.Exchange <- io exchange
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("preference")>]
        member _.Preference((n, args), preference) =
            let apply (args: MxRecordRecordArgs) =
                args.Preference <- input preference
                args

            ()
            n, List.Cons(apply, args)

        member _.Preference((n, args), preference) =
            let apply (args: MxRecordRecordArgs) =
                args.Preference <- io preference
                args

            ()
            n, List.Cons(apply, args)

    let mxRecordRecord = MxRecordRecordBuilder()

    type SRVRecordRecordBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SRVRecordRecordArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("port")>]
        member _.Port((n, args), port) =
            let apply (args: SRVRecordRecordArgs) =
                args.Port <- input port
                args

            ()
            n, List.Cons(apply, args)

        member _.Port((n, args), port) =
            let apply (args: SRVRecordRecordArgs) =
                args.Port <- io port
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("priority")>]
        member _.Priority((n, args), priority) =
            let apply (args: SRVRecordRecordArgs) =
                args.Priority <- input priority
                args

            ()
            n, List.Cons(apply, args)

        member _.Priority((n, args), priority) =
            let apply (args: SRVRecordRecordArgs) =
                args.Priority <- io priority
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("target")>]
        member _.Target((n, args), target) =
            let apply (args: SRVRecordRecordArgs) =
                args.Target <- input target
                args

            ()
            n, List.Cons(apply, args)

        member _.Target((n, args), target) =
            let apply (args: SRVRecordRecordArgs) =
                args.Target <- io target
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("weight")>]
        member _.Weight((n, args), weight) =
            let apply (args: SRVRecordRecordArgs) =
                args.Weight <- input weight
                args

            ()
            n, List.Cons(apply, args)

        member _.Weight((n, args), weight) =
            let apply (args: SRVRecordRecordArgs) =
                args.Weight <- io weight
                args

            ()
            n, List.Cons(apply, args)

    let sRVRecordRecord = SRVRecordRecordBuilder()

    type TxtRecordRecordBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (TxtRecordRecordArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("value")>]
        member _.Value((n, args), value) =
            let apply (args: TxtRecordRecordArgs) =
                args.Value <- input value
                args

            ()
            n, List.Cons(apply, args)

        member _.Value((n, args), value) =
            let apply (args: TxtRecordRecordArgs) =
                args.Value <- io value
                args

            ()
            n, List.Cons(apply, args)

    let txtRecordRecord = TxtRecordRecordBuilder()

    type AAAARecordBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            AAAARecord(name, (List.fold func (AAAARecordArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: AAAARecordArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: AAAARecordArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("records")>]
        member _.Records((name, args), records) =
            let apply (args: AAAARecordArgs) =
                args.Records <- inputList records
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AAAARecordArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AAAARecordArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: AAAARecordArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("ttl")>]
        member _.Ttl((name, args), ttl) =
            let apply (args: AAAARecordArgs) =
                args.Ttl <- input ttl
                args

            ()
            name, List.Cons(apply, args)

        member _.Ttl((name, args), ttl) =
            let apply (args: AAAARecordArgs) =
                args.Ttl <- io ttl
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zoneName")>]
        member _.ZoneName((name, args), zoneName) =
            let apply (args: AAAARecordArgs) =
                args.ZoneName <- input zoneName
                args

            ()
            name, List.Cons(apply, args)

        member _.ZoneName((name, args), zoneName) =
            let apply (args: AAAARecordArgs) =
                args.ZoneName <- io zoneName
                args

            ()
            name, List.Cons(apply, args)

    let aAAARecord = AAAARecordBuilder()

    type ARecordBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ARecord(name, (List.fold func (ARecordArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ARecordArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ARecordArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("records")>]
        member _.Records((name, args), records) =
            let apply (args: ARecordArgs) =
                args.Records <- inputList records
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ARecordArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ARecordArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ARecordArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("ttl")>]
        member _.Ttl((name, args), ttl) =
            let apply (args: ARecordArgs) =
                args.Ttl <- input ttl
                args

            ()
            name, List.Cons(apply, args)

        member _.Ttl((name, args), ttl) =
            let apply (args: ARecordArgs) =
                args.Ttl <- io ttl
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zoneName")>]
        member _.ZoneName((name, args), zoneName) =
            let apply (args: ARecordArgs) =
                args.ZoneName <- input zoneName
                args

            ()
            name, List.Cons(apply, args)

        member _.ZoneName((name, args), zoneName) =
            let apply (args: ARecordArgs) =
                args.ZoneName <- io zoneName
                args

            ()
            name, List.Cons(apply, args)

    let aRecord = ARecordBuilder()

    type CnameRecordBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            CnameRecord(name, (List.fold func (CnameRecordArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: CnameRecordArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: CnameRecordArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("record")>]
        member _.Record((name, args), record) =
            let apply (args: CnameRecordArgs) =
                args.Record <- input record
                args

            ()
            name, List.Cons(apply, args)

        member _.Record((name, args), record) =
            let apply (args: CnameRecordArgs) =
                args.Record <- io record
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: CnameRecordArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: CnameRecordArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: CnameRecordArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("ttl")>]
        member _.Ttl((name, args), ttl) =
            let apply (args: CnameRecordArgs) =
                args.Ttl <- input ttl
                args

            ()
            name, List.Cons(apply, args)

        member _.Ttl((name, args), ttl) =
            let apply (args: CnameRecordArgs) =
                args.Ttl <- io ttl
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zoneName")>]
        member _.ZoneName((name, args), zoneName) =
            let apply (args: CnameRecordArgs) =
                args.ZoneName <- input zoneName
                args

            ()
            name, List.Cons(apply, args)

        member _.ZoneName((name, args), zoneName) =
            let apply (args: CnameRecordArgs) =
                args.ZoneName <- io zoneName
                args

            ()
            name, List.Cons(apply, args)

    let cnameRecord = CnameRecordBuilder()

    type LinkServiceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            LinkService(name, (List.fold func (LinkServiceArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("autoApprovalSubscriptionIds")>]
        member _.AutoApprovalSubscriptionIds((name, args), autoApprovalSubscriptionIds) =
            let apply (args: LinkServiceArgs) =
                args.AutoApprovalSubscriptionIds <- inputList autoApprovalSubscriptionIds
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enableProxyProtocol")>]
        member _.EnableProxyProtocol((name, args), enableProxyProtocol) =
            let apply (args: LinkServiceArgs) =
                args.EnableProxyProtocol <- input enableProxyProtocol
                args

            ()
            name, List.Cons(apply, args)

        member _.EnableProxyProtocol((name, args), enableProxyProtocol) =
            let apply (args: LinkServiceArgs) =
                args.EnableProxyProtocol <- io enableProxyProtocol
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("loadBalancerFrontendIpConfigurationIds")>]
        member _.LoadBalancerFrontendIpConfigurationIds((name, args), loadBalancerFrontendIpConfigurationIds) =
            let apply (args: LinkServiceArgs) =
                args.LoadBalancerFrontendIpConfigurationIds <- inputList loadBalancerFrontendIpConfigurationIds
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: LinkServiceArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: LinkServiceArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: LinkServiceArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: LinkServiceArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("natIpConfigurations")>]
        member _.NatIpConfigurations((name, args), natIpConfigurations) =
            let apply (args: LinkServiceArgs) =
                args.NatIpConfigurations <- inputList natIpConfigurations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: LinkServiceArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: LinkServiceArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: LinkServiceArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("visibilitySubscriptionIds")>]
        member _.VisibilitySubscriptionIds((name, args), visibilitySubscriptionIds) =
            let apply (args: LinkServiceArgs) =
                args.VisibilitySubscriptionIds <- inputList visibilitySubscriptionIds
                args

            ()
            name, List.Cons(apply, args)

    let linkService = LinkServiceBuilder()

    type MxRecordBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            MxRecord(name, (List.fold func (MxRecordArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: MxRecordArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: MxRecordArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("records")>]
        member _.Records((name, args), records) =
            let apply (args: MxRecordArgs) =
                args.Records <- inputList records
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: MxRecordArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: MxRecordArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: MxRecordArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("ttl")>]
        member _.Ttl((name, args), ttl) =
            let apply (args: MxRecordArgs) =
                args.Ttl <- input ttl
                args

            ()
            name, List.Cons(apply, args)

        member _.Ttl((name, args), ttl) =
            let apply (args: MxRecordArgs) =
                args.Ttl <- io ttl
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zoneName")>]
        member _.ZoneName((name, args), zoneName) =
            let apply (args: MxRecordArgs) =
                args.ZoneName <- input zoneName
                args

            ()
            name, List.Cons(apply, args)

        member _.ZoneName((name, args), zoneName) =
            let apply (args: MxRecordArgs) =
                args.ZoneName <- io zoneName
                args

            ()
            name, List.Cons(apply, args)

    let mxRecord = MxRecordBuilder()

    type PTRRecordBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            PTRRecord(name, (List.fold func (PTRRecordArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: PTRRecordArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: PTRRecordArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("records")>]
        member _.Records((name, args), records) =
            let apply (args: PTRRecordArgs) =
                args.Records <- inputList records
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: PTRRecordArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: PTRRecordArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: PTRRecordArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("ttl")>]
        member _.Ttl((name, args), ttl) =
            let apply (args: PTRRecordArgs) =
                args.Ttl <- input ttl
                args

            ()
            name, List.Cons(apply, args)

        member _.Ttl((name, args), ttl) =
            let apply (args: PTRRecordArgs) =
                args.Ttl <- io ttl
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zoneName")>]
        member _.ZoneName((name, args), zoneName) =
            let apply (args: PTRRecordArgs) =
                args.ZoneName <- input zoneName
                args

            ()
            name, List.Cons(apply, args)

        member _.ZoneName((name, args), zoneName) =
            let apply (args: PTRRecordArgs) =
                args.ZoneName <- io zoneName
                args

            ()
            name, List.Cons(apply, args)

    let pTRRecord = PTRRecordBuilder()

    type SRVRecordBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            SRVRecord(name, (List.fold func (SRVRecordArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: SRVRecordArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: SRVRecordArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("records")>]
        member _.Records((name, args), records) =
            let apply (args: SRVRecordArgs) =
                args.Records <- inputList records
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SRVRecordArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SRVRecordArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: SRVRecordArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("ttl")>]
        member _.Ttl((name, args), ttl) =
            let apply (args: SRVRecordArgs) =
                args.Ttl <- input ttl
                args

            ()
            name, List.Cons(apply, args)

        member _.Ttl((name, args), ttl) =
            let apply (args: SRVRecordArgs) =
                args.Ttl <- io ttl
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zoneName")>]
        member _.ZoneName((name, args), zoneName) =
            let apply (args: SRVRecordArgs) =
                args.ZoneName <- input zoneName
                args

            ()
            name, List.Cons(apply, args)

        member _.ZoneName((name, args), zoneName) =
            let apply (args: SRVRecordArgs) =
                args.ZoneName <- io zoneName
                args

            ()
            name, List.Cons(apply, args)

    let sRVRecord = SRVRecordBuilder()

    type TxtRecordBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            TxtRecord(name, (List.fold func (TxtRecordArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: TxtRecordArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: TxtRecordArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("records")>]
        member _.Records((name, args), records) =
            let apply (args: TxtRecordArgs) =
                args.Records <- inputList records
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: TxtRecordArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: TxtRecordArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: TxtRecordArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("ttl")>]
        member _.Ttl((name, args), ttl) =
            let apply (args: TxtRecordArgs) =
                args.Ttl <- input ttl
                args

            ()
            name, List.Cons(apply, args)

        member _.Ttl((name, args), ttl) =
            let apply (args: TxtRecordArgs) =
                args.Ttl <- io ttl
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zoneName")>]
        member _.ZoneName((name, args), zoneName) =
            let apply (args: TxtRecordArgs) =
                args.ZoneName <- input zoneName
                args

            ()
            name, List.Cons(apply, args)

        member _.ZoneName((name, args), zoneName) =
            let apply (args: TxtRecordArgs) =
                args.ZoneName <- io zoneName
                args

            ()
            name, List.Cons(apply, args)

    let txtRecord = TxtRecordBuilder()

    type ZoneBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Zone(name, (List.fold func (ZoneArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ZoneArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ZoneArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ZoneArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ZoneArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ZoneArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let zone = ZoneBuilder()

    type ZoneVirtualNetworkLinkBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ZoneVirtualNetworkLink(name, (List.fold func (ZoneVirtualNetworkLinkArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ZoneVirtualNetworkLinkArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ZoneVirtualNetworkLinkArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("privateDnsZoneName")>]
        member _.PrivateDnsZoneName((name, args), privateDnsZoneName) =
            let apply (args: ZoneVirtualNetworkLinkArgs) =
                args.PrivateDnsZoneName <- input privateDnsZoneName
                args

            ()
            name, List.Cons(apply, args)

        member _.PrivateDnsZoneName((name, args), privateDnsZoneName) =
            let apply (args: ZoneVirtualNetworkLinkArgs) =
                args.PrivateDnsZoneName <- io privateDnsZoneName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("registrationEnabled")>]
        member _.RegistrationEnabled((name, args), registrationEnabled) =
            let apply (args: ZoneVirtualNetworkLinkArgs) =
                args.RegistrationEnabled <- input registrationEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.RegistrationEnabled((name, args), registrationEnabled) =
            let apply (args: ZoneVirtualNetworkLinkArgs) =
                args.RegistrationEnabled <- io registrationEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ZoneVirtualNetworkLinkArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ZoneVirtualNetworkLinkArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ZoneVirtualNetworkLinkArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("virtualNetworkId")>]
        member _.VirtualNetworkId((name, args), virtualNetworkId) =
            let apply (args: ZoneVirtualNetworkLinkArgs) =
                args.VirtualNetworkId <- input virtualNetworkId
                args

            ()
            name, List.Cons(apply, args)

        member _.VirtualNetworkId((name, args), virtualNetworkId) =
            let apply (args: ZoneVirtualNetworkLinkArgs) =
                args.VirtualNetworkId <- io virtualNetworkId
                args

            ()
            name, List.Cons(apply, args)

    let zoneVirtualNetworkLink = ZoneVirtualNetworkLinkBuilder()

module PrivateLink =
    open Pulumi.Azure.PrivateLink
    open Pulumi.Azure.PrivateLink.Inputs

    type EndpointCustomDnsConfigBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointCustomDnsConfigArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("fqdn")>]
        member _.Fqdn((n, args), fqdn) =
            let apply (args: EndpointCustomDnsConfigArgs) =
                args.Fqdn <- input fqdn
                args

            ()
            n, List.Cons(apply, args)

        member _.Fqdn((n, args), fqdn) =
            let apply (args: EndpointCustomDnsConfigArgs) =
                args.Fqdn <- io fqdn
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ipAddresses")>]
        member _.IpAddresses((n, args), ipAddresses) =
            let apply (args: EndpointCustomDnsConfigArgs) =
                args.IpAddresses <- inputList ipAddresses
                args

            ()
            n, List.Cons(apply, args)

    let endpointCustomDnsConfig = EndpointCustomDnsConfigBuilder()

    type EndpointPrivateDnsZoneConfigBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointPrivateDnsZoneConfigArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: EndpointPrivateDnsZoneConfigArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: EndpointPrivateDnsZoneConfigArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: EndpointPrivateDnsZoneConfigArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: EndpointPrivateDnsZoneConfigArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("privateDnsZoneId")>]
        member _.PrivateDnsZoneId((n, args), privateDnsZoneId) =
            let apply (args: EndpointPrivateDnsZoneConfigArgs) =
                args.PrivateDnsZoneId <- input privateDnsZoneId
                args

            ()
            n, List.Cons(apply, args)

        member _.PrivateDnsZoneId((n, args), privateDnsZoneId) =
            let apply (args: EndpointPrivateDnsZoneConfigArgs) =
                args.PrivateDnsZoneId <- io privateDnsZoneId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("recordSets")>]
        member _.RecordSets((n, args), recordSets) =
            let apply (args: EndpointPrivateDnsZoneConfigArgs) =
                args.RecordSets <- inputList recordSets
                args

            ()
            n, List.Cons(apply, args)

    let endpointPrivateDnsZoneConfig = EndpointPrivateDnsZoneConfigBuilder()

    type EndpointPrivateDnsZoneConfigRecordSetBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointPrivateDnsZoneConfigRecordSetArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("fqdn")>]
        member _.Fqdn((n, args), fqdn) =
            let apply (args: EndpointPrivateDnsZoneConfigRecordSetArgs) =
                args.Fqdn <- input fqdn
                args

            ()
            n, List.Cons(apply, args)

        member _.Fqdn((n, args), fqdn) =
            let apply (args: EndpointPrivateDnsZoneConfigRecordSetArgs) =
                args.Fqdn <- io fqdn
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ipAddresses")>]
        member _.IpAddresses((n, args), ipAddresses) =
            let apply (args: EndpointPrivateDnsZoneConfigRecordSetArgs) =
                args.IpAddresses <- inputList ipAddresses
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: EndpointPrivateDnsZoneConfigRecordSetArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: EndpointPrivateDnsZoneConfigRecordSetArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ttl")>]
        member _.Ttl((n, args), ttl) =
            let apply (args: EndpointPrivateDnsZoneConfigRecordSetArgs) =
                args.Ttl <- input ttl
                args

            ()
            n, List.Cons(apply, args)

        member _.Ttl((n, args), ttl) =
            let apply (args: EndpointPrivateDnsZoneConfigRecordSetArgs) =
                args.Ttl <- io ttl
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: EndpointPrivateDnsZoneConfigRecordSetArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: EndpointPrivateDnsZoneConfigRecordSetArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let endpointPrivateDnsZoneConfigRecordSet =
        EndpointPrivateDnsZoneConfigRecordSetBuilder()

    type EndpointPrivateDnsZoneGroupBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointPrivateDnsZoneGroupArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: EndpointPrivateDnsZoneGroupArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: EndpointPrivateDnsZoneGroupArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: EndpointPrivateDnsZoneGroupArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: EndpointPrivateDnsZoneGroupArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("privateDnsZoneIds")>]
        member _.PrivateDnsZoneIds((n, args), privateDnsZoneIds) =
            let apply (args: EndpointPrivateDnsZoneGroupArgs) =
                args.PrivateDnsZoneIds <- inputList privateDnsZoneIds
                args

            ()
            n, List.Cons(apply, args)

    let endpointPrivateDnsZoneGroup = EndpointPrivateDnsZoneGroupBuilder()

    type EndpointPrivateServiceConnectionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointPrivateServiceConnectionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("isManualConnection")>]
        member _.IsManualConnection((n, args), isManualConnection) =
            let apply (args: EndpointPrivateServiceConnectionArgs) =
                args.IsManualConnection <- input isManualConnection
                args

            ()
            n, List.Cons(apply, args)

        member _.IsManualConnection((n, args), isManualConnection) =
            let apply (args: EndpointPrivateServiceConnectionArgs) =
                args.IsManualConnection <- io isManualConnection
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: EndpointPrivateServiceConnectionArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: EndpointPrivateServiceConnectionArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("privateConnectionResourceId")>]
        member _.PrivateConnectionResourceId((n, args), privateConnectionResourceId) =
            let apply (args: EndpointPrivateServiceConnectionArgs) =
                args.PrivateConnectionResourceId <- input privateConnectionResourceId
                args

            ()
            n, List.Cons(apply, args)

        member _.PrivateConnectionResourceId((n, args), privateConnectionResourceId) =
            let apply (args: EndpointPrivateServiceConnectionArgs) =
                args.PrivateConnectionResourceId <- io privateConnectionResourceId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("privateIpAddress")>]
        member _.PrivateIpAddress((n, args), privateIpAddress) =
            let apply (args: EndpointPrivateServiceConnectionArgs) =
                args.PrivateIpAddress <- input privateIpAddress
                args

            ()
            n, List.Cons(apply, args)

        member _.PrivateIpAddress((n, args), privateIpAddress) =
            let apply (args: EndpointPrivateServiceConnectionArgs) =
                args.PrivateIpAddress <- io privateIpAddress
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("requestMessage")>]
        member _.RequestMessage((n, args), requestMessage) =
            let apply (args: EndpointPrivateServiceConnectionArgs) =
                args.RequestMessage <- input requestMessage
                args

            ()
            n, List.Cons(apply, args)

        member _.RequestMessage((n, args), requestMessage) =
            let apply (args: EndpointPrivateServiceConnectionArgs) =
                args.RequestMessage <- io requestMessage
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subresourceNames")>]
        member _.SubresourceNames((n, args), subresourceNames) =
            let apply (args: EndpointPrivateServiceConnectionArgs) =
                args.SubresourceNames <- inputList subresourceNames
                args

            ()
            n, List.Cons(apply, args)

    let endpointPrivateServiceConnection =
        EndpointPrivateServiceConnectionBuilder()

    type EndpointBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Endpoint(name, (List.fold func (EndpointArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: EndpointArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: EndpointArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: EndpointArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: EndpointArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: EndpointArgs) =
                   args.PrivateDnsZoneGroup <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: EndpointArgs) =
                   args.PrivateServiceConnection <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: EndpointArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: EndpointArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((name, args), subnetId) =
            let apply (args: EndpointArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            name, List.Cons(apply, args)

        member _.SubnetId((name, args), subnetId) =
            let apply (args: EndpointArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: EndpointArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let endpoint = EndpointBuilder()

module Redis =
    open Pulumi.Azure.Redis
    open Pulumi.Azure.Redis.Inputs

    type CachePatchScheduleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (CachePatchScheduleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("dayOfWeek")>]
        member _.DayOfWeek((n, args), dayOfWeek) =
            let apply (args: CachePatchScheduleArgs) =
                args.DayOfWeek <- input dayOfWeek
                args

            ()
            n, List.Cons(apply, args)

        member _.DayOfWeek((n, args), dayOfWeek) =
            let apply (args: CachePatchScheduleArgs) =
                args.DayOfWeek <- io dayOfWeek
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("startHourUtc")>]
        member _.StartHourUtc((n, args), startHourUtc) =
            let apply (args: CachePatchScheduleArgs) =
                args.StartHourUtc <- input startHourUtc
                args

            ()
            n, List.Cons(apply, args)

        member _.StartHourUtc((n, args), startHourUtc) =
            let apply (args: CachePatchScheduleArgs) =
                args.StartHourUtc <- io startHourUtc
                args

            ()
            n, List.Cons(apply, args)

    let cachePatchSchedule = CachePatchScheduleBuilder()

    type CacheRedisConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (CacheRedisConfigurationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("aofBackupEnabled")>]
        member _.AofBackupEnabled((n, args), aofBackupEnabled) =
            let apply (args: CacheRedisConfigurationArgs) =
                args.AofBackupEnabled <- input aofBackupEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.AofBackupEnabled((n, args), aofBackupEnabled) =
            let apply (args: CacheRedisConfigurationArgs) =
                args.AofBackupEnabled <- io aofBackupEnabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("aofStorageConnectionString0")>]
        member _.AofStorageConnectionString0((n, args), aofStorageConnectionString0) =
            let apply (args: CacheRedisConfigurationArgs) =
                args.AofStorageConnectionString0 <- input aofStorageConnectionString0
                args

            ()
            n, List.Cons(apply, args)

        member _.AofStorageConnectionString0((n, args), aofStorageConnectionString0) =
            let apply (args: CacheRedisConfigurationArgs) =
                args.AofStorageConnectionString0 <- io aofStorageConnectionString0
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("aofStorageConnectionString1")>]
        member _.AofStorageConnectionString1((n, args), aofStorageConnectionString1) =
            let apply (args: CacheRedisConfigurationArgs) =
                args.AofStorageConnectionString1 <- input aofStorageConnectionString1
                args

            ()
            n, List.Cons(apply, args)

        member _.AofStorageConnectionString1((n, args), aofStorageConnectionString1) =
            let apply (args: CacheRedisConfigurationArgs) =
                args.AofStorageConnectionString1 <- io aofStorageConnectionString1
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("enableAuthentication")>]
        member _.EnableAuthentication((n, args), enableAuthentication) =
            let apply (args: CacheRedisConfigurationArgs) =
                args.EnableAuthentication <- input enableAuthentication
                args

            ()
            n, List.Cons(apply, args)

        member _.EnableAuthentication((n, args), enableAuthentication) =
            let apply (args: CacheRedisConfigurationArgs) =
                args.EnableAuthentication <- io enableAuthentication
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("maxclients")>]
        member _.Maxclients((n, args), maxclients) =
            let apply (args: CacheRedisConfigurationArgs) =
                args.Maxclients <- input maxclients
                args

            ()
            n, List.Cons(apply, args)

        member _.Maxclients((n, args), maxclients) =
            let apply (args: CacheRedisConfigurationArgs) =
                args.Maxclients <- io maxclients
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("maxfragmentationmemoryReserved")>]
        member _.MaxfragmentationmemoryReserved((n, args), maxfragmentationmemoryReserved) =
            let apply (args: CacheRedisConfigurationArgs) =
                args.MaxfragmentationmemoryReserved <- input maxfragmentationmemoryReserved
                args

            ()
            n, List.Cons(apply, args)

        member _.MaxfragmentationmemoryReserved((n, args), maxfragmentationmemoryReserved) =
            let apply (args: CacheRedisConfigurationArgs) =
                args.MaxfragmentationmemoryReserved <- io maxfragmentationmemoryReserved
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("maxmemoryDelta")>]
        member _.MaxmemoryDelta((n, args), maxmemoryDelta) =
            let apply (args: CacheRedisConfigurationArgs) =
                args.MaxmemoryDelta <- input maxmemoryDelta
                args

            ()
            n, List.Cons(apply, args)

        member _.MaxmemoryDelta((n, args), maxmemoryDelta) =
            let apply (args: CacheRedisConfigurationArgs) =
                args.MaxmemoryDelta <- io maxmemoryDelta
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("maxmemoryPolicy")>]
        member _.MaxmemoryPolicy((n, args), maxmemoryPolicy) =
            let apply (args: CacheRedisConfigurationArgs) =
                args.MaxmemoryPolicy <- input maxmemoryPolicy
                args

            ()
            n, List.Cons(apply, args)

        member _.MaxmemoryPolicy((n, args), maxmemoryPolicy) =
            let apply (args: CacheRedisConfigurationArgs) =
                args.MaxmemoryPolicy <- io maxmemoryPolicy
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("maxmemoryReserved")>]
        member _.MaxmemoryReserved((n, args), maxmemoryReserved) =
            let apply (args: CacheRedisConfigurationArgs) =
                args.MaxmemoryReserved <- input maxmemoryReserved
                args

            ()
            n, List.Cons(apply, args)

        member _.MaxmemoryReserved((n, args), maxmemoryReserved) =
            let apply (args: CacheRedisConfigurationArgs) =
                args.MaxmemoryReserved <- io maxmemoryReserved
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("notifyKeyspaceEvents")>]
        member _.NotifyKeyspaceEvents((n, args), notifyKeyspaceEvents) =
            let apply (args: CacheRedisConfigurationArgs) =
                args.NotifyKeyspaceEvents <- input notifyKeyspaceEvents
                args

            ()
            n, List.Cons(apply, args)

        member _.NotifyKeyspaceEvents((n, args), notifyKeyspaceEvents) =
            let apply (args: CacheRedisConfigurationArgs) =
                args.NotifyKeyspaceEvents <- io notifyKeyspaceEvents
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("rdbBackupEnabled")>]
        member _.RdbBackupEnabled((n, args), rdbBackupEnabled) =
            let apply (args: CacheRedisConfigurationArgs) =
                args.RdbBackupEnabled <- input rdbBackupEnabled
                args

            ()
            n, List.Cons(apply, args)

        member _.RdbBackupEnabled((n, args), rdbBackupEnabled) =
            let apply (args: CacheRedisConfigurationArgs) =
                args.RdbBackupEnabled <- io rdbBackupEnabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("rdbBackupFrequency")>]
        member _.RdbBackupFrequency((n, args), rdbBackupFrequency) =
            let apply (args: CacheRedisConfigurationArgs) =
                args.RdbBackupFrequency <- input rdbBackupFrequency
                args

            ()
            n, List.Cons(apply, args)

        member _.RdbBackupFrequency((n, args), rdbBackupFrequency) =
            let apply (args: CacheRedisConfigurationArgs) =
                args.RdbBackupFrequency <- io rdbBackupFrequency
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("rdbBackupMaxSnapshotCount")>]
        member _.RdbBackupMaxSnapshotCount((n, args), rdbBackupMaxSnapshotCount) =
            let apply (args: CacheRedisConfigurationArgs) =
                args.RdbBackupMaxSnapshotCount <- input rdbBackupMaxSnapshotCount
                args

            ()
            n, List.Cons(apply, args)

        member _.RdbBackupMaxSnapshotCount((n, args), rdbBackupMaxSnapshotCount) =
            let apply (args: CacheRedisConfigurationArgs) =
                args.RdbBackupMaxSnapshotCount <- io rdbBackupMaxSnapshotCount
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("rdbStorageConnectionString")>]
        member _.RdbStorageConnectionString((n, args), rdbStorageConnectionString) =
            let apply (args: CacheRedisConfigurationArgs) =
                args.RdbStorageConnectionString <- input rdbStorageConnectionString
                args

            ()
            n, List.Cons(apply, args)

        member _.RdbStorageConnectionString((n, args), rdbStorageConnectionString) =
            let apply (args: CacheRedisConfigurationArgs) =
                args.RdbStorageConnectionString <- io rdbStorageConnectionString
                args

            ()
            n, List.Cons(apply, args)

    let cacheRedisConfiguration = CacheRedisConfigurationBuilder()

    type CacheBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Cache(name, (List.fold func (CacheArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("capacity")>]
        member _.Capacity((name, args), capacity) =
            let apply (args: CacheArgs) =
                args.Capacity <- input capacity
                args

            ()
            name, List.Cons(apply, args)

        member _.Capacity((name, args), capacity) =
            let apply (args: CacheArgs) =
                args.Capacity <- io capacity
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enableNonSslPort")>]
        member _.EnableNonSslPort((name, args), enableNonSslPort) =
            let apply (args: CacheArgs) =
                args.EnableNonSslPort <- input enableNonSslPort
                args

            ()
            name, List.Cons(apply, args)

        member _.EnableNonSslPort((name, args), enableNonSslPort) =
            let apply (args: CacheArgs) =
                args.EnableNonSslPort <- io enableNonSslPort
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("family")>]
        member _.Family((name, args), family) =
            let apply (args: CacheArgs) =
                args.Family <- input family
                args

            ()
            name, List.Cons(apply, args)

        member _.Family((name, args), family) =
            let apply (args: CacheArgs) =
                args.Family <- io family
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: CacheArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: CacheArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("minimumTlsVersion")>]
        member _.MinimumTlsVersion((name, args), minimumTlsVersion) =
            let apply (args: CacheArgs) =
                args.MinimumTlsVersion <- input minimumTlsVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.MinimumTlsVersion((name, args), minimumTlsVersion) =
            let apply (args: CacheArgs) =
                args.MinimumTlsVersion <- io minimumTlsVersion
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: CacheArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: CacheArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("patchSchedules")>]
        member _.PatchSchedules((name, args), patchSchedules) =
            let apply (args: CacheArgs) =
                args.PatchSchedules <- inputList patchSchedules
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("privateStaticIpAddress")>]
        member _.PrivateStaticIpAddress((name, args), privateStaticIpAddress) =
            let apply (args: CacheArgs) =
                args.PrivateStaticIpAddress <- input privateStaticIpAddress
                args

            ()
            name, List.Cons(apply, args)

        member _.PrivateStaticIpAddress((name, args), privateStaticIpAddress) =
            let apply (args: CacheArgs) =
                args.PrivateStaticIpAddress <- io privateStaticIpAddress
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: CacheArgs) =
                   args.RedisConfiguration <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: CacheArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: CacheArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("shardCount")>]
        member _.ShardCount((name, args), shardCount) =
            let apply (args: CacheArgs) =
                args.ShardCount <- input shardCount
                args

            ()
            name, List.Cons(apply, args)

        member _.ShardCount((name, args), shardCount) =
            let apply (args: CacheArgs) =
                args.ShardCount <- io shardCount
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("skuName")>]
        member _.SkuName((name, args), skuName) =
            let apply (args: CacheArgs) =
                args.SkuName <- input skuName
                args

            ()
            name, List.Cons(apply, args)

        member _.SkuName((name, args), skuName) =
            let apply (args: CacheArgs) =
                args.SkuName <- io skuName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((name, args), subnetId) =
            let apply (args: CacheArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            name, List.Cons(apply, args)

        member _.SubnetId((name, args), subnetId) =
            let apply (args: CacheArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: CacheArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zones")>]
        member _.Zones((name, args), zones) =
            let apply (args: CacheArgs) =
                args.Zones <- input zones
                args

            ()
            name, List.Cons(apply, args)

        member _.Zones((name, args), zones) =
            let apply (args: CacheArgs) =
                args.Zones <- io zones
                args

            ()
            name, List.Cons(apply, args)

    let cache = CacheBuilder()

    type FirewallRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            FirewallRule(name, (List.fold func (FirewallRuleArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("endIp")>]
        member _.EndIp((name, args), endIp) =
            let apply (args: FirewallRuleArgs) =
                args.EndIp <- input endIp
                args

            ()
            name, List.Cons(apply, args)

        member _.EndIp((name, args), endIp) =
            let apply (args: FirewallRuleArgs) =
                args.EndIp <- io endIp
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: FirewallRuleArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: FirewallRuleArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("redisCacheName")>]
        member _.RedisCacheName((name, args), redisCacheName) =
            let apply (args: FirewallRuleArgs) =
                args.RedisCacheName <- input redisCacheName
                args

            ()
            name, List.Cons(apply, args)

        member _.RedisCacheName((name, args), redisCacheName) =
            let apply (args: FirewallRuleArgs) =
                args.RedisCacheName <- io redisCacheName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FirewallRuleArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FirewallRuleArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("startIp")>]
        member _.StartIp((name, args), startIp) =
            let apply (args: FirewallRuleArgs) =
                args.StartIp <- input startIp
                args

            ()
            name, List.Cons(apply, args)

        member _.StartIp((name, args), startIp) =
            let apply (args: FirewallRuleArgs) =
                args.StartIp <- io startIp
                args

            ()
            name, List.Cons(apply, args)

    let firewallRule = FirewallRuleBuilder()

module Role =
    open Pulumi.Azure.Role
    open Pulumi.Azure.Role.Inputs

    type DefinitionPermissionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (DefinitionPermissionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("actions")>]
        member _.Actions((n, args), actions) =
            let apply (args: DefinitionPermissionArgs) =
                args.Actions <- inputList actions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("dataActions")>]
        member _.DataActions((n, args), dataActions) =
            let apply (args: DefinitionPermissionArgs) =
                args.DataActions <- inputList dataActions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("notActions")>]
        member _.NotActions((n, args), notActions) =
            let apply (args: DefinitionPermissionArgs) =
                args.NotActions <- inputList notActions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("notDataActions")>]
        member _.NotDataActions((n, args), notDataActions) =
            let apply (args: DefinitionPermissionArgs) =
                args.NotDataActions <- inputList notDataActions
                args

            ()
            n, List.Cons(apply, args)

    let definitionPermission = DefinitionPermissionBuilder()

    type AssignmentBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Assignment(name, (List.fold func (AssignmentArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: AssignmentArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: AssignmentArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("principalId")>]
        member _.PrincipalId((name, args), principalId) =
            let apply (args: AssignmentArgs) =
                args.PrincipalId <- input principalId
                args

            ()
            name, List.Cons(apply, args)

        member _.PrincipalId((name, args), principalId) =
            let apply (args: AssignmentArgs) =
                args.PrincipalId <- io principalId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("roleDefinitionId")>]
        member _.RoleDefinitionId((name, args), roleDefinitionId) =
            let apply (args: AssignmentArgs) =
                args.RoleDefinitionId <- input roleDefinitionId
                args

            ()
            name, List.Cons(apply, args)

        member _.RoleDefinitionId((name, args), roleDefinitionId) =
            let apply (args: AssignmentArgs) =
                args.RoleDefinitionId <- io roleDefinitionId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("roleDefinitionName")>]
        member _.RoleDefinitionName((name, args), roleDefinitionName) =
            let apply (args: AssignmentArgs) =
                args.RoleDefinitionName <- input roleDefinitionName
                args

            ()
            name, List.Cons(apply, args)

        member _.RoleDefinitionName((name, args), roleDefinitionName) =
            let apply (args: AssignmentArgs) =
                args.RoleDefinitionName <- io roleDefinitionName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("scope")>]
        member _.Scope((name, args), scope) =
            let apply (args: AssignmentArgs) =
                args.Scope <- input scope
                args

            ()
            name, List.Cons(apply, args)

        member _.Scope((name, args), scope) =
            let apply (args: AssignmentArgs) =
                args.Scope <- io scope
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("skipServicePrincipalAadCheck")>]
        member _.SkipServicePrincipalAadCheck((name, args), skipServicePrincipalAadCheck) =
            let apply (args: AssignmentArgs) =
                args.SkipServicePrincipalAadCheck <- input skipServicePrincipalAadCheck
                args

            ()
            name, List.Cons(apply, args)

        member _.SkipServicePrincipalAadCheck((name, args), skipServicePrincipalAadCheck) =
            let apply (args: AssignmentArgs) =
                args.SkipServicePrincipalAadCheck <- io skipServicePrincipalAadCheck
                args

            ()
            name, List.Cons(apply, args)

    let assignment = AssignmentBuilder()

    type DefinitionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Definition(name, (List.fold func (DefinitionArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("assignableScopes")>]
        member _.AssignableScopes((name, args), assignableScopes) =
            let apply (args: DefinitionArgs) =
                args.AssignableScopes <- inputList assignableScopes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: DefinitionArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: DefinitionArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: DefinitionArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: DefinitionArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("permissions")>]
        member _.Permissions((name, args), permissions) =
            let apply (args: DefinitionArgs) =
                args.Permissions <- inputList permissions
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("roleDefinitionId")>]
        member _.RoleDefinitionId((name, args), roleDefinitionId) =
            let apply (args: DefinitionArgs) =
                args.RoleDefinitionId <- input roleDefinitionId
                args

            ()
            name, List.Cons(apply, args)

        member _.RoleDefinitionId((name, args), roleDefinitionId) =
            let apply (args: DefinitionArgs) =
                args.RoleDefinitionId <- io roleDefinitionId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("scope")>]
        member _.Scope((name, args), scope) =
            let apply (args: DefinitionArgs) =
                args.Scope <- input scope
                args

            ()
            name, List.Cons(apply, args)

        member _.Scope((name, args), scope) =
            let apply (args: DefinitionArgs) =
                args.Scope <- io scope
                args

            ()
            name, List.Cons(apply, args)

    let definition = DefinitionBuilder()

module Search =
    open Pulumi.Azure.Search
    open Pulumi.Azure.Search.Inputs

    type ServiceQueryKeyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ServiceQueryKeyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("key")>]
        member _.Key((n, args), key) =
            let apply (args: ServiceQueryKeyArgs) =
                args.Key <- input key
                args

            ()
            n, List.Cons(apply, args)

        member _.Key((n, args), key) =
            let apply (args: ServiceQueryKeyArgs) =
                args.Key <- io key
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ServiceQueryKeyArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ServiceQueryKeyArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

    let serviceQueryKey = ServiceQueryKeyBuilder()

    type ServiceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Service(name, (List.fold func (ServiceArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ServiceArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ServiceArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ServiceArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ServiceArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("partitionCount")>]
        member _.PartitionCount((name, args), partitionCount) =
            let apply (args: ServiceArgs) =
                args.PartitionCount <- input partitionCount
                args

            ()
            name, List.Cons(apply, args)

        member _.PartitionCount((name, args), partitionCount) =
            let apply (args: ServiceArgs) =
                args.PartitionCount <- io partitionCount
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("replicaCount")>]
        member _.ReplicaCount((name, args), replicaCount) =
            let apply (args: ServiceArgs) =
                args.ReplicaCount <- input replicaCount
                args

            ()
            name, List.Cons(apply, args)

        member _.ReplicaCount((name, args), replicaCount) =
            let apply (args: ServiceArgs) =
                args.ReplicaCount <- io replicaCount
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ServiceArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ServiceArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sku")>]
        member _.Sku((name, args), sku) =
            let apply (args: ServiceArgs) =
                args.Sku <- input sku
                args

            ()
            name, List.Cons(apply, args)

        member _.Sku((name, args), sku) =
            let apply (args: ServiceArgs) =
                args.Sku <- io sku
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ServiceArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let service = ServiceBuilder()

module ServiceBus =
    open Pulumi.Azure.ServiceBus
    open Pulumi.Azure.ServiceBus.Inputs

    type NamespaceNetworkRuleSetNetworkRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (NamespaceNetworkRuleSetNetworkRuleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("ignoreMissingVnetServiceEndpoint")>]
        member _.IgnoreMissingVnetServiceEndpoint((n, args), ignoreMissingVnetServiceEndpoint) =
            let apply (args: NamespaceNetworkRuleSetNetworkRuleArgs) =
                args.IgnoreMissingVnetServiceEndpoint <- input ignoreMissingVnetServiceEndpoint
                args

            ()
            n, List.Cons(apply, args)

        member _.IgnoreMissingVnetServiceEndpoint((n, args), ignoreMissingVnetServiceEndpoint) =
            let apply (args: NamespaceNetworkRuleSetNetworkRuleArgs) =
                args.IgnoreMissingVnetServiceEndpoint <- io ignoreMissingVnetServiceEndpoint
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((n, args), subnetId) =
            let apply (args: NamespaceNetworkRuleSetNetworkRuleArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            n, List.Cons(apply, args)

        member _.SubnetId((n, args), subnetId) =
            let apply (args: NamespaceNetworkRuleSetNetworkRuleArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            n, List.Cons(apply, args)

    let namespaceNetworkRuleSetNetworkRule =
        NamespaceNetworkRuleSetNetworkRuleBuilder()

    type SubscriptionRuleCorrelationFilterBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SubscriptionRuleCorrelationFilterArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("contentType")>]
        member _.ContentType((n, args), contentType) =
            let apply (args: SubscriptionRuleCorrelationFilterArgs) =
                args.ContentType <- input contentType
                args

            ()
            n, List.Cons(apply, args)

        member _.ContentType((n, args), contentType) =
            let apply (args: SubscriptionRuleCorrelationFilterArgs) =
                args.ContentType <- io contentType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("correlationId")>]
        member _.CorrelationId((n, args), correlationId) =
            let apply (args: SubscriptionRuleCorrelationFilterArgs) =
                args.CorrelationId <- input correlationId
                args

            ()
            n, List.Cons(apply, args)

        member _.CorrelationId((n, args), correlationId) =
            let apply (args: SubscriptionRuleCorrelationFilterArgs) =
                args.CorrelationId <- io correlationId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("label")>]
        member _.Label((n, args), label) =
            let apply (args: SubscriptionRuleCorrelationFilterArgs) =
                args.Label <- input label
                args

            ()
            n, List.Cons(apply, args)

        member _.Label((n, args), label) =
            let apply (args: SubscriptionRuleCorrelationFilterArgs) =
                args.Label <- io label
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("messageId")>]
        member _.MessageId((n, args), messageId) =
            let apply (args: SubscriptionRuleCorrelationFilterArgs) =
                args.MessageId <- input messageId
                args

            ()
            n, List.Cons(apply, args)

        member _.MessageId((n, args), messageId) =
            let apply (args: SubscriptionRuleCorrelationFilterArgs) =
                args.MessageId <- io messageId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("replyTo")>]
        member _.ReplyTo((n, args), replyTo) =
            let apply (args: SubscriptionRuleCorrelationFilterArgs) =
                args.ReplyTo <- input replyTo
                args

            ()
            n, List.Cons(apply, args)

        member _.ReplyTo((n, args), replyTo) =
            let apply (args: SubscriptionRuleCorrelationFilterArgs) =
                args.ReplyTo <- io replyTo
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("replyToSessionId")>]
        member _.ReplyToSessionId((n, args), replyToSessionId) =
            let apply (args: SubscriptionRuleCorrelationFilterArgs) =
                args.ReplyToSessionId <- input replyToSessionId
                args

            ()
            n, List.Cons(apply, args)

        member _.ReplyToSessionId((n, args), replyToSessionId) =
            let apply (args: SubscriptionRuleCorrelationFilterArgs) =
                args.ReplyToSessionId <- io replyToSessionId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("sessionId")>]
        member _.SessionId((n, args), sessionId) =
            let apply (args: SubscriptionRuleCorrelationFilterArgs) =
                args.SessionId <- input sessionId
                args

            ()
            n, List.Cons(apply, args)

        member _.SessionId((n, args), sessionId) =
            let apply (args: SubscriptionRuleCorrelationFilterArgs) =
                args.SessionId <- io sessionId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("to")>]
        member _.To((n, args), ``to``) =
            let apply (args: SubscriptionRuleCorrelationFilterArgs) =
                args.To <- input ``to``
                args

            ()
            n, List.Cons(apply, args)

        member _.To((n, args), ``to``) =
            let apply (args: SubscriptionRuleCorrelationFilterArgs) =
                args.To <- io ``to``
                args

            ()
            n, List.Cons(apply, args)

    let subscriptionRuleCorrelationFilter =
        SubscriptionRuleCorrelationFilterBuilder()

    type NamespaceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Namespace(name, (List.fold func (NamespaceArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("capacity")>]
        member _.Capacity((name, args), capacity) =
            let apply (args: NamespaceArgs) =
                args.Capacity <- input capacity
                args

            ()
            name, List.Cons(apply, args)

        member _.Capacity((name, args), capacity) =
            let apply (args: NamespaceArgs) =
                args.Capacity <- io capacity
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: NamespaceArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: NamespaceArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: NamespaceArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: NamespaceArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NamespaceArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NamespaceArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sku")>]
        member _.Sku((name, args), sku) =
            let apply (args: NamespaceArgs) =
                args.Sku <- input sku
                args

            ()
            name, List.Cons(apply, args)

        member _.Sku((name, args), sku) =
            let apply (args: NamespaceArgs) =
                args.Sku <- io sku
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: NamespaceArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("zoneRedundant")>]
        member _.ZoneRedundant((name, args), zoneRedundant) =
            let apply (args: NamespaceArgs) =
                args.ZoneRedundant <- input zoneRedundant
                args

            ()
            name, List.Cons(apply, args)

        member _.ZoneRedundant((name, args), zoneRedundant) =
            let apply (args: NamespaceArgs) =
                args.ZoneRedundant <- io zoneRedundant
                args

            ()
            name, List.Cons(apply, args)

    let ``namespace`` = NamespaceBuilder()

    type NamespaceAuthorizationRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            NamespaceAuthorizationRule(name, (List.fold func (NamespaceAuthorizationRuleArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("listen")>]
        member _.Listen((name, args), listen) =
            let apply (args: NamespaceAuthorizationRuleArgs) =
                args.Listen <- input listen
                args

            ()
            name, List.Cons(apply, args)

        member _.Listen((name, args), listen) =
            let apply (args: NamespaceAuthorizationRuleArgs) =
                args.Listen <- io listen
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("manage")>]
        member _.Manage((name, args), manage) =
            let apply (args: NamespaceAuthorizationRuleArgs) =
                args.Manage <- input manage
                args

            ()
            name, List.Cons(apply, args)

        member _.Manage((name, args), manage) =
            let apply (args: NamespaceAuthorizationRuleArgs) =
                args.Manage <- io manage
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: NamespaceAuthorizationRuleArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: NamespaceAuthorizationRuleArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("namespaceName")>]
        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: NamespaceAuthorizationRuleArgs) =
                args.NamespaceName <- input namespaceName
                args

            ()
            name, List.Cons(apply, args)

        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: NamespaceAuthorizationRuleArgs) =
                args.NamespaceName <- io namespaceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NamespaceAuthorizationRuleArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NamespaceAuthorizationRuleArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("send")>]
        member _.Send((name, args), send) =
            let apply (args: NamespaceAuthorizationRuleArgs) =
                args.Send <- input send
                args

            ()
            name, List.Cons(apply, args)

        member _.Send((name, args), send) =
            let apply (args: NamespaceAuthorizationRuleArgs) =
                args.Send <- io send
                args

            ()
            name, List.Cons(apply, args)

    let namespaceAuthorizationRule = NamespaceAuthorizationRuleBuilder()

    type NamespaceNetworkRuleSetBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            NamespaceNetworkRuleSet(name, (List.fold func (NamespaceNetworkRuleSetArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("defaultAction")>]
        member _.DefaultAction((name, args), defaultAction) =
            let apply (args: NamespaceNetworkRuleSetArgs) =
                args.DefaultAction <- input defaultAction
                args

            ()
            name, List.Cons(apply, args)

        member _.DefaultAction((name, args), defaultAction) =
            let apply (args: NamespaceNetworkRuleSetArgs) =
                args.DefaultAction <- io defaultAction
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("ipRules")>]
        member _.IpRules((name, args), ipRules) =
            let apply (args: NamespaceNetworkRuleSetArgs) =
                args.IpRules <- inputList ipRules
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("namespaceName")>]
        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: NamespaceNetworkRuleSetArgs) =
                args.NamespaceName <- input namespaceName
                args

            ()
            name, List.Cons(apply, args)

        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: NamespaceNetworkRuleSetArgs) =
                args.NamespaceName <- io namespaceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("networkRules")>]
        member _.NetworkRules((name, args), networkRules) =
            let apply (args: NamespaceNetworkRuleSetArgs) =
                args.NetworkRules <- inputList networkRules
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NamespaceNetworkRuleSetArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NamespaceNetworkRuleSetArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let namespaceNetworkRuleSet = NamespaceNetworkRuleSetBuilder()

    type QueueBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Queue(name, (List.fold func (QueueArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("autoDeleteOnIdle")>]
        member _.AutoDeleteOnIdle((name, args), autoDeleteOnIdle) =
            let apply (args: QueueArgs) =
                args.AutoDeleteOnIdle <- input autoDeleteOnIdle
                args

            ()
            name, List.Cons(apply, args)

        member _.AutoDeleteOnIdle((name, args), autoDeleteOnIdle) =
            let apply (args: QueueArgs) =
                args.AutoDeleteOnIdle <- io autoDeleteOnIdle
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("deadLetteringOnMessageExpiration")>]
        member _.DeadLetteringOnMessageExpiration((name, args), deadLetteringOnMessageExpiration) =
            let apply (args: QueueArgs) =
                args.DeadLetteringOnMessageExpiration <- input deadLetteringOnMessageExpiration
                args

            ()
            name, List.Cons(apply, args)

        member _.DeadLetteringOnMessageExpiration((name, args), deadLetteringOnMessageExpiration) =
            let apply (args: QueueArgs) =
                args.DeadLetteringOnMessageExpiration <- io deadLetteringOnMessageExpiration
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("defaultMessageTtl")>]
        member _.DefaultMessageTtl((name, args), defaultMessageTtl) =
            let apply (args: QueueArgs) =
                args.DefaultMessageTtl <- input defaultMessageTtl
                args

            ()
            name, List.Cons(apply, args)

        member _.DefaultMessageTtl((name, args), defaultMessageTtl) =
            let apply (args: QueueArgs) =
                args.DefaultMessageTtl <- io defaultMessageTtl
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("duplicateDetectionHistoryTimeWindow")>]
        member _.DuplicateDetectionHistoryTimeWindow((name, args), duplicateDetectionHistoryTimeWindow) =
            let apply (args: QueueArgs) =
                args.DuplicateDetectionHistoryTimeWindow <- input duplicateDetectionHistoryTimeWindow
                args

            ()
            name, List.Cons(apply, args)

        member _.DuplicateDetectionHistoryTimeWindow((name, args), duplicateDetectionHistoryTimeWindow) =
            let apply (args: QueueArgs) =
                args.DuplicateDetectionHistoryTimeWindow <- io duplicateDetectionHistoryTimeWindow
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enableExpress")>]
        member _.EnableExpress((name, args), enableExpress) =
            let apply (args: QueueArgs) =
                args.EnableExpress <- input enableExpress
                args

            ()
            name, List.Cons(apply, args)

        member _.EnableExpress((name, args), enableExpress) =
            let apply (args: QueueArgs) =
                args.EnableExpress <- io enableExpress
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enablePartitioning")>]
        member _.EnablePartitioning((name, args), enablePartitioning) =
            let apply (args: QueueArgs) =
                args.EnablePartitioning <- input enablePartitioning
                args

            ()
            name, List.Cons(apply, args)

        member _.EnablePartitioning((name, args), enablePartitioning) =
            let apply (args: QueueArgs) =
                args.EnablePartitioning <- io enablePartitioning
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("lockDuration")>]
        member _.LockDuration((name, args), lockDuration) =
            let apply (args: QueueArgs) =
                args.LockDuration <- input lockDuration
                args

            ()
            name, List.Cons(apply, args)

        member _.LockDuration((name, args), lockDuration) =
            let apply (args: QueueArgs) =
                args.LockDuration <- io lockDuration
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("maxDeliveryCount")>]
        member _.MaxDeliveryCount((name, args), maxDeliveryCount) =
            let apply (args: QueueArgs) =
                args.MaxDeliveryCount <- input maxDeliveryCount
                args

            ()
            name, List.Cons(apply, args)

        member _.MaxDeliveryCount((name, args), maxDeliveryCount) =
            let apply (args: QueueArgs) =
                args.MaxDeliveryCount <- io maxDeliveryCount
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("maxSizeInMegabytes")>]
        member _.MaxSizeInMegabytes((name, args), maxSizeInMegabytes) =
            let apply (args: QueueArgs) =
                args.MaxSizeInMegabytes <- input maxSizeInMegabytes
                args

            ()
            name, List.Cons(apply, args)

        member _.MaxSizeInMegabytes((name, args), maxSizeInMegabytes) =
            let apply (args: QueueArgs) =
                args.MaxSizeInMegabytes <- io maxSizeInMegabytes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: QueueArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: QueueArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("namespaceName")>]
        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: QueueArgs) =
                args.NamespaceName <- input namespaceName
                args

            ()
            name, List.Cons(apply, args)

        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: QueueArgs) =
                args.NamespaceName <- io namespaceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("requiresDuplicateDetection")>]
        member _.RequiresDuplicateDetection((name, args), requiresDuplicateDetection) =
            let apply (args: QueueArgs) =
                args.RequiresDuplicateDetection <- input requiresDuplicateDetection
                args

            ()
            name, List.Cons(apply, args)

        member _.RequiresDuplicateDetection((name, args), requiresDuplicateDetection) =
            let apply (args: QueueArgs) =
                args.RequiresDuplicateDetection <- io requiresDuplicateDetection
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("requiresSession")>]
        member _.RequiresSession((name, args), requiresSession) =
            let apply (args: QueueArgs) =
                args.RequiresSession <- input requiresSession
                args

            ()
            name, List.Cons(apply, args)

        member _.RequiresSession((name, args), requiresSession) =
            let apply (args: QueueArgs) =
                args.RequiresSession <- io requiresSession
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: QueueArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: QueueArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let queue = QueueBuilder()

    type QueueAuthorizationRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            QueueAuthorizationRule(name, (List.fold func (QueueAuthorizationRuleArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("listen")>]
        member _.Listen((name, args), listen) =
            let apply (args: QueueAuthorizationRuleArgs) =
                args.Listen <- input listen
                args

            ()
            name, List.Cons(apply, args)

        member _.Listen((name, args), listen) =
            let apply (args: QueueAuthorizationRuleArgs) =
                args.Listen <- io listen
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("manage")>]
        member _.Manage((name, args), manage) =
            let apply (args: QueueAuthorizationRuleArgs) =
                args.Manage <- input manage
                args

            ()
            name, List.Cons(apply, args)

        member _.Manage((name, args), manage) =
            let apply (args: QueueAuthorizationRuleArgs) =
                args.Manage <- io manage
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: QueueAuthorizationRuleArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: QueueAuthorizationRuleArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("namespaceName")>]
        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: QueueAuthorizationRuleArgs) =
                args.NamespaceName <- input namespaceName
                args

            ()
            name, List.Cons(apply, args)

        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: QueueAuthorizationRuleArgs) =
                args.NamespaceName <- io namespaceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("queueName")>]
        member _.QueueName((name, args), queueName) =
            let apply (args: QueueAuthorizationRuleArgs) =
                args.QueueName <- input queueName
                args

            ()
            name, List.Cons(apply, args)

        member _.QueueName((name, args), queueName) =
            let apply (args: QueueAuthorizationRuleArgs) =
                args.QueueName <- io queueName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: QueueAuthorizationRuleArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: QueueAuthorizationRuleArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("send")>]
        member _.Send((name, args), send) =
            let apply (args: QueueAuthorizationRuleArgs) =
                args.Send <- input send
                args

            ()
            name, List.Cons(apply, args)

        member _.Send((name, args), send) =
            let apply (args: QueueAuthorizationRuleArgs) =
                args.Send <- io send
                args

            ()
            name, List.Cons(apply, args)

    let queueAuthorizationRule = QueueAuthorizationRuleBuilder()

    type SubscriptionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Subscription(name, (List.fold func (SubscriptionArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("autoDeleteOnIdle")>]
        member _.AutoDeleteOnIdle((name, args), autoDeleteOnIdle) =
            let apply (args: SubscriptionArgs) =
                args.AutoDeleteOnIdle <- input autoDeleteOnIdle
                args

            ()
            name, List.Cons(apply, args)

        member _.AutoDeleteOnIdle((name, args), autoDeleteOnIdle) =
            let apply (args: SubscriptionArgs) =
                args.AutoDeleteOnIdle <- io autoDeleteOnIdle
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("deadLetteringOnMessageExpiration")>]
        member _.DeadLetteringOnMessageExpiration((name, args), deadLetteringOnMessageExpiration) =
            let apply (args: SubscriptionArgs) =
                args.DeadLetteringOnMessageExpiration <- input deadLetteringOnMessageExpiration
                args

            ()
            name, List.Cons(apply, args)

        member _.DeadLetteringOnMessageExpiration((name, args), deadLetteringOnMessageExpiration) =
            let apply (args: SubscriptionArgs) =
                args.DeadLetteringOnMessageExpiration <- io deadLetteringOnMessageExpiration
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("defaultMessageTtl")>]
        member _.DefaultMessageTtl((name, args), defaultMessageTtl) =
            let apply (args: SubscriptionArgs) =
                args.DefaultMessageTtl <- input defaultMessageTtl
                args

            ()
            name, List.Cons(apply, args)

        member _.DefaultMessageTtl((name, args), defaultMessageTtl) =
            let apply (args: SubscriptionArgs) =
                args.DefaultMessageTtl <- io defaultMessageTtl
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enableBatchedOperations")>]
        member _.EnableBatchedOperations((name, args), enableBatchedOperations) =
            let apply (args: SubscriptionArgs) =
                args.EnableBatchedOperations <- input enableBatchedOperations
                args

            ()
            name, List.Cons(apply, args)

        member _.EnableBatchedOperations((name, args), enableBatchedOperations) =
            let apply (args: SubscriptionArgs) =
                args.EnableBatchedOperations <- io enableBatchedOperations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("forwardDeadLetteredMessagesTo")>]
        member _.ForwardDeadLetteredMessagesTo((name, args), forwardDeadLetteredMessagesTo) =
            let apply (args: SubscriptionArgs) =
                args.ForwardDeadLetteredMessagesTo <- input forwardDeadLetteredMessagesTo
                args

            ()
            name, List.Cons(apply, args)

        member _.ForwardDeadLetteredMessagesTo((name, args), forwardDeadLetteredMessagesTo) =
            let apply (args: SubscriptionArgs) =
                args.ForwardDeadLetteredMessagesTo <- io forwardDeadLetteredMessagesTo
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("forwardTo")>]
        member _.ForwardTo((name, args), forwardTo) =
            let apply (args: SubscriptionArgs) =
                args.ForwardTo <- input forwardTo
                args

            ()
            name, List.Cons(apply, args)

        member _.ForwardTo((name, args), forwardTo) =
            let apply (args: SubscriptionArgs) =
                args.ForwardTo <- io forwardTo
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("lockDuration")>]
        member _.LockDuration((name, args), lockDuration) =
            let apply (args: SubscriptionArgs) =
                args.LockDuration <- input lockDuration
                args

            ()
            name, List.Cons(apply, args)

        member _.LockDuration((name, args), lockDuration) =
            let apply (args: SubscriptionArgs) =
                args.LockDuration <- io lockDuration
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("maxDeliveryCount")>]
        member _.MaxDeliveryCount((name, args), maxDeliveryCount) =
            let apply (args: SubscriptionArgs) =
                args.MaxDeliveryCount <- input maxDeliveryCount
                args

            ()
            name, List.Cons(apply, args)

        member _.MaxDeliveryCount((name, args), maxDeliveryCount) =
            let apply (args: SubscriptionArgs) =
                args.MaxDeliveryCount <- io maxDeliveryCount
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: SubscriptionArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: SubscriptionArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("namespaceName")>]
        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: SubscriptionArgs) =
                args.NamespaceName <- input namespaceName
                args

            ()
            name, List.Cons(apply, args)

        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: SubscriptionArgs) =
                args.NamespaceName <- io namespaceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("requiresSession")>]
        member _.RequiresSession((name, args), requiresSession) =
            let apply (args: SubscriptionArgs) =
                args.RequiresSession <- input requiresSession
                args

            ()
            name, List.Cons(apply, args)

        member _.RequiresSession((name, args), requiresSession) =
            let apply (args: SubscriptionArgs) =
                args.RequiresSession <- io requiresSession
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SubscriptionArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SubscriptionArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("topicName")>]
        member _.TopicName((name, args), topicName) =
            let apply (args: SubscriptionArgs) =
                args.TopicName <- input topicName
                args

            ()
            name, List.Cons(apply, args)

        member _.TopicName((name, args), topicName) =
            let apply (args: SubscriptionArgs) =
                args.TopicName <- io topicName
                args

            ()
            name, List.Cons(apply, args)

    let subscription = SubscriptionBuilder()

    type SubscriptionRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            SubscriptionRule(name, (List.fold func (SubscriptionRuleArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("action")>]
        member _.Action((name, args), action) =
            let apply (args: SubscriptionRuleArgs) =
                args.Action <- input action
                args

            ()
            name, List.Cons(apply, args)

        member _.Action((name, args), action) =
            let apply (args: SubscriptionRuleArgs) =
                args.Action <- io action
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: SubscriptionRuleArgs) =
                   args.CorrelationFilter <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("filterType")>]
        member _.FilterType((name, args), filterType) =
            let apply (args: SubscriptionRuleArgs) =
                args.FilterType <- input filterType
                args

            ()
            name, List.Cons(apply, args)

        member _.FilterType((name, args), filterType) =
            let apply (args: SubscriptionRuleArgs) =
                args.FilterType <- io filterType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: SubscriptionRuleArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: SubscriptionRuleArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("namespaceName")>]
        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: SubscriptionRuleArgs) =
                args.NamespaceName <- input namespaceName
                args

            ()
            name, List.Cons(apply, args)

        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: SubscriptionRuleArgs) =
                args.NamespaceName <- io namespaceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SubscriptionRuleArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SubscriptionRuleArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sqlFilter")>]
        member _.SqlFilter((name, args), sqlFilter) =
            let apply (args: SubscriptionRuleArgs) =
                args.SqlFilter <- input sqlFilter
                args

            ()
            name, List.Cons(apply, args)

        member _.SqlFilter((name, args), sqlFilter) =
            let apply (args: SubscriptionRuleArgs) =
                args.SqlFilter <- io sqlFilter
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("subscriptionName")>]
        member _.SubscriptionName((name, args), subscriptionName) =
            let apply (args: SubscriptionRuleArgs) =
                args.SubscriptionName <- input subscriptionName
                args

            ()
            name, List.Cons(apply, args)

        member _.SubscriptionName((name, args), subscriptionName) =
            let apply (args: SubscriptionRuleArgs) =
                args.SubscriptionName <- io subscriptionName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("topicName")>]
        member _.TopicName((name, args), topicName) =
            let apply (args: SubscriptionRuleArgs) =
                args.TopicName <- input topicName
                args

            ()
            name, List.Cons(apply, args)

        member _.TopicName((name, args), topicName) =
            let apply (args: SubscriptionRuleArgs) =
                args.TopicName <- io topicName
                args

            ()
            name, List.Cons(apply, args)

    let subscriptionRule = SubscriptionRuleBuilder()

    type TopicBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Topic(name, (List.fold func (TopicArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("autoDeleteOnIdle")>]
        member _.AutoDeleteOnIdle((name, args), autoDeleteOnIdle) =
            let apply (args: TopicArgs) =
                args.AutoDeleteOnIdle <- input autoDeleteOnIdle
                args

            ()
            name, List.Cons(apply, args)

        member _.AutoDeleteOnIdle((name, args), autoDeleteOnIdle) =
            let apply (args: TopicArgs) =
                args.AutoDeleteOnIdle <- io autoDeleteOnIdle
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("defaultMessageTtl")>]
        member _.DefaultMessageTtl((name, args), defaultMessageTtl) =
            let apply (args: TopicArgs) =
                args.DefaultMessageTtl <- input defaultMessageTtl
                args

            ()
            name, List.Cons(apply, args)

        member _.DefaultMessageTtl((name, args), defaultMessageTtl) =
            let apply (args: TopicArgs) =
                args.DefaultMessageTtl <- io defaultMessageTtl
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("duplicateDetectionHistoryTimeWindow")>]
        member _.DuplicateDetectionHistoryTimeWindow((name, args), duplicateDetectionHistoryTimeWindow) =
            let apply (args: TopicArgs) =
                args.DuplicateDetectionHistoryTimeWindow <- input duplicateDetectionHistoryTimeWindow
                args

            ()
            name, List.Cons(apply, args)

        member _.DuplicateDetectionHistoryTimeWindow((name, args), duplicateDetectionHistoryTimeWindow) =
            let apply (args: TopicArgs) =
                args.DuplicateDetectionHistoryTimeWindow <- io duplicateDetectionHistoryTimeWindow
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enableBatchedOperations")>]
        member _.EnableBatchedOperations((name, args), enableBatchedOperations) =
            let apply (args: TopicArgs) =
                args.EnableBatchedOperations <- input enableBatchedOperations
                args

            ()
            name, List.Cons(apply, args)

        member _.EnableBatchedOperations((name, args), enableBatchedOperations) =
            let apply (args: TopicArgs) =
                args.EnableBatchedOperations <- io enableBatchedOperations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enableExpress")>]
        member _.EnableExpress((name, args), enableExpress) =
            let apply (args: TopicArgs) =
                args.EnableExpress <- input enableExpress
                args

            ()
            name, List.Cons(apply, args)

        member _.EnableExpress((name, args), enableExpress) =
            let apply (args: TopicArgs) =
                args.EnableExpress <- io enableExpress
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enablePartitioning")>]
        member _.EnablePartitioning((name, args), enablePartitioning) =
            let apply (args: TopicArgs) =
                args.EnablePartitioning <- input enablePartitioning
                args

            ()
            name, List.Cons(apply, args)

        member _.EnablePartitioning((name, args), enablePartitioning) =
            let apply (args: TopicArgs) =
                args.EnablePartitioning <- io enablePartitioning
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("maxSizeInMegabytes")>]
        member _.MaxSizeInMegabytes((name, args), maxSizeInMegabytes) =
            let apply (args: TopicArgs) =
                args.MaxSizeInMegabytes <- input maxSizeInMegabytes
                args

            ()
            name, List.Cons(apply, args)

        member _.MaxSizeInMegabytes((name, args), maxSizeInMegabytes) =
            let apply (args: TopicArgs) =
                args.MaxSizeInMegabytes <- io maxSizeInMegabytes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: TopicArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: TopicArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("namespaceName")>]
        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: TopicArgs) =
                args.NamespaceName <- input namespaceName
                args

            ()
            name, List.Cons(apply, args)

        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: TopicArgs) =
                args.NamespaceName <- io namespaceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("requiresDuplicateDetection")>]
        member _.RequiresDuplicateDetection((name, args), requiresDuplicateDetection) =
            let apply (args: TopicArgs) =
                args.RequiresDuplicateDetection <- input requiresDuplicateDetection
                args

            ()
            name, List.Cons(apply, args)

        member _.RequiresDuplicateDetection((name, args), requiresDuplicateDetection) =
            let apply (args: TopicArgs) =
                args.RequiresDuplicateDetection <- io requiresDuplicateDetection
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: TopicArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: TopicArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("status")>]
        member _.Status((name, args), status) =
            let apply (args: TopicArgs) =
                args.Status <- input status
                args

            ()
            name, List.Cons(apply, args)

        member _.Status((name, args), status) =
            let apply (args: TopicArgs) =
                args.Status <- io status
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("supportOrdering")>]
        member _.SupportOrdering((name, args), supportOrdering) =
            let apply (args: TopicArgs) =
                args.SupportOrdering <- input supportOrdering
                args

            ()
            name, List.Cons(apply, args)

        member _.SupportOrdering((name, args), supportOrdering) =
            let apply (args: TopicArgs) =
                args.SupportOrdering <- io supportOrdering
                args

            ()
            name, List.Cons(apply, args)

    let topic = TopicBuilder()

    type TopicAuthorizationRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            TopicAuthorizationRule(name, (List.fold func (TopicAuthorizationRuleArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("listen")>]
        member _.Listen((name, args), listen) =
            let apply (args: TopicAuthorizationRuleArgs) =
                args.Listen <- input listen
                args

            ()
            name, List.Cons(apply, args)

        member _.Listen((name, args), listen) =
            let apply (args: TopicAuthorizationRuleArgs) =
                args.Listen <- io listen
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("manage")>]
        member _.Manage((name, args), manage) =
            let apply (args: TopicAuthorizationRuleArgs) =
                args.Manage <- input manage
                args

            ()
            name, List.Cons(apply, args)

        member _.Manage((name, args), manage) =
            let apply (args: TopicAuthorizationRuleArgs) =
                args.Manage <- io manage
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: TopicAuthorizationRuleArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: TopicAuthorizationRuleArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("namespaceName")>]
        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: TopicAuthorizationRuleArgs) =
                args.NamespaceName <- input namespaceName
                args

            ()
            name, List.Cons(apply, args)

        member _.NamespaceName((name, args), namespaceName) =
            let apply (args: TopicAuthorizationRuleArgs) =
                args.NamespaceName <- io namespaceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: TopicAuthorizationRuleArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: TopicAuthorizationRuleArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("send")>]
        member _.Send((name, args), send) =
            let apply (args: TopicAuthorizationRuleArgs) =
                args.Send <- input send
                args

            ()
            name, List.Cons(apply, args)

        member _.Send((name, args), send) =
            let apply (args: TopicAuthorizationRuleArgs) =
                args.Send <- io send
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("topicName")>]
        member _.TopicName((name, args), topicName) =
            let apply (args: TopicAuthorizationRuleArgs) =
                args.TopicName <- input topicName
                args

            ()
            name, List.Cons(apply, args)

        member _.TopicName((name, args), topicName) =
            let apply (args: TopicAuthorizationRuleArgs) =
                args.TopicName <- io topicName
                args

            ()
            name, List.Cons(apply, args)

    let topicAuthorizationRule = TopicAuthorizationRuleBuilder()

module ServiceFabric =
    open Pulumi.Azure.ServiceFabric
    open Pulumi.Azure.ServiceFabric.Inputs

    type ClusterAzureActiveDirectoryBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ClusterAzureActiveDirectoryArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("clientApplicationId")>]
        member _.ClientApplicationId((n, args), clientApplicationId) =
            let apply (args: ClusterAzureActiveDirectoryArgs) =
                args.ClientApplicationId <- input clientApplicationId
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientApplicationId((n, args), clientApplicationId) =
            let apply (args: ClusterAzureActiveDirectoryArgs) =
                args.ClientApplicationId <- io clientApplicationId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("clusterApplicationId")>]
        member _.ClusterApplicationId((n, args), clusterApplicationId) =
            let apply (args: ClusterAzureActiveDirectoryArgs) =
                args.ClusterApplicationId <- input clusterApplicationId
                args

            ()
            n, List.Cons(apply, args)

        member _.ClusterApplicationId((n, args), clusterApplicationId) =
            let apply (args: ClusterAzureActiveDirectoryArgs) =
                args.ClusterApplicationId <- io clusterApplicationId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tenantId")>]
        member _.TenantId((n, args), tenantId) =
            let apply (args: ClusterAzureActiveDirectoryArgs) =
                args.TenantId <- input tenantId
                args

            ()
            n, List.Cons(apply, args)

        member _.TenantId((n, args), tenantId) =
            let apply (args: ClusterAzureActiveDirectoryArgs) =
                args.TenantId <- io tenantId
                args

            ()
            n, List.Cons(apply, args)

    let clusterAzureActiveDirectory = ClusterAzureActiveDirectoryBuilder()

    type ClusterCertificateBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ClusterCertificateArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("thumbprint")>]
        member _.Thumbprint((n, args), thumbprint) =
            let apply (args: ClusterCertificateArgs) =
                args.Thumbprint <- input thumbprint
                args

            ()
            n, List.Cons(apply, args)

        member _.Thumbprint((n, args), thumbprint) =
            let apply (args: ClusterCertificateArgs) =
                args.Thumbprint <- io thumbprint
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("thumbprintSecondary")>]
        member _.ThumbprintSecondary((n, args), thumbprintSecondary) =
            let apply (args: ClusterCertificateArgs) =
                args.ThumbprintSecondary <- input thumbprintSecondary
                args

            ()
            n, List.Cons(apply, args)

        member _.ThumbprintSecondary((n, args), thumbprintSecondary) =
            let apply (args: ClusterCertificateArgs) =
                args.ThumbprintSecondary <- io thumbprintSecondary
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("x509StoreName")>]
        member _.X509StoreName((n, args), x509StoreName) =
            let apply (args: ClusterCertificateArgs) =
                args.X509StoreName <- input x509StoreName
                args

            ()
            n, List.Cons(apply, args)

        member _.X509StoreName((n, args), x509StoreName) =
            let apply (args: ClusterCertificateArgs) =
                args.X509StoreName <- io x509StoreName
                args

            ()
            n, List.Cons(apply, args)

    let clusterCertificate = ClusterCertificateBuilder()

    type ClusterCertificateCommonNamesBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ClusterCertificateCommonNamesArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("commonNames")>]
        member _.CommonNames((n, args), commonNames) =
            let apply (args: ClusterCertificateCommonNamesArgs) =
                args.CommonNames <- inputList commonNames
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("x509StoreName")>]
        member _.X509StoreName((n, args), x509StoreName) =
            let apply (args: ClusterCertificateCommonNamesArgs) =
                args.X509StoreName <- input x509StoreName
                args

            ()
            n, List.Cons(apply, args)

        member _.X509StoreName((n, args), x509StoreName) =
            let apply (args: ClusterCertificateCommonNamesArgs) =
                args.X509StoreName <- io x509StoreName
                args

            ()
            n, List.Cons(apply, args)

    let clusterCertificateCommonNames = ClusterCertificateCommonNamesBuilder()

    type ClusterCertificateCommonNamesCommonNameBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ClusterCertificateCommonNamesCommonNameArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("certificateCommonName")>]
        member _.CertificateCommonName((n, args), certificateCommonName) =
            let apply (args: ClusterCertificateCommonNamesCommonNameArgs) =
                args.CertificateCommonName <- input certificateCommonName
                args

            ()
            n, List.Cons(apply, args)

        member _.CertificateCommonName((n, args), certificateCommonName) =
            let apply (args: ClusterCertificateCommonNamesCommonNameArgs) =
                args.CertificateCommonName <- io certificateCommonName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("certificateIssuerThumbprint")>]
        member _.CertificateIssuerThumbprint((n, args), certificateIssuerThumbprint) =
            let apply (args: ClusterCertificateCommonNamesCommonNameArgs) =
                args.CertificateIssuerThumbprint <- input certificateIssuerThumbprint
                args

            ()
            n, List.Cons(apply, args)

        member _.CertificateIssuerThumbprint((n, args), certificateIssuerThumbprint) =
            let apply (args: ClusterCertificateCommonNamesCommonNameArgs) =
                args.CertificateIssuerThumbprint <- io certificateIssuerThumbprint
                args

            ()
            n, List.Cons(apply, args)

    let clusterCertificateCommonNamesCommonName =
        ClusterCertificateCommonNamesCommonNameBuilder()

    type ClusterClientCertificateCommonNameBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ClusterClientCertificateCommonNameArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("commonName")>]
        member _.CommonName((n, args), commonName) =
            let apply (args: ClusterClientCertificateCommonNameArgs) =
                args.CommonName <- input commonName
                args

            ()
            n, List.Cons(apply, args)

        member _.CommonName((n, args), commonName) =
            let apply (args: ClusterClientCertificateCommonNameArgs) =
                args.CommonName <- io commonName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("isAdmin")>]
        member _.IsAdmin((n, args), isAdmin) =
            let apply (args: ClusterClientCertificateCommonNameArgs) =
                args.IsAdmin <- input isAdmin
                args

            ()
            n, List.Cons(apply, args)

        member _.IsAdmin((n, args), isAdmin) =
            let apply (args: ClusterClientCertificateCommonNameArgs) =
                args.IsAdmin <- io isAdmin
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("issuerThumbprint")>]
        member _.IssuerThumbprint((n, args), issuerThumbprint) =
            let apply (args: ClusterClientCertificateCommonNameArgs) =
                args.IssuerThumbprint <- input issuerThumbprint
                args

            ()
            n, List.Cons(apply, args)

        member _.IssuerThumbprint((n, args), issuerThumbprint) =
            let apply (args: ClusterClientCertificateCommonNameArgs) =
                args.IssuerThumbprint <- io issuerThumbprint
                args

            ()
            n, List.Cons(apply, args)

    let clusterClientCertificateCommonName =
        ClusterClientCertificateCommonNameBuilder()

    type ClusterClientCertificateThumbprintBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ClusterClientCertificateThumbprintArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("isAdmin")>]
        member _.IsAdmin((n, args), isAdmin) =
            let apply (args: ClusterClientCertificateThumbprintArgs) =
                args.IsAdmin <- input isAdmin
                args

            ()
            n, List.Cons(apply, args)

        member _.IsAdmin((n, args), isAdmin) =
            let apply (args: ClusterClientCertificateThumbprintArgs) =
                args.IsAdmin <- io isAdmin
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("thumbprint")>]
        member _.Thumbprint((n, args), thumbprint) =
            let apply (args: ClusterClientCertificateThumbprintArgs) =
                args.Thumbprint <- input thumbprint
                args

            ()
            n, List.Cons(apply, args)

        member _.Thumbprint((n, args), thumbprint) =
            let apply (args: ClusterClientCertificateThumbprintArgs) =
                args.Thumbprint <- io thumbprint
                args

            ()
            n, List.Cons(apply, args)

    let clusterClientCertificateThumbprint =
        ClusterClientCertificateThumbprintBuilder()

    type ClusterDiagnosticsConfigBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ClusterDiagnosticsConfigArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("blobEndpoint")>]
        member _.BlobEndpoint((n, args), blobEndpoint) =
            let apply (args: ClusterDiagnosticsConfigArgs) =
                args.BlobEndpoint <- input blobEndpoint
                args

            ()
            n, List.Cons(apply, args)

        member _.BlobEndpoint((n, args), blobEndpoint) =
            let apply (args: ClusterDiagnosticsConfigArgs) =
                args.BlobEndpoint <- io blobEndpoint
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("protectedAccountKeyName")>]
        member _.ProtectedAccountKeyName((n, args), protectedAccountKeyName) =
            let apply (args: ClusterDiagnosticsConfigArgs) =
                args.ProtectedAccountKeyName <- input protectedAccountKeyName
                args

            ()
            n, List.Cons(apply, args)

        member _.ProtectedAccountKeyName((n, args), protectedAccountKeyName) =
            let apply (args: ClusterDiagnosticsConfigArgs) =
                args.ProtectedAccountKeyName <- io protectedAccountKeyName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("queueEndpoint")>]
        member _.QueueEndpoint((n, args), queueEndpoint) =
            let apply (args: ClusterDiagnosticsConfigArgs) =
                args.QueueEndpoint <- input queueEndpoint
                args

            ()
            n, List.Cons(apply, args)

        member _.QueueEndpoint((n, args), queueEndpoint) =
            let apply (args: ClusterDiagnosticsConfigArgs) =
                args.QueueEndpoint <- io queueEndpoint
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageAccountName")>]
        member _.StorageAccountName((n, args), storageAccountName) =
            let apply (args: ClusterDiagnosticsConfigArgs) =
                args.StorageAccountName <- input storageAccountName
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountName((n, args), storageAccountName) =
            let apply (args: ClusterDiagnosticsConfigArgs) =
                args.StorageAccountName <- io storageAccountName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tableEndpoint")>]
        member _.TableEndpoint((n, args), tableEndpoint) =
            let apply (args: ClusterDiagnosticsConfigArgs) =
                args.TableEndpoint <- input tableEndpoint
                args

            ()
            n, List.Cons(apply, args)

        member _.TableEndpoint((n, args), tableEndpoint) =
            let apply (args: ClusterDiagnosticsConfigArgs) =
                args.TableEndpoint <- io tableEndpoint
                args

            ()
            n, List.Cons(apply, args)

    let clusterDiagnosticsConfig = ClusterDiagnosticsConfigBuilder()

    type ClusterFabricSettingBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ClusterFabricSettingArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ClusterFabricSettingArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ClusterFabricSettingArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("parameters")>]
        member _.Parameters((n, args), parameters) =
            let apply (args: ClusterFabricSettingArgs) =
                args.Parameters <- inputMap parameters
                args

            ()
            n, List.Cons(apply, args)

    let clusterFabricSetting = ClusterFabricSettingBuilder()

    type ClusterNodeTypeBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ClusterNodeTypeArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: ClusterNodeTypeArgs) =
                   args.ApplicationPorts <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("capacities")>]
        member _.Capacities((n, args), capacities) =
            let apply (args: ClusterNodeTypeArgs) =
                args.Capacities <- inputMap capacities
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("clientEndpointPort")>]
        member _.ClientEndpointPort((n, args), clientEndpointPort) =
            let apply (args: ClusterNodeTypeArgs) =
                args.ClientEndpointPort <- input clientEndpointPort
                args

            ()
            n, List.Cons(apply, args)

        member _.ClientEndpointPort((n, args), clientEndpointPort) =
            let apply (args: ClusterNodeTypeArgs) =
                args.ClientEndpointPort <- io clientEndpointPort
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("durabilityLevel")>]
        member _.DurabilityLevel((n, args), durabilityLevel) =
            let apply (args: ClusterNodeTypeArgs) =
                args.DurabilityLevel <- input durabilityLevel
                args

            ()
            n, List.Cons(apply, args)

        member _.DurabilityLevel((n, args), durabilityLevel) =
            let apply (args: ClusterNodeTypeArgs) =
                args.DurabilityLevel <- io durabilityLevel
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ClusterNodeTypeArgs) =
                   args.EphemeralPorts <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("httpEndpointPort")>]
        member _.HttpEndpointPort((n, args), httpEndpointPort) =
            let apply (args: ClusterNodeTypeArgs) =
                args.HttpEndpointPort <- input httpEndpointPort
                args

            ()
            n, List.Cons(apply, args)

        member _.HttpEndpointPort((n, args), httpEndpointPort) =
            let apply (args: ClusterNodeTypeArgs) =
                args.HttpEndpointPort <- io httpEndpointPort
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("instanceCount")>]
        member _.InstanceCount((n, args), instanceCount) =
            let apply (args: ClusterNodeTypeArgs) =
                args.InstanceCount <- input instanceCount
                args

            ()
            n, List.Cons(apply, args)

        member _.InstanceCount((n, args), instanceCount) =
            let apply (args: ClusterNodeTypeArgs) =
                args.InstanceCount <- io instanceCount
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("isPrimary")>]
        member _.IsPrimary((n, args), isPrimary) =
            let apply (args: ClusterNodeTypeArgs) =
                args.IsPrimary <- input isPrimary
                args

            ()
            n, List.Cons(apply, args)

        member _.IsPrimary((n, args), isPrimary) =
            let apply (args: ClusterNodeTypeArgs) =
                args.IsPrimary <- io isPrimary
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ClusterNodeTypeArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ClusterNodeTypeArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("placementProperties")>]
        member _.PlacementProperties((n, args), placementProperties) =
            let apply (args: ClusterNodeTypeArgs) =
                args.PlacementProperties <- inputMap placementProperties
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("reverseProxyEndpointPort")>]
        member _.ReverseProxyEndpointPort((n, args), reverseProxyEndpointPort) =
            let apply (args: ClusterNodeTypeArgs) =
                args.ReverseProxyEndpointPort <- input reverseProxyEndpointPort
                args

            ()
            n, List.Cons(apply, args)

        member _.ReverseProxyEndpointPort((n, args), reverseProxyEndpointPort) =
            let apply (args: ClusterNodeTypeArgs) =
                args.ReverseProxyEndpointPort <- io reverseProxyEndpointPort
                args

            ()
            n, List.Cons(apply, args)

    let clusterNodeType = ClusterNodeTypeBuilder()

    type ClusterNodeTypeApplicationPortsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ClusterNodeTypeApplicationPortsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("endPort")>]
        member _.EndPort((n, args), endPort) =
            let apply (args: ClusterNodeTypeApplicationPortsArgs) =
                args.EndPort <- input endPort
                args

            ()
            n, List.Cons(apply, args)

        member _.EndPort((n, args), endPort) =
            let apply (args: ClusterNodeTypeApplicationPortsArgs) =
                args.EndPort <- io endPort
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("startPort")>]
        member _.StartPort((n, args), startPort) =
            let apply (args: ClusterNodeTypeApplicationPortsArgs) =
                args.StartPort <- input startPort
                args

            ()
            n, List.Cons(apply, args)

        member _.StartPort((n, args), startPort) =
            let apply (args: ClusterNodeTypeApplicationPortsArgs) =
                args.StartPort <- io startPort
                args

            ()
            n, List.Cons(apply, args)

    let clusterNodeTypeApplicationPorts = ClusterNodeTypeApplicationPortsBuilder()

    type ClusterNodeTypeEphemeralPortsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ClusterNodeTypeEphemeralPortsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("endPort")>]
        member _.EndPort((n, args), endPort) =
            let apply (args: ClusterNodeTypeEphemeralPortsArgs) =
                args.EndPort <- input endPort
                args

            ()
            n, List.Cons(apply, args)

        member _.EndPort((n, args), endPort) =
            let apply (args: ClusterNodeTypeEphemeralPortsArgs) =
                args.EndPort <- io endPort
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("startPort")>]
        member _.StartPort((n, args), startPort) =
            let apply (args: ClusterNodeTypeEphemeralPortsArgs) =
                args.StartPort <- input startPort
                args

            ()
            n, List.Cons(apply, args)

        member _.StartPort((n, args), startPort) =
            let apply (args: ClusterNodeTypeEphemeralPortsArgs) =
                args.StartPort <- io startPort
                args

            ()
            n, List.Cons(apply, args)

    let clusterNodeTypeEphemeralPorts = ClusterNodeTypeEphemeralPortsBuilder()

    type ClusterReverseProxyCertificateBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ClusterReverseProxyCertificateArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("thumbprint")>]
        member _.Thumbprint((n, args), thumbprint) =
            let apply (args: ClusterReverseProxyCertificateArgs) =
                args.Thumbprint <- input thumbprint
                args

            ()
            n, List.Cons(apply, args)

        member _.Thumbprint((n, args), thumbprint) =
            let apply (args: ClusterReverseProxyCertificateArgs) =
                args.Thumbprint <- io thumbprint
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("thumbprintSecondary")>]
        member _.ThumbprintSecondary((n, args), thumbprintSecondary) =
            let apply (args: ClusterReverseProxyCertificateArgs) =
                args.ThumbprintSecondary <- input thumbprintSecondary
                args

            ()
            n, List.Cons(apply, args)

        member _.ThumbprintSecondary((n, args), thumbprintSecondary) =
            let apply (args: ClusterReverseProxyCertificateArgs) =
                args.ThumbprintSecondary <- io thumbprintSecondary
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("x509StoreName")>]
        member _.X509StoreName((n, args), x509StoreName) =
            let apply (args: ClusterReverseProxyCertificateArgs) =
                args.X509StoreName <- input x509StoreName
                args

            ()
            n, List.Cons(apply, args)

        member _.X509StoreName((n, args), x509StoreName) =
            let apply (args: ClusterReverseProxyCertificateArgs) =
                args.X509StoreName <- io x509StoreName
                args

            ()
            n, List.Cons(apply, args)

    let clusterReverseProxyCertificate = ClusterReverseProxyCertificateBuilder()

    type ClusterBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Cluster(name, (List.fold func (ClusterArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("addOnFeatures")>]
        member _.AddOnFeatures((name, args), addOnFeatures) =
            let apply (args: ClusterArgs) =
                args.AddOnFeatures <- inputList addOnFeatures
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ClusterArgs) =
                   args.AzureActiveDirectory <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: ClusterArgs) =
                   args.Certificate <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: ClusterArgs) =
                   args.CertificateCommonNames <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("clientCertificateCommonNames")>]
        member _.ClientCertificateCommonNames((name, args), clientCertificateCommonNames) =
            let apply (args: ClusterArgs) =
                args.ClientCertificateCommonNames <- inputList clientCertificateCommonNames
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("clientCertificateThumbprints")>]
        member _.ClientCertificateThumbprints((name, args), clientCertificateThumbprints) =
            let apply (args: ClusterArgs) =
                args.ClientCertificateThumbprints <- inputList clientCertificateThumbprints
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("clusterCodeVersion")>]
        member _.ClusterCodeVersion((name, args), clusterCodeVersion) =
            let apply (args: ClusterArgs) =
                args.ClusterCodeVersion <- input clusterCodeVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.ClusterCodeVersion((name, args), clusterCodeVersion) =
            let apply (args: ClusterArgs) =
                args.ClusterCodeVersion <- io clusterCodeVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ClusterArgs) =
                   args.DiagnosticsConfig <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("fabricSettings")>]
        member _.FabricSettings((name, args), fabricSettings) =
            let apply (args: ClusterArgs) =
                args.FabricSettings <- inputList fabricSettings
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ClusterArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ClusterArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("managementEndpoint")>]
        member _.ManagementEndpoint((name, args), managementEndpoint) =
            let apply (args: ClusterArgs) =
                args.ManagementEndpoint <- input managementEndpoint
                args

            ()
            name, List.Cons(apply, args)

        member _.ManagementEndpoint((name, args), managementEndpoint) =
            let apply (args: ClusterArgs) =
                args.ManagementEndpoint <- io managementEndpoint
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ClusterArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ClusterArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("nodeTypes")>]
        member _.NodeTypes((name, args), nodeTypes) =
            let apply (args: ClusterArgs) =
                args.NodeTypes <- inputList nodeTypes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("reliabilityLevel")>]
        member _.ReliabilityLevel((name, args), reliabilityLevel) =
            let apply (args: ClusterArgs) =
                args.ReliabilityLevel <- input reliabilityLevel
                args

            ()
            name, List.Cons(apply, args)

        member _.ReliabilityLevel((name, args), reliabilityLevel) =
            let apply (args: ClusterArgs) =
                args.ReliabilityLevel <- io reliabilityLevel
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ClusterArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ClusterArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ClusterArgs) =
                   args.ReverseProxyCertificate <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ClusterArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("upgradeMode")>]
        member _.UpgradeMode((name, args), upgradeMode) =
            let apply (args: ClusterArgs) =
                args.UpgradeMode <- input upgradeMode
                args

            ()
            name, List.Cons(apply, args)

        member _.UpgradeMode((name, args), upgradeMode) =
            let apply (args: ClusterArgs) =
                args.UpgradeMode <- io upgradeMode
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("vmImage")>]
        member _.VmImage((name, args), vmImage) =
            let apply (args: ClusterArgs) =
                args.VmImage <- input vmImage
                args

            ()
            name, List.Cons(apply, args)

        member _.VmImage((name, args), vmImage) =
            let apply (args: ClusterArgs) =
                args.VmImage <- io vmImage
                args

            ()
            name, List.Cons(apply, args)

    let cluster = ClusterBuilder()

module SignalR =
    open Pulumi.Azure.SignalR
    open Pulumi.Azure.SignalR.Inputs

    type ServiceCorBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ServiceCorArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("allowedOrigins")>]
        member _.AllowedOrigins((n, args), allowedOrigins) =
            let apply (args: ServiceCorArgs) =
                args.AllowedOrigins <- inputList allowedOrigins
                args

            ()
            n, List.Cons(apply, args)

    let serviceCor = ServiceCorBuilder()

    type ServiceFeatureBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ServiceFeatureArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("flag")>]
        member _.Flag((n, args), flag) =
            let apply (args: ServiceFeatureArgs) =
                args.Flag <- input flag
                args

            ()
            n, List.Cons(apply, args)

        member _.Flag((n, args), flag) =
            let apply (args: ServiceFeatureArgs) =
                args.Flag <- io flag
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((n, args), value) =
            let apply (args: ServiceFeatureArgs) =
                args.Value <- input value
                args

            ()
            n, List.Cons(apply, args)

        member _.Value((n, args), value) =
            let apply (args: ServiceFeatureArgs) =
                args.Value <- io value
                args

            ()
            n, List.Cons(apply, args)

    let serviceFeature = ServiceFeatureBuilder()

    type ServiceSkuBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ServiceSkuArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("capacity")>]
        member _.Capacity((n, args), capacity) =
            let apply (args: ServiceSkuArgs) =
                args.Capacity <- input capacity
                args

            ()
            n, List.Cons(apply, args)

        member _.Capacity((n, args), capacity) =
            let apply (args: ServiceSkuArgs) =
                args.Capacity <- io capacity
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ServiceSkuArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ServiceSkuArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

    let serviceSku = ServiceSkuBuilder()

    type ServiceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Service(name, (List.fold func (ServiceArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("cors")>]
        member _.Cors((name, args), cors) =
            let apply (args: ServiceArgs) =
                args.Cors <- inputList cors
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("features")>]
        member _.Features((name, args), features) =
            let apply (args: ServiceArgs) =
                args.Features <- inputList features
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ServiceArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ServiceArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ServiceArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ServiceArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ServiceArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ServiceArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ServiceArgs) =
                   args.Sku <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ServiceArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let service = ServiceBuilder()

module SiteRecovery =
    open Pulumi.Azure.SiteRecovery
    open Pulumi.Azure.SiteRecovery.Inputs

    type ReplicatedVMManagedDiskBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ReplicatedVMManagedDiskArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("diskId")>]
        member _.DiskId((n, args), diskId) =
            let apply (args: ReplicatedVMManagedDiskArgs) =
                args.DiskId <- input diskId
                args

            ()
            n, List.Cons(apply, args)

        member _.DiskId((n, args), diskId) =
            let apply (args: ReplicatedVMManagedDiskArgs) =
                args.DiskId <- io diskId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("stagingStorageAccountId")>]
        member _.StagingStorageAccountId((n, args), stagingStorageAccountId) =
            let apply (args: ReplicatedVMManagedDiskArgs) =
                args.StagingStorageAccountId <- input stagingStorageAccountId
                args

            ()
            n, List.Cons(apply, args)

        member _.StagingStorageAccountId((n, args), stagingStorageAccountId) =
            let apply (args: ReplicatedVMManagedDiskArgs) =
                args.StagingStorageAccountId <- io stagingStorageAccountId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("targetDiskType")>]
        member _.TargetDiskType((n, args), targetDiskType) =
            let apply (args: ReplicatedVMManagedDiskArgs) =
                args.TargetDiskType <- input targetDiskType
                args

            ()
            n, List.Cons(apply, args)

        member _.TargetDiskType((n, args), targetDiskType) =
            let apply (args: ReplicatedVMManagedDiskArgs) =
                args.TargetDiskType <- io targetDiskType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("targetReplicaDiskType")>]
        member _.TargetReplicaDiskType((n, args), targetReplicaDiskType) =
            let apply (args: ReplicatedVMManagedDiskArgs) =
                args.TargetReplicaDiskType <- input targetReplicaDiskType
                args

            ()
            n, List.Cons(apply, args)

        member _.TargetReplicaDiskType((n, args), targetReplicaDiskType) =
            let apply (args: ReplicatedVMManagedDiskArgs) =
                args.TargetReplicaDiskType <- io targetReplicaDiskType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("targetResourceGroupId")>]
        member _.TargetResourceGroupId((n, args), targetResourceGroupId) =
            let apply (args: ReplicatedVMManagedDiskArgs) =
                args.TargetResourceGroupId <- input targetResourceGroupId
                args

            ()
            n, List.Cons(apply, args)

        member _.TargetResourceGroupId((n, args), targetResourceGroupId) =
            let apply (args: ReplicatedVMManagedDiskArgs) =
                args.TargetResourceGroupId <- io targetResourceGroupId
                args

            ()
            n, List.Cons(apply, args)

    let replicatedVMManagedDisk = ReplicatedVMManagedDiskBuilder()

    type FabricBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Fabric(name, (List.fold func (FabricArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: FabricArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: FabricArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: FabricArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: FabricArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("recoveryVaultName")>]
        member _.RecoveryVaultName((name, args), recoveryVaultName) =
            let apply (args: FabricArgs) =
                args.RecoveryVaultName <- input recoveryVaultName
                args

            ()
            name, List.Cons(apply, args)

        member _.RecoveryVaultName((name, args), recoveryVaultName) =
            let apply (args: FabricArgs) =
                args.RecoveryVaultName <- io recoveryVaultName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FabricArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FabricArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let fabric = FabricBuilder()

    type NetworkMappingBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            NetworkMapping(name, (List.fold func (NetworkMappingArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: NetworkMappingArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: NetworkMappingArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("recoveryVaultName")>]
        member _.RecoveryVaultName((name, args), recoveryVaultName) =
            let apply (args: NetworkMappingArgs) =
                args.RecoveryVaultName <- input recoveryVaultName
                args

            ()
            name, List.Cons(apply, args)

        member _.RecoveryVaultName((name, args), recoveryVaultName) =
            let apply (args: NetworkMappingArgs) =
                args.RecoveryVaultName <- io recoveryVaultName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NetworkMappingArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NetworkMappingArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sourceNetworkId")>]
        member _.SourceNetworkId((name, args), sourceNetworkId) =
            let apply (args: NetworkMappingArgs) =
                args.SourceNetworkId <- input sourceNetworkId
                args

            ()
            name, List.Cons(apply, args)

        member _.SourceNetworkId((name, args), sourceNetworkId) =
            let apply (args: NetworkMappingArgs) =
                args.SourceNetworkId <- io sourceNetworkId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sourceRecoveryFabricName")>]
        member _.SourceRecoveryFabricName((name, args), sourceRecoveryFabricName) =
            let apply (args: NetworkMappingArgs) =
                args.SourceRecoveryFabricName <- input sourceRecoveryFabricName
                args

            ()
            name, List.Cons(apply, args)

        member _.SourceRecoveryFabricName((name, args), sourceRecoveryFabricName) =
            let apply (args: NetworkMappingArgs) =
                args.SourceRecoveryFabricName <- io sourceRecoveryFabricName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("targetNetworkId")>]
        member _.TargetNetworkId((name, args), targetNetworkId) =
            let apply (args: NetworkMappingArgs) =
                args.TargetNetworkId <- input targetNetworkId
                args

            ()
            name, List.Cons(apply, args)

        member _.TargetNetworkId((name, args), targetNetworkId) =
            let apply (args: NetworkMappingArgs) =
                args.TargetNetworkId <- io targetNetworkId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("targetRecoveryFabricName")>]
        member _.TargetRecoveryFabricName((name, args), targetRecoveryFabricName) =
            let apply (args: NetworkMappingArgs) =
                args.TargetRecoveryFabricName <- input targetRecoveryFabricName
                args

            ()
            name, List.Cons(apply, args)

        member _.TargetRecoveryFabricName((name, args), targetRecoveryFabricName) =
            let apply (args: NetworkMappingArgs) =
                args.TargetRecoveryFabricName <- io targetRecoveryFabricName
                args

            ()
            name, List.Cons(apply, args)

    let networkMapping = NetworkMappingBuilder()

    type ProtectionContainerBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ProtectionContainer(name, (List.fold func (ProtectionContainerArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ProtectionContainerArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ProtectionContainerArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("recoveryFabricName")>]
        member _.RecoveryFabricName((name, args), recoveryFabricName) =
            let apply (args: ProtectionContainerArgs) =
                args.RecoveryFabricName <- input recoveryFabricName
                args

            ()
            name, List.Cons(apply, args)

        member _.RecoveryFabricName((name, args), recoveryFabricName) =
            let apply (args: ProtectionContainerArgs) =
                args.RecoveryFabricName <- io recoveryFabricName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("recoveryVaultName")>]
        member _.RecoveryVaultName((name, args), recoveryVaultName) =
            let apply (args: ProtectionContainerArgs) =
                args.RecoveryVaultName <- input recoveryVaultName
                args

            ()
            name, List.Cons(apply, args)

        member _.RecoveryVaultName((name, args), recoveryVaultName) =
            let apply (args: ProtectionContainerArgs) =
                args.RecoveryVaultName <- io recoveryVaultName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ProtectionContainerArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ProtectionContainerArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let protectionContainer = ProtectionContainerBuilder()

    type ProtectionContainerMappingBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ProtectionContainerMapping(name, (List.fold func (ProtectionContainerMappingArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ProtectionContainerMappingArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ProtectionContainerMappingArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("recoveryFabricName")>]
        member _.RecoveryFabricName((name, args), recoveryFabricName) =
            let apply (args: ProtectionContainerMappingArgs) =
                args.RecoveryFabricName <- input recoveryFabricName
                args

            ()
            name, List.Cons(apply, args)

        member _.RecoveryFabricName((name, args), recoveryFabricName) =
            let apply (args: ProtectionContainerMappingArgs) =
                args.RecoveryFabricName <- io recoveryFabricName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("recoveryReplicationPolicyId")>]
        member _.RecoveryReplicationPolicyId((name, args), recoveryReplicationPolicyId) =
            let apply (args: ProtectionContainerMappingArgs) =
                args.RecoveryReplicationPolicyId <- input recoveryReplicationPolicyId
                args

            ()
            name, List.Cons(apply, args)

        member _.RecoveryReplicationPolicyId((name, args), recoveryReplicationPolicyId) =
            let apply (args: ProtectionContainerMappingArgs) =
                args.RecoveryReplicationPolicyId <- io recoveryReplicationPolicyId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("recoverySourceProtectionContainerName")>]
        member _.RecoverySourceProtectionContainerName((name, args), recoverySourceProtectionContainerName) =
            let apply (args: ProtectionContainerMappingArgs) =
                args.RecoverySourceProtectionContainerName <- input recoverySourceProtectionContainerName
                args

            ()
            name, List.Cons(apply, args)

        member _.RecoverySourceProtectionContainerName((name, args), recoverySourceProtectionContainerName) =
            let apply (args: ProtectionContainerMappingArgs) =
                args.RecoverySourceProtectionContainerName <- io recoverySourceProtectionContainerName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("recoveryTargetProtectionContainerId")>]
        member _.RecoveryTargetProtectionContainerId((name, args), recoveryTargetProtectionContainerId) =
            let apply (args: ProtectionContainerMappingArgs) =
                args.RecoveryTargetProtectionContainerId <- input recoveryTargetProtectionContainerId
                args

            ()
            name, List.Cons(apply, args)

        member _.RecoveryTargetProtectionContainerId((name, args), recoveryTargetProtectionContainerId) =
            let apply (args: ProtectionContainerMappingArgs) =
                args.RecoveryTargetProtectionContainerId <- io recoveryTargetProtectionContainerId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("recoveryVaultName")>]
        member _.RecoveryVaultName((name, args), recoveryVaultName) =
            let apply (args: ProtectionContainerMappingArgs) =
                args.RecoveryVaultName <- input recoveryVaultName
                args

            ()
            name, List.Cons(apply, args)

        member _.RecoveryVaultName((name, args), recoveryVaultName) =
            let apply (args: ProtectionContainerMappingArgs) =
                args.RecoveryVaultName <- io recoveryVaultName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ProtectionContainerMappingArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ProtectionContainerMappingArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let protectionContainerMapping = ProtectionContainerMappingBuilder()

    type ReplicatedVMBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ReplicatedVM(name, (List.fold func (ReplicatedVMArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("managedDisks")>]
        member _.ManagedDisks((name, args), managedDisks) =
            let apply (args: ReplicatedVMArgs) =
                args.ManagedDisks <- inputList managedDisks
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ReplicatedVMArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ReplicatedVMArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("recoveryReplicationPolicyId")>]
        member _.RecoveryReplicationPolicyId((name, args), recoveryReplicationPolicyId) =
            let apply (args: ReplicatedVMArgs) =
                args.RecoveryReplicationPolicyId <- input recoveryReplicationPolicyId
                args

            ()
            name, List.Cons(apply, args)

        member _.RecoveryReplicationPolicyId((name, args), recoveryReplicationPolicyId) =
            let apply (args: ReplicatedVMArgs) =
                args.RecoveryReplicationPolicyId <- io recoveryReplicationPolicyId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("recoveryVaultName")>]
        member _.RecoveryVaultName((name, args), recoveryVaultName) =
            let apply (args: ReplicatedVMArgs) =
                args.RecoveryVaultName <- input recoveryVaultName
                args

            ()
            name, List.Cons(apply, args)

        member _.RecoveryVaultName((name, args), recoveryVaultName) =
            let apply (args: ReplicatedVMArgs) =
                args.RecoveryVaultName <- io recoveryVaultName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ReplicatedVMArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ReplicatedVMArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sourceRecoveryFabricName")>]
        member _.SourceRecoveryFabricName((name, args), sourceRecoveryFabricName) =
            let apply (args: ReplicatedVMArgs) =
                args.SourceRecoveryFabricName <- input sourceRecoveryFabricName
                args

            ()
            name, List.Cons(apply, args)

        member _.SourceRecoveryFabricName((name, args), sourceRecoveryFabricName) =
            let apply (args: ReplicatedVMArgs) =
                args.SourceRecoveryFabricName <- io sourceRecoveryFabricName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sourceRecoveryProtectionContainerName")>]
        member _.SourceRecoveryProtectionContainerName((name, args), sourceRecoveryProtectionContainerName) =
            let apply (args: ReplicatedVMArgs) =
                args.SourceRecoveryProtectionContainerName <- input sourceRecoveryProtectionContainerName
                args

            ()
            name, List.Cons(apply, args)

        member _.SourceRecoveryProtectionContainerName((name, args), sourceRecoveryProtectionContainerName) =
            let apply (args: ReplicatedVMArgs) =
                args.SourceRecoveryProtectionContainerName <- io sourceRecoveryProtectionContainerName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sourceVmId")>]
        member _.SourceVmId((name, args), sourceVmId) =
            let apply (args: ReplicatedVMArgs) =
                args.SourceVmId <- input sourceVmId
                args

            ()
            name, List.Cons(apply, args)

        member _.SourceVmId((name, args), sourceVmId) =
            let apply (args: ReplicatedVMArgs) =
                args.SourceVmId <- io sourceVmId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("targetAvailabilitySetId")>]
        member _.TargetAvailabilitySetId((name, args), targetAvailabilitySetId) =
            let apply (args: ReplicatedVMArgs) =
                args.TargetAvailabilitySetId <- input targetAvailabilitySetId
                args

            ()
            name, List.Cons(apply, args)

        member _.TargetAvailabilitySetId((name, args), targetAvailabilitySetId) =
            let apply (args: ReplicatedVMArgs) =
                args.TargetAvailabilitySetId <- io targetAvailabilitySetId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("targetRecoveryFabricId")>]
        member _.TargetRecoveryFabricId((name, args), targetRecoveryFabricId) =
            let apply (args: ReplicatedVMArgs) =
                args.TargetRecoveryFabricId <- input targetRecoveryFabricId
                args

            ()
            name, List.Cons(apply, args)

        member _.TargetRecoveryFabricId((name, args), targetRecoveryFabricId) =
            let apply (args: ReplicatedVMArgs) =
                args.TargetRecoveryFabricId <- io targetRecoveryFabricId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("targetRecoveryProtectionContainerId")>]
        member _.TargetRecoveryProtectionContainerId((name, args), targetRecoveryProtectionContainerId) =
            let apply (args: ReplicatedVMArgs) =
                args.TargetRecoveryProtectionContainerId <- input targetRecoveryProtectionContainerId
                args

            ()
            name, List.Cons(apply, args)

        member _.TargetRecoveryProtectionContainerId((name, args), targetRecoveryProtectionContainerId) =
            let apply (args: ReplicatedVMArgs) =
                args.TargetRecoveryProtectionContainerId <- io targetRecoveryProtectionContainerId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("targetResourceGroupId")>]
        member _.TargetResourceGroupId((name, args), targetResourceGroupId) =
            let apply (args: ReplicatedVMArgs) =
                args.TargetResourceGroupId <- input targetResourceGroupId
                args

            ()
            name, List.Cons(apply, args)

        member _.TargetResourceGroupId((name, args), targetResourceGroupId) =
            let apply (args: ReplicatedVMArgs) =
                args.TargetResourceGroupId <- io targetResourceGroupId
                args

            ()
            name, List.Cons(apply, args)

    let replicatedVM = ReplicatedVMBuilder()

    type ReplicationPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ReplicationPolicy(name, (List.fold func (ReplicationPolicyArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("applicationConsistentSnapshotFrequencyInMinutes")>]
        member _.ApplicationConsistentSnapshotFrequencyInMinutes(
            (name, args),
            applicationConsistentSnapshotFrequencyInMinutes)
            =

            let apply (args: ReplicationPolicyArgs) =
                args.ApplicationConsistentSnapshotFrequencyInMinutes <- input
                                                                            applicationConsistentSnapshotFrequencyInMinutes
                args

            ()
            name, List.Cons(apply, args)

        member _.ApplicationConsistentSnapshotFrequencyInMinutes(
            (name, args),
            applicationConsistentSnapshotFrequencyInMinutes)
            =

            let apply (args: ReplicationPolicyArgs) =
                args.ApplicationConsistentSnapshotFrequencyInMinutes <- io
                                                                            applicationConsistentSnapshotFrequencyInMinutes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ReplicationPolicyArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ReplicationPolicyArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("recoveryPointRetentionInMinutes")>]
        member _.RecoveryPointRetentionInMinutes((name, args), recoveryPointRetentionInMinutes) =
            let apply (args: ReplicationPolicyArgs) =
                args.RecoveryPointRetentionInMinutes <- input recoveryPointRetentionInMinutes
                args

            ()
            name, List.Cons(apply, args)

        member _.RecoveryPointRetentionInMinutes((name, args), recoveryPointRetentionInMinutes) =
            let apply (args: ReplicationPolicyArgs) =
                args.RecoveryPointRetentionInMinutes <- io recoveryPointRetentionInMinutes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("recoveryVaultName")>]
        member _.RecoveryVaultName((name, args), recoveryVaultName) =
            let apply (args: ReplicationPolicyArgs) =
                args.RecoveryVaultName <- input recoveryVaultName
                args

            ()
            name, List.Cons(apply, args)

        member _.RecoveryVaultName((name, args), recoveryVaultName) =
            let apply (args: ReplicationPolicyArgs) =
                args.RecoveryVaultName <- io recoveryVaultName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ReplicationPolicyArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ReplicationPolicyArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

    let replicationPolicy = ReplicationPolicyBuilder()

module Sql =
    open Pulumi.Azure.Sql
    open Pulumi.Azure.Sql.Inputs

    type DatabaseExtendedAuditingPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (DatabaseExtendedAuditingPolicyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("retentionInDays")>]
        member _.RetentionInDays((n, args), retentionInDays) =
            let apply (args: DatabaseExtendedAuditingPolicyArgs) =
                args.RetentionInDays <- input retentionInDays
                args

            ()
            n, List.Cons(apply, args)

        member _.RetentionInDays((n, args), retentionInDays) =
            let apply (args: DatabaseExtendedAuditingPolicyArgs) =
                args.RetentionInDays <- io retentionInDays
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageAccountAccessKey")>]
        member _.StorageAccountAccessKey((n, args), storageAccountAccessKey) =
            let apply (args: DatabaseExtendedAuditingPolicyArgs) =
                args.StorageAccountAccessKey <- input storageAccountAccessKey
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountAccessKey((n, args), storageAccountAccessKey) =
            let apply (args: DatabaseExtendedAuditingPolicyArgs) =
                args.StorageAccountAccessKey <- io storageAccountAccessKey
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageAccountAccessKeyIsSecondary")>]
        member _.StorageAccountAccessKeyIsSecondary((n, args), storageAccountAccessKeyIsSecondary) =
            let apply (args: DatabaseExtendedAuditingPolicyArgs) =
                args.StorageAccountAccessKeyIsSecondary <- input storageAccountAccessKeyIsSecondary
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountAccessKeyIsSecondary((n, args), storageAccountAccessKeyIsSecondary) =
            let apply (args: DatabaseExtendedAuditingPolicyArgs) =
                args.StorageAccountAccessKeyIsSecondary <- io storageAccountAccessKeyIsSecondary
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageEndpoint")>]
        member _.StorageEndpoint((n, args), storageEndpoint) =
            let apply (args: DatabaseExtendedAuditingPolicyArgs) =
                args.StorageEndpoint <- input storageEndpoint
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageEndpoint((n, args), storageEndpoint) =
            let apply (args: DatabaseExtendedAuditingPolicyArgs) =
                args.StorageEndpoint <- io storageEndpoint
                args

            ()
            n, List.Cons(apply, args)

    let databaseExtendedAuditingPolicy = DatabaseExtendedAuditingPolicyBuilder()

    type DatabaseImportBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (DatabaseImportArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("administratorLogin")>]
        member _.AdministratorLogin((n, args), administratorLogin) =
            let apply (args: DatabaseImportArgs) =
                args.AdministratorLogin <- input administratorLogin
                args

            ()
            n, List.Cons(apply, args)

        member _.AdministratorLogin((n, args), administratorLogin) =
            let apply (args: DatabaseImportArgs) =
                args.AdministratorLogin <- io administratorLogin
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("administratorLoginPassword")>]
        member _.AdministratorLoginPassword((n, args), administratorLoginPassword) =
            let apply (args: DatabaseImportArgs) =
                args.AdministratorLoginPassword <- input administratorLoginPassword
                args

            ()
            n, List.Cons(apply, args)

        member _.AdministratorLoginPassword((n, args), administratorLoginPassword) =
            let apply (args: DatabaseImportArgs) =
                args.AdministratorLoginPassword <- io administratorLoginPassword
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("authenticationType")>]
        member _.AuthenticationType((n, args), authenticationType) =
            let apply (args: DatabaseImportArgs) =
                args.AuthenticationType <- input authenticationType
                args

            ()
            n, List.Cons(apply, args)

        member _.AuthenticationType((n, args), authenticationType) =
            let apply (args: DatabaseImportArgs) =
                args.AuthenticationType <- io authenticationType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("operationMode")>]
        member _.OperationMode((n, args), operationMode) =
            let apply (args: DatabaseImportArgs) =
                args.OperationMode <- input operationMode
                args

            ()
            n, List.Cons(apply, args)

        member _.OperationMode((n, args), operationMode) =
            let apply (args: DatabaseImportArgs) =
                args.OperationMode <- io operationMode
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageKey")>]
        member _.StorageKey((n, args), storageKey) =
            let apply (args: DatabaseImportArgs) =
                args.StorageKey <- input storageKey
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageKey((n, args), storageKey) =
            let apply (args: DatabaseImportArgs) =
                args.StorageKey <- io storageKey
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageKeyType")>]
        member _.StorageKeyType((n, args), storageKeyType) =
            let apply (args: DatabaseImportArgs) =
                args.StorageKeyType <- input storageKeyType
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageKeyType((n, args), storageKeyType) =
            let apply (args: DatabaseImportArgs) =
                args.StorageKeyType <- io storageKeyType
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageUri")>]
        member _.StorageUri((n, args), storageUri) =
            let apply (args: DatabaseImportArgs) =
                args.StorageUri <- input storageUri
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageUri((n, args), storageUri) =
            let apply (args: DatabaseImportArgs) =
                args.StorageUri <- io storageUri
                args

            ()
            n, List.Cons(apply, args)

    let databaseImport = DatabaseImportBuilder()

    type DatabaseThreatDetectionPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (DatabaseThreatDetectionPolicyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("disabledAlerts")>]
        member _.DisabledAlerts((n, args), disabledAlerts) =
            let apply (args: DatabaseThreatDetectionPolicyArgs) =
                args.DisabledAlerts <- inputList disabledAlerts
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("emailAccountAdmins")>]
        member _.EmailAccountAdmins((n, args), emailAccountAdmins) =
            let apply (args: DatabaseThreatDetectionPolicyArgs) =
                args.EmailAccountAdmins <- input emailAccountAdmins
                args

            ()
            n, List.Cons(apply, args)

        member _.EmailAccountAdmins((n, args), emailAccountAdmins) =
            let apply (args: DatabaseThreatDetectionPolicyArgs) =
                args.EmailAccountAdmins <- io emailAccountAdmins
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("emailAddresses")>]
        member _.EmailAddresses((n, args), emailAddresses) =
            let apply (args: DatabaseThreatDetectionPolicyArgs) =
                args.EmailAddresses <- inputList emailAddresses
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("retentionDays")>]
        member _.RetentionDays((n, args), retentionDays) =
            let apply (args: DatabaseThreatDetectionPolicyArgs) =
                args.RetentionDays <- input retentionDays
                args

            ()
            n, List.Cons(apply, args)

        member _.RetentionDays((n, args), retentionDays) =
            let apply (args: DatabaseThreatDetectionPolicyArgs) =
                args.RetentionDays <- io retentionDays
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("state")>]
        member _.State((n, args), state) =
            let apply (args: DatabaseThreatDetectionPolicyArgs) =
                args.State <- input state
                args

            ()
            n, List.Cons(apply, args)

        member _.State((n, args), state) =
            let apply (args: DatabaseThreatDetectionPolicyArgs) =
                args.State <- io state
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageAccountAccessKey")>]
        member _.StorageAccountAccessKey((n, args), storageAccountAccessKey) =
            let apply (args: DatabaseThreatDetectionPolicyArgs) =
                args.StorageAccountAccessKey <- input storageAccountAccessKey
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountAccessKey((n, args), storageAccountAccessKey) =
            let apply (args: DatabaseThreatDetectionPolicyArgs) =
                args.StorageAccountAccessKey <- io storageAccountAccessKey
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageEndpoint")>]
        member _.StorageEndpoint((n, args), storageEndpoint) =
            let apply (args: DatabaseThreatDetectionPolicyArgs) =
                args.StorageEndpoint <- input storageEndpoint
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageEndpoint((n, args), storageEndpoint) =
            let apply (args: DatabaseThreatDetectionPolicyArgs) =
                args.StorageEndpoint <- io storageEndpoint
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("useServerDefault")>]
        member _.UseServerDefault((n, args), useServerDefault) =
            let apply (args: DatabaseThreatDetectionPolicyArgs) =
                args.UseServerDefault <- input useServerDefault
                args

            ()
            n, List.Cons(apply, args)

        member _.UseServerDefault((n, args), useServerDefault) =
            let apply (args: DatabaseThreatDetectionPolicyArgs) =
                args.UseServerDefault <- io useServerDefault
                args

            ()
            n, List.Cons(apply, args)

    let databaseThreatDetectionPolicy = DatabaseThreatDetectionPolicyBuilder()

    type FailoverGroupPartnerServerBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FailoverGroupPartnerServerArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: FailoverGroupPartnerServerArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: FailoverGroupPartnerServerArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((n, args), location) =
            let apply (args: FailoverGroupPartnerServerArgs) =
                args.Location <- input location
                args

            ()
            n, List.Cons(apply, args)

        member _.Location((n, args), location) =
            let apply (args: FailoverGroupPartnerServerArgs) =
                args.Location <- io location
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("role")>]
        member _.Role((n, args), role) =
            let apply (args: FailoverGroupPartnerServerArgs) =
                args.Role <- input role
                args

            ()
            n, List.Cons(apply, args)

        member _.Role((n, args), role) =
            let apply (args: FailoverGroupPartnerServerArgs) =
                args.Role <- io role
                args

            ()
            n, List.Cons(apply, args)

    let failoverGroupPartnerServer = FailoverGroupPartnerServerBuilder()

    type FailoverGroupReadWriteEndpointFailoverPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FailoverGroupReadWriteEndpointFailoverPolicyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("graceMinutes")>]
        member _.GraceMinutes((n, args), graceMinutes) =
            let apply (args: FailoverGroupReadWriteEndpointFailoverPolicyArgs) =
                args.GraceMinutes <- input graceMinutes
                args

            ()
            n, List.Cons(apply, args)

        member _.GraceMinutes((n, args), graceMinutes) =
            let apply (args: FailoverGroupReadWriteEndpointFailoverPolicyArgs) =
                args.GraceMinutes <- io graceMinutes
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("mode")>]
        member _.Mode((n, args), mode) =
            let apply (args: FailoverGroupReadWriteEndpointFailoverPolicyArgs) =
                args.Mode <- input mode
                args

            ()
            n, List.Cons(apply, args)

        member _.Mode((n, args), mode) =
            let apply (args: FailoverGroupReadWriteEndpointFailoverPolicyArgs) =
                args.Mode <- io mode
                args

            ()
            n, List.Cons(apply, args)

    let failoverGroupReadWriteEndpointFailoverPolicy =
        FailoverGroupReadWriteEndpointFailoverPolicyBuilder()

    type FailoverGroupReadonlyEndpointFailoverPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FailoverGroupReadonlyEndpointFailoverPolicyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("mode")>]
        member _.Mode((n, args), mode) =
            let apply (args: FailoverGroupReadonlyEndpointFailoverPolicyArgs) =
                args.Mode <- input mode
                args

            ()
            n, List.Cons(apply, args)

        member _.Mode((n, args), mode) =
            let apply (args: FailoverGroupReadonlyEndpointFailoverPolicyArgs) =
                args.Mode <- io mode
                args

            ()
            n, List.Cons(apply, args)

    let failoverGroupReadonlyEndpointFailoverPolicy =
        FailoverGroupReadonlyEndpointFailoverPolicyBuilder()

    type SqlServerExtendedAuditingPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SqlServerExtendedAuditingPolicyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("retentionInDays")>]
        member _.RetentionInDays((n, args), retentionInDays) =
            let apply (args: SqlServerExtendedAuditingPolicyArgs) =
                args.RetentionInDays <- input retentionInDays
                args

            ()
            n, List.Cons(apply, args)

        member _.RetentionInDays((n, args), retentionInDays) =
            let apply (args: SqlServerExtendedAuditingPolicyArgs) =
                args.RetentionInDays <- io retentionInDays
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageAccountAccessKey")>]
        member _.StorageAccountAccessKey((n, args), storageAccountAccessKey) =
            let apply (args: SqlServerExtendedAuditingPolicyArgs) =
                args.StorageAccountAccessKey <- input storageAccountAccessKey
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountAccessKey((n, args), storageAccountAccessKey) =
            let apply (args: SqlServerExtendedAuditingPolicyArgs) =
                args.StorageAccountAccessKey <- io storageAccountAccessKey
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageAccountAccessKeyIsSecondary")>]
        member _.StorageAccountAccessKeyIsSecondary((n, args), storageAccountAccessKeyIsSecondary) =
            let apply (args: SqlServerExtendedAuditingPolicyArgs) =
                args.StorageAccountAccessKeyIsSecondary <- input storageAccountAccessKeyIsSecondary
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageAccountAccessKeyIsSecondary((n, args), storageAccountAccessKeyIsSecondary) =
            let apply (args: SqlServerExtendedAuditingPolicyArgs) =
                args.StorageAccountAccessKeyIsSecondary <- io storageAccountAccessKeyIsSecondary
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("storageEndpoint")>]
        member _.StorageEndpoint((n, args), storageEndpoint) =
            let apply (args: SqlServerExtendedAuditingPolicyArgs) =
                args.StorageEndpoint <- input storageEndpoint
                args

            ()
            n, List.Cons(apply, args)

        member _.StorageEndpoint((n, args), storageEndpoint) =
            let apply (args: SqlServerExtendedAuditingPolicyArgs) =
                args.StorageEndpoint <- io storageEndpoint
                args

            ()
            n, List.Cons(apply, args)

    let sqlServerExtendedAuditingPolicy = SqlServerExtendedAuditingPolicyBuilder()

    type SqlServerIdentityBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (SqlServerIdentityArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("principalId")>]
        member _.PrincipalId((n, args), principalId) =
            let apply (args: SqlServerIdentityArgs) =
                args.PrincipalId <- input principalId
                args

            ()
            n, List.Cons(apply, args)

        member _.PrincipalId((n, args), principalId) =
            let apply (args: SqlServerIdentityArgs) =
                args.PrincipalId <- io principalId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tenantId")>]
        member _.TenantId((n, args), tenantId) =
            let apply (args: SqlServerIdentityArgs) =
                args.TenantId <- input tenantId
                args

            ()
            n, List.Cons(apply, args)

        member _.TenantId((n, args), tenantId) =
            let apply (args: SqlServerIdentityArgs) =
                args.TenantId <- io tenantId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: SqlServerIdentityArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: SqlServerIdentityArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let sqlServerIdentity = SqlServerIdentityBuilder()

    type ActiveDirectoryAdministratorBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ActiveDirectoryAdministrator(name, (List.fold func (ActiveDirectoryAdministratorArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("login")>]
        member _.Login((name, args), login) =
            let apply (args: ActiveDirectoryAdministratorArgs) =
                args.Login <- input login
                args

            ()
            name, List.Cons(apply, args)

        member _.Login((name, args), login) =
            let apply (args: ActiveDirectoryAdministratorArgs) =
                args.Login <- io login
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("objectId")>]
        member _.ObjectId((name, args), objectId) =
            let apply (args: ActiveDirectoryAdministratorArgs) =
                args.ObjectId <- input objectId
                args

            ()
            name, List.Cons(apply, args)

        member _.ObjectId((name, args), objectId) =
            let apply (args: ActiveDirectoryAdministratorArgs) =
                args.ObjectId <- io objectId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ActiveDirectoryAdministratorArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ActiveDirectoryAdministratorArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serverName")>]
        member _.ServerName((name, args), serverName) =
            let apply (args: ActiveDirectoryAdministratorArgs) =
                args.ServerName <- input serverName
                args

            ()
            name, List.Cons(apply, args)

        member _.ServerName((name, args), serverName) =
            let apply (args: ActiveDirectoryAdministratorArgs) =
                args.ServerName <- io serverName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tenantId")>]
        member _.TenantId((name, args), tenantId) =
            let apply (args: ActiveDirectoryAdministratorArgs) =
                args.TenantId <- input tenantId
                args

            ()
            name, List.Cons(apply, args)

        member _.TenantId((name, args), tenantId) =
            let apply (args: ActiveDirectoryAdministratorArgs) =
                args.TenantId <- io tenantId
                args

            ()
            name, List.Cons(apply, args)

    let activeDirectoryAdministrator = ActiveDirectoryAdministratorBuilder()

    type DatabaseBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Database(name, (List.fold func (DatabaseArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("collation")>]
        member _.Collation((name, args), collation) =
            let apply (args: DatabaseArgs) =
                args.Collation <- input collation
                args

            ()
            name, List.Cons(apply, args)

        member _.Collation((name, args), collation) =
            let apply (args: DatabaseArgs) =
                args.Collation <- io collation
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("createMode")>]
        member _.CreateMode((name, args), createMode) =
            let apply (args: DatabaseArgs) =
                args.CreateMode <- input createMode
                args

            ()
            name, List.Cons(apply, args)

        member _.CreateMode((name, args), createMode) =
            let apply (args: DatabaseArgs) =
                args.CreateMode <- io createMode
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("edition")>]
        member _.Edition((name, args), edition) =
            let apply (args: DatabaseArgs) =
                args.Edition <- input edition
                args

            ()
            name, List.Cons(apply, args)

        member _.Edition((name, args), edition) =
            let apply (args: DatabaseArgs) =
                args.Edition <- io edition
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("elasticPoolName")>]
        member _.ElasticPoolName((name, args), elasticPoolName) =
            let apply (args: DatabaseArgs) =
                args.ElasticPoolName <- input elasticPoolName
                args

            ()
            name, List.Cons(apply, args)

        member _.ElasticPoolName((name, args), elasticPoolName) =
            let apply (args: DatabaseArgs) =
                args.ElasticPoolName <- io elasticPoolName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: DatabaseArgs) =
                   args.ExtendedAuditingPolicy <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: DatabaseArgs) =
                   args.Import <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: DatabaseArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: DatabaseArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("maxSizeBytes")>]
        member _.MaxSizeBytes((name, args), maxSizeBytes) =
            let apply (args: DatabaseArgs) =
                args.MaxSizeBytes <- input maxSizeBytes
                args

            ()
            name, List.Cons(apply, args)

        member _.MaxSizeBytes((name, args), maxSizeBytes) =
            let apply (args: DatabaseArgs) =
                args.MaxSizeBytes <- io maxSizeBytes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("maxSizeGb")>]
        member _.MaxSizeGb((name, args), maxSizeGb) =
            let apply (args: DatabaseArgs) =
                args.MaxSizeGb <- input maxSizeGb
                args

            ()
            name, List.Cons(apply, args)

        member _.MaxSizeGb((name, args), maxSizeGb) =
            let apply (args: DatabaseArgs) =
                args.MaxSizeGb <- io maxSizeGb
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: DatabaseArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: DatabaseArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("readScale")>]
        member _.ReadScale((name, args), readScale) =
            let apply (args: DatabaseArgs) =
                args.ReadScale <- input readScale
                args

            ()
            name, List.Cons(apply, args)

        member _.ReadScale((name, args), readScale) =
            let apply (args: DatabaseArgs) =
                args.ReadScale <- io readScale
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("requestedServiceObjectiveId")>]
        member _.RequestedServiceObjectiveId((name, args), requestedServiceObjectiveId) =
            let apply (args: DatabaseArgs) =
                args.RequestedServiceObjectiveId <- input requestedServiceObjectiveId
                args

            ()
            name, List.Cons(apply, args)

        member _.RequestedServiceObjectiveId((name, args), requestedServiceObjectiveId) =
            let apply (args: DatabaseArgs) =
                args.RequestedServiceObjectiveId <- io requestedServiceObjectiveId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("requestedServiceObjectiveName")>]
        member _.RequestedServiceObjectiveName((name, args), requestedServiceObjectiveName) =
            let apply (args: DatabaseArgs) =
                args.RequestedServiceObjectiveName <- input requestedServiceObjectiveName
                args

            ()
            name, List.Cons(apply, args)

        member _.RequestedServiceObjectiveName((name, args), requestedServiceObjectiveName) =
            let apply (args: DatabaseArgs) =
                args.RequestedServiceObjectiveName <- io requestedServiceObjectiveName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DatabaseArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DatabaseArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("restorePointInTime")>]
        member _.RestorePointInTime((name, args), restorePointInTime) =
            let apply (args: DatabaseArgs) =
                args.RestorePointInTime <- input restorePointInTime
                args

            ()
            name, List.Cons(apply, args)

        member _.RestorePointInTime((name, args), restorePointInTime) =
            let apply (args: DatabaseArgs) =
                args.RestorePointInTime <- io restorePointInTime
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serverName")>]
        member _.ServerName((name, args), serverName) =
            let apply (args: DatabaseArgs) =
                args.ServerName <- input serverName
                args

            ()
            name, List.Cons(apply, args)

        member _.ServerName((name, args), serverName) =
            let apply (args: DatabaseArgs) =
                args.ServerName <- io serverName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sourceDatabaseDeletionDate")>]
        member _.SourceDatabaseDeletionDate((name, args), sourceDatabaseDeletionDate) =
            let apply (args: DatabaseArgs) =
                args.SourceDatabaseDeletionDate <- input sourceDatabaseDeletionDate
                args

            ()
            name, List.Cons(apply, args)

        member _.SourceDatabaseDeletionDate((name, args), sourceDatabaseDeletionDate) =
            let apply (args: DatabaseArgs) =
                args.SourceDatabaseDeletionDate <- io sourceDatabaseDeletionDate
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sourceDatabaseId")>]
        member _.SourceDatabaseId((name, args), sourceDatabaseId) =
            let apply (args: DatabaseArgs) =
                args.SourceDatabaseId <- input sourceDatabaseId
                args

            ()
            name, List.Cons(apply, args)

        member _.SourceDatabaseId((name, args), sourceDatabaseId) =
            let apply (args: DatabaseArgs) =
                args.SourceDatabaseId <- io sourceDatabaseId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: DatabaseArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: DatabaseArgs) =
                   args.ThreatDetectionPolicy <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("zoneRedundant")>]
        member _.ZoneRedundant((name, args), zoneRedundant) =
            let apply (args: DatabaseArgs) =
                args.ZoneRedundant <- input zoneRedundant
                args

            ()
            name, List.Cons(apply, args)

        member _.ZoneRedundant((name, args), zoneRedundant) =
            let apply (args: DatabaseArgs) =
                args.ZoneRedundant <- io zoneRedundant
                args

            ()
            name, List.Cons(apply, args)

    let database = DatabaseBuilder()

    type ElasticPoolBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ElasticPool(name, (List.fold func (ElasticPoolArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("dbDtuMax")>]
        member _.DbDtuMax((name, args), dbDtuMax) =
            let apply (args: ElasticPoolArgs) =
                args.DbDtuMax <- input dbDtuMax
                args

            ()
            name, List.Cons(apply, args)

        member _.DbDtuMax((name, args), dbDtuMax) =
            let apply (args: ElasticPoolArgs) =
                args.DbDtuMax <- io dbDtuMax
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("dbDtuMin")>]
        member _.DbDtuMin((name, args), dbDtuMin) =
            let apply (args: ElasticPoolArgs) =
                args.DbDtuMin <- input dbDtuMin
                args

            ()
            name, List.Cons(apply, args)

        member _.DbDtuMin((name, args), dbDtuMin) =
            let apply (args: ElasticPoolArgs) =
                args.DbDtuMin <- io dbDtuMin
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("dtu")>]
        member _.Dtu((name, args), dtu) =
            let apply (args: ElasticPoolArgs) =
                args.Dtu <- input dtu
                args

            ()
            name, List.Cons(apply, args)

        member _.Dtu((name, args), dtu) =
            let apply (args: ElasticPoolArgs) =
                args.Dtu <- io dtu
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("edition")>]
        member _.Edition((name, args), edition) =
            let apply (args: ElasticPoolArgs) =
                args.Edition <- input edition
                args

            ()
            name, List.Cons(apply, args)

        member _.Edition((name, args), edition) =
            let apply (args: ElasticPoolArgs) =
                args.Edition <- io edition
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ElasticPoolArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ElasticPoolArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ElasticPoolArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ElasticPoolArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("poolSize")>]
        member _.PoolSize((name, args), poolSize) =
            let apply (args: ElasticPoolArgs) =
                args.PoolSize <- input poolSize
                args

            ()
            name, List.Cons(apply, args)

        member _.PoolSize((name, args), poolSize) =
            let apply (args: ElasticPoolArgs) =
                args.PoolSize <- io poolSize
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ElasticPoolArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ElasticPoolArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serverName")>]
        member _.ServerName((name, args), serverName) =
            let apply (args: ElasticPoolArgs) =
                args.ServerName <- input serverName
                args

            ()
            name, List.Cons(apply, args)

        member _.ServerName((name, args), serverName) =
            let apply (args: ElasticPoolArgs) =
                args.ServerName <- io serverName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ElasticPoolArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let elasticPool = ElasticPoolBuilder()

    type FailoverGroupBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            FailoverGroup(name, (List.fold func (FailoverGroupArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("databases")>]
        member _.Databases((name, args), databases) =
            let apply (args: FailoverGroupArgs) =
                args.Databases <- inputList databases
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: FailoverGroupArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: FailoverGroupArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("partnerServers")>]
        member _.PartnerServers((name, args), partnerServers) =
            let apply (args: FailoverGroupArgs) =
                args.PartnerServers <- inputList partnerServers
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: FailoverGroupArgs) =
                   args.ReadWriteEndpointFailoverPolicy <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: FailoverGroupArgs) =
                   args.ReadonlyEndpointFailoverPolicy <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FailoverGroupArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FailoverGroupArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serverName")>]
        member _.ServerName((name, args), serverName) =
            let apply (args: FailoverGroupArgs) =
                args.ServerName <- input serverName
                args

            ()
            name, List.Cons(apply, args)

        member _.ServerName((name, args), serverName) =
            let apply (args: FailoverGroupArgs) =
                args.ServerName <- io serverName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: FailoverGroupArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let failoverGroup = FailoverGroupBuilder()

    type FirewallRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            FirewallRule(name, (List.fold func (FirewallRuleArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("endIpAddress")>]
        member _.EndIpAddress((name, args), endIpAddress) =
            let apply (args: FirewallRuleArgs) =
                args.EndIpAddress <- input endIpAddress
                args

            ()
            name, List.Cons(apply, args)

        member _.EndIpAddress((name, args), endIpAddress) =
            let apply (args: FirewallRuleArgs) =
                args.EndIpAddress <- io endIpAddress
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: FirewallRuleArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: FirewallRuleArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FirewallRuleArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FirewallRuleArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serverName")>]
        member _.ServerName((name, args), serverName) =
            let apply (args: FirewallRuleArgs) =
                args.ServerName <- input serverName
                args

            ()
            name, List.Cons(apply, args)

        member _.ServerName((name, args), serverName) =
            let apply (args: FirewallRuleArgs) =
                args.ServerName <- io serverName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("startIpAddress")>]
        member _.StartIpAddress((name, args), startIpAddress) =
            let apply (args: FirewallRuleArgs) =
                args.StartIpAddress <- input startIpAddress
                args

            ()
            name, List.Cons(apply, args)

        member _.StartIpAddress((name, args), startIpAddress) =
            let apply (args: FirewallRuleArgs) =
                args.StartIpAddress <- io startIpAddress
                args

            ()
            name, List.Cons(apply, args)

    let firewallRule = FirewallRuleBuilder()

    type SqlServerBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            SqlServer(name, (List.fold func (SqlServerArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("administratorLogin")>]
        member _.AdministratorLogin((name, args), administratorLogin) =
            let apply (args: SqlServerArgs) =
                args.AdministratorLogin <- input administratorLogin
                args

            ()
            name, List.Cons(apply, args)

        member _.AdministratorLogin((name, args), administratorLogin) =
            let apply (args: SqlServerArgs) =
                args.AdministratorLogin <- io administratorLogin
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("administratorLoginPassword")>]
        member _.AdministratorLoginPassword((name, args), administratorLoginPassword) =
            let apply (args: SqlServerArgs) =
                args.AdministratorLoginPassword <- input administratorLoginPassword
                args

            ()
            name, List.Cons(apply, args)

        member _.AdministratorLoginPassword((name, args), administratorLoginPassword) =
            let apply (args: SqlServerArgs) =
                args.AdministratorLoginPassword <- io administratorLoginPassword
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("connectionPolicy")>]
        member _.ConnectionPolicy((name, args), connectionPolicy) =
            let apply (args: SqlServerArgs) =
                args.ConnectionPolicy <- input connectionPolicy
                args

            ()
            name, List.Cons(apply, args)

        member _.ConnectionPolicy((name, args), connectionPolicy) =
            let apply (args: SqlServerArgs) =
                args.ConnectionPolicy <- io connectionPolicy
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: SqlServerArgs) =
                   args.ExtendedAuditingPolicy <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: SqlServerArgs) =
                   args.Identity <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: SqlServerArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: SqlServerArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: SqlServerArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: SqlServerArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SqlServerArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SqlServerArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: SqlServerArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("version")>]
        member _.Version((name, args), version) =
            let apply (args: SqlServerArgs) =
                args.Version <- input version
                args

            ()
            name, List.Cons(apply, args)

        member _.Version((name, args), version) =
            let apply (args: SqlServerArgs) =
                args.Version <- io version
                args

            ()
            name, List.Cons(apply, args)

    let sqlServer = SqlServerBuilder()

    type VirtualNetworkRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            VirtualNetworkRule(name, (List.fold func (VirtualNetworkRuleArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("ignoreMissingVnetServiceEndpoint")>]
        member _.IgnoreMissingVnetServiceEndpoint((name, args), ignoreMissingVnetServiceEndpoint) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.IgnoreMissingVnetServiceEndpoint <- input ignoreMissingVnetServiceEndpoint
                args

            ()
            name, List.Cons(apply, args)

        member _.IgnoreMissingVnetServiceEndpoint((name, args), ignoreMissingVnetServiceEndpoint) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.IgnoreMissingVnetServiceEndpoint <- io ignoreMissingVnetServiceEndpoint
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serverName")>]
        member _.ServerName((name, args), serverName) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.ServerName <- input serverName
                args

            ()
            name, List.Cons(apply, args)

        member _.ServerName((name, args), serverName) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.ServerName <- io serverName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((name, args), subnetId) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            name, List.Cons(apply, args)

        member _.SubnetId((name, args), subnetId) =
            let apply (args: VirtualNetworkRuleArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            name, List.Cons(apply, args)

    let virtualNetworkRule = VirtualNetworkRuleBuilder()

module Storage =
    open Pulumi.Azure.Storage
    open Pulumi.Azure.Storage.Inputs

    type AccountBlobPropertiesBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AccountBlobPropertiesArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("corsRules")>]
        member _.CorsRules((n, args), corsRules) =
            let apply (args: AccountBlobPropertiesArgs) =
                args.CorsRules <- inputList corsRules
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: AccountBlobPropertiesArgs) =
                   args.DeleteRetentionPolicy <- input arg
                   args

               ()
               func) ]

    let accountBlobProperties = AccountBlobPropertiesBuilder()

    type AccountBlobPropertiesCorsRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AccountBlobPropertiesCorsRuleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("allowedHeaders")>]
        member _.AllowedHeaders((n, args), allowedHeaders) =
            let apply (args: AccountBlobPropertiesCorsRuleArgs) =
                args.AllowedHeaders <- inputList allowedHeaders
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("allowedMethods")>]
        member _.AllowedMethods((n, args), allowedMethods) =
            let apply (args: AccountBlobPropertiesCorsRuleArgs) =
                args.AllowedMethods <- inputList allowedMethods
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("allowedOrigins")>]
        member _.AllowedOrigins((n, args), allowedOrigins) =
            let apply (args: AccountBlobPropertiesCorsRuleArgs) =
                args.AllowedOrigins <- inputList allowedOrigins
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("exposedHeaders")>]
        member _.ExposedHeaders((n, args), exposedHeaders) =
            let apply (args: AccountBlobPropertiesCorsRuleArgs) =
                args.ExposedHeaders <- inputList exposedHeaders
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("maxAgeInSeconds")>]
        member _.MaxAgeInSeconds((n, args), maxAgeInSeconds) =
            let apply (args: AccountBlobPropertiesCorsRuleArgs) =
                args.MaxAgeInSeconds <- input maxAgeInSeconds
                args

            ()
            n, List.Cons(apply, args)

        member _.MaxAgeInSeconds((n, args), maxAgeInSeconds) =
            let apply (args: AccountBlobPropertiesCorsRuleArgs) =
                args.MaxAgeInSeconds <- io maxAgeInSeconds
                args

            ()
            n, List.Cons(apply, args)

    let accountBlobPropertiesCorsRule = AccountBlobPropertiesCorsRuleBuilder()

    type AccountBlobPropertiesDeleteRetentionPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AccountBlobPropertiesDeleteRetentionPolicyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("days")>]
        member _.Days((n, args), days) =
            let apply (args: AccountBlobPropertiesDeleteRetentionPolicyArgs) =
                args.Days <- input days
                args

            ()
            n, List.Cons(apply, args)

        member _.Days((n, args), days) =
            let apply (args: AccountBlobPropertiesDeleteRetentionPolicyArgs) =
                args.Days <- io days
                args

            ()
            n, List.Cons(apply, args)

    let accountBlobPropertiesDeleteRetentionPolicy =
        AccountBlobPropertiesDeleteRetentionPolicyBuilder()

    type AccountCustomDomainBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AccountCustomDomainArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: AccountCustomDomainArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: AccountCustomDomainArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("useSubdomain")>]
        member _.UseSubdomain((n, args), useSubdomain) =
            let apply (args: AccountCustomDomainArgs) =
                args.UseSubdomain <- input useSubdomain
                args

            ()
            n, List.Cons(apply, args)

        member _.UseSubdomain((n, args), useSubdomain) =
            let apply (args: AccountCustomDomainArgs) =
                args.UseSubdomain <- io useSubdomain
                args

            ()
            n, List.Cons(apply, args)

    let accountCustomDomain = AccountCustomDomainBuilder()

    type AccountIdentityBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AccountIdentityArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("principalId")>]
        member _.PrincipalId((n, args), principalId) =
            let apply (args: AccountIdentityArgs) =
                args.PrincipalId <- input principalId
                args

            ()
            n, List.Cons(apply, args)

        member _.PrincipalId((n, args), principalId) =
            let apply (args: AccountIdentityArgs) =
                args.PrincipalId <- io principalId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tenantId")>]
        member _.TenantId((n, args), tenantId) =
            let apply (args: AccountIdentityArgs) =
                args.TenantId <- input tenantId
                args

            ()
            n, List.Cons(apply, args)

        member _.TenantId((n, args), tenantId) =
            let apply (args: AccountIdentityArgs) =
                args.TenantId <- io tenantId
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: AccountIdentityArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: AccountIdentityArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let accountIdentity = AccountIdentityBuilder()

    type AccountQueuePropertiesBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AccountQueuePropertiesArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("corsRules")>]
        member _.CorsRules((n, args), corsRules) =
            let apply (args: AccountQueuePropertiesArgs) =
                args.CorsRules <- inputList corsRules
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: AccountQueuePropertiesArgs) =
                   args.HourMetrics <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: AccountQueuePropertiesArgs) =
                   args.Logging <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: AccountQueuePropertiesArgs) =
                   args.MinuteMetrics <- input arg
                   args

               ()
               func) ]

    let accountQueueProperties = AccountQueuePropertiesBuilder()

    type AccountQueuePropertiesCorsRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AccountQueuePropertiesCorsRuleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("allowedHeaders")>]
        member _.AllowedHeaders((n, args), allowedHeaders) =
            let apply (args: AccountQueuePropertiesCorsRuleArgs) =
                args.AllowedHeaders <- inputList allowedHeaders
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("allowedMethods")>]
        member _.AllowedMethods((n, args), allowedMethods) =
            let apply (args: AccountQueuePropertiesCorsRuleArgs) =
                args.AllowedMethods <- inputList allowedMethods
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("allowedOrigins")>]
        member _.AllowedOrigins((n, args), allowedOrigins) =
            let apply (args: AccountQueuePropertiesCorsRuleArgs) =
                args.AllowedOrigins <- inputList allowedOrigins
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("exposedHeaders")>]
        member _.ExposedHeaders((n, args), exposedHeaders) =
            let apply (args: AccountQueuePropertiesCorsRuleArgs) =
                args.ExposedHeaders <- inputList exposedHeaders
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("maxAgeInSeconds")>]
        member _.MaxAgeInSeconds((n, args), maxAgeInSeconds) =
            let apply (args: AccountQueuePropertiesCorsRuleArgs) =
                args.MaxAgeInSeconds <- input maxAgeInSeconds
                args

            ()
            n, List.Cons(apply, args)

        member _.MaxAgeInSeconds((n, args), maxAgeInSeconds) =
            let apply (args: AccountQueuePropertiesCorsRuleArgs) =
                args.MaxAgeInSeconds <- io maxAgeInSeconds
                args

            ()
            n, List.Cons(apply, args)

    let accountQueuePropertiesCorsRule = AccountQueuePropertiesCorsRuleBuilder()

    type AccountQueuePropertiesHourMetricsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AccountQueuePropertiesHourMetricsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: AccountQueuePropertiesHourMetricsArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: AccountQueuePropertiesHourMetricsArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("includeApis")>]
        member _.IncludeApis((n, args), includeApis) =
            let apply (args: AccountQueuePropertiesHourMetricsArgs) =
                args.IncludeApis <- input includeApis
                args

            ()
            n, List.Cons(apply, args)

        member _.IncludeApis((n, args), includeApis) =
            let apply (args: AccountQueuePropertiesHourMetricsArgs) =
                args.IncludeApis <- io includeApis
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("retentionPolicyDays")>]
        member _.RetentionPolicyDays((n, args), retentionPolicyDays) =
            let apply (args: AccountQueuePropertiesHourMetricsArgs) =
                args.RetentionPolicyDays <- input retentionPolicyDays
                args

            ()
            n, List.Cons(apply, args)

        member _.RetentionPolicyDays((n, args), retentionPolicyDays) =
            let apply (args: AccountQueuePropertiesHourMetricsArgs) =
                args.RetentionPolicyDays <- io retentionPolicyDays
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("version")>]
        member _.Version((n, args), version) =
            let apply (args: AccountQueuePropertiesHourMetricsArgs) =
                args.Version <- input version
                args

            ()
            n, List.Cons(apply, args)

        member _.Version((n, args), version) =
            let apply (args: AccountQueuePropertiesHourMetricsArgs) =
                args.Version <- io version
                args

            ()
            n, List.Cons(apply, args)

    let accountQueuePropertiesHourMetrics =
        AccountQueuePropertiesHourMetricsBuilder()

    type AccountQueuePropertiesLoggingBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AccountQueuePropertiesLoggingArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("delete")>]
        member _.Delete((n, args), delete) =
            let apply (args: AccountQueuePropertiesLoggingArgs) =
                args.Delete <- input delete
                args

            ()
            n, List.Cons(apply, args)

        member _.Delete((n, args), delete) =
            let apply (args: AccountQueuePropertiesLoggingArgs) =
                args.Delete <- io delete
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("read")>]
        member _.Read((n, args), read) =
            let apply (args: AccountQueuePropertiesLoggingArgs) =
                args.Read <- input read
                args

            ()
            n, List.Cons(apply, args)

        member _.Read((n, args), read) =
            let apply (args: AccountQueuePropertiesLoggingArgs) =
                args.Read <- io read
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("retentionPolicyDays")>]
        member _.RetentionPolicyDays((n, args), retentionPolicyDays) =
            let apply (args: AccountQueuePropertiesLoggingArgs) =
                args.RetentionPolicyDays <- input retentionPolicyDays
                args

            ()
            n, List.Cons(apply, args)

        member _.RetentionPolicyDays((n, args), retentionPolicyDays) =
            let apply (args: AccountQueuePropertiesLoggingArgs) =
                args.RetentionPolicyDays <- io retentionPolicyDays
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("version")>]
        member _.Version((n, args), version) =
            let apply (args: AccountQueuePropertiesLoggingArgs) =
                args.Version <- input version
                args

            ()
            n, List.Cons(apply, args)

        member _.Version((n, args), version) =
            let apply (args: AccountQueuePropertiesLoggingArgs) =
                args.Version <- io version
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("write")>]
        member _.Write((n, args), write) =
            let apply (args: AccountQueuePropertiesLoggingArgs) =
                args.Write <- input write
                args

            ()
            n, List.Cons(apply, args)

        member _.Write((n, args), write) =
            let apply (args: AccountQueuePropertiesLoggingArgs) =
                args.Write <- io write
                args

            ()
            n, List.Cons(apply, args)

    let accountQueuePropertiesLogging = AccountQueuePropertiesLoggingBuilder()

    type AccountQueuePropertiesMinuteMetricsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AccountQueuePropertiesMinuteMetricsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: AccountQueuePropertiesMinuteMetricsArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: AccountQueuePropertiesMinuteMetricsArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("includeApis")>]
        member _.IncludeApis((n, args), includeApis) =
            let apply (args: AccountQueuePropertiesMinuteMetricsArgs) =
                args.IncludeApis <- input includeApis
                args

            ()
            n, List.Cons(apply, args)

        member _.IncludeApis((n, args), includeApis) =
            let apply (args: AccountQueuePropertiesMinuteMetricsArgs) =
                args.IncludeApis <- io includeApis
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("retentionPolicyDays")>]
        member _.RetentionPolicyDays((n, args), retentionPolicyDays) =
            let apply (args: AccountQueuePropertiesMinuteMetricsArgs) =
                args.RetentionPolicyDays <- input retentionPolicyDays
                args

            ()
            n, List.Cons(apply, args)

        member _.RetentionPolicyDays((n, args), retentionPolicyDays) =
            let apply (args: AccountQueuePropertiesMinuteMetricsArgs) =
                args.RetentionPolicyDays <- io retentionPolicyDays
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("version")>]
        member _.Version((n, args), version) =
            let apply (args: AccountQueuePropertiesMinuteMetricsArgs) =
                args.Version <- input version
                args

            ()
            n, List.Cons(apply, args)

        member _.Version((n, args), version) =
            let apply (args: AccountQueuePropertiesMinuteMetricsArgs) =
                args.Version <- io version
                args

            ()
            n, List.Cons(apply, args)

    let accountQueuePropertiesMinuteMetrics =
        AccountQueuePropertiesMinuteMetricsBuilder()

    type AccountStaticWebsiteBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (AccountStaticWebsiteArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("error404Document")>]
        member _.Error404Document((n, args), error404Document) =
            let apply (args: AccountStaticWebsiteArgs) =
                args.Error404Document <- input error404Document
                args

            ()
            n, List.Cons(apply, args)

        member _.Error404Document((n, args), error404Document) =
            let apply (args: AccountStaticWebsiteArgs) =
                args.Error404Document <- io error404Document
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("indexDocument")>]
        member _.IndexDocument((n, args), indexDocument) =
            let apply (args: AccountStaticWebsiteArgs) =
                args.IndexDocument <- input indexDocument
                args

            ()
            n, List.Cons(apply, args)

        member _.IndexDocument((n, args), indexDocument) =
            let apply (args: AccountStaticWebsiteArgs) =
                args.IndexDocument <- io indexDocument
                args

            ()
            n, List.Cons(apply, args)

    let accountStaticWebsite = AccountStaticWebsiteBuilder()

    type ManagementPolicyRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ManagementPolicyRuleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: ManagementPolicyRuleArgs) =
                   args.Actions <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: ManagementPolicyRuleArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: ManagementPolicyRuleArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ManagementPolicyRuleArgs) =
                   args.Filters <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ManagementPolicyRuleArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ManagementPolicyRuleArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

    let managementPolicyRule = ManagementPolicyRuleBuilder()

    type ManagementPolicyRuleActionsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ManagementPolicyRuleActionsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        member _.Yield arg =
            null,
            [ (
               let func (args: ManagementPolicyRuleActionsArgs) =
                   args.BaseBlob <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: ManagementPolicyRuleActionsArgs) =
                   args.Snapshot <- input arg
                   args

               ()
               func) ]

    let managementPolicyRuleActions = ManagementPolicyRuleActionsBuilder()

    type ManagementPolicyRuleActionsBaseBlobBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ManagementPolicyRuleActionsBaseBlobArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("deleteAfterDaysSinceModificationGreaterThan")>]
        member _.DeleteAfterDaysSinceModificationGreaterThan((n, args), deleteAfterDaysSinceModificationGreaterThan) =
            let apply (args: ManagementPolicyRuleActionsBaseBlobArgs) =
                args.DeleteAfterDaysSinceModificationGreaterThan <- input deleteAfterDaysSinceModificationGreaterThan
                args

            ()
            n, List.Cons(apply, args)

        member _.DeleteAfterDaysSinceModificationGreaterThan((n, args), deleteAfterDaysSinceModificationGreaterThan) =
            let apply (args: ManagementPolicyRuleActionsBaseBlobArgs) =
                args.DeleteAfterDaysSinceModificationGreaterThan <- io deleteAfterDaysSinceModificationGreaterThan
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tierToArchiveAfterDaysSinceModificationGreaterThan")>]
        member _.TierToArchiveAfterDaysSinceModificationGreaterThan(
            (n, args),
            tierToArchiveAfterDaysSinceModificationGreaterThan)
            =

            let apply (args: ManagementPolicyRuleActionsBaseBlobArgs) =
                args.TierToArchiveAfterDaysSinceModificationGreaterThan <- input
                                                                               tierToArchiveAfterDaysSinceModificationGreaterThan
                args

            ()
            n, List.Cons(apply, args)

        member _.TierToArchiveAfterDaysSinceModificationGreaterThan(
            (n, args),
            tierToArchiveAfterDaysSinceModificationGreaterThan)
            =

            let apply (args: ManagementPolicyRuleActionsBaseBlobArgs) =
                args.TierToArchiveAfterDaysSinceModificationGreaterThan <- io
                                                                               tierToArchiveAfterDaysSinceModificationGreaterThan
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("tierToCoolAfterDaysSinceModificationGreaterThan")>]
        member _.TierToCoolAfterDaysSinceModificationGreaterThan(
            (n, args),
            tierToCoolAfterDaysSinceModificationGreaterThan)
            =

            let apply (args: ManagementPolicyRuleActionsBaseBlobArgs) =
                args.TierToCoolAfterDaysSinceModificationGreaterThan <- input
                                                                            tierToCoolAfterDaysSinceModificationGreaterThan
                args

            ()
            n, List.Cons(apply, args)

        member _.TierToCoolAfterDaysSinceModificationGreaterThan(
            (n, args),
            tierToCoolAfterDaysSinceModificationGreaterThan)
            =

            let apply (args: ManagementPolicyRuleActionsBaseBlobArgs) =
                args.TierToCoolAfterDaysSinceModificationGreaterThan <- io
                                                                            tierToCoolAfterDaysSinceModificationGreaterThan
                args

            ()
            n, List.Cons(apply, args)

    let managementPolicyRuleActionsBaseBlob =
        ManagementPolicyRuleActionsBaseBlobBuilder()

    type ManagementPolicyRuleActionsSnapshotBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ManagementPolicyRuleActionsSnapshotArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("deleteAfterDaysSinceCreationGreaterThan")>]
        member _.DeleteAfterDaysSinceCreationGreaterThan((n, args), deleteAfterDaysSinceCreationGreaterThan) =
            let apply (args: ManagementPolicyRuleActionsSnapshotArgs) =
                args.DeleteAfterDaysSinceCreationGreaterThan <- input deleteAfterDaysSinceCreationGreaterThan
                args

            ()
            n, List.Cons(apply, args)

        member _.DeleteAfterDaysSinceCreationGreaterThan((n, args), deleteAfterDaysSinceCreationGreaterThan) =
            let apply (args: ManagementPolicyRuleActionsSnapshotArgs) =
                args.DeleteAfterDaysSinceCreationGreaterThan <- io deleteAfterDaysSinceCreationGreaterThan
                args

            ()
            n, List.Cons(apply, args)

    let managementPolicyRuleActionsSnapshot =
        ManagementPolicyRuleActionsSnapshotBuilder()

    type ManagementPolicyRuleFiltersBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ManagementPolicyRuleFiltersArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("blobTypes")>]
        member _.BlobTypes((n, args), blobTypes) =
            let apply (args: ManagementPolicyRuleFiltersArgs) =
                args.BlobTypes <- inputList blobTypes
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("prefixMatches")>]
        member _.PrefixMatches((n, args), prefixMatches) =
            let apply (args: ManagementPolicyRuleFiltersArgs) =
                args.PrefixMatches <- inputList prefixMatches
                args

            ()
            n, List.Cons(apply, args)

    let managementPolicyRuleFilters = ManagementPolicyRuleFiltersBuilder()

    type ShareAclBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ShareAclArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("accessPolicies")>]
        member _.AccessPolicies((n, args), accessPolicies) =
            let apply (args: ShareAclArgs) =
                args.AccessPolicies <- inputList accessPolicies
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: ShareAclArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: ShareAclArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

    let shareAcl = ShareAclBuilder()

    type ShareAclAccessPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ShareAclAccessPolicyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("expiry")>]
        member _.Expiry((n, args), expiry) =
            let apply (args: ShareAclAccessPolicyArgs) =
                args.Expiry <- input expiry
                args

            ()
            n, List.Cons(apply, args)

        member _.Expiry((n, args), expiry) =
            let apply (args: ShareAclAccessPolicyArgs) =
                args.Expiry <- io expiry
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("permissions")>]
        member _.Permissions((n, args), permissions) =
            let apply (args: ShareAclAccessPolicyArgs) =
                args.Permissions <- input permissions
                args

            ()
            n, List.Cons(apply, args)

        member _.Permissions((n, args), permissions) =
            let apply (args: ShareAclAccessPolicyArgs) =
                args.Permissions <- io permissions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("start")>]
        member _.Start((n, args), start) =
            let apply (args: ShareAclAccessPolicyArgs) =
                args.Start <- input start
                args

            ()
            n, List.Cons(apply, args)

        member _.Start((n, args), start) =
            let apply (args: ShareAclAccessPolicyArgs) =
                args.Start <- io start
                args

            ()
            n, List.Cons(apply, args)

    let shareAclAccessPolicy = ShareAclAccessPolicyBuilder()

    type TableAclBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (TableAclArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("accessPolicies")>]
        member _.AccessPolicies((n, args), accessPolicies) =
            let apply (args: TableAclArgs) =
                args.AccessPolicies <- inputList accessPolicies
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("id")>]
        member _.Id((n, args), id) =
            let apply (args: TableAclArgs) =
                args.Id <- input id
                args

            ()
            n, List.Cons(apply, args)

        member _.Id((n, args), id) =
            let apply (args: TableAclArgs) =
                args.Id <- io id
                args

            ()
            n, List.Cons(apply, args)

    let tableAcl = TableAclBuilder()

    type TableAclAccessPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (TableAclAccessPolicyArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("expiry")>]
        member _.Expiry((n, args), expiry) =
            let apply (args: TableAclAccessPolicyArgs) =
                args.Expiry <- input expiry
                args

            ()
            n, List.Cons(apply, args)

        member _.Expiry((n, args), expiry) =
            let apply (args: TableAclAccessPolicyArgs) =
                args.Expiry <- io expiry
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("permissions")>]
        member _.Permissions((n, args), permissions) =
            let apply (args: TableAclAccessPolicyArgs) =
                args.Permissions <- input permissions
                args

            ()
            n, List.Cons(apply, args)

        member _.Permissions((n, args), permissions) =
            let apply (args: TableAclAccessPolicyArgs) =
                args.Permissions <- io permissions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("start")>]
        member _.Start((n, args), start) =
            let apply (args: TableAclAccessPolicyArgs) =
                args.Start <- input start
                args

            ()
            n, List.Cons(apply, args)

        member _.Start((n, args), start) =
            let apply (args: TableAclAccessPolicyArgs) =
                args.Start <- io start
                args

            ()
            n, List.Cons(apply, args)

    let tableAclAccessPolicy = TableAclAccessPolicyBuilder()

    type AccountBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Account(name, (List.fold func (AccountArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("accessTier")>]
        member _.AccessTier((name, args), accessTier) =
            let apply (args: AccountArgs) =
                args.AccessTier <- input accessTier
                args

            ()
            name, List.Cons(apply, args)

        member _.AccessTier((name, args), accessTier) =
            let apply (args: AccountArgs) =
                args.AccessTier <- io accessTier
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("accountKind")>]
        member _.AccountKind((name, args), accountKind) =
            let apply (args: AccountArgs) =
                args.AccountKind <- input accountKind
                args

            ()
            name, List.Cons(apply, args)

        member _.AccountKind((name, args), accountKind) =
            let apply (args: AccountArgs) =
                args.AccountKind <- io accountKind
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("accountReplicationType")>]
        member _.AccountReplicationType((name, args), accountReplicationType) =
            let apply (args: AccountArgs) =
                args.AccountReplicationType <- input accountReplicationType
                args

            ()
            name, List.Cons(apply, args)

        member _.AccountReplicationType((name, args), accountReplicationType) =
            let apply (args: AccountArgs) =
                args.AccountReplicationType <- io accountReplicationType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("accountTier")>]
        member _.AccountTier((name, args), accountTier) =
            let apply (args: AccountArgs) =
                args.AccountTier <- input accountTier
                args

            ()
            name, List.Cons(apply, args)

        member _.AccountTier((name, args), accountTier) =
            let apply (args: AccountArgs) =
                args.AccountTier <- io accountTier
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: AccountArgs) =
                   args.BlobProperties <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: AccountArgs) =
                   args.CustomDomain <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("enableHttpsTrafficOnly")>]
        member _.EnableHttpsTrafficOnly((name, args), enableHttpsTrafficOnly) =
            let apply (args: AccountArgs) =
                args.EnableHttpsTrafficOnly <- input enableHttpsTrafficOnly
                args

            ()
            name, List.Cons(apply, args)

        member _.EnableHttpsTrafficOnly((name, args), enableHttpsTrafficOnly) =
            let apply (args: AccountArgs) =
                args.EnableHttpsTrafficOnly <- io enableHttpsTrafficOnly
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: AccountArgs) =
                   args.Identity <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("isHnsEnabled")>]
        member _.IsHnsEnabled((name, args), isHnsEnabled) =
            let apply (args: AccountArgs) =
                args.IsHnsEnabled <- input isHnsEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.IsHnsEnabled((name, args), isHnsEnabled) =
            let apply (args: AccountArgs) =
                args.IsHnsEnabled <- io isHnsEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: AccountArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: AccountArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: AccountArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: AccountArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: AccountArgs) =
                   args.NetworkRules <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: AccountArgs) =
                   args.QueueProperties <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AccountArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AccountArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: AccountArgs) =
                   args.StaticWebsite <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: AccountArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let account = AccountBuilder()

    type BlobBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Blob(name, (List.fold func (BlobArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("accessTier")>]
        member _.AccessTier((name, args), accessTier) =
            let apply (args: BlobArgs) =
                args.AccessTier <- input accessTier
                args

            ()
            name, List.Cons(apply, args)

        member _.AccessTier((name, args), accessTier) =
            let apply (args: BlobArgs) =
                args.AccessTier <- io accessTier
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("contentType")>]
        member _.ContentType((name, args), contentType) =
            let apply (args: BlobArgs) =
                args.ContentType <- input contentType
                args

            ()
            name, List.Cons(apply, args)

        member _.ContentType((name, args), contentType) =
            let apply (args: BlobArgs) =
                args.ContentType <- io contentType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("metadata")>]
        member _.Metadata((name, args), metadata) =
            let apply (args: BlobArgs) =
                args.Metadata <- inputMap metadata
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: BlobArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: BlobArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("parallelism")>]
        member _.Parallelism((name, args), parallelism) =
            let apply (args: BlobArgs) =
                args.Parallelism <- input parallelism
                args

            ()
            name, List.Cons(apply, args)

        member _.Parallelism((name, args), parallelism) =
            let apply (args: BlobArgs) =
                args.Parallelism <- io parallelism
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("size")>]
        member _.Size((name, args), size) =
            let apply (args: BlobArgs) =
                args.Size <- input size
                args

            ()
            name, List.Cons(apply, args)

        member _.Size((name, args), size) =
            let apply (args: BlobArgs) =
                args.Size <- io size
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("source")>]
        member _.Source((name, args), source) =
            let apply (args: BlobArgs) =
                args.Source <- input source
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sourceContent")>]
        member _.SourceContent((name, args), sourceContent) =
            let apply (args: BlobArgs) =
                args.SourceContent <- input sourceContent
                args

            ()
            name, List.Cons(apply, args)

        member _.SourceContent((name, args), sourceContent) =
            let apply (args: BlobArgs) =
                args.SourceContent <- io sourceContent
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sourceUri")>]
        member _.SourceUri((name, args), sourceUri) =
            let apply (args: BlobArgs) =
                args.SourceUri <- input sourceUri
                args

            ()
            name, List.Cons(apply, args)

        member _.SourceUri((name, args), sourceUri) =
            let apply (args: BlobArgs) =
                args.SourceUri <- io sourceUri
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageAccountName")>]
        member _.StorageAccountName((name, args), storageAccountName) =
            let apply (args: BlobArgs) =
                args.StorageAccountName <- input storageAccountName
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageAccountName((name, args), storageAccountName) =
            let apply (args: BlobArgs) =
                args.StorageAccountName <- io storageAccountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageContainerName")>]
        member _.StorageContainerName((name, args), storageContainerName) =
            let apply (args: BlobArgs) =
                args.StorageContainerName <- input storageContainerName
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageContainerName((name, args), storageContainerName) =
            let apply (args: BlobArgs) =
                args.StorageContainerName <- io storageContainerName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((name, args), ``type``) =
            let apply (args: BlobArgs) =
                args.Type <- input ``type``
                args

            ()
            name, List.Cons(apply, args)

        member _.Type((name, args), ``type``) =
            let apply (args: BlobArgs) =
                args.Type <- io ``type``
                args

            ()
            name, List.Cons(apply, args)

    let blob = BlobBuilder()

    type ContainerBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Container(name, (List.fold func (ContainerArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("containerAccessType")>]
        member _.ContainerAccessType((name, args), containerAccessType) =
            let apply (args: ContainerArgs) =
                args.ContainerAccessType <- input containerAccessType
                args

            ()
            name, List.Cons(apply, args)

        member _.ContainerAccessType((name, args), containerAccessType) =
            let apply (args: ContainerArgs) =
                args.ContainerAccessType <- io containerAccessType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("metadata")>]
        member _.Metadata((name, args), metadata) =
            let apply (args: ContainerArgs) =
                args.Metadata <- inputMap metadata
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ContainerArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ContainerArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageAccountName")>]
        member _.StorageAccountName((name, args), storageAccountName) =
            let apply (args: ContainerArgs) =
                args.StorageAccountName <- input storageAccountName
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageAccountName((name, args), storageAccountName) =
            let apply (args: ContainerArgs) =
                args.StorageAccountName <- io storageAccountName
                args

            ()
            name, List.Cons(apply, args)

    let container = ContainerBuilder()

    type CustomerManagedKeyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            CustomerManagedKey(name, (List.fold func (CustomerManagedKeyArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("keyName")>]
        member _.KeyName((name, args), keyName) =
            let apply (args: CustomerManagedKeyArgs) =
                args.KeyName <- input keyName
                args

            ()
            name, List.Cons(apply, args)

        member _.KeyName((name, args), keyName) =
            let apply (args: CustomerManagedKeyArgs) =
                args.KeyName <- io keyName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("keyVaultId")>]
        member _.KeyVaultId((name, args), keyVaultId) =
            let apply (args: CustomerManagedKeyArgs) =
                args.KeyVaultId <- input keyVaultId
                args

            ()
            name, List.Cons(apply, args)

        member _.KeyVaultId((name, args), keyVaultId) =
            let apply (args: CustomerManagedKeyArgs) =
                args.KeyVaultId <- io keyVaultId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("keyVersion")>]
        member _.KeyVersion((name, args), keyVersion) =
            let apply (args: CustomerManagedKeyArgs) =
                args.KeyVersion <- input keyVersion
                args

            ()
            name, List.Cons(apply, args)

        member _.KeyVersion((name, args), keyVersion) =
            let apply (args: CustomerManagedKeyArgs) =
                args.KeyVersion <- io keyVersion
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageAccountId")>]
        member _.StorageAccountId((name, args), storageAccountId) =
            let apply (args: CustomerManagedKeyArgs) =
                args.StorageAccountId <- input storageAccountId
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageAccountId((name, args), storageAccountId) =
            let apply (args: CustomerManagedKeyArgs) =
                args.StorageAccountId <- io storageAccountId
                args

            ()
            name, List.Cons(apply, args)

    let customerManagedKey = CustomerManagedKeyBuilder()

    type DataLakeGen2FilesystemBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            DataLakeGen2Filesystem(name, (List.fold func (DataLakeGen2FilesystemArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: DataLakeGen2FilesystemArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: DataLakeGen2FilesystemArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("properties")>]
        member _.Properties((name, args), properties) =
            let apply (args: DataLakeGen2FilesystemArgs) =
                args.Properties <- inputMap properties
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageAccountId")>]
        member _.StorageAccountId((name, args), storageAccountId) =
            let apply (args: DataLakeGen2FilesystemArgs) =
                args.StorageAccountId <- input storageAccountId
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageAccountId((name, args), storageAccountId) =
            let apply (args: DataLakeGen2FilesystemArgs) =
                args.StorageAccountId <- io storageAccountId
                args

            ()
            name, List.Cons(apply, args)

    let dataLakeGen2Filesystem = DataLakeGen2FilesystemBuilder()

    type ManagementPolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ManagementPolicy(name, (List.fold func (ManagementPolicyArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("rules")>]
        member _.Rules((name, args), rules) =
            let apply (args: ManagementPolicyArgs) =
                args.Rules <- inputList rules
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageAccountId")>]
        member _.StorageAccountId((name, args), storageAccountId) =
            let apply (args: ManagementPolicyArgs) =
                args.StorageAccountId <- input storageAccountId
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageAccountId((name, args), storageAccountId) =
            let apply (args: ManagementPolicyArgs) =
                args.StorageAccountId <- io storageAccountId
                args

            ()
            name, List.Cons(apply, args)

    let managementPolicy = ManagementPolicyBuilder()

    type QueueBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Queue(name, (List.fold func (QueueArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("metadata")>]
        member _.Metadata((name, args), metadata) =
            let apply (args: QueueArgs) =
                args.Metadata <- inputMap metadata
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: QueueArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: QueueArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageAccountName")>]
        member _.StorageAccountName((name, args), storageAccountName) =
            let apply (args: QueueArgs) =
                args.StorageAccountName <- input storageAccountName
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageAccountName((name, args), storageAccountName) =
            let apply (args: QueueArgs) =
                args.StorageAccountName <- io storageAccountName
                args

            ()
            name, List.Cons(apply, args)

    let queue = QueueBuilder()

    type ShareBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Share(name, (List.fold func (ShareArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("acls")>]
        member _.Acls((name, args), acls) =
            let apply (args: ShareArgs) =
                args.Acls <- inputList acls
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("metadata")>]
        member _.Metadata((name, args), metadata) =
            let apply (args: ShareArgs) =
                args.Metadata <- inputMap metadata
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ShareArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ShareArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("quota")>]
        member _.Quota((name, args), quota) =
            let apply (args: ShareArgs) =
                args.Quota <- input quota
                args

            ()
            name, List.Cons(apply, args)

        member _.Quota((name, args), quota) =
            let apply (args: ShareArgs) =
                args.Quota <- io quota
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageAccountName")>]
        member _.StorageAccountName((name, args), storageAccountName) =
            let apply (args: ShareArgs) =
                args.StorageAccountName <- input storageAccountName
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageAccountName((name, args), storageAccountName) =
            let apply (args: ShareArgs) =
                args.StorageAccountName <- io storageAccountName
                args

            ()
            name, List.Cons(apply, args)

    let share = ShareBuilder()

    type ShareDirectoryBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ShareDirectory(name, (List.fold func (ShareDirectoryArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("metadata")>]
        member _.Metadata((name, args), metadata) =
            let apply (args: ShareDirectoryArgs) =
                args.Metadata <- inputMap metadata
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ShareDirectoryArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ShareDirectoryArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("shareName")>]
        member _.ShareName((name, args), shareName) =
            let apply (args: ShareDirectoryArgs) =
                args.ShareName <- input shareName
                args

            ()
            name, List.Cons(apply, args)

        member _.ShareName((name, args), shareName) =
            let apply (args: ShareDirectoryArgs) =
                args.ShareName <- io shareName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageAccountName")>]
        member _.StorageAccountName((name, args), storageAccountName) =
            let apply (args: ShareDirectoryArgs) =
                args.StorageAccountName <- input storageAccountName
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageAccountName((name, args), storageAccountName) =
            let apply (args: ShareDirectoryArgs) =
                args.StorageAccountName <- io storageAccountName
                args

            ()
            name, List.Cons(apply, args)

    let shareDirectory = ShareDirectoryBuilder()

    type TableBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Table(name, (List.fold func (TableArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("acls")>]
        member _.Acls((name, args), acls) =
            let apply (args: TableArgs) =
                args.Acls <- inputList acls
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: TableArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: TableArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageAccountName")>]
        member _.StorageAccountName((name, args), storageAccountName) =
            let apply (args: TableArgs) =
                args.StorageAccountName <- input storageAccountName
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageAccountName((name, args), storageAccountName) =
            let apply (args: TableArgs) =
                args.StorageAccountName <- io storageAccountName
                args

            ()
            name, List.Cons(apply, args)

    let table = TableBuilder()

    type TableEntityBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            TableEntity(name, (List.fold func (TableEntityArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("entity")>]
        member _.Entity((name, args), entity) =
            let apply (args: TableEntityArgs) =
                args.Entity <- inputMap entity
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("partitionKey")>]
        member _.PartitionKey((name, args), partitionKey) =
            let apply (args: TableEntityArgs) =
                args.PartitionKey <- input partitionKey
                args

            ()
            name, List.Cons(apply, args)

        member _.PartitionKey((name, args), partitionKey) =
            let apply (args: TableEntityArgs) =
                args.PartitionKey <- io partitionKey
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("rowKey")>]
        member _.RowKey((name, args), rowKey) =
            let apply (args: TableEntityArgs) =
                args.RowKey <- input rowKey
                args

            ()
            name, List.Cons(apply, args)

        member _.RowKey((name, args), rowKey) =
            let apply (args: TableEntityArgs) =
                args.RowKey <- io rowKey
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageAccountName")>]
        member _.StorageAccountName((name, args), storageAccountName) =
            let apply (args: TableEntityArgs) =
                args.StorageAccountName <- input storageAccountName
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageAccountName((name, args), storageAccountName) =
            let apply (args: TableEntityArgs) =
                args.StorageAccountName <- io storageAccountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tableName")>]
        member _.TableName((name, args), tableName) =
            let apply (args: TableEntityArgs) =
                args.TableName <- input tableName
                args

            ()
            name, List.Cons(apply, args)

        member _.TableName((name, args), tableName) =
            let apply (args: TableEntityArgs) =
                args.TableName <- io tableName
                args

            ()
            name, List.Cons(apply, args)

    let tableEntity = TableEntityBuilder()

    type ZipBlobBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ZipBlob(name, (List.fold func (ZipBlobArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("accessTier")>]
        member _.AccessTier((name, args), accessTier) =
            let apply (args: ZipBlobArgs) =
                args.AccessTier <- input accessTier
                args

            ()
            name, List.Cons(apply, args)

        member _.AccessTier((name, args), accessTier) =
            let apply (args: ZipBlobArgs) =
                args.AccessTier <- io accessTier
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("content")>]
        member _.Content((name, args), content) =
            let apply (args: ZipBlobArgs) =
                args.Content <- input content
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("contentType")>]
        member _.ContentType((name, args), contentType) =
            let apply (args: ZipBlobArgs) =
                args.ContentType <- input contentType
                args

            ()
            name, List.Cons(apply, args)

        member _.ContentType((name, args), contentType) =
            let apply (args: ZipBlobArgs) =
                args.ContentType <- io contentType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("metadata")>]
        member _.Metadata((name, args), metadata) =
            let apply (args: ZipBlobArgs) =
                args.Metadata <- inputMap metadata
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ZipBlobArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ZipBlobArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("parallelism")>]
        member _.Parallelism((name, args), parallelism) =
            let apply (args: ZipBlobArgs) =
                args.Parallelism <- input parallelism
                args

            ()
            name, List.Cons(apply, args)

        member _.Parallelism((name, args), parallelism) =
            let apply (args: ZipBlobArgs) =
                args.Parallelism <- io parallelism
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("size")>]
        member _.Size((name, args), size) =
            let apply (args: ZipBlobArgs) =
                args.Size <- input size
                args

            ()
            name, List.Cons(apply, args)

        member _.Size((name, args), size) =
            let apply (args: ZipBlobArgs) =
                args.Size <- io size
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sourceContent")>]
        member _.SourceContent((name, args), sourceContent) =
            let apply (args: ZipBlobArgs) =
                args.SourceContent <- input sourceContent
                args

            ()
            name, List.Cons(apply, args)

        member _.SourceContent((name, args), sourceContent) =
            let apply (args: ZipBlobArgs) =
                args.SourceContent <- io sourceContent
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sourceUri")>]
        member _.SourceUri((name, args), sourceUri) =
            let apply (args: ZipBlobArgs) =
                args.SourceUri <- input sourceUri
                args

            ()
            name, List.Cons(apply, args)

        member _.SourceUri((name, args), sourceUri) =
            let apply (args: ZipBlobArgs) =
                args.SourceUri <- io sourceUri
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageAccountName")>]
        member _.StorageAccountName((name, args), storageAccountName) =
            let apply (args: ZipBlobArgs) =
                args.StorageAccountName <- input storageAccountName
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageAccountName((name, args), storageAccountName) =
            let apply (args: ZipBlobArgs) =
                args.StorageAccountName <- io storageAccountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageContainerName")>]
        member _.StorageContainerName((name, args), storageContainerName) =
            let apply (args: ZipBlobArgs) =
                args.StorageContainerName <- input storageContainerName
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageContainerName((name, args), storageContainerName) =
            let apply (args: ZipBlobArgs) =
                args.StorageContainerName <- io storageContainerName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((name, args), ``type``) =
            let apply (args: ZipBlobArgs) =
                args.Type <- input ``type``
                args

            ()
            name, List.Cons(apply, args)

        member _.Type((name, args), ``type``) =
            let apply (args: ZipBlobArgs) =
                args.Type <- io ``type``
                args

            ()
            name, List.Cons(apply, args)

    let zipBlob = ZipBlobBuilder()

module StreamAnalytics =
    open Pulumi.Azure.StreamAnalytics
    open Pulumi.Azure.StreamAnalytics.Inputs

    type FunctionJavaScriptUDFInputBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FunctionJavaScriptUDFInputArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: FunctionJavaScriptUDFInputArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: FunctionJavaScriptUDFInputArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let functionJavaScriptUDFInput = FunctionJavaScriptUDFInputBuilder()

    type FunctionJavaScriptUDFOutputBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (FunctionJavaScriptUDFOutputArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: FunctionJavaScriptUDFOutputArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: FunctionJavaScriptUDFOutputArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let functionJavaScriptUDFOutput = FunctionJavaScriptUDFOutputBuilder()

    type OutputBlobSerializationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (OutputBlobSerializationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("encoding")>]
        member _.Encoding((n, args), encoding) =
            let apply (args: OutputBlobSerializationArgs) =
                args.Encoding <- input encoding
                args

            ()
            n, List.Cons(apply, args)

        member _.Encoding((n, args), encoding) =
            let apply (args: OutputBlobSerializationArgs) =
                args.Encoding <- io encoding
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("fieldDelimiter")>]
        member _.FieldDelimiter((n, args), fieldDelimiter) =
            let apply (args: OutputBlobSerializationArgs) =
                args.FieldDelimiter <- input fieldDelimiter
                args

            ()
            n, List.Cons(apply, args)

        member _.FieldDelimiter((n, args), fieldDelimiter) =
            let apply (args: OutputBlobSerializationArgs) =
                args.FieldDelimiter <- io fieldDelimiter
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("format")>]
        member _.Format((n, args), format) =
            let apply (args: OutputBlobSerializationArgs) =
                args.Format <- input format
                args

            ()
            n, List.Cons(apply, args)

        member _.Format((n, args), format) =
            let apply (args: OutputBlobSerializationArgs) =
                args.Format <- io format
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: OutputBlobSerializationArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: OutputBlobSerializationArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let outputBlobSerialization = OutputBlobSerializationBuilder()

    type OutputEventHubSerializationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (OutputEventHubSerializationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("encoding")>]
        member _.Encoding((n, args), encoding) =
            let apply (args: OutputEventHubSerializationArgs) =
                args.Encoding <- input encoding
                args

            ()
            n, List.Cons(apply, args)

        member _.Encoding((n, args), encoding) =
            let apply (args: OutputEventHubSerializationArgs) =
                args.Encoding <- io encoding
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("fieldDelimiter")>]
        member _.FieldDelimiter((n, args), fieldDelimiter) =
            let apply (args: OutputEventHubSerializationArgs) =
                args.FieldDelimiter <- input fieldDelimiter
                args

            ()
            n, List.Cons(apply, args)

        member _.FieldDelimiter((n, args), fieldDelimiter) =
            let apply (args: OutputEventHubSerializationArgs) =
                args.FieldDelimiter <- io fieldDelimiter
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("format")>]
        member _.Format((n, args), format) =
            let apply (args: OutputEventHubSerializationArgs) =
                args.Format <- input format
                args

            ()
            n, List.Cons(apply, args)

        member _.Format((n, args), format) =
            let apply (args: OutputEventHubSerializationArgs) =
                args.Format <- io format
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: OutputEventHubSerializationArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: OutputEventHubSerializationArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let outputEventHubSerialization = OutputEventHubSerializationBuilder()

    type OutputServiceBusQueueSerializationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (OutputServiceBusQueueSerializationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("encoding")>]
        member _.Encoding((n, args), encoding) =
            let apply (args: OutputServiceBusQueueSerializationArgs) =
                args.Encoding <- input encoding
                args

            ()
            n, List.Cons(apply, args)

        member _.Encoding((n, args), encoding) =
            let apply (args: OutputServiceBusQueueSerializationArgs) =
                args.Encoding <- io encoding
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("fieldDelimiter")>]
        member _.FieldDelimiter((n, args), fieldDelimiter) =
            let apply (args: OutputServiceBusQueueSerializationArgs) =
                args.FieldDelimiter <- input fieldDelimiter
                args

            ()
            n, List.Cons(apply, args)

        member _.FieldDelimiter((n, args), fieldDelimiter) =
            let apply (args: OutputServiceBusQueueSerializationArgs) =
                args.FieldDelimiter <- io fieldDelimiter
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("format")>]
        member _.Format((n, args), format) =
            let apply (args: OutputServiceBusQueueSerializationArgs) =
                args.Format <- input format
                args

            ()
            n, List.Cons(apply, args)

        member _.Format((n, args), format) =
            let apply (args: OutputServiceBusQueueSerializationArgs) =
                args.Format <- io format
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: OutputServiceBusQueueSerializationArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: OutputServiceBusQueueSerializationArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let outputServiceBusQueueSerialization =
        OutputServiceBusQueueSerializationBuilder()

    type OutputServicebusTopicSerializationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (OutputServicebusTopicSerializationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("encoding")>]
        member _.Encoding((n, args), encoding) =
            let apply (args: OutputServicebusTopicSerializationArgs) =
                args.Encoding <- input encoding
                args

            ()
            n, List.Cons(apply, args)

        member _.Encoding((n, args), encoding) =
            let apply (args: OutputServicebusTopicSerializationArgs) =
                args.Encoding <- io encoding
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("fieldDelimiter")>]
        member _.FieldDelimiter((n, args), fieldDelimiter) =
            let apply (args: OutputServicebusTopicSerializationArgs) =
                args.FieldDelimiter <- input fieldDelimiter
                args

            ()
            n, List.Cons(apply, args)

        member _.FieldDelimiter((n, args), fieldDelimiter) =
            let apply (args: OutputServicebusTopicSerializationArgs) =
                args.FieldDelimiter <- io fieldDelimiter
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("format")>]
        member _.Format((n, args), format) =
            let apply (args: OutputServicebusTopicSerializationArgs) =
                args.Format <- input format
                args

            ()
            n, List.Cons(apply, args)

        member _.Format((n, args), format) =
            let apply (args: OutputServicebusTopicSerializationArgs) =
                args.Format <- io format
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: OutputServicebusTopicSerializationArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: OutputServicebusTopicSerializationArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let outputServicebusTopicSerialization =
        OutputServicebusTopicSerializationBuilder()

    type ReferenceInputBlobSerializationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ReferenceInputBlobSerializationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("encoding")>]
        member _.Encoding((n, args), encoding) =
            let apply (args: ReferenceInputBlobSerializationArgs) =
                args.Encoding <- input encoding
                args

            ()
            n, List.Cons(apply, args)

        member _.Encoding((n, args), encoding) =
            let apply (args: ReferenceInputBlobSerializationArgs) =
                args.Encoding <- io encoding
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("fieldDelimiter")>]
        member _.FieldDelimiter((n, args), fieldDelimiter) =
            let apply (args: ReferenceInputBlobSerializationArgs) =
                args.FieldDelimiter <- input fieldDelimiter
                args

            ()
            n, List.Cons(apply, args)

        member _.FieldDelimiter((n, args), fieldDelimiter) =
            let apply (args: ReferenceInputBlobSerializationArgs) =
                args.FieldDelimiter <- io fieldDelimiter
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: ReferenceInputBlobSerializationArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: ReferenceInputBlobSerializationArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let referenceInputBlobSerialization = ReferenceInputBlobSerializationBuilder()

    type StreamInputBlobSerializationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (StreamInputBlobSerializationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("encoding")>]
        member _.Encoding((n, args), encoding) =
            let apply (args: StreamInputBlobSerializationArgs) =
                args.Encoding <- input encoding
                args

            ()
            n, List.Cons(apply, args)

        member _.Encoding((n, args), encoding) =
            let apply (args: StreamInputBlobSerializationArgs) =
                args.Encoding <- io encoding
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("fieldDelimiter")>]
        member _.FieldDelimiter((n, args), fieldDelimiter) =
            let apply (args: StreamInputBlobSerializationArgs) =
                args.FieldDelimiter <- input fieldDelimiter
                args

            ()
            n, List.Cons(apply, args)

        member _.FieldDelimiter((n, args), fieldDelimiter) =
            let apply (args: StreamInputBlobSerializationArgs) =
                args.FieldDelimiter <- io fieldDelimiter
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: StreamInputBlobSerializationArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: StreamInputBlobSerializationArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let streamInputBlobSerialization = StreamInputBlobSerializationBuilder()

    type StreamInputEventHubSerializationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (StreamInputEventHubSerializationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("encoding")>]
        member _.Encoding((n, args), encoding) =
            let apply (args: StreamInputEventHubSerializationArgs) =
                args.Encoding <- input encoding
                args

            ()
            n, List.Cons(apply, args)

        member _.Encoding((n, args), encoding) =
            let apply (args: StreamInputEventHubSerializationArgs) =
                args.Encoding <- io encoding
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("fieldDelimiter")>]
        member _.FieldDelimiter((n, args), fieldDelimiter) =
            let apply (args: StreamInputEventHubSerializationArgs) =
                args.FieldDelimiter <- input fieldDelimiter
                args

            ()
            n, List.Cons(apply, args)

        member _.FieldDelimiter((n, args), fieldDelimiter) =
            let apply (args: StreamInputEventHubSerializationArgs) =
                args.FieldDelimiter <- io fieldDelimiter
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: StreamInputEventHubSerializationArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: StreamInputEventHubSerializationArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let streamInputEventHubSerialization =
        StreamInputEventHubSerializationBuilder()

    type StreamInputIotHubSerializationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (StreamInputIotHubSerializationArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("encoding")>]
        member _.Encoding((n, args), encoding) =
            let apply (args: StreamInputIotHubSerializationArgs) =
                args.Encoding <- input encoding
                args

            ()
            n, List.Cons(apply, args)

        member _.Encoding((n, args), encoding) =
            let apply (args: StreamInputIotHubSerializationArgs) =
                args.Encoding <- io encoding
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("fieldDelimiter")>]
        member _.FieldDelimiter((n, args), fieldDelimiter) =
            let apply (args: StreamInputIotHubSerializationArgs) =
                args.FieldDelimiter <- input fieldDelimiter
                args

            ()
            n, List.Cons(apply, args)

        member _.FieldDelimiter((n, args), fieldDelimiter) =
            let apply (args: StreamInputIotHubSerializationArgs) =
                args.FieldDelimiter <- io fieldDelimiter
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: StreamInputIotHubSerializationArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: StreamInputIotHubSerializationArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

    let streamInputIotHubSerialization = StreamInputIotHubSerializationBuilder()

    type FunctionJavaScriptUDFBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            FunctionJavaScriptUDF(name, (List.fold func (FunctionJavaScriptUDFArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("inputs")>]
        member _.Inputs((name, args), inputs) =
            let apply (args: FunctionJavaScriptUDFArgs) =
                args.Inputs <- inputList inputs
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: FunctionJavaScriptUDFArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: FunctionJavaScriptUDFArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: FunctionJavaScriptUDFArgs) =
                   args.Output <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FunctionJavaScriptUDFArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: FunctionJavaScriptUDFArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("script")>]
        member _.Script((name, args), script) =
            let apply (args: FunctionJavaScriptUDFArgs) =
                args.Script <- input script
                args

            ()
            name, List.Cons(apply, args)

        member _.Script((name, args), script) =
            let apply (args: FunctionJavaScriptUDFArgs) =
                args.Script <- io script
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("streamAnalyticsJobName")>]
        member _.StreamAnalyticsJobName((name, args), streamAnalyticsJobName) =
            let apply (args: FunctionJavaScriptUDFArgs) =
                args.StreamAnalyticsJobName <- input streamAnalyticsJobName
                args

            ()
            name, List.Cons(apply, args)

        member _.StreamAnalyticsJobName((name, args), streamAnalyticsJobName) =
            let apply (args: FunctionJavaScriptUDFArgs) =
                args.StreamAnalyticsJobName <- io streamAnalyticsJobName
                args

            ()
            name, List.Cons(apply, args)

    let functionJavaScriptUDF = FunctionJavaScriptUDFBuilder()

    type JobBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Job(name, (List.fold func (JobArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("compatibilityLevel")>]
        member _.CompatibilityLevel((name, args), compatibilityLevel) =
            let apply (args: JobArgs) =
                args.CompatibilityLevel <- input compatibilityLevel
                args

            ()
            name, List.Cons(apply, args)

        member _.CompatibilityLevel((name, args), compatibilityLevel) =
            let apply (args: JobArgs) =
                args.CompatibilityLevel <- io compatibilityLevel
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("dataLocale")>]
        member _.DataLocale((name, args), dataLocale) =
            let apply (args: JobArgs) =
                args.DataLocale <- input dataLocale
                args

            ()
            name, List.Cons(apply, args)

        member _.DataLocale((name, args), dataLocale) =
            let apply (args: JobArgs) =
                args.DataLocale <- io dataLocale
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("eventsLateArrivalMaxDelayInSeconds")>]
        member _.EventsLateArrivalMaxDelayInSeconds((name, args), eventsLateArrivalMaxDelayInSeconds) =
            let apply (args: JobArgs) =
                args.EventsLateArrivalMaxDelayInSeconds <- input eventsLateArrivalMaxDelayInSeconds
                args

            ()
            name, List.Cons(apply, args)

        member _.EventsLateArrivalMaxDelayInSeconds((name, args), eventsLateArrivalMaxDelayInSeconds) =
            let apply (args: JobArgs) =
                args.EventsLateArrivalMaxDelayInSeconds <- io eventsLateArrivalMaxDelayInSeconds
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("eventsOutOfOrderMaxDelayInSeconds")>]
        member _.EventsOutOfOrderMaxDelayInSeconds((name, args), eventsOutOfOrderMaxDelayInSeconds) =
            let apply (args: JobArgs) =
                args.EventsOutOfOrderMaxDelayInSeconds <- input eventsOutOfOrderMaxDelayInSeconds
                args

            ()
            name, List.Cons(apply, args)

        member _.EventsOutOfOrderMaxDelayInSeconds((name, args), eventsOutOfOrderMaxDelayInSeconds) =
            let apply (args: JobArgs) =
                args.EventsOutOfOrderMaxDelayInSeconds <- io eventsOutOfOrderMaxDelayInSeconds
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("eventsOutOfOrderPolicy")>]
        member _.EventsOutOfOrderPolicy((name, args), eventsOutOfOrderPolicy) =
            let apply (args: JobArgs) =
                args.EventsOutOfOrderPolicy <- input eventsOutOfOrderPolicy
                args

            ()
            name, List.Cons(apply, args)

        member _.EventsOutOfOrderPolicy((name, args), eventsOutOfOrderPolicy) =
            let apply (args: JobArgs) =
                args.EventsOutOfOrderPolicy <- io eventsOutOfOrderPolicy
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: JobArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: JobArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: JobArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: JobArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("outputErrorPolicy")>]
        member _.OutputErrorPolicy((name, args), outputErrorPolicy) =
            let apply (args: JobArgs) =
                args.OutputErrorPolicy <- input outputErrorPolicy
                args

            ()
            name, List.Cons(apply, args)

        member _.OutputErrorPolicy((name, args), outputErrorPolicy) =
            let apply (args: JobArgs) =
                args.OutputErrorPolicy <- io outputErrorPolicy
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: JobArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: JobArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("streamingUnits")>]
        member _.StreamingUnits((name, args), streamingUnits) =
            let apply (args: JobArgs) =
                args.StreamingUnits <- input streamingUnits
                args

            ()
            name, List.Cons(apply, args)

        member _.StreamingUnits((name, args), streamingUnits) =
            let apply (args: JobArgs) =
                args.StreamingUnits <- io streamingUnits
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: JobArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("transformationQuery")>]
        member _.TransformationQuery((name, args), transformationQuery) =
            let apply (args: JobArgs) =
                args.TransformationQuery <- input transformationQuery
                args

            ()
            name, List.Cons(apply, args)

        member _.TransformationQuery((name, args), transformationQuery) =
            let apply (args: JobArgs) =
                args.TransformationQuery <- io transformationQuery
                args

            ()
            name, List.Cons(apply, args)

    let job = JobBuilder()

    type OutputBlobBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            OutputBlob(name, (List.fold func (OutputBlobArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("dateFormat")>]
        member _.DateFormat((name, args), dateFormat) =
            let apply (args: OutputBlobArgs) =
                args.DateFormat <- input dateFormat
                args

            ()
            name, List.Cons(apply, args)

        member _.DateFormat((name, args), dateFormat) =
            let apply (args: OutputBlobArgs) =
                args.DateFormat <- io dateFormat
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: OutputBlobArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: OutputBlobArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("pathPattern")>]
        member _.PathPattern((name, args), pathPattern) =
            let apply (args: OutputBlobArgs) =
                args.PathPattern <- input pathPattern
                args

            ()
            name, List.Cons(apply, args)

        member _.PathPattern((name, args), pathPattern) =
            let apply (args: OutputBlobArgs) =
                args.PathPattern <- io pathPattern
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: OutputBlobArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: OutputBlobArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: OutputBlobArgs) =
                   args.Serialization <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("storageAccountKey")>]
        member _.StorageAccountKey((name, args), storageAccountKey) =
            let apply (args: OutputBlobArgs) =
                args.StorageAccountKey <- input storageAccountKey
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageAccountKey((name, args), storageAccountKey) =
            let apply (args: OutputBlobArgs) =
                args.StorageAccountKey <- io storageAccountKey
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageAccountName")>]
        member _.StorageAccountName((name, args), storageAccountName) =
            let apply (args: OutputBlobArgs) =
                args.StorageAccountName <- input storageAccountName
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageAccountName((name, args), storageAccountName) =
            let apply (args: OutputBlobArgs) =
                args.StorageAccountName <- io storageAccountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageContainerName")>]
        member _.StorageContainerName((name, args), storageContainerName) =
            let apply (args: OutputBlobArgs) =
                args.StorageContainerName <- input storageContainerName
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageContainerName((name, args), storageContainerName) =
            let apply (args: OutputBlobArgs) =
                args.StorageContainerName <- io storageContainerName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("streamAnalyticsJobName")>]
        member _.StreamAnalyticsJobName((name, args), streamAnalyticsJobName) =
            let apply (args: OutputBlobArgs) =
                args.StreamAnalyticsJobName <- input streamAnalyticsJobName
                args

            ()
            name, List.Cons(apply, args)

        member _.StreamAnalyticsJobName((name, args), streamAnalyticsJobName) =
            let apply (args: OutputBlobArgs) =
                args.StreamAnalyticsJobName <- io streamAnalyticsJobName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("timeFormat")>]
        member _.TimeFormat((name, args), timeFormat) =
            let apply (args: OutputBlobArgs) =
                args.TimeFormat <- input timeFormat
                args

            ()
            name, List.Cons(apply, args)

        member _.TimeFormat((name, args), timeFormat) =
            let apply (args: OutputBlobArgs) =
                args.TimeFormat <- io timeFormat
                args

            ()
            name, List.Cons(apply, args)

    let outputBlob = OutputBlobBuilder()

    type OutputEventHubBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            OutputEventHub(name, (List.fold func (OutputEventHubArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("eventhubName")>]
        member _.EventhubName((name, args), eventhubName) =
            let apply (args: OutputEventHubArgs) =
                args.EventhubName <- input eventhubName
                args

            ()
            name, List.Cons(apply, args)

        member _.EventhubName((name, args), eventhubName) =
            let apply (args: OutputEventHubArgs) =
                args.EventhubName <- io eventhubName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: OutputEventHubArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: OutputEventHubArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: OutputEventHubArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: OutputEventHubArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: OutputEventHubArgs) =
                   args.Serialization <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("servicebusNamespace")>]
        member _.ServicebusNamespace((name, args), servicebusNamespace) =
            let apply (args: OutputEventHubArgs) =
                args.ServicebusNamespace <- input servicebusNamespace
                args

            ()
            name, List.Cons(apply, args)

        member _.ServicebusNamespace((name, args), servicebusNamespace) =
            let apply (args: OutputEventHubArgs) =
                args.ServicebusNamespace <- io servicebusNamespace
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sharedAccessPolicyKey")>]
        member _.SharedAccessPolicyKey((name, args), sharedAccessPolicyKey) =
            let apply (args: OutputEventHubArgs) =
                args.SharedAccessPolicyKey <- input sharedAccessPolicyKey
                args

            ()
            name, List.Cons(apply, args)

        member _.SharedAccessPolicyKey((name, args), sharedAccessPolicyKey) =
            let apply (args: OutputEventHubArgs) =
                args.SharedAccessPolicyKey <- io sharedAccessPolicyKey
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sharedAccessPolicyName")>]
        member _.SharedAccessPolicyName((name, args), sharedAccessPolicyName) =
            let apply (args: OutputEventHubArgs) =
                args.SharedAccessPolicyName <- input sharedAccessPolicyName
                args

            ()
            name, List.Cons(apply, args)

        member _.SharedAccessPolicyName((name, args), sharedAccessPolicyName) =
            let apply (args: OutputEventHubArgs) =
                args.SharedAccessPolicyName <- io sharedAccessPolicyName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("streamAnalyticsJobName")>]
        member _.StreamAnalyticsJobName((name, args), streamAnalyticsJobName) =
            let apply (args: OutputEventHubArgs) =
                args.StreamAnalyticsJobName <- input streamAnalyticsJobName
                args

            ()
            name, List.Cons(apply, args)

        member _.StreamAnalyticsJobName((name, args), streamAnalyticsJobName) =
            let apply (args: OutputEventHubArgs) =
                args.StreamAnalyticsJobName <- io streamAnalyticsJobName
                args

            ()
            name, List.Cons(apply, args)

    let outputEventHub = OutputEventHubBuilder()

    type OutputMssqlBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            OutputMssql(name, (List.fold func (OutputMssqlArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("database")>]
        member _.Database((name, args), database) =
            let apply (args: OutputMssqlArgs) =
                args.Database <- input database
                args

            ()
            name, List.Cons(apply, args)

        member _.Database((name, args), database) =
            let apply (args: OutputMssqlArgs) =
                args.Database <- io database
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: OutputMssqlArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: OutputMssqlArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("password")>]
        member _.Password((name, args), password) =
            let apply (args: OutputMssqlArgs) =
                args.Password <- input password
                args

            ()
            name, List.Cons(apply, args)

        member _.Password((name, args), password) =
            let apply (args: OutputMssqlArgs) =
                args.Password <- io password
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: OutputMssqlArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: OutputMssqlArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("server")>]
        member _.Server((name, args), server) =
            let apply (args: OutputMssqlArgs) =
                args.Server <- input server
                args

            ()
            name, List.Cons(apply, args)

        member _.Server((name, args), server) =
            let apply (args: OutputMssqlArgs) =
                args.Server <- io server
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("streamAnalyticsJobName")>]
        member _.StreamAnalyticsJobName((name, args), streamAnalyticsJobName) =
            let apply (args: OutputMssqlArgs) =
                args.StreamAnalyticsJobName <- input streamAnalyticsJobName
                args

            ()
            name, List.Cons(apply, args)

        member _.StreamAnalyticsJobName((name, args), streamAnalyticsJobName) =
            let apply (args: OutputMssqlArgs) =
                args.StreamAnalyticsJobName <- io streamAnalyticsJobName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("table")>]
        member _.Table((name, args), table) =
            let apply (args: OutputMssqlArgs) =
                args.Table <- input table
                args

            ()
            name, List.Cons(apply, args)

        member _.Table((name, args), table) =
            let apply (args: OutputMssqlArgs) =
                args.Table <- io table
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("user")>]
        member _.User((name, args), user) =
            let apply (args: OutputMssqlArgs) =
                args.User <- input user
                args

            ()
            name, List.Cons(apply, args)

        member _.User((name, args), user) =
            let apply (args: OutputMssqlArgs) =
                args.User <- io user
                args

            ()
            name, List.Cons(apply, args)

    let outputMssql = OutputMssqlBuilder()

    type OutputServiceBusQueueBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            OutputServiceBusQueue(name, (List.fold func (OutputServiceBusQueueArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: OutputServiceBusQueueArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: OutputServiceBusQueueArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("queueName")>]
        member _.QueueName((name, args), queueName) =
            let apply (args: OutputServiceBusQueueArgs) =
                args.QueueName <- input queueName
                args

            ()
            name, List.Cons(apply, args)

        member _.QueueName((name, args), queueName) =
            let apply (args: OutputServiceBusQueueArgs) =
                args.QueueName <- io queueName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: OutputServiceBusQueueArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: OutputServiceBusQueueArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: OutputServiceBusQueueArgs) =
                   args.Serialization <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("servicebusNamespace")>]
        member _.ServicebusNamespace((name, args), servicebusNamespace) =
            let apply (args: OutputServiceBusQueueArgs) =
                args.ServicebusNamespace <- input servicebusNamespace
                args

            ()
            name, List.Cons(apply, args)

        member _.ServicebusNamespace((name, args), servicebusNamespace) =
            let apply (args: OutputServiceBusQueueArgs) =
                args.ServicebusNamespace <- io servicebusNamespace
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sharedAccessPolicyKey")>]
        member _.SharedAccessPolicyKey((name, args), sharedAccessPolicyKey) =
            let apply (args: OutputServiceBusQueueArgs) =
                args.SharedAccessPolicyKey <- input sharedAccessPolicyKey
                args

            ()
            name, List.Cons(apply, args)

        member _.SharedAccessPolicyKey((name, args), sharedAccessPolicyKey) =
            let apply (args: OutputServiceBusQueueArgs) =
                args.SharedAccessPolicyKey <- io sharedAccessPolicyKey
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sharedAccessPolicyName")>]
        member _.SharedAccessPolicyName((name, args), sharedAccessPolicyName) =
            let apply (args: OutputServiceBusQueueArgs) =
                args.SharedAccessPolicyName <- input sharedAccessPolicyName
                args

            ()
            name, List.Cons(apply, args)

        member _.SharedAccessPolicyName((name, args), sharedAccessPolicyName) =
            let apply (args: OutputServiceBusQueueArgs) =
                args.SharedAccessPolicyName <- io sharedAccessPolicyName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("streamAnalyticsJobName")>]
        member _.StreamAnalyticsJobName((name, args), streamAnalyticsJobName) =
            let apply (args: OutputServiceBusQueueArgs) =
                args.StreamAnalyticsJobName <- input streamAnalyticsJobName
                args

            ()
            name, List.Cons(apply, args)

        member _.StreamAnalyticsJobName((name, args), streamAnalyticsJobName) =
            let apply (args: OutputServiceBusQueueArgs) =
                args.StreamAnalyticsJobName <- io streamAnalyticsJobName
                args

            ()
            name, List.Cons(apply, args)

    let outputServiceBusQueue = OutputServiceBusQueueBuilder()

    type OutputServicebusTopicBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            OutputServicebusTopic(name, (List.fold func (OutputServicebusTopicArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: OutputServicebusTopicArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: OutputServicebusTopicArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: OutputServicebusTopicArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: OutputServicebusTopicArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: OutputServicebusTopicArgs) =
                   args.Serialization <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("servicebusNamespace")>]
        member _.ServicebusNamespace((name, args), servicebusNamespace) =
            let apply (args: OutputServicebusTopicArgs) =
                args.ServicebusNamespace <- input servicebusNamespace
                args

            ()
            name, List.Cons(apply, args)

        member _.ServicebusNamespace((name, args), servicebusNamespace) =
            let apply (args: OutputServicebusTopicArgs) =
                args.ServicebusNamespace <- io servicebusNamespace
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sharedAccessPolicyKey")>]
        member _.SharedAccessPolicyKey((name, args), sharedAccessPolicyKey) =
            let apply (args: OutputServicebusTopicArgs) =
                args.SharedAccessPolicyKey <- input sharedAccessPolicyKey
                args

            ()
            name, List.Cons(apply, args)

        member _.SharedAccessPolicyKey((name, args), sharedAccessPolicyKey) =
            let apply (args: OutputServicebusTopicArgs) =
                args.SharedAccessPolicyKey <- io sharedAccessPolicyKey
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sharedAccessPolicyName")>]
        member _.SharedAccessPolicyName((name, args), sharedAccessPolicyName) =
            let apply (args: OutputServicebusTopicArgs) =
                args.SharedAccessPolicyName <- input sharedAccessPolicyName
                args

            ()
            name, List.Cons(apply, args)

        member _.SharedAccessPolicyName((name, args), sharedAccessPolicyName) =
            let apply (args: OutputServicebusTopicArgs) =
                args.SharedAccessPolicyName <- io sharedAccessPolicyName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("streamAnalyticsJobName")>]
        member _.StreamAnalyticsJobName((name, args), streamAnalyticsJobName) =
            let apply (args: OutputServicebusTopicArgs) =
                args.StreamAnalyticsJobName <- input streamAnalyticsJobName
                args

            ()
            name, List.Cons(apply, args)

        member _.StreamAnalyticsJobName((name, args), streamAnalyticsJobName) =
            let apply (args: OutputServicebusTopicArgs) =
                args.StreamAnalyticsJobName <- io streamAnalyticsJobName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("topicName")>]
        member _.TopicName((name, args), topicName) =
            let apply (args: OutputServicebusTopicArgs) =
                args.TopicName <- input topicName
                args

            ()
            name, List.Cons(apply, args)

        member _.TopicName((name, args), topicName) =
            let apply (args: OutputServicebusTopicArgs) =
                args.TopicName <- io topicName
                args

            ()
            name, List.Cons(apply, args)

    let outputServicebusTopic = OutputServicebusTopicBuilder()

    type ReferenceInputBlobBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ReferenceInputBlob(name, (List.fold func (ReferenceInputBlobArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("dateFormat")>]
        member _.DateFormat((name, args), dateFormat) =
            let apply (args: ReferenceInputBlobArgs) =
                args.DateFormat <- input dateFormat
                args

            ()
            name, List.Cons(apply, args)

        member _.DateFormat((name, args), dateFormat) =
            let apply (args: ReferenceInputBlobArgs) =
                args.DateFormat <- io dateFormat
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ReferenceInputBlobArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ReferenceInputBlobArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("pathPattern")>]
        member _.PathPattern((name, args), pathPattern) =
            let apply (args: ReferenceInputBlobArgs) =
                args.PathPattern <- input pathPattern
                args

            ()
            name, List.Cons(apply, args)

        member _.PathPattern((name, args), pathPattern) =
            let apply (args: ReferenceInputBlobArgs) =
                args.PathPattern <- io pathPattern
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ReferenceInputBlobArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ReferenceInputBlobArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: ReferenceInputBlobArgs) =
                   args.Serialization <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("storageAccountKey")>]
        member _.StorageAccountKey((name, args), storageAccountKey) =
            let apply (args: ReferenceInputBlobArgs) =
                args.StorageAccountKey <- input storageAccountKey
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageAccountKey((name, args), storageAccountKey) =
            let apply (args: ReferenceInputBlobArgs) =
                args.StorageAccountKey <- io storageAccountKey
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageAccountName")>]
        member _.StorageAccountName((name, args), storageAccountName) =
            let apply (args: ReferenceInputBlobArgs) =
                args.StorageAccountName <- input storageAccountName
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageAccountName((name, args), storageAccountName) =
            let apply (args: ReferenceInputBlobArgs) =
                args.StorageAccountName <- io storageAccountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageContainerName")>]
        member _.StorageContainerName((name, args), storageContainerName) =
            let apply (args: ReferenceInputBlobArgs) =
                args.StorageContainerName <- input storageContainerName
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageContainerName((name, args), storageContainerName) =
            let apply (args: ReferenceInputBlobArgs) =
                args.StorageContainerName <- io storageContainerName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("streamAnalyticsJobName")>]
        member _.StreamAnalyticsJobName((name, args), streamAnalyticsJobName) =
            let apply (args: ReferenceInputBlobArgs) =
                args.StreamAnalyticsJobName <- input streamAnalyticsJobName
                args

            ()
            name, List.Cons(apply, args)

        member _.StreamAnalyticsJobName((name, args), streamAnalyticsJobName) =
            let apply (args: ReferenceInputBlobArgs) =
                args.StreamAnalyticsJobName <- io streamAnalyticsJobName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("timeFormat")>]
        member _.TimeFormat((name, args), timeFormat) =
            let apply (args: ReferenceInputBlobArgs) =
                args.TimeFormat <- input timeFormat
                args

            ()
            name, List.Cons(apply, args)

        member _.TimeFormat((name, args), timeFormat) =
            let apply (args: ReferenceInputBlobArgs) =
                args.TimeFormat <- io timeFormat
                args

            ()
            name, List.Cons(apply, args)

    let referenceInputBlob = ReferenceInputBlobBuilder()

    type StreamInputBlobBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            StreamInputBlob(name, (List.fold func (StreamInputBlobArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("dateFormat")>]
        member _.DateFormat((name, args), dateFormat) =
            let apply (args: StreamInputBlobArgs) =
                args.DateFormat <- input dateFormat
                args

            ()
            name, List.Cons(apply, args)

        member _.DateFormat((name, args), dateFormat) =
            let apply (args: StreamInputBlobArgs) =
                args.DateFormat <- io dateFormat
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: StreamInputBlobArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: StreamInputBlobArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("pathPattern")>]
        member _.PathPattern((name, args), pathPattern) =
            let apply (args: StreamInputBlobArgs) =
                args.PathPattern <- input pathPattern
                args

            ()
            name, List.Cons(apply, args)

        member _.PathPattern((name, args), pathPattern) =
            let apply (args: StreamInputBlobArgs) =
                args.PathPattern <- io pathPattern
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: StreamInputBlobArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: StreamInputBlobArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: StreamInputBlobArgs) =
                   args.Serialization <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("storageAccountKey")>]
        member _.StorageAccountKey((name, args), storageAccountKey) =
            let apply (args: StreamInputBlobArgs) =
                args.StorageAccountKey <- input storageAccountKey
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageAccountKey((name, args), storageAccountKey) =
            let apply (args: StreamInputBlobArgs) =
                args.StorageAccountKey <- io storageAccountKey
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageAccountName")>]
        member _.StorageAccountName((name, args), storageAccountName) =
            let apply (args: StreamInputBlobArgs) =
                args.StorageAccountName <- input storageAccountName
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageAccountName((name, args), storageAccountName) =
            let apply (args: StreamInputBlobArgs) =
                args.StorageAccountName <- io storageAccountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("storageContainerName")>]
        member _.StorageContainerName((name, args), storageContainerName) =
            let apply (args: StreamInputBlobArgs) =
                args.StorageContainerName <- input storageContainerName
                args

            ()
            name, List.Cons(apply, args)

        member _.StorageContainerName((name, args), storageContainerName) =
            let apply (args: StreamInputBlobArgs) =
                args.StorageContainerName <- io storageContainerName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("streamAnalyticsJobName")>]
        member _.StreamAnalyticsJobName((name, args), streamAnalyticsJobName) =
            let apply (args: StreamInputBlobArgs) =
                args.StreamAnalyticsJobName <- input streamAnalyticsJobName
                args

            ()
            name, List.Cons(apply, args)

        member _.StreamAnalyticsJobName((name, args), streamAnalyticsJobName) =
            let apply (args: StreamInputBlobArgs) =
                args.StreamAnalyticsJobName <- io streamAnalyticsJobName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("timeFormat")>]
        member _.TimeFormat((name, args), timeFormat) =
            let apply (args: StreamInputBlobArgs) =
                args.TimeFormat <- input timeFormat
                args

            ()
            name, List.Cons(apply, args)

        member _.TimeFormat((name, args), timeFormat) =
            let apply (args: StreamInputBlobArgs) =
                args.TimeFormat <- io timeFormat
                args

            ()
            name, List.Cons(apply, args)

    let streamInputBlob = StreamInputBlobBuilder()

    type StreamInputEventHubBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            StreamInputEventHub(name, (List.fold func (StreamInputEventHubArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("eventhubConsumerGroupName")>]
        member _.EventhubConsumerGroupName((name, args), eventhubConsumerGroupName) =
            let apply (args: StreamInputEventHubArgs) =
                args.EventhubConsumerGroupName <- input eventhubConsumerGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.EventhubConsumerGroupName((name, args), eventhubConsumerGroupName) =
            let apply (args: StreamInputEventHubArgs) =
                args.EventhubConsumerGroupName <- io eventhubConsumerGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("eventhubName")>]
        member _.EventhubName((name, args), eventhubName) =
            let apply (args: StreamInputEventHubArgs) =
                args.EventhubName <- input eventhubName
                args

            ()
            name, List.Cons(apply, args)

        member _.EventhubName((name, args), eventhubName) =
            let apply (args: StreamInputEventHubArgs) =
                args.EventhubName <- io eventhubName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: StreamInputEventHubArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: StreamInputEventHubArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: StreamInputEventHubArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: StreamInputEventHubArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: StreamInputEventHubArgs) =
                   args.Serialization <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("servicebusNamespace")>]
        member _.ServicebusNamespace((name, args), servicebusNamespace) =
            let apply (args: StreamInputEventHubArgs) =
                args.ServicebusNamespace <- input servicebusNamespace
                args

            ()
            name, List.Cons(apply, args)

        member _.ServicebusNamespace((name, args), servicebusNamespace) =
            let apply (args: StreamInputEventHubArgs) =
                args.ServicebusNamespace <- io servicebusNamespace
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sharedAccessPolicyKey")>]
        member _.SharedAccessPolicyKey((name, args), sharedAccessPolicyKey) =
            let apply (args: StreamInputEventHubArgs) =
                args.SharedAccessPolicyKey <- input sharedAccessPolicyKey
                args

            ()
            name, List.Cons(apply, args)

        member _.SharedAccessPolicyKey((name, args), sharedAccessPolicyKey) =
            let apply (args: StreamInputEventHubArgs) =
                args.SharedAccessPolicyKey <- io sharedAccessPolicyKey
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sharedAccessPolicyName")>]
        member _.SharedAccessPolicyName((name, args), sharedAccessPolicyName) =
            let apply (args: StreamInputEventHubArgs) =
                args.SharedAccessPolicyName <- input sharedAccessPolicyName
                args

            ()
            name, List.Cons(apply, args)

        member _.SharedAccessPolicyName((name, args), sharedAccessPolicyName) =
            let apply (args: StreamInputEventHubArgs) =
                args.SharedAccessPolicyName <- io sharedAccessPolicyName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("streamAnalyticsJobName")>]
        member _.StreamAnalyticsJobName((name, args), streamAnalyticsJobName) =
            let apply (args: StreamInputEventHubArgs) =
                args.StreamAnalyticsJobName <- input streamAnalyticsJobName
                args

            ()
            name, List.Cons(apply, args)

        member _.StreamAnalyticsJobName((name, args), streamAnalyticsJobName) =
            let apply (args: StreamInputEventHubArgs) =
                args.StreamAnalyticsJobName <- io streamAnalyticsJobName
                args

            ()
            name, List.Cons(apply, args)

    let streamInputEventHub = StreamInputEventHubBuilder()

    type StreamInputIotHubBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            StreamInputIotHub(name, (List.fold func (StreamInputIotHubArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("endpoint")>]
        member _.Endpoint((name, args), endpoint) =
            let apply (args: StreamInputIotHubArgs) =
                args.Endpoint <- input endpoint
                args

            ()
            name, List.Cons(apply, args)

        member _.Endpoint((name, args), endpoint) =
            let apply (args: StreamInputIotHubArgs) =
                args.Endpoint <- io endpoint
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("eventhubConsumerGroupName")>]
        member _.EventhubConsumerGroupName((name, args), eventhubConsumerGroupName) =
            let apply (args: StreamInputIotHubArgs) =
                args.EventhubConsumerGroupName <- input eventhubConsumerGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.EventhubConsumerGroupName((name, args), eventhubConsumerGroupName) =
            let apply (args: StreamInputIotHubArgs) =
                args.EventhubConsumerGroupName <- io eventhubConsumerGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("iothubNamespace")>]
        member _.IothubNamespace((name, args), iothubNamespace) =
            let apply (args: StreamInputIotHubArgs) =
                args.IothubNamespace <- input iothubNamespace
                args

            ()
            name, List.Cons(apply, args)

        member _.IothubNamespace((name, args), iothubNamespace) =
            let apply (args: StreamInputIotHubArgs) =
                args.IothubNamespace <- io iothubNamespace
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: StreamInputIotHubArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: StreamInputIotHubArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: StreamInputIotHubArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: StreamInputIotHubArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: StreamInputIotHubArgs) =
                   args.Serialization <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("sharedAccessPolicyKey")>]
        member _.SharedAccessPolicyKey((name, args), sharedAccessPolicyKey) =
            let apply (args: StreamInputIotHubArgs) =
                args.SharedAccessPolicyKey <- input sharedAccessPolicyKey
                args

            ()
            name, List.Cons(apply, args)

        member _.SharedAccessPolicyKey((name, args), sharedAccessPolicyKey) =
            let apply (args: StreamInputIotHubArgs) =
                args.SharedAccessPolicyKey <- io sharedAccessPolicyKey
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sharedAccessPolicyName")>]
        member _.SharedAccessPolicyName((name, args), sharedAccessPolicyName) =
            let apply (args: StreamInputIotHubArgs) =
                args.SharedAccessPolicyName <- input sharedAccessPolicyName
                args

            ()
            name, List.Cons(apply, args)

        member _.SharedAccessPolicyName((name, args), sharedAccessPolicyName) =
            let apply (args: StreamInputIotHubArgs) =
                args.SharedAccessPolicyName <- io sharedAccessPolicyName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("streamAnalyticsJobName")>]
        member _.StreamAnalyticsJobName((name, args), streamAnalyticsJobName) =
            let apply (args: StreamInputIotHubArgs) =
                args.StreamAnalyticsJobName <- input streamAnalyticsJobName
                args

            ()
            name, List.Cons(apply, args)

        member _.StreamAnalyticsJobName((name, args), streamAnalyticsJobName) =
            let apply (args: StreamInputIotHubArgs) =
                args.StreamAnalyticsJobName <- io streamAnalyticsJobName
                args

            ()
            name, List.Cons(apply, args)

    let streamInputIotHub = StreamInputIotHubBuilder()

module TrafficManager =
    open Pulumi.Azure.TrafficManager
    open Pulumi.Azure.TrafficManager.Inputs

    type EndpointCustomHeaderBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointCustomHeaderArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: EndpointCustomHeaderArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: EndpointCustomHeaderArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((n, args), value) =
            let apply (args: EndpointCustomHeaderArgs) =
                args.Value <- input value
                args

            ()
            n, List.Cons(apply, args)

        member _.Value((n, args), value) =
            let apply (args: EndpointCustomHeaderArgs) =
                args.Value <- io value
                args

            ()
            n, List.Cons(apply, args)

    let endpointCustomHeader = EndpointCustomHeaderBuilder()

    type EndpointSubnetBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (EndpointSubnetArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("first")>]
        member _.First((n, args), first) =
            let apply (args: EndpointSubnetArgs) =
                args.First <- input first
                args

            ()
            n, List.Cons(apply, args)

        member _.First((n, args), first) =
            let apply (args: EndpointSubnetArgs) =
                args.First <- io first
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("last")>]
        member _.Last((n, args), last) =
            let apply (args: EndpointSubnetArgs) =
                args.Last <- input last
                args

            ()
            n, List.Cons(apply, args)

        member _.Last((n, args), last) =
            let apply (args: EndpointSubnetArgs) =
                args.Last <- io last
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("scope")>]
        member _.Scope((n, args), scope) =
            let apply (args: EndpointSubnetArgs) =
                args.Scope <- input scope
                args

            ()
            n, List.Cons(apply, args)

        member _.Scope((n, args), scope) =
            let apply (args: EndpointSubnetArgs) =
                args.Scope <- io scope
                args

            ()
            n, List.Cons(apply, args)

    let endpointSubnet = EndpointSubnetBuilder()

    type ProfileDnsConfigBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ProfileDnsConfigArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("relativeName")>]
        member _.RelativeName((n, args), relativeName) =
            let apply (args: ProfileDnsConfigArgs) =
                args.RelativeName <- input relativeName
                args

            ()
            n, List.Cons(apply, args)

        member _.RelativeName((n, args), relativeName) =
            let apply (args: ProfileDnsConfigArgs) =
                args.RelativeName <- io relativeName
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ttl")>]
        member _.Ttl((n, args), ttl) =
            let apply (args: ProfileDnsConfigArgs) =
                args.Ttl <- input ttl
                args

            ()
            n, List.Cons(apply, args)

        member _.Ttl((n, args), ttl) =
            let apply (args: ProfileDnsConfigArgs) =
                args.Ttl <- io ttl
                args

            ()
            n, List.Cons(apply, args)

    let profileDnsConfig = ProfileDnsConfigBuilder()

    type ProfileMonitorConfigBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ProfileMonitorConfigArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("customHeaders")>]
        member _.CustomHeaders((n, args), customHeaders) =
            let apply (args: ProfileMonitorConfigArgs) =
                args.CustomHeaders <- inputList customHeaders
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("expectedStatusCodeRanges")>]
        member _.ExpectedStatusCodeRanges((n, args), expectedStatusCodeRanges) =
            let apply (args: ProfileMonitorConfigArgs) =
                args.ExpectedStatusCodeRanges <- inputList expectedStatusCodeRanges
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("intervalInSeconds")>]
        member _.IntervalInSeconds((n, args), intervalInSeconds) =
            let apply (args: ProfileMonitorConfigArgs) =
                args.IntervalInSeconds <- input intervalInSeconds
                args

            ()
            n, List.Cons(apply, args)

        member _.IntervalInSeconds((n, args), intervalInSeconds) =
            let apply (args: ProfileMonitorConfigArgs) =
                args.IntervalInSeconds <- io intervalInSeconds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("path")>]
        member _.Path((n, args), path) =
            let apply (args: ProfileMonitorConfigArgs) =
                args.Path <- input path
                args

            ()
            n, List.Cons(apply, args)

        member _.Path((n, args), path) =
            let apply (args: ProfileMonitorConfigArgs) =
                args.Path <- io path
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("port")>]
        member _.Port((n, args), port) =
            let apply (args: ProfileMonitorConfigArgs) =
                args.Port <- input port
                args

            ()
            n, List.Cons(apply, args)

        member _.Port((n, args), port) =
            let apply (args: ProfileMonitorConfigArgs) =
                args.Port <- io port
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("protocol")>]
        member _.Protocol((n, args), protocol) =
            let apply (args: ProfileMonitorConfigArgs) =
                args.Protocol <- input protocol
                args

            ()
            n, List.Cons(apply, args)

        member _.Protocol((n, args), protocol) =
            let apply (args: ProfileMonitorConfigArgs) =
                args.Protocol <- io protocol
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("timeoutInSeconds")>]
        member _.TimeoutInSeconds((n, args), timeoutInSeconds) =
            let apply (args: ProfileMonitorConfigArgs) =
                args.TimeoutInSeconds <- input timeoutInSeconds
                args

            ()
            n, List.Cons(apply, args)

        member _.TimeoutInSeconds((n, args), timeoutInSeconds) =
            let apply (args: ProfileMonitorConfigArgs) =
                args.TimeoutInSeconds <- io timeoutInSeconds
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("toleratedNumberOfFailures")>]
        member _.ToleratedNumberOfFailures((n, args), toleratedNumberOfFailures) =
            let apply (args: ProfileMonitorConfigArgs) =
                args.ToleratedNumberOfFailures <- input toleratedNumberOfFailures
                args

            ()
            n, List.Cons(apply, args)

        member _.ToleratedNumberOfFailures((n, args), toleratedNumberOfFailures) =
            let apply (args: ProfileMonitorConfigArgs) =
                args.ToleratedNumberOfFailures <- io toleratedNumberOfFailures
                args

            ()
            n, List.Cons(apply, args)

    let profileMonitorConfig = ProfileMonitorConfigBuilder()

    type ProfileMonitorConfigCustomHeaderBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (ProfileMonitorConfigCustomHeaderArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: ProfileMonitorConfigCustomHeaderArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: ProfileMonitorConfigCustomHeaderArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("value")>]
        member _.Value((n, args), value) =
            let apply (args: ProfileMonitorConfigCustomHeaderArgs) =
                args.Value <- input value
                args

            ()
            n, List.Cons(apply, args)

        member _.Value((n, args), value) =
            let apply (args: ProfileMonitorConfigCustomHeaderArgs) =
                args.Value <- io value
                args

            ()
            n, List.Cons(apply, args)

    let profileMonitorConfigCustomHeader =
        ProfileMonitorConfigCustomHeaderBuilder()

    type EndpointBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Endpoint(name, (List.fold func (EndpointArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("customHeaders")>]
        member _.CustomHeaders((name, args), customHeaders) =
            let apply (args: EndpointArgs) =
                args.CustomHeaders <- inputList customHeaders
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("endpointLocation")>]
        member _.EndpointLocation((name, args), endpointLocation) =
            let apply (args: EndpointArgs) =
                args.EndpointLocation <- input endpointLocation
                args

            ()
            name, List.Cons(apply, args)

        member _.EndpointLocation((name, args), endpointLocation) =
            let apply (args: EndpointArgs) =
                args.EndpointLocation <- io endpointLocation
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("endpointStatus")>]
        member _.EndpointStatus((name, args), endpointStatus) =
            let apply (args: EndpointArgs) =
                args.EndpointStatus <- input endpointStatus
                args

            ()
            name, List.Cons(apply, args)

        member _.EndpointStatus((name, args), endpointStatus) =
            let apply (args: EndpointArgs) =
                args.EndpointStatus <- io endpointStatus
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("geoMappings")>]
        member _.GeoMappings((name, args), geoMappings) =
            let apply (args: EndpointArgs) =
                args.GeoMappings <- inputList geoMappings
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("minChildEndpoints")>]
        member _.MinChildEndpoints((name, args), minChildEndpoints) =
            let apply (args: EndpointArgs) =
                args.MinChildEndpoints <- input minChildEndpoints
                args

            ()
            name, List.Cons(apply, args)

        member _.MinChildEndpoints((name, args), minChildEndpoints) =
            let apply (args: EndpointArgs) =
                args.MinChildEndpoints <- io minChildEndpoints
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: EndpointArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: EndpointArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("priority")>]
        member _.Priority((name, args), priority) =
            let apply (args: EndpointArgs) =
                args.Priority <- input priority
                args

            ()
            name, List.Cons(apply, args)

        member _.Priority((name, args), priority) =
            let apply (args: EndpointArgs) =
                args.Priority <- io priority
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("profileName")>]
        member _.ProfileName((name, args), profileName) =
            let apply (args: EndpointArgs) =
                args.ProfileName <- input profileName
                args

            ()
            name, List.Cons(apply, args)

        member _.ProfileName((name, args), profileName) =
            let apply (args: EndpointArgs) =
                args.ProfileName <- io profileName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: EndpointArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: EndpointArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("subnets")>]
        member _.Subnets((name, args), subnets) =
            let apply (args: EndpointArgs) =
                args.Subnets <- inputList subnets
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("target")>]
        member _.Target((name, args), target) =
            let apply (args: EndpointArgs) =
                args.Target <- input target
                args

            ()
            name, List.Cons(apply, args)

        member _.Target((name, args), target) =
            let apply (args: EndpointArgs) =
                args.Target <- io target
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("targetResourceId")>]
        member _.TargetResourceId((name, args), targetResourceId) =
            let apply (args: EndpointArgs) =
                args.TargetResourceId <- input targetResourceId
                args

            ()
            name, List.Cons(apply, args)

        member _.TargetResourceId((name, args), targetResourceId) =
            let apply (args: EndpointArgs) =
                args.TargetResourceId <- io targetResourceId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((name, args), ``type``) =
            let apply (args: EndpointArgs) =
                args.Type <- input ``type``
                args

            ()
            name, List.Cons(apply, args)

        member _.Type((name, args), ``type``) =
            let apply (args: EndpointArgs) =
                args.Type <- io ``type``
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("weight")>]
        member _.Weight((name, args), weight) =
            let apply (args: EndpointArgs) =
                args.Weight <- input weight
                args

            ()
            name, List.Cons(apply, args)

        member _.Weight((name, args), weight) =
            let apply (args: EndpointArgs) =
                args.Weight <- io weight
                args

            ()
            name, List.Cons(apply, args)

    let endpoint = EndpointBuilder()

    type ProfileBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Profile(name, (List.fold func (ProfileArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        member _.Yield arg =
            null,
            [ (
               let func (args: ProfileArgs) =
                   args.DnsConfig <- input arg
                   args

               ()
               func) ]

        member _.Yield arg =
            null,
            [ (
               let func (args: ProfileArgs) =
                   args.MonitorConfig <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ProfileArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ProfileArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("profileStatus")>]
        member _.ProfileStatus((name, args), profileStatus) =
            let apply (args: ProfileArgs) =
                args.ProfileStatus <- input profileStatus
                args

            ()
            name, List.Cons(apply, args)

        member _.ProfileStatus((name, args), profileStatus) =
            let apply (args: ProfileArgs) =
                args.ProfileStatus <- io profileStatus
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ProfileArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ProfileArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ProfileArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("trafficRoutingMethod")>]
        member _.TrafficRoutingMethod((name, args), trafficRoutingMethod) =
            let apply (args: ProfileArgs) =
                args.TrafficRoutingMethod <- input trafficRoutingMethod
                args

            ()
            name, List.Cons(apply, args)

        member _.TrafficRoutingMethod((name, args), trafficRoutingMethod) =
            let apply (args: ProfileArgs) =
                args.TrafficRoutingMethod <- io trafficRoutingMethod
                args

            ()
            name, List.Cons(apply, args)

    let profile = ProfileBuilder()

module Waf =
    open Pulumi.Azure.Waf
    open Pulumi.Azure.Waf.Inputs

    type PolicyCustomRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (PolicyCustomRuleArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("action")>]
        member _.Action((n, args), action) =
            let apply (args: PolicyCustomRuleArgs) =
                args.Action <- input action
                args

            ()
            n, List.Cons(apply, args)

        member _.Action((n, args), action) =
            let apply (args: PolicyCustomRuleArgs) =
                args.Action <- io action
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("matchConditions")>]
        member _.MatchConditions((n, args), matchConditions) =
            let apply (args: PolicyCustomRuleArgs) =
                args.MatchConditions <- inputList matchConditions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("name")>]
        member _.Name((n, args), name) =
            let apply (args: PolicyCustomRuleArgs) =
                args.Name <- input name
                args

            ()
            n, List.Cons(apply, args)

        member _.Name((n, args), name) =
            let apply (args: PolicyCustomRuleArgs) =
                args.Name <- io name
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("priority")>]
        member _.Priority((n, args), priority) =
            let apply (args: PolicyCustomRuleArgs) =
                args.Priority <- input priority
                args

            ()
            n, List.Cons(apply, args)

        member _.Priority((n, args), priority) =
            let apply (args: PolicyCustomRuleArgs) =
                args.Priority <- io priority
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ruleType")>]
        member _.RuleType((n, args), ruleType) =
            let apply (args: PolicyCustomRuleArgs) =
                args.RuleType <- input ruleType
                args

            ()
            n, List.Cons(apply, args)

        member _.RuleType((n, args), ruleType) =
            let apply (args: PolicyCustomRuleArgs) =
                args.RuleType <- io ruleType
                args

            ()
            n, List.Cons(apply, args)

    let policyCustomRule = PolicyCustomRuleBuilder()

    type PolicyCustomRuleMatchConditionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (PolicyCustomRuleMatchConditionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("matchValues")>]
        member _.MatchValues((n, args), matchValues) =
            let apply (args: PolicyCustomRuleMatchConditionArgs) =
                args.MatchValues <- inputList matchValues
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("matchVariables")>]
        member _.MatchVariables((n, args), matchVariables) =
            let apply (args: PolicyCustomRuleMatchConditionArgs) =
                args.MatchVariables <- inputList matchVariables
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("negationCondition")>]
        member _.NegationCondition((n, args), negationCondition) =
            let apply (args: PolicyCustomRuleMatchConditionArgs) =
                args.NegationCondition <- input negationCondition
                args

            ()
            n, List.Cons(apply, args)

        member _.NegationCondition((n, args), negationCondition) =
            let apply (args: PolicyCustomRuleMatchConditionArgs) =
                args.NegationCondition <- io negationCondition
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("operator")>]
        member _.Operator((n, args), operator) =
            let apply (args: PolicyCustomRuleMatchConditionArgs) =
                args.Operator <- input operator
                args

            ()
            n, List.Cons(apply, args)

        member _.Operator((n, args), operator) =
            let apply (args: PolicyCustomRuleMatchConditionArgs) =
                args.Operator <- io operator
                args

            ()
            n, List.Cons(apply, args)

    let policyCustomRuleMatchCondition = PolicyCustomRuleMatchConditionBuilder()

    type PolicyCustomRuleMatchConditionMatchVariableBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (PolicyCustomRuleMatchConditionMatchVariableArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("selector")>]
        member _.Selector((n, args), selector) =
            let apply (args: PolicyCustomRuleMatchConditionMatchVariableArgs) =
                args.Selector <- input selector
                args

            ()
            n, List.Cons(apply, args)

        member _.Selector((n, args), selector) =
            let apply (args: PolicyCustomRuleMatchConditionMatchVariableArgs) =
                args.Selector <- io selector
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("variableName")>]
        member _.VariableName((n, args), variableName) =
            let apply (args: PolicyCustomRuleMatchConditionMatchVariableArgs) =
                args.VariableName <- input variableName
                args

            ()
            n, List.Cons(apply, args)

        member _.VariableName((n, args), variableName) =
            let apply (args: PolicyCustomRuleMatchConditionMatchVariableArgs) =
                args.VariableName <- io variableName
                args

            ()
            n, List.Cons(apply, args)

    let policyCustomRuleMatchConditionMatchVariable =
        PolicyCustomRuleMatchConditionMatchVariableBuilder()

    type PolicyManagedRulesBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (PolicyManagedRulesArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("exclusions")>]
        member _.Exclusions((n, args), exclusions) =
            let apply (args: PolicyManagedRulesArgs) =
                args.Exclusions <- inputList exclusions
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("managedRuleSets")>]
        member _.ManagedRuleSets((n, args), managedRuleSets) =
            let apply (args: PolicyManagedRulesArgs) =
                args.ManagedRuleSets <- inputList managedRuleSets
                args

            ()
            n, List.Cons(apply, args)

    let policyManagedRules = PolicyManagedRulesBuilder()

    type PolicyManagedRulesExclusionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (PolicyManagedRulesExclusionArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("matchVariable")>]
        member _.MatchVariable((n, args), matchVariable) =
            let apply (args: PolicyManagedRulesExclusionArgs) =
                args.MatchVariable <- input matchVariable
                args

            ()
            n, List.Cons(apply, args)

        member _.MatchVariable((n, args), matchVariable) =
            let apply (args: PolicyManagedRulesExclusionArgs) =
                args.MatchVariable <- io matchVariable
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("selector")>]
        member _.Selector((n, args), selector) =
            let apply (args: PolicyManagedRulesExclusionArgs) =
                args.Selector <- input selector
                args

            ()
            n, List.Cons(apply, args)

        member _.Selector((n, args), selector) =
            let apply (args: PolicyManagedRulesExclusionArgs) =
                args.Selector <- io selector
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("selectorMatchOperator")>]
        member _.SelectorMatchOperator((n, args), selectorMatchOperator) =
            let apply (args: PolicyManagedRulesExclusionArgs) =
                args.SelectorMatchOperator <- input selectorMatchOperator
                args

            ()
            n, List.Cons(apply, args)

        member _.SelectorMatchOperator((n, args), selectorMatchOperator) =
            let apply (args: PolicyManagedRulesExclusionArgs) =
                args.SelectorMatchOperator <- io selectorMatchOperator
                args

            ()
            n, List.Cons(apply, args)

    let policyManagedRulesExclusion = PolicyManagedRulesExclusionBuilder()

    type PolicyManagedRulesManagedRuleSetBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (PolicyManagedRulesManagedRuleSetArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("ruleGroupOverrides")>]
        member _.RuleGroupOverrides((n, args), ruleGroupOverrides) =
            let apply (args: PolicyManagedRulesManagedRuleSetArgs) =
                args.RuleGroupOverrides <- inputList ruleGroupOverrides
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((n, args), ``type``) =
            let apply (args: PolicyManagedRulesManagedRuleSetArgs) =
                args.Type <- input ``type``
                args

            ()
            n, List.Cons(apply, args)

        member _.Type((n, args), ``type``) =
            let apply (args: PolicyManagedRulesManagedRuleSetArgs) =
                args.Type <- io ``type``
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("version")>]
        member _.Version((n, args), version) =
            let apply (args: PolicyManagedRulesManagedRuleSetArgs) =
                args.Version <- input version
                args

            ()
            n, List.Cons(apply, args)

        member _.Version((n, args), version) =
            let apply (args: PolicyManagedRulesManagedRuleSetArgs) =
                args.Version <- io version
                args

            ()
            n, List.Cons(apply, args)

    let policyManagedRulesManagedRuleSet =
        PolicyManagedRulesManagedRuleSetBuilder()

    type PolicyManagedRulesManagedRuleSetRuleGroupOverrideBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (PolicyManagedRulesManagedRuleSetRuleGroupOverrideArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("disabledRules")>]
        member _.DisabledRules((n, args), disabledRules) =
            let apply (args: PolicyManagedRulesManagedRuleSetRuleGroupOverrideArgs) =
                args.DisabledRules <- inputList disabledRules
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("ruleGroupName")>]
        member _.RuleGroupName((n, args), ruleGroupName) =
            let apply (args: PolicyManagedRulesManagedRuleSetRuleGroupOverrideArgs) =
                args.RuleGroupName <- input ruleGroupName
                args

            ()
            n, List.Cons(apply, args)

        member _.RuleGroupName((n, args), ruleGroupName) =
            let apply (args: PolicyManagedRulesManagedRuleSetRuleGroupOverrideArgs) =
                args.RuleGroupName <- io ruleGroupName
                args

            ()
            n, List.Cons(apply, args)

    let policyManagedRulesManagedRuleSetRuleGroupOverride =
        PolicyManagedRulesManagedRuleSetRuleGroupOverrideBuilder()

    type PolicyPolicySettingsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(_, args) =
            let func args f = f args
            ()
            List.fold func (PolicyPolicySettingsArgs()) args

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("enabled")>]
        member _.Enabled((n, args), enabled) =
            let apply (args: PolicyPolicySettingsArgs) =
                args.Enabled <- input enabled
                args

            ()
            n, List.Cons(apply, args)

        member _.Enabled((n, args), enabled) =
            let apply (args: PolicyPolicySettingsArgs) =
                args.Enabled <- io enabled
                args

            ()
            n, List.Cons(apply, args)

        [<CustomOperation("mode")>]
        member _.Mode((n, args), mode) =
            let apply (args: PolicyPolicySettingsArgs) =
                args.Mode <- input mode
                args

            ()
            n, List.Cons(apply, args)

        member _.Mode((n, args), mode) =
            let apply (args: PolicyPolicySettingsArgs) =
                args.Mode <- io mode
                args

            ()
            n, List.Cons(apply, args)

    let policyPolicySettings = PolicyPolicySettingsBuilder()

    type PolicyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Policy(name, (List.fold func (PolicyArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("customRules")>]
        member _.CustomRules((name, args), customRules) =
            let apply (args: PolicyArgs) =
                args.CustomRules <- inputList customRules
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: PolicyArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: PolicyArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: PolicyArgs) =
                   args.ManagedRules <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: PolicyArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: PolicyArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.Yield arg =
            null,
            [ (
               let func (args: PolicyArgs) =
                   args.PolicySettings <- input arg
                   args

               ()
               func) ]

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: PolicyArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: PolicyArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: PolicyArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let policy = PolicyBuilder()

module AppInsights =
    open Pulumi.Azure.AppInsights

    type AnalyticsItemBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            AnalyticsItem(name, (List.fold func (AnalyticsItemArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("applicationInsightsId")>]
        member _.ApplicationInsightsId((name, args), applicationInsightsId) =
            let apply (args: AnalyticsItemArgs) =
                args.ApplicationInsightsId <- input applicationInsightsId
                args

            ()
            name, List.Cons(apply, args)

        member _.ApplicationInsightsId((name, args), applicationInsightsId) =
            let apply (args: AnalyticsItemArgs) =
                args.ApplicationInsightsId <- io applicationInsightsId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("content")>]
        member _.Content((name, args), content) =
            let apply (args: AnalyticsItemArgs) =
                args.Content <- input content
                args

            ()
            name, List.Cons(apply, args)

        member _.Content((name, args), content) =
            let apply (args: AnalyticsItemArgs) =
                args.Content <- io content
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("functionAlias")>]
        member _.FunctionAlias((name, args), functionAlias) =
            let apply (args: AnalyticsItemArgs) =
                args.FunctionAlias <- input functionAlias
                args

            ()
            name, List.Cons(apply, args)

        member _.FunctionAlias((name, args), functionAlias) =
            let apply (args: AnalyticsItemArgs) =
                args.FunctionAlias <- io functionAlias
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: AnalyticsItemArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: AnalyticsItemArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("scope")>]
        member _.Scope((name, args), scope) =
            let apply (args: AnalyticsItemArgs) =
                args.Scope <- input scope
                args

            ()
            name, List.Cons(apply, args)

        member _.Scope((name, args), scope) =
            let apply (args: AnalyticsItemArgs) =
                args.Scope <- io scope
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("type")>]
        member _.Type((name, args), ``type``) =
            let apply (args: AnalyticsItemArgs) =
                args.Type <- input ``type``
                args

            ()
            name, List.Cons(apply, args)

        member _.Type((name, args), ``type``) =
            let apply (args: AnalyticsItemArgs) =
                args.Type <- io ``type``
                args

            ()
            name, List.Cons(apply, args)

    let analyticsItem = AnalyticsItemBuilder()

    type ApiKeyBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ApiKey(name, (List.fold func (ApiKeyArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("applicationInsightsId")>]
        member _.ApplicationInsightsId((name, args), applicationInsightsId) =
            let apply (args: ApiKeyArgs) =
                args.ApplicationInsightsId <- input applicationInsightsId
                args

            ()
            name, List.Cons(apply, args)

        member _.ApplicationInsightsId((name, args), applicationInsightsId) =
            let apply (args: ApiKeyArgs) =
                args.ApplicationInsightsId <- io applicationInsightsId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ApiKeyArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ApiKeyArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("readPermissions")>]
        member _.ReadPermissions((name, args), readPermissions) =
            let apply (args: ApiKeyArgs) =
                args.ReadPermissions <- inputList readPermissions
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("writePermissions")>]
        member _.WritePermissions((name, args), writePermissions) =
            let apply (args: ApiKeyArgs) =
                args.WritePermissions <- inputList writePermissions
                args

            ()
            name, List.Cons(apply, args)

    let apiKey = ApiKeyBuilder()

    type InsightsBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Insights(name, (List.fold func (InsightsArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("applicationType")>]
        member _.ApplicationType((name, args), applicationType) =
            let apply (args: InsightsArgs) =
                args.ApplicationType <- input applicationType
                args

            ()
            name, List.Cons(apply, args)

        member _.ApplicationType((name, args), applicationType) =
            let apply (args: InsightsArgs) =
                args.ApplicationType <- io applicationType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("dailyDataCapInGb")>]
        member _.DailyDataCapInGb((name, args), dailyDataCapInGb) =
            let apply (args: InsightsArgs) =
                args.DailyDataCapInGb <- input dailyDataCapInGb
                args

            ()
            name, List.Cons(apply, args)

        member _.DailyDataCapInGb((name, args), dailyDataCapInGb) =
            let apply (args: InsightsArgs) =
                args.DailyDataCapInGb <- io dailyDataCapInGb
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("dailyDataCapNotificationsDisabled")>]
        member _.DailyDataCapNotificationsDisabled((name, args), dailyDataCapNotificationsDisabled) =
            let apply (args: InsightsArgs) =
                args.DailyDataCapNotificationsDisabled <- input dailyDataCapNotificationsDisabled
                args

            ()
            name, List.Cons(apply, args)

        member _.DailyDataCapNotificationsDisabled((name, args), dailyDataCapNotificationsDisabled) =
            let apply (args: InsightsArgs) =
                args.DailyDataCapNotificationsDisabled <- io dailyDataCapNotificationsDisabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("disableIpMasking")>]
        member _.DisableIpMasking((name, args), disableIpMasking) =
            let apply (args: InsightsArgs) =
                args.DisableIpMasking <- input disableIpMasking
                args

            ()
            name, List.Cons(apply, args)

        member _.DisableIpMasking((name, args), disableIpMasking) =
            let apply (args: InsightsArgs) =
                args.DisableIpMasking <- io disableIpMasking
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: InsightsArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: InsightsArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: InsightsArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: InsightsArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: InsightsArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: InsightsArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("retentionInDays")>]
        member _.RetentionInDays((name, args), retentionInDays) =
            let apply (args: InsightsArgs) =
                args.RetentionInDays <- input retentionInDays
                args

            ()
            name, List.Cons(apply, args)

        member _.RetentionInDays((name, args), retentionInDays) =
            let apply (args: InsightsArgs) =
                args.RetentionInDays <- io retentionInDays
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("samplingPercentage")>]
        member _.SamplingPercentage((name, args), samplingPercentage) =
            let apply (args: InsightsArgs) =
                args.SamplingPercentage <- input samplingPercentage
                args

            ()
            name, List.Cons(apply, args)

        member _.SamplingPercentage((name, args), samplingPercentage) =
            let apply (args: InsightsArgs) =
                args.SamplingPercentage <- io samplingPercentage
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: InsightsArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let insights = InsightsBuilder()

    type WebTestBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            WebTest(name, (List.fold func (WebTestArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("applicationInsightsId")>]
        member _.ApplicationInsightsId((name, args), applicationInsightsId) =
            let apply (args: WebTestArgs) =
                args.ApplicationInsightsId <- input applicationInsightsId
                args

            ()
            name, List.Cons(apply, args)

        member _.ApplicationInsightsId((name, args), applicationInsightsId) =
            let apply (args: WebTestArgs) =
                args.ApplicationInsightsId <- io applicationInsightsId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("configuration")>]
        member _.Configuration((name, args), configuration) =
            let apply (args: WebTestArgs) =
                args.Configuration <- input configuration
                args

            ()
            name, List.Cons(apply, args)

        member _.Configuration((name, args), configuration) =
            let apply (args: WebTestArgs) =
                args.Configuration <- io configuration
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: WebTestArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: WebTestArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((name, args), enabled) =
            let apply (args: WebTestArgs) =
                args.Enabled <- input enabled
                args

            ()
            name, List.Cons(apply, args)

        member _.Enabled((name, args), enabled) =
            let apply (args: WebTestArgs) =
                args.Enabled <- io enabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("frequency")>]
        member _.Frequency((name, args), frequency) =
            let apply (args: WebTestArgs) =
                args.Frequency <- input frequency
                args

            ()
            name, List.Cons(apply, args)

        member _.Frequency((name, args), frequency) =
            let apply (args: WebTestArgs) =
                args.Frequency <- io frequency
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("geoLocations")>]
        member _.GeoLocations((name, args), geoLocations) =
            let apply (args: WebTestArgs) =
                args.GeoLocations <- inputList geoLocations
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("kind")>]
        member _.Kind((name, args), kind) =
            let apply (args: WebTestArgs) =
                args.Kind <- input kind
                args

            ()
            name, List.Cons(apply, args)

        member _.Kind((name, args), kind) =
            let apply (args: WebTestArgs) =
                args.Kind <- io kind
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: WebTestArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: WebTestArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: WebTestArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: WebTestArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: WebTestArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: WebTestArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("retryEnabled")>]
        member _.RetryEnabled((name, args), retryEnabled) =
            let apply (args: WebTestArgs) =
                args.RetryEnabled <- input retryEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.RetryEnabled((name, args), retryEnabled) =
            let apply (args: WebTestArgs) =
                args.RetryEnabled <- io retryEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: WebTestArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("timeout")>]
        member _.Timeout((name, args), timeout) =
            let apply (args: WebTestArgs) =
                args.Timeout <- input timeout
                args

            ()
            name, List.Cons(apply, args)

        member _.Timeout((name, args), timeout) =
            let apply (args: WebTestArgs) =
                args.Timeout <- io timeout
                args

            ()
            name, List.Cons(apply, args)

    let webTest = WebTestBuilder()

module Cognitive =
    open Pulumi.Azure.Cognitive

    type AccountBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Account(name, (List.fold func (AccountArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("kind")>]
        member _.Kind((name, args), kind) =
            let apply (args: AccountArgs) =
                args.Kind <- input kind
                args

            ()
            name, List.Cons(apply, args)

        member _.Kind((name, args), kind) =
            let apply (args: AccountArgs) =
                args.Kind <- io kind
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: AccountArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: AccountArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: AccountArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: AccountArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("qnaRuntimeEndpoint")>]
        member _.QnaRuntimeEndpoint((name, args), qnaRuntimeEndpoint) =
            let apply (args: AccountArgs) =
                args.QnaRuntimeEndpoint <- input qnaRuntimeEndpoint
                args

            ()
            name, List.Cons(apply, args)

        member _.QnaRuntimeEndpoint((name, args), qnaRuntimeEndpoint) =
            let apply (args: AccountArgs) =
                args.QnaRuntimeEndpoint <- io qnaRuntimeEndpoint
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AccountArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AccountArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("skuName")>]
        member _.SkuName((name, args), skuName) =
            let apply (args: AccountArgs) =
                args.SkuName <- input skuName
                args

            ()
            name, List.Cons(apply, args)

        member _.SkuName((name, args), skuName) =
            let apply (args: AccountArgs) =
                args.SkuName <- io skuName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: AccountArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let account = AccountBuilder()

module Dashboard =
    open Pulumi.Azure.Dashboard

    type DashboardBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Dashboard(name, (List.fold func (DashboardArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("dashboardProperties")>]
        member _.DashboardProperties((name, args), dashboardProperties) =
            let apply (args: DashboardArgs) =
                args.DashboardProperties <- input dashboardProperties
                args

            ()
            name, List.Cons(apply, args)

        member _.DashboardProperties((name, args), dashboardProperties) =
            let apply (args: DashboardArgs) =
                args.DashboardProperties <- io dashboardProperties
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: DashboardArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: DashboardArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: DashboardArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: DashboardArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DashboardArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DashboardArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: DashboardArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let dashboard = DashboardBuilder()

module DatabaseMigration =
    open Pulumi.Azure.DatabaseMigration

    type ProjectBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Project(name, (List.fold func (ProjectArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ProjectArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ProjectArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ProjectArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ProjectArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ProjectArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ProjectArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("serviceName")>]
        member _.ServiceName((name, args), serviceName) =
            let apply (args: ProjectArgs) =
                args.ServiceName <- input serviceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ServiceName((name, args), serviceName) =
            let apply (args: ProjectArgs) =
                args.ServiceName <- io serviceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sourcePlatform")>]
        member _.SourcePlatform((name, args), sourcePlatform) =
            let apply (args: ProjectArgs) =
                args.SourcePlatform <- input sourcePlatform
                args

            ()
            name, List.Cons(apply, args)

        member _.SourcePlatform((name, args), sourcePlatform) =
            let apply (args: ProjectArgs) =
                args.SourcePlatform <- io sourcePlatform
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ProjectArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("targetPlatform")>]
        member _.TargetPlatform((name, args), targetPlatform) =
            let apply (args: ProjectArgs) =
                args.TargetPlatform <- input targetPlatform
                args

            ()
            name, List.Cons(apply, args)

        member _.TargetPlatform((name, args), targetPlatform) =
            let apply (args: ProjectArgs) =
                args.TargetPlatform <- io targetPlatform
                args

            ()
            name, List.Cons(apply, args)

    let project = ProjectBuilder()

    type ServiceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Service(name, (List.fold func (ServiceArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ServiceArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ServiceArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ServiceArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ServiceArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ServiceArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ServiceArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("skuName")>]
        member _.SkuName((name, args), skuName) =
            let apply (args: ServiceArgs) =
                args.SkuName <- input skuName
                args

            ()
            name, List.Cons(apply, args)

        member _.SkuName((name, args), skuName) =
            let apply (args: ServiceArgs) =
                args.SkuName <- io skuName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("subnetId")>]
        member _.SubnetId((name, args), subnetId) =
            let apply (args: ServiceArgs) =
                args.SubnetId <- input subnetId
                args

            ()
            name, List.Cons(apply, args)

        member _.SubnetId((name, args), subnetId) =
            let apply (args: ServiceArgs) =
                args.SubnetId <- io subnetId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ServiceArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let service = ServiceBuilder()

module DataLake =
    open Pulumi.Azure.DataLake

    type AnalyticsAccountBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            AnalyticsAccount(name, (List.fold func (AnalyticsAccountArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("defaultStoreAccountName")>]
        member _.DefaultStoreAccountName((name, args), defaultStoreAccountName) =
            let apply (args: AnalyticsAccountArgs) =
                args.DefaultStoreAccountName <- input defaultStoreAccountName
                args

            ()
            name, List.Cons(apply, args)

        member _.DefaultStoreAccountName((name, args), defaultStoreAccountName) =
            let apply (args: AnalyticsAccountArgs) =
                args.DefaultStoreAccountName <- io defaultStoreAccountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: AnalyticsAccountArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: AnalyticsAccountArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: AnalyticsAccountArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: AnalyticsAccountArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AnalyticsAccountArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AnalyticsAccountArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: AnalyticsAccountArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tier")>]
        member _.Tier((name, args), tier) =
            let apply (args: AnalyticsAccountArgs) =
                args.Tier <- input tier
                args

            ()
            name, List.Cons(apply, args)

        member _.Tier((name, args), tier) =
            let apply (args: AnalyticsAccountArgs) =
                args.Tier <- io tier
                args

            ()
            name, List.Cons(apply, args)

    let analyticsAccount = AnalyticsAccountBuilder()

    type AnalyticsFirewallRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            AnalyticsFirewallRule(name, (List.fold func (AnalyticsFirewallRuleArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("accountName")>]
        member _.AccountName((name, args), accountName) =
            let apply (args: AnalyticsFirewallRuleArgs) =
                args.AccountName <- input accountName
                args

            ()
            name, List.Cons(apply, args)

        member _.AccountName((name, args), accountName) =
            let apply (args: AnalyticsFirewallRuleArgs) =
                args.AccountName <- io accountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("endIpAddress")>]
        member _.EndIpAddress((name, args), endIpAddress) =
            let apply (args: AnalyticsFirewallRuleArgs) =
                args.EndIpAddress <- input endIpAddress
                args

            ()
            name, List.Cons(apply, args)

        member _.EndIpAddress((name, args), endIpAddress) =
            let apply (args: AnalyticsFirewallRuleArgs) =
                args.EndIpAddress <- io endIpAddress
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: AnalyticsFirewallRuleArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: AnalyticsFirewallRuleArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AnalyticsFirewallRuleArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AnalyticsFirewallRuleArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("startIpAddress")>]
        member _.StartIpAddress((name, args), startIpAddress) =
            let apply (args: AnalyticsFirewallRuleArgs) =
                args.StartIpAddress <- input startIpAddress
                args

            ()
            name, List.Cons(apply, args)

        member _.StartIpAddress((name, args), startIpAddress) =
            let apply (args: AnalyticsFirewallRuleArgs) =
                args.StartIpAddress <- io startIpAddress
                args

            ()
            name, List.Cons(apply, args)

    let analyticsFirewallRule = AnalyticsFirewallRuleBuilder()

    type StoreBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Store(name, (List.fold func (StoreArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("encryptionState")>]
        member _.EncryptionState((name, args), encryptionState) =
            let apply (args: StoreArgs) =
                args.EncryptionState <- input encryptionState
                args

            ()
            name, List.Cons(apply, args)

        member _.EncryptionState((name, args), encryptionState) =
            let apply (args: StoreArgs) =
                args.EncryptionState <- io encryptionState
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("encryptionType")>]
        member _.EncryptionType((name, args), encryptionType) =
            let apply (args: StoreArgs) =
                args.EncryptionType <- input encryptionType
                args

            ()
            name, List.Cons(apply, args)

        member _.EncryptionType((name, args), encryptionType) =
            let apply (args: StoreArgs) =
                args.EncryptionType <- io encryptionType
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("firewallAllowAzureIps")>]
        member _.FirewallAllowAzureIps((name, args), firewallAllowAzureIps) =
            let apply (args: StoreArgs) =
                args.FirewallAllowAzureIps <- input firewallAllowAzureIps
                args

            ()
            name, List.Cons(apply, args)

        member _.FirewallAllowAzureIps((name, args), firewallAllowAzureIps) =
            let apply (args: StoreArgs) =
                args.FirewallAllowAzureIps <- io firewallAllowAzureIps
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("firewallState")>]
        member _.FirewallState((name, args), firewallState) =
            let apply (args: StoreArgs) =
                args.FirewallState <- input firewallState
                args

            ()
            name, List.Cons(apply, args)

        member _.FirewallState((name, args), firewallState) =
            let apply (args: StoreArgs) =
                args.FirewallState <- io firewallState
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: StoreArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: StoreArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: StoreArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: StoreArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: StoreArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: StoreArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: StoreArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tier")>]
        member _.Tier((name, args), tier) =
            let apply (args: StoreArgs) =
                args.Tier <- input tier
                args

            ()
            name, List.Cons(apply, args)

        member _.Tier((name, args), tier) =
            let apply (args: StoreArgs) =
                args.Tier <- io tier
                args

            ()
            name, List.Cons(apply, args)

    let store = StoreBuilder()

    type StoreFileBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            StoreFile(name, (List.fold func (StoreFileArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("accountName")>]
        member _.AccountName((name, args), accountName) =
            let apply (args: StoreFileArgs) =
                args.AccountName <- input accountName
                args

            ()
            name, List.Cons(apply, args)

        member _.AccountName((name, args), accountName) =
            let apply (args: StoreFileArgs) =
                args.AccountName <- io accountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("localFilePath")>]
        member _.LocalFilePath((name, args), localFilePath) =
            let apply (args: StoreFileArgs) =
                args.LocalFilePath <- input localFilePath
                args

            ()
            name, List.Cons(apply, args)

        member _.LocalFilePath((name, args), localFilePath) =
            let apply (args: StoreFileArgs) =
                args.LocalFilePath <- io localFilePath
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("remoteFilePath")>]
        member _.RemoteFilePath((name, args), remoteFilePath) =
            let apply (args: StoreFileArgs) =
                args.RemoteFilePath <- input remoteFilePath
                args

            ()
            name, List.Cons(apply, args)

        member _.RemoteFilePath((name, args), remoteFilePath) =
            let apply (args: StoreFileArgs) =
                args.RemoteFilePath <- io remoteFilePath
                args

            ()
            name, List.Cons(apply, args)

    let storeFile = StoreFileBuilder()

    type StoreFirewallRuleBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            StoreFirewallRule(name, (List.fold func (StoreFirewallRuleArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("accountName")>]
        member _.AccountName((name, args), accountName) =
            let apply (args: StoreFirewallRuleArgs) =
                args.AccountName <- input accountName
                args

            ()
            name, List.Cons(apply, args)

        member _.AccountName((name, args), accountName) =
            let apply (args: StoreFirewallRuleArgs) =
                args.AccountName <- io accountName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("endIpAddress")>]
        member _.EndIpAddress((name, args), endIpAddress) =
            let apply (args: StoreFirewallRuleArgs) =
                args.EndIpAddress <- input endIpAddress
                args

            ()
            name, List.Cons(apply, args)

        member _.EndIpAddress((name, args), endIpAddress) =
            let apply (args: StoreFirewallRuleArgs) =
                args.EndIpAddress <- io endIpAddress
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: StoreFirewallRuleArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: StoreFirewallRuleArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: StoreFirewallRuleArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: StoreFirewallRuleArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("startIpAddress")>]
        member _.StartIpAddress((name, args), startIpAddress) =
            let apply (args: StoreFirewallRuleArgs) =
                args.StartIpAddress <- input startIpAddress
                args

            ()
            name, List.Cons(apply, args)

        member _.StartIpAddress((name, args), startIpAddress) =
            let apply (args: StoreFirewallRuleArgs) =
                args.StartIpAddress <- io startIpAddress
                args

            ()
            name, List.Cons(apply, args)

    let storeFirewallRule = StoreFirewallRuleBuilder()

module DevSpace =
    open Pulumi.Azure.DevSpace

    type ControllerBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Controller(name, (List.fold func (ControllerArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ControllerArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ControllerArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ControllerArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ControllerArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ControllerArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ControllerArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("skuName")>]
        member _.SkuName((name, args), skuName) =
            let apply (args: ControllerArgs) =
                args.SkuName <- input skuName
                args

            ()
            name, List.Cons(apply, args)

        member _.SkuName((name, args), skuName) =
            let apply (args: ControllerArgs) =
                args.SkuName <- io skuName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ControllerArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("targetContainerHostCredentialsBase64")>]
        member _.TargetContainerHostCredentialsBase64((name, args), targetContainerHostCredentialsBase64) =
            let apply (args: ControllerArgs) =
                args.TargetContainerHostCredentialsBase64 <- input targetContainerHostCredentialsBase64
                args

            ()
            name, List.Cons(apply, args)

        member _.TargetContainerHostCredentialsBase64((name, args), targetContainerHostCredentialsBase64) =
            let apply (args: ControllerArgs) =
                args.TargetContainerHostCredentialsBase64 <- io targetContainerHostCredentialsBase64
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("targetContainerHostResourceId")>]
        member _.TargetContainerHostResourceId((name, args), targetContainerHostResourceId) =
            let apply (args: ControllerArgs) =
                args.TargetContainerHostResourceId <- input targetContainerHostResourceId
                args

            ()
            name, List.Cons(apply, args)

        member _.TargetContainerHostResourceId((name, args), targetContainerHostResourceId) =
            let apply (args: ControllerArgs) =
                args.TargetContainerHostResourceId <- io targetContainerHostResourceId
                args

            ()
            name, List.Cons(apply, args)

    let controller = ControllerBuilder()

module IotCentral =
    open Pulumi.Azure.IotCentral

    type ApplicationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Application(name, (List.fold func (ApplicationArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("displayName")>]
        member _.DisplayName((name, args), displayName) =
            let apply (args: ApplicationArgs) =
                args.DisplayName <- input displayName
                args

            ()
            name, List.Cons(apply, args)

        member _.DisplayName((name, args), displayName) =
            let apply (args: ApplicationArgs) =
                args.DisplayName <- io displayName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ApplicationArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ApplicationArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ApplicationArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ApplicationArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ApplicationArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ApplicationArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sku")>]
        member _.Sku((name, args), sku) =
            let apply (args: ApplicationArgs) =
                args.Sku <- input sku
                args

            ()
            name, List.Cons(apply, args)

        member _.Sku((name, args), sku) =
            let apply (args: ApplicationArgs) =
                args.Sku <- io sku
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("subDomain")>]
        member _.SubDomain((name, args), subDomain) =
            let apply (args: ApplicationArgs) =
                args.SubDomain <- input subDomain
                args

            ()
            name, List.Cons(apply, args)

        member _.SubDomain((name, args), subDomain) =
            let apply (args: ApplicationArgs) =
                args.SubDomain <- io subDomain
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ApplicationArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("template")>]
        member _.Template((name, args), template) =
            let apply (args: ApplicationArgs) =
                args.Template <- input template
                args

            ()
            name, List.Cons(apply, args)

        member _.Template((name, args), template) =
            let apply (args: ApplicationArgs) =
                args.Template <- io template
                args

            ()
            name, List.Cons(apply, args)

    let application = ApplicationBuilder()

module LogAnalytics =
    open Pulumi.Azure.LogAnalytics

    type DataSourceWindowsEventBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            DataSourceWindowsEvent(name, (List.fold func (DataSourceWindowsEventArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("eventLogName")>]
        member _.EventLogName((name, args), eventLogName) =
            let apply (args: DataSourceWindowsEventArgs) =
                args.EventLogName <- input eventLogName
                args

            ()
            name, List.Cons(apply, args)

        member _.EventLogName((name, args), eventLogName) =
            let apply (args: DataSourceWindowsEventArgs) =
                args.EventLogName <- io eventLogName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("eventTypes")>]
        member _.EventTypes((name, args), eventTypes) =
            let apply (args: DataSourceWindowsEventArgs) =
                args.EventTypes <- inputList eventTypes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: DataSourceWindowsEventArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: DataSourceWindowsEventArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DataSourceWindowsEventArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DataSourceWindowsEventArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("workspaceName")>]
        member _.WorkspaceName((name, args), workspaceName) =
            let apply (args: DataSourceWindowsEventArgs) =
                args.WorkspaceName <- input workspaceName
                args

            ()
            name, List.Cons(apply, args)

        member _.WorkspaceName((name, args), workspaceName) =
            let apply (args: DataSourceWindowsEventArgs) =
                args.WorkspaceName <- io workspaceName
                args

            ()
            name, List.Cons(apply, args)

    let dataSourceWindowsEvent = DataSourceWindowsEventBuilder()

    type DataSourceWindowsPerformanceCounterBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            DataSourceWindowsPerformanceCounter(name, (List.fold func (DataSourceWindowsPerformanceCounterArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("counterName")>]
        member _.CounterName((name, args), counterName) =
            let apply (args: DataSourceWindowsPerformanceCounterArgs) =
                args.CounterName <- input counterName
                args

            ()
            name, List.Cons(apply, args)

        member _.CounterName((name, args), counterName) =
            let apply (args: DataSourceWindowsPerformanceCounterArgs) =
                args.CounterName <- io counterName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("instanceName")>]
        member _.InstanceName((name, args), instanceName) =
            let apply (args: DataSourceWindowsPerformanceCounterArgs) =
                args.InstanceName <- input instanceName
                args

            ()
            name, List.Cons(apply, args)

        member _.InstanceName((name, args), instanceName) =
            let apply (args: DataSourceWindowsPerformanceCounterArgs) =
                args.InstanceName <- io instanceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("intervalSeconds")>]
        member _.IntervalSeconds((name, args), intervalSeconds) =
            let apply (args: DataSourceWindowsPerformanceCounterArgs) =
                args.IntervalSeconds <- input intervalSeconds
                args

            ()
            name, List.Cons(apply, args)

        member _.IntervalSeconds((name, args), intervalSeconds) =
            let apply (args: DataSourceWindowsPerformanceCounterArgs) =
                args.IntervalSeconds <- io intervalSeconds
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: DataSourceWindowsPerformanceCounterArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: DataSourceWindowsPerformanceCounterArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("objectName")>]
        member _.ObjectName((name, args), objectName) =
            let apply (args: DataSourceWindowsPerformanceCounterArgs) =
                args.ObjectName <- input objectName
                args

            ()
            name, List.Cons(apply, args)

        member _.ObjectName((name, args), objectName) =
            let apply (args: DataSourceWindowsPerformanceCounterArgs) =
                args.ObjectName <- io objectName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DataSourceWindowsPerformanceCounterArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: DataSourceWindowsPerformanceCounterArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("workspaceName")>]
        member _.WorkspaceName((name, args), workspaceName) =
            let apply (args: DataSourceWindowsPerformanceCounterArgs) =
                args.WorkspaceName <- input workspaceName
                args

            ()
            name, List.Cons(apply, args)

        member _.WorkspaceName((name, args), workspaceName) =
            let apply (args: DataSourceWindowsPerformanceCounterArgs) =
                args.WorkspaceName <- io workspaceName
                args

            ()
            name, List.Cons(apply, args)

    let dataSourceWindowsPerformanceCounter =
        DataSourceWindowsPerformanceCounterBuilder()

    type LinkedServiceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            LinkedService(name, (List.fold func (LinkedServiceArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("linkedServiceName")>]
        member _.LinkedServiceName((name, args), linkedServiceName) =
            let apply (args: LinkedServiceArgs) =
                args.LinkedServiceName <- input linkedServiceName
                args

            ()
            name, List.Cons(apply, args)

        member _.LinkedServiceName((name, args), linkedServiceName) =
            let apply (args: LinkedServiceArgs) =
                args.LinkedServiceName <- io linkedServiceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: LinkedServiceArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: LinkedServiceArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceId")>]
        member _.ResourceId((name, args), resourceId) =
            let apply (args: LinkedServiceArgs) =
                args.ResourceId <- input resourceId
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceId((name, args), resourceId) =
            let apply (args: LinkedServiceArgs) =
                args.ResourceId <- io resourceId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: LinkedServiceArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("workspaceName")>]
        member _.WorkspaceName((name, args), workspaceName) =
            let apply (args: LinkedServiceArgs) =
                args.WorkspaceName <- input workspaceName
                args

            ()
            name, List.Cons(apply, args)

        member _.WorkspaceName((name, args), workspaceName) =
            let apply (args: LinkedServiceArgs) =
                args.WorkspaceName <- io workspaceName
                args

            ()
            name, List.Cons(apply, args)

    let linkedService = LinkedServiceBuilder()

module Maintenance =
    open Pulumi.Azure.Maintenance

    type AssignmentDedicatedHostBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            AssignmentDedicatedHost(name, (List.fold func (AssignmentDedicatedHostArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("dedicatedHostId")>]
        member _.DedicatedHostId((name, args), dedicatedHostId) =
            let apply (args: AssignmentDedicatedHostArgs) =
                args.DedicatedHostId <- input dedicatedHostId
                args

            ()
            name, List.Cons(apply, args)

        member _.DedicatedHostId((name, args), dedicatedHostId) =
            let apply (args: AssignmentDedicatedHostArgs) =
                args.DedicatedHostId <- io dedicatedHostId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: AssignmentDedicatedHostArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: AssignmentDedicatedHostArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("maintenanceConfigurationId")>]
        member _.MaintenanceConfigurationId((name, args), maintenanceConfigurationId) =
            let apply (args: AssignmentDedicatedHostArgs) =
                args.MaintenanceConfigurationId <- input maintenanceConfigurationId
                args

            ()
            name, List.Cons(apply, args)

        member _.MaintenanceConfigurationId((name, args), maintenanceConfigurationId) =
            let apply (args: AssignmentDedicatedHostArgs) =
                args.MaintenanceConfigurationId <- io maintenanceConfigurationId
                args

            ()
            name, List.Cons(apply, args)

    let assignmentDedicatedHost = AssignmentDedicatedHostBuilder()

    type AssignmentVirtualMachineBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            AssignmentVirtualMachine(name, (List.fold func (AssignmentVirtualMachineArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: AssignmentVirtualMachineArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: AssignmentVirtualMachineArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("maintenanceConfigurationId")>]
        member _.MaintenanceConfigurationId((name, args), maintenanceConfigurationId) =
            let apply (args: AssignmentVirtualMachineArgs) =
                args.MaintenanceConfigurationId <- input maintenanceConfigurationId
                args

            ()
            name, List.Cons(apply, args)

        member _.MaintenanceConfigurationId((name, args), maintenanceConfigurationId) =
            let apply (args: AssignmentVirtualMachineArgs) =
                args.MaintenanceConfigurationId <- io maintenanceConfigurationId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("virtualMachineId")>]
        member _.VirtualMachineId((name, args), virtualMachineId) =
            let apply (args: AssignmentVirtualMachineArgs) =
                args.VirtualMachineId <- input virtualMachineId
                args

            ()
            name, List.Cons(apply, args)

        member _.VirtualMachineId((name, args), virtualMachineId) =
            let apply (args: AssignmentVirtualMachineArgs) =
                args.VirtualMachineId <- io virtualMachineId
                args

            ()
            name, List.Cons(apply, args)

    let assignmentVirtualMachine = AssignmentVirtualMachineBuilder()

    type ConfigurationBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Configuration(name, (List.fold func (ConfigurationArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: ConfigurationArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: ConfigurationArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ConfigurationArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ConfigurationArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ConfigurationArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: ConfigurationArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("scope")>]
        member _.Scope((name, args), scope) =
            let apply (args: ConfigurationArgs) =
                args.Scope <- input scope
                args

            ()
            name, List.Cons(apply, args)

        member _.Scope((name, args), scope) =
            let apply (args: ConfigurationArgs) =
                args.Scope <- io scope
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: ConfigurationArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let configuration = ConfigurationBuilder()

module Management =
    open Pulumi.Azure.Management

    type GroupBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Group(name, (List.fold func (GroupArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("displayName")>]
        member _.DisplayName((name, args), displayName) =
            let apply (args: GroupArgs) =
                args.DisplayName <- input displayName
                args

            ()
            name, List.Cons(apply, args)

        member _.DisplayName((name, args), displayName) =
            let apply (args: GroupArgs) =
                args.DisplayName <- io displayName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("groupId")>]
        member _.GroupId((name, args), groupId) =
            let apply (args: GroupArgs) =
                args.GroupId <- input groupId
                args

            ()
            name, List.Cons(apply, args)

        member _.GroupId((name, args), groupId) =
            let apply (args: GroupArgs) =
                args.GroupId <- io groupId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: GroupArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: GroupArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("parentManagementGroupId")>]
        member _.ParentManagementGroupId((name, args), parentManagementGroupId) =
            let apply (args: GroupArgs) =
                args.ParentManagementGroupId <- input parentManagementGroupId
                args

            ()
            name, List.Cons(apply, args)

        member _.ParentManagementGroupId((name, args), parentManagementGroupId) =
            let apply (args: GroupArgs) =
                args.ParentManagementGroupId <- io parentManagementGroupId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("subscriptionIds")>]
        member _.SubscriptionIds((name, args), subscriptionIds) =
            let apply (args: GroupArgs) =
                args.SubscriptionIds <- inputList subscriptionIds
                args

            ()
            name, List.Cons(apply, args)

    let group = GroupBuilder()

    type LockBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Lock(name, (List.fold func (LockArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("lockLevel")>]
        member _.LockLevel((name, args), lockLevel) =
            let apply (args: LockArgs) =
                args.LockLevel <- input lockLevel
                args

            ()
            name, List.Cons(apply, args)

        member _.LockLevel((name, args), lockLevel) =
            let apply (args: LockArgs) =
                args.LockLevel <- io lockLevel
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: LockArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: LockArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("notes")>]
        member _.Notes((name, args), notes) =
            let apply (args: LockArgs) =
                args.Notes <- input notes
                args

            ()
            name, List.Cons(apply, args)

        member _.Notes((name, args), notes) =
            let apply (args: LockArgs) =
                args.Notes <- io notes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("scope")>]
        member _.Scope((name, args), scope) =
            let apply (args: LockArgs) =
                args.Scope <- input scope
                args

            ()
            name, List.Cons(apply, args)

        member _.Scope((name, args), scope) =
            let apply (args: LockArgs) =
                args.Scope <- io scope
                args

            ()
            name, List.Cons(apply, args)

    let lock = LockBuilder()

module ManagementGroups =
    open Pulumi.Azure.ManagementGroups

    type ManagementGroupBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ManagementGroup(name, (List.fold func (ManagementGroupArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("displayName")>]
        member _.DisplayName((name, args), displayName) =
            let apply (args: ManagementGroupArgs) =
                args.DisplayName <- input displayName
                args

            ()
            name, List.Cons(apply, args)

        member _.DisplayName((name, args), displayName) =
            let apply (args: ManagementGroupArgs) =
                args.DisplayName <- io displayName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("groupId")>]
        member _.GroupId((name, args), groupId) =
            let apply (args: ManagementGroupArgs) =
                args.GroupId <- input groupId
                args

            ()
            name, List.Cons(apply, args)

        member _.GroupId((name, args), groupId) =
            let apply (args: ManagementGroupArgs) =
                args.GroupId <- io groupId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ManagementGroupArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ManagementGroupArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("parentManagementGroupId")>]
        member _.ParentManagementGroupId((name, args), parentManagementGroupId) =
            let apply (args: ManagementGroupArgs) =
                args.ParentManagementGroupId <- input parentManagementGroupId
                args

            ()
            name, List.Cons(apply, args)

        member _.ParentManagementGroupId((name, args), parentManagementGroupId) =
            let apply (args: ManagementGroupArgs) =
                args.ParentManagementGroupId <- io parentManagementGroupId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("subscriptionIds")>]
        member _.SubscriptionIds((name, args), subscriptionIds) =
            let apply (args: ManagementGroupArgs) =
                args.SubscriptionIds <- inputList subscriptionIds
                args

            ()
            name, List.Cons(apply, args)

    let managementGroup = ManagementGroupBuilder()

module ManagementResource =
    open Pulumi.Azure.ManagementResource

    type ManangementLockBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            ManangementLock(name, (List.fold func (ManangementLockArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("lockLevel")>]
        member _.LockLevel((name, args), lockLevel) =
            let apply (args: ManangementLockArgs) =
                args.LockLevel <- input lockLevel
                args

            ()
            name, List.Cons(apply, args)

        member _.LockLevel((name, args), lockLevel) =
            let apply (args: ManangementLockArgs) =
                args.LockLevel <- io lockLevel
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: ManangementLockArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: ManangementLockArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("notes")>]
        member _.Notes((name, args), notes) =
            let apply (args: ManangementLockArgs) =
                args.Notes <- input notes
                args

            ()
            name, List.Cons(apply, args)

        member _.Notes((name, args), notes) =
            let apply (args: ManangementLockArgs) =
                args.Notes <- io notes
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("scope")>]
        member _.Scope((name, args), scope) =
            let apply (args: ManangementLockArgs) =
                args.Scope <- input scope
                args

            ()
            name, List.Cons(apply, args)

        member _.Scope((name, args), scope) =
            let apply (args: ManangementLockArgs) =
                args.Scope <- io scope
                args

            ()
            name, List.Cons(apply, args)

    let manangementLock = ManangementLockBuilder()

module Maps =
    open Pulumi.Azure.Maps

    type AccountBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Account(name, (List.fold func (AccountArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: AccountArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: AccountArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AccountArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: AccountArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("skuName")>]
        member _.SkuName((name, args), skuName) =
            let apply (args: AccountArgs) =
                args.SkuName <- input skuName
                args

            ()
            name, List.Cons(apply, args)

        member _.SkuName((name, args), skuName) =
            let apply (args: AccountArgs) =
                args.SkuName <- io skuName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: AccountArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let account = AccountBuilder()

module Marketplace =
    open Pulumi.Azure.Marketplace

    type AgreementBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Agreement(name, (List.fold func (AgreementArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("offer")>]
        member _.Offer((name, args), offer) =
            let apply (args: AgreementArgs) =
                args.Offer <- input offer
                args

            ()
            name, List.Cons(apply, args)

        member _.Offer((name, args), offer) =
            let apply (args: AgreementArgs) =
                args.Offer <- io offer
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("plan")>]
        member _.Plan((name, args), plan) =
            let apply (args: AgreementArgs) =
                args.Plan <- input plan
                args

            ()
            name, List.Cons(apply, args)

        member _.Plan((name, args), plan) =
            let apply (args: AgreementArgs) =
                args.Plan <- io plan
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("publisher")>]
        member _.Publisher((name, args), publisher) =
            let apply (args: AgreementArgs) =
                args.Publisher <- input publisher
                args

            ()
            name, List.Cons(apply, args)

        member _.Publisher((name, args), publisher) =
            let apply (args: AgreementArgs) =
                args.Publisher <- io publisher
                args

            ()
            name, List.Cons(apply, args)

    let agreement = AgreementBuilder()

module MixedReality =
    open Pulumi.Azure.MixedReality

    type SpatialAnchorsAccountBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            SpatialAnchorsAccount(name, (List.fold func (SpatialAnchorsAccountArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: SpatialAnchorsAccountArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: SpatialAnchorsAccountArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: SpatialAnchorsAccountArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: SpatialAnchorsAccountArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SpatialAnchorsAccountArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: SpatialAnchorsAccountArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: SpatialAnchorsAccountArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let spatialAnchorsAccount = SpatialAnchorsAccountBuilder()

module Msi =
    open Pulumi.Azure.Msi

    type UserAssignedIdentityBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            UserAssignedIdentity(name, (List.fold func (UserAssignedIdentityArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: UserAssignedIdentityArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: UserAssignedIdentityArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: UserAssignedIdentityArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: UserAssignedIdentityArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: UserAssignedIdentityArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: UserAssignedIdentityArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: UserAssignedIdentityArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let userAssignedIdentity = UserAssignedIdentityBuilder()

module PowerBI =
    open Pulumi.Azure.PowerBI

    type EmbeddedBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Embedded(name, (List.fold func (EmbeddedArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("administrators")>]
        member _.Administrators((name, args), administrators) =
            let apply (args: EmbeddedArgs) =
                args.Administrators <- inputList administrators
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: EmbeddedArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: EmbeddedArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: EmbeddedArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: EmbeddedArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: EmbeddedArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: EmbeddedArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("skuName")>]
        member _.SkuName((name, args), skuName) =
            let apply (args: EmbeddedArgs) =
                args.SkuName <- input skuName
                args

            ()
            name, List.Cons(apply, args)

        member _.SkuName((name, args), skuName) =
            let apply (args: EmbeddedArgs) =
                args.SkuName <- io skuName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: EmbeddedArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let embedded = EmbeddedBuilder()

module Proximity =
    open Pulumi.Azure.Proximity

    type PlacementGroupBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            PlacementGroup(name, (List.fold func (PlacementGroupArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: PlacementGroupArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: PlacementGroupArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: PlacementGroupArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: PlacementGroupArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: PlacementGroupArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: PlacementGroupArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: PlacementGroupArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let placementGroup = PlacementGroupBuilder()

module RecoveryServices =
    open Pulumi.Azure.RecoveryServices

    type VaultBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Vault(name, (List.fold func (VaultArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: VaultArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: VaultArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: VaultArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: VaultArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: VaultArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: VaultArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("sku")>]
        member _.Sku((name, args), sku) =
            let apply (args: VaultArgs) =
                args.Sku <- input sku
                args

            ()
            name, List.Cons(apply, args)

        member _.Sku((name, args), sku) =
            let apply (args: VaultArgs) =
                args.Sku <- io sku
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("softDeleteEnabled")>]
        member _.SoftDeleteEnabled((name, args), softDeleteEnabled) =
            let apply (args: VaultArgs) =
                args.SoftDeleteEnabled <- input softDeleteEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.SoftDeleteEnabled((name, args), softDeleteEnabled) =
            let apply (args: VaultArgs) =
                args.SoftDeleteEnabled <- io softDeleteEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: VaultArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let vault = VaultBuilder()

module Relay =
    open Pulumi.Azure.Relay

    type HybridConnectionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            HybridConnection(name, (List.fold func (HybridConnectionArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: HybridConnectionArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: HybridConnectionArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("relayNamespaceName")>]
        member _.RelayNamespaceName((name, args), relayNamespaceName) =
            let apply (args: HybridConnectionArgs) =
                args.RelayNamespaceName <- input relayNamespaceName
                args

            ()
            name, List.Cons(apply, args)

        member _.RelayNamespaceName((name, args), relayNamespaceName) =
            let apply (args: HybridConnectionArgs) =
                args.RelayNamespaceName <- io relayNamespaceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("requiresClientAuthorization")>]
        member _.RequiresClientAuthorization((name, args), requiresClientAuthorization) =
            let apply (args: HybridConnectionArgs) =
                args.RequiresClientAuthorization <- input requiresClientAuthorization
                args

            ()
            name, List.Cons(apply, args)

        member _.RequiresClientAuthorization((name, args), requiresClientAuthorization) =
            let apply (args: HybridConnectionArgs) =
                args.RequiresClientAuthorization <- io requiresClientAuthorization
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: HybridConnectionArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: HybridConnectionArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("userMetadata")>]
        member _.UserMetadata((name, args), userMetadata) =
            let apply (args: HybridConnectionArgs) =
                args.UserMetadata <- input userMetadata
                args

            ()
            name, List.Cons(apply, args)

        member _.UserMetadata((name, args), userMetadata) =
            let apply (args: HybridConnectionArgs) =
                args.UserMetadata <- io userMetadata
                args

            ()
            name, List.Cons(apply, args)

    let hybridConnection = HybridConnectionBuilder()

    type NamespaceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Namespace(name, (List.fold func (NamespaceArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("location")>]
        member _.Location((name, args), location) =
            let apply (args: NamespaceArgs) =
                args.Location <- input location
                args

            ()
            name, List.Cons(apply, args)

        member _.Location((name, args), location) =
            let apply (args: NamespaceArgs) =
                args.Location <- io location
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: NamespaceArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: NamespaceArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceGroup")>]
        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NamespaceArgs) =
                args.ResourceGroupName <- input resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceGroup((name, args), resourceGroupName) =
            let apply (args: NamespaceArgs) =
                args.ResourceGroupName <- io resourceGroupName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("skuName")>]
        member _.SkuName((name, args), skuName) =
            let apply (args: NamespaceArgs) =
                args.SkuName <- input skuName
                args

            ()
            name, List.Cons(apply, args)

        member _.SkuName((name, args), skuName) =
            let apply (args: NamespaceArgs) =
                args.SkuName <- io skuName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tags")>]
        member _.Tags((name, args), tags) =
            let apply (args: NamespaceArgs) =
                args.Tags <- inputMap tags
                args

            ()
            name, List.Cons(apply, args)

    let ``namespace`` = NamespaceBuilder()

module SecurityCenter =
    open Pulumi.Azure.SecurityCenter

    type AdvancedThreatProtectionBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            AdvancedThreatProtection(name, (List.fold func (AdvancedThreatProtectionArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("enabled")>]
        member _.Enabled((name, args), enabled) =
            let apply (args: AdvancedThreatProtectionArgs) =
                args.Enabled <- input enabled
                args

            ()
            name, List.Cons(apply, args)

        member _.Enabled((name, args), enabled) =
            let apply (args: AdvancedThreatProtectionArgs) =
                args.Enabled <- io enabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("targetResourceId")>]
        member _.TargetResourceId((name, args), targetResourceId) =
            let apply (args: AdvancedThreatProtectionArgs) =
                args.TargetResourceId <- input targetResourceId
                args

            ()
            name, List.Cons(apply, args)

        member _.TargetResourceId((name, args), targetResourceId) =
            let apply (args: AdvancedThreatProtectionArgs) =
                args.TargetResourceId <- io targetResourceId
                args

            ()
            name, List.Cons(apply, args)

    let advancedThreatProtection = AdvancedThreatProtectionBuilder()

    type ContactBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Contact(name, (List.fold func (ContactArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("alertNotifications")>]
        member _.AlertNotifications((name, args), alertNotifications) =
            let apply (args: ContactArgs) =
                args.AlertNotifications <- input alertNotifications
                args

            ()
            name, List.Cons(apply, args)

        member _.AlertNotifications((name, args), alertNotifications) =
            let apply (args: ContactArgs) =
                args.AlertNotifications <- io alertNotifications
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("alertsToAdmins")>]
        member _.AlertsToAdmins((name, args), alertsToAdmins) =
            let apply (args: ContactArgs) =
                args.AlertsToAdmins <- input alertsToAdmins
                args

            ()
            name, List.Cons(apply, args)

        member _.AlertsToAdmins((name, args), alertsToAdmins) =
            let apply (args: ContactArgs) =
                args.AlertsToAdmins <- io alertsToAdmins
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("email")>]
        member _.Email((name, args), email) =
            let apply (args: ContactArgs) =
                args.Email <- input email
                args

            ()
            name, List.Cons(apply, args)

        member _.Email((name, args), email) =
            let apply (args: ContactArgs) =
                args.Email <- io email
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("phone")>]
        member _.Phone((name, args), phone) =
            let apply (args: ContactArgs) =
                args.Phone <- input phone
                args

            ()
            name, List.Cons(apply, args)

        member _.Phone((name, args), phone) =
            let apply (args: ContactArgs) =
                args.Phone <- io phone
                args

            ()
            name, List.Cons(apply, args)

    let contact = ContactBuilder()

    type SubscriptionPricingBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            SubscriptionPricing(name, (List.fold func (SubscriptionPricingArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("tier")>]
        member _.Tier((name, args), tier) =
            let apply (args: SubscriptionPricingArgs) =
                args.Tier <- input tier
                args

            ()
            name, List.Cons(apply, args)

        member _.Tier((name, args), tier) =
            let apply (args: SubscriptionPricingArgs) =
                args.Tier <- io tier
                args

            ()
            name, List.Cons(apply, args)

    let subscriptionPricing = SubscriptionPricingBuilder()

    type WorkspaceBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            Workspace(name, (List.fold func (WorkspaceArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("scope")>]
        member _.Scope((name, args), scope) =
            let apply (args: WorkspaceArgs) =
                args.Scope <- input scope
                args

            ()
            name, List.Cons(apply, args)

        member _.Scope((name, args), scope) =
            let apply (args: WorkspaceArgs) =
                args.Scope <- io scope
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("workspaceId")>]
        member _.WorkspaceId((name, args), workspaceId) =
            let apply (args: WorkspaceArgs) =
                args.WorkspaceId <- input workspaceId
                args

            ()
            name, List.Cons(apply, args)

        member _.WorkspaceId((name, args), workspaceId) =
            let apply (args: WorkspaceArgs) =
                args.WorkspaceId <- io workspaceId
                args

            ()
            name, List.Cons(apply, args)

    let workspace = WorkspaceBuilder()

module Sentinel =
    open Pulumi.Azure.Sentinel

    type AlertRuleMsSecurityIncidentBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            AlertRuleMsSecurityIncident(name, (List.fold func (AlertRuleMsSecurityIncidentArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: AlertRuleMsSecurityIncidentArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: AlertRuleMsSecurityIncidentArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("displayName")>]
        member _.DisplayName((name, args), displayName) =
            let apply (args: AlertRuleMsSecurityIncidentArgs) =
                args.DisplayName <- input displayName
                args

            ()
            name, List.Cons(apply, args)

        member _.DisplayName((name, args), displayName) =
            let apply (args: AlertRuleMsSecurityIncidentArgs) =
                args.DisplayName <- io displayName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((name, args), enabled) =
            let apply (args: AlertRuleMsSecurityIncidentArgs) =
                args.Enabled <- input enabled
                args

            ()
            name, List.Cons(apply, args)

        member _.Enabled((name, args), enabled) =
            let apply (args: AlertRuleMsSecurityIncidentArgs) =
                args.Enabled <- io enabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("logAnalyticsWorkspaceId")>]
        member _.LogAnalyticsWorkspaceId((name, args), logAnalyticsWorkspaceId) =
            let apply (args: AlertRuleMsSecurityIncidentArgs) =
                args.LogAnalyticsWorkspaceId <- input logAnalyticsWorkspaceId
                args

            ()
            name, List.Cons(apply, args)

        member _.LogAnalyticsWorkspaceId((name, args), logAnalyticsWorkspaceId) =
            let apply (args: AlertRuleMsSecurityIncidentArgs) =
                args.LogAnalyticsWorkspaceId <- io logAnalyticsWorkspaceId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: AlertRuleMsSecurityIncidentArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: AlertRuleMsSecurityIncidentArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("productFilter")>]
        member _.ProductFilter((name, args), productFilter) =
            let apply (args: AlertRuleMsSecurityIncidentArgs) =
                args.ProductFilter <- input productFilter
                args

            ()
            name, List.Cons(apply, args)

        member _.ProductFilter((name, args), productFilter) =
            let apply (args: AlertRuleMsSecurityIncidentArgs) =
                args.ProductFilter <- io productFilter
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("severityFilters")>]
        member _.SeverityFilters((name, args), severityFilters) =
            let apply (args: AlertRuleMsSecurityIncidentArgs) =
                args.SeverityFilters <- inputList severityFilters
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("textWhitelists")>]
        member _.TextWhitelists((name, args), textWhitelists) =
            let apply (args: AlertRuleMsSecurityIncidentArgs) =
                args.TextWhitelists <- inputList textWhitelists
                args

            ()
            name, List.Cons(apply, args)

    let alertRuleMsSecurityIncident = AlertRuleMsSecurityIncidentBuilder()

    type AlertRuleScheduledBuilder() =
        member _.Yield(_: unit) = null, [ id ]

        member _.Run(name, args) =
            let func args f = f args
            ()
            AlertRuleScheduled(name, (List.fold func (AlertRuleScheduledArgs()) args))

        member this.Combine((lName, lArgs), (rName, rArgs)) =
            (match lName, rName with
             | null, null -> null
             | null, name -> name
             | name, null -> name
             | _ -> failwith "Duplicate name"),
            (List.concat [ lArgs; rArgs ])

        member this.For(args, delayedArgs) = this.Combine(args, delayedArgs ())
        member _.Delay f = f ()
        member _.Zero _ = ()

        [<CustomOperation("name")>]
        member _.Name((_, args), newName) = newName, args

        [<CustomOperation("description")>]
        member _.Description((name, args), description) =
            let apply (args: AlertRuleScheduledArgs) =
                args.Description <- input description
                args

            ()
            name, List.Cons(apply, args)

        member _.Description((name, args), description) =
            let apply (args: AlertRuleScheduledArgs) =
                args.Description <- io description
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("displayName")>]
        member _.DisplayName((name, args), displayName) =
            let apply (args: AlertRuleScheduledArgs) =
                args.DisplayName <- input displayName
                args

            ()
            name, List.Cons(apply, args)

        member _.DisplayName((name, args), displayName) =
            let apply (args: AlertRuleScheduledArgs) =
                args.DisplayName <- io displayName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("enabled")>]
        member _.Enabled((name, args), enabled) =
            let apply (args: AlertRuleScheduledArgs) =
                args.Enabled <- input enabled
                args

            ()
            name, List.Cons(apply, args)

        member _.Enabled((name, args), enabled) =
            let apply (args: AlertRuleScheduledArgs) =
                args.Enabled <- io enabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("logAnalyticsWorkspaceId")>]
        member _.LogAnalyticsWorkspaceId((name, args), logAnalyticsWorkspaceId) =
            let apply (args: AlertRuleScheduledArgs) =
                args.LogAnalyticsWorkspaceId <- input logAnalyticsWorkspaceId
                args

            ()
            name, List.Cons(apply, args)

        member _.LogAnalyticsWorkspaceId((name, args), logAnalyticsWorkspaceId) =
            let apply (args: AlertRuleScheduledArgs) =
                args.LogAnalyticsWorkspaceId <- io logAnalyticsWorkspaceId
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("resourceName")>]
        member _.ResourceName((name, args), resourceName) =
            let apply (args: AlertRuleScheduledArgs) =
                args.Name <- input resourceName
                args

            ()
            name, List.Cons(apply, args)

        member _.ResourceName((name, args), resourceName) =
            let apply (args: AlertRuleScheduledArgs) =
                args.Name <- io resourceName
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("query")>]
        member _.Query((name, args), query) =
            let apply (args: AlertRuleScheduledArgs) =
                args.Query <- input query
                args

            ()
            name, List.Cons(apply, args)

        member _.Query((name, args), query) =
            let apply (args: AlertRuleScheduledArgs) =
                args.Query <- io query
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("queryFrequency")>]
        member _.QueryFrequency((name, args), queryFrequency) =
            let apply (args: AlertRuleScheduledArgs) =
                args.QueryFrequency <- input queryFrequency
                args

            ()
            name, List.Cons(apply, args)

        member _.QueryFrequency((name, args), queryFrequency) =
            let apply (args: AlertRuleScheduledArgs) =
                args.QueryFrequency <- io queryFrequency
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("queryPeriod")>]
        member _.QueryPeriod((name, args), queryPeriod) =
            let apply (args: AlertRuleScheduledArgs) =
                args.QueryPeriod <- input queryPeriod
                args

            ()
            name, List.Cons(apply, args)

        member _.QueryPeriod((name, args), queryPeriod) =
            let apply (args: AlertRuleScheduledArgs) =
                args.QueryPeriod <- io queryPeriod
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("severity")>]
        member _.Severity((name, args), severity) =
            let apply (args: AlertRuleScheduledArgs) =
                args.Severity <- input severity
                args

            ()
            name, List.Cons(apply, args)

        member _.Severity((name, args), severity) =
            let apply (args: AlertRuleScheduledArgs) =
                args.Severity <- io severity
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("suppressionDuration")>]
        member _.SuppressionDuration((name, args), suppressionDuration) =
            let apply (args: AlertRuleScheduledArgs) =
                args.SuppressionDuration <- input suppressionDuration
                args

            ()
            name, List.Cons(apply, args)

        member _.SuppressionDuration((name, args), suppressionDuration) =
            let apply (args: AlertRuleScheduledArgs) =
                args.SuppressionDuration <- io suppressionDuration
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("suppressionEnabled")>]
        member _.SuppressionEnabled((name, args), suppressionEnabled) =
            let apply (args: AlertRuleScheduledArgs) =
                args.SuppressionEnabled <- input suppressionEnabled
                args

            ()
            name, List.Cons(apply, args)

        member _.SuppressionEnabled((name, args), suppressionEnabled) =
            let apply (args: AlertRuleScheduledArgs) =
                args.SuppressionEnabled <- io suppressionEnabled
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("tactics")>]
        member _.Tactics((name, args), tactics) =
            let apply (args: AlertRuleScheduledArgs) =
                args.Tactics <- inputList tactics
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("triggerOperator")>]
        member _.TriggerOperator((name, args), triggerOperator) =
            let apply (args: AlertRuleScheduledArgs) =
                args.TriggerOperator <- input triggerOperator
                args

            ()
            name, List.Cons(apply, args)

        member _.TriggerOperator((name, args), triggerOperator) =
            let apply (args: AlertRuleScheduledArgs) =
                args.TriggerOperator <- io triggerOperator
                args

            ()
            name, List.Cons(apply, args)

        [<CustomOperation("triggerThreshold")>]
        member _.TriggerThreshold((name, args), triggerThreshold) =
            let apply (args: AlertRuleScheduledArgs) =
                args.TriggerThreshold <- input triggerThreshold
                args

            ()
            name, List.Cons(apply, args)

        member _.TriggerThreshold((name, args), triggerThreshold) =
            let apply (args: AlertRuleScheduledArgs) =
                args.TriggerThreshold <- io triggerThreshold
                args

            ()
            name, List.Cons(apply, args)

    let alertRuleScheduled = AlertRuleScheduledBuilder()
